[{"content":"函数的定义 函数是基本的代码块，用于执行一个任务。\n声明方式 1 2 3 func function_name( [parameter list] ) [return_types] { 函数体 } func ：函数由 func 开始声明 function_name ：函数名称，参数列表和返回值类型构成了函数签名。 parameter list ：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。 return_types ：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。 函数体：函数定义的代码集合。 注意事项 数据类型在参数名后面 当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。 1 2 3 func add(x, y int) int { return x + y } 函数可以返回任意数量的返回值。 Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。没有参数的 return 语句会直接返回已命名的返回值，也就是「裸」返回值。 1 2 3 4 5 func split(sum int) (x, y int) { x = sum * 4 / 9 y = sum - x return } 函数式编程 可变参数 类似于Java，可变参数放在参数列表最后一个，且只支持一个可变参数\n1 2 3 4 // 使用 ... （三个点）就可以实现可变参数 func funcName(args ...type){ } 参数传递机制 类似于Java，go的参数传递机制也只有值传递一种\n值传递：值传递实际上就是一份拷贝，函数内部对该值的修改，不会影响函数外部的值 引用传递：引用传递本质上也是值传递，只不过这份值是一个指针（地址）。 所以我们在函数内对这份值的修改，其实不是改这个值，而是去修改这个值所指向的数据，所以是会影响到函数外部的值的。 ","date":"2025-06-22T23:37:36+08:00","permalink":"https://Tyritic.github.io/p/go%E7%9A%84%E5%87%BD%E6%95%B0/","title":"Go的函数"},{"content":"循环结构 Go 只有一种循环结构：for 循环。\n基本的 for 循环由三部分组成，它们用分号隔开：\n初始化语句：在第一次迭代前执行，通常为一句短变量声明（可选） 条件表达式：在每次迭代前求值 后置语句：在每次迭代的结尾执行（可选） 1 2 3 4 5 6 7 func main() { sum := 0 for i := 0; i \u0026lt; 10; i++ { sum += i } fmt.Println(sum) } 实现Java中的while循环只需要去掉初始化语句和后置语句\n1 2 3 for sum \u0026lt; 1000 { sum += sum } 分支结构 if结构 类似于Java的if结构，表达式外无需小括号 ( ) ，而大括号 { } 则是必须的。\n基本结构 1 2 3 4 5 6 7 8 9 if 布尔表达式 { /* 在布尔表达式为 true 时执行 */ } if 布尔表达式 { /* 在布尔表达式为 true 时执行 */ } else { /* 在布尔表达式为 false 时执行 */ } 示例代码\n1 2 3 4 5 6 func sqrt(x float64) string { if x \u0026lt; 0 { return sqrt(-x) + \u0026#34;i\u0026#34; } return fmt.Sprint(math.Sqrt(x)) } if 语句可以在条件表达式前执行一个短变量声明语句\n1 2 3 4 5 6 func pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v \u0026lt; lim { return v } return lim } switch结构 switch 语句是编写一连串 if - else 语句的简便方法。它运行第一个 case 值 值等于条件表达式的子句。\n基本结构 1 2 3 4 5 6 7 8 switch var1 { case val1: ... case val2: ... default: ... } 1 2 3 4 5 6 7 8 9 switch x.(type){ case type: statement(s); case type: statement(s); /* 你可以定义任意个数的case */ default: /* 可选 */ statement(s); } 注意事项 相比于Java，Go 只会运行选定的 case ，而非之后所有的 case。 在效果上，Go 的做法相当于这些语言中为每个 case 后面自动添加了所需的 break 语句。 switch 的 case 无需为常量，且取值不限于整数。 在case中以 fallthrough 语句结束会穿透switch语句，只能穿透一个 case 子句。程序会继续执行下一条 case，且它不会去判断下一个 case 的表达式是否为 true。 1 2 3 4 5 6 7 8 9 10 11 switch os := runtime.GOOS; os { case \u0026#34;darwin\u0026#34;: fmt.Println(\u0026#34;macOS.\u0026#34;) // fallthrough case \u0026#34;linux\u0026#34;: fmt.Println(\u0026#34;Linux.\u0026#34;) default: // freebsd, openbsd, // plan9, windows... fmt.Printf(\u0026#34;%s.\\n\u0026#34;, os) } 无条件switch语句可以用于代替多次 if-then-else 写得更加清晰。\n1 2 3 4 5 6 7 8 9 10 11 func main() { t := time.Now() switch { case t.Hour() \u0026lt; 12: fmt.Println(\u0026#34;早上好！\u0026#34;) case t.Hour() \u0026lt; 17: fmt.Println(\u0026#34;下午好！\u0026#34;) default: fmt.Println(\u0026#34;晚上好！\u0026#34;) } } 推迟调用 defer 语句会将函数推迟到外层函数返回之后执行。\n推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。\n原理：推迟调用的函数调用会被压入一个栈中。 当外层函数返回时，被推迟的调用会按照后进先出的顺序调用。\n1 2 3 4 5 6 7 8 func main() { defer fmt.Println(\u0026#34;world\u0026#34;) fmt.Println(\u0026#34;hello\u0026#34;) } // output: // hello // world 跳转控制语句 break ：终止某个语句块的执行，用于中断for循环 如果break出现在多次嵌套的语句块中，可以使用标签来指定终止哪个循环 1 2 3 4 5 6 7 label2 for i:=0;i\u0026lt;4;i++{ label1 for j:=0;j\u0026lt;10;j++{ break label2 } } continue：跳过本次循环，继续执行下一次循环。 for 循环中，执行 continue 语句会触发 for 增量语句的执行 ","date":"2025-06-22T23:22:47+08:00","permalink":"https://Tyritic.github.io/p/go%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%84/","title":"Go的程序运行结构"},{"content":"变量的声明方式 声明变量的一般形式是使用 var 关键字，有以下使用方法\n指定变量类型，声明后若不赋值，使用默认值。\n1 var var_name var_type 根据值自行判定变量类型（类型推导）\n1 var v_name = value 省略 var , 使用初始化声明 :=\n:= 左侧的变量不应该是已经声明过的，否则会导致编译错误。 在定义变量 a 之前使用它，则会得到编译错误 undefined: a。 声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误 1 v_name := value 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func main() { //第一种 使用默认值 var a int fmt.Printf(\u0026#34;a = %d\\n\u0026#34;, a) //第二种 var b int = 10 fmt.Printf(\u0026#34;b = %d\\n\u0026#34;, b) //第三种 省略后面的数据类型,自动匹配类型 var c = 20 fmt.Printf(\u0026#34;c = %d\\n\u0026#34;, c) //第四种 省略var关键字 d := 3.14 fmt.Printf(\u0026#34;d = %f\\n\u0026#34;, d) } 多变量声明方式\n对于全局变量可以采用分解的方式来一次性声明\n1 2 3 4 5 var x, y int var ( // 分解的写法,一般用于声明全局变量 a int b bool ) 也可以直接使用单变量的三种方式\n1 2 3 var c, d int = 1, 2 var e, f = 123, \u0026#34;liudanbing\u0026#34; g, h := 123 //只能在函数体内使用 基本数据类型 Go的数据类型分类与Java类似分为基本数据类型和派生数据类型\n基本数据类型 数值型 整数型 浮点型 字符型（没有专门的字符型，使用 byte 来保存字符） 布尔型：bool 字符串：String 派生数据类型 指针 数组 结构体 管道 函数 切片 接口 map 数值型 整数型 整数型用于存储整数数值\n有符号整数\n类型 有无符号 占用存储空间 数据范围 int8 有 1个字节 $-128$~$127$ int16 有 2个字节 $-2^{15}$~$2^{15}-1$ int32 有 3个字节 $-2^{31}$~$2^{31}-1$ int64 有 4个字节 $-2^{63}$~$2^{63}-1$ 无符号整数\n类型 有无符号 占用存储空间 数据范围 uint8 无 1个字节 $0$~$255$ uint16 无 2个字节 $0$~$2^{16}-1$ uint32 无 3个字节 $0$~$2^{32}-1$ uint64 无 4个字节 $0$~$2^{64}-1$ 其他整数类型\n类型 有无符号 占用存储空间 数据范围 注意事项 int 有 32位系统4个字节64位系统8个字节 $-2^{31}$~$2^{31}-1$（32位系统）\n$-2^{63}$ ~$2^{63}-1$（64位系统） uint 无 32位系统4个字节64位系统8个字节 $0$$2^{32}-1$（32位系统）\n$0$$2^{64}-1$（64位系统） rune 有 3个字节 $-2^{31}$~$2^{31}-1$ 等价 int32，表示一个 Unicode 码 byte 无 1个字节 $0$~$255$ 当要存储字符时选用byte Golang中的默认整数类型为 int\n浮点数型 类型 占用存储空间 表数范围 float32 4字节 float64 8字节 注意事项\nGolang 浮点类型有固定的范围和字段长度，不受具体 OS(操作系统)的影响。 Golang 的浮点型默认声明为 float64 类型。 字符型 Golang 中没有专门的字符类型，如果要存储单个字符(字母)，一般使用 byte 来保存。字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。也就是说对于传统的字符串是由字符组成的，而Go的字符串不同，它是由字节组成的。\nGo中的字符型使用 byte 来保存，字符使用 ' ' 括起来\n1 var x byte =\u0026#39;a\u0026#39; 可以使用转义字符将字符变成特殊字符常量，常见的转义字符如下\n\\t ：制表符 \\n ：换行符 \\r ：一个回车 注意事项\nGo的字符采用UTF-8编码，字符本质上是一个整数，直接输出时是输出字符的UTF-8码值 使用格式化输出 %c 才能输出字符值 布尔类型 布尔类型使用 bool 存储，大小为1个字节，只允许值为 true 和 false\n字符串类型 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。字符串的编码为UTF8 ，源代码中的文本字符串通常被解释为采用 UTF8 编码的 Unicode 码点（rune）序列。因此字符串可以包含任意的数据\n底层原理 1 2 3 4 type StringHeader struct { Data uintptr Len int } 注意事项\n在Go中字符串是不可变的，类似Java 表示方法 使用双引号 “ ” 表示字符串会识别转义字符 使用反引号 · · 以字符串的原生形式输出，包括换行和特殊字符，可以实现防止攻击、输出源代码等效果 字符串之间使用 + 进行拼接 对于长字符串使用分行拼接处理，将 + 保留在上一行 基本数据类型的默认值 在 go 中，数据类型都有一个默认值，当没有赋值时，就会保留默认值，在go 中，默认值又叫零值。\n数据类型 默认值 int 0 float 0 string \u0026quot;\u0026quot; bool false 基本数据类型之间的相互转换 Go和Java不同，Go不支持数据类型的自动转换需要显式自动转换\n语法格式\n1 2 var i dataType var j =newType(i) 基本数据类型和string之间的转换 基本数据类型转string fmt.Sprintf(\u0026quot;%参数\u0026quot;,表达式) 使用 strconv 包中的函数 func FormatBool(b bool) string func FormatInt(i int64,base int) string func FormatFloat(f float64,fmt byte,prec,bitSize int) string string转基本类型 使用 strcov 包中的函数 func ParseBool(str string) (value bool, err error) func ParseFloat(s string, bitSize int) (f float64,er error) func Parselnt(s string, base int, bitSize int) ( int64,err error) func ParseUint(s string, b int, bitSize int) (n uint64 err error) 指针 类似于C++，Go保留了指针\n指针保存了值的内存地址，其零值为 nil 。\n取址符：\u0026amp; 操作符生成一个指向其操作数的指针，获取地址。 解引用：* 操作符表示指针指向的底层值。 结构体 一个结构体（struct）就是一组 字段（field）。\n1 2 3 4 5 6 7 8 9 // 声明 type struct_variable_type struct { member definition member definition ... member definition } // 初始化 variable_name := structure_variable_type {value1, value2...valuen} Go的结构体支持匿名字段，用于在一个结构体中插入另一个结构体，可以用于模拟实现继承行为\n结构体常通过指针传递，避免复制整个结构体，提高性能。\n数组 类型 [n]T 表示一个数组，它拥有 n 个类型为 T 的值。\n声明方法 1 2 3 var a [n]T //基本方式 primes := [6]int{2, 3, 5, 7, 11, 13} //字面量声明 balance := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0} //不确定数组长度 存储特点 数组的长度是其类型的一部分，因此数组不能改变大小。 数组元素类型相同 数组在内存中连续存储 如果数组长度不确定，可以使用 ... 代替数组的长度，编译器会根据元素个数自行推断数组的长度 数组是值类型，并不是隐式的指向第一个元素的指针（比如 C 语言的数组），而是一个完整的值赋值和传参会复制整个数组 遍历方式 使用 range 循环进行遍历，其中第一个返回值为数组下标，第二个返回值为数组值\n1 2 3 for i, v := range b { // 通过数组指针迭代数组的元素 fmt.Println(i, v) } 值数据类型和引用数据类型 数据类型分为值数据类型和引用数据类型\n值数据类型：这种类型的变量直接指向存在内存中的值 引用数据类型：这种类型的变量存储的是变量所在的内存地址 常见的值数据类型有\n布尔：bool 字符串：string 数值型 有符号整数 int int8 int16 int32 int64 无符号整数 uint uint8 uint16 uint32 uint64 uintptr 字符型：byte // uint8 的别名 rune // int32 的别名，表示一个 Unicode 码位 浮点型 float32 float64 虚数 complex64 complex128 数组 结构体 常见的引用数据类型\n指针 切片 映射 常量 常量是一个简单值的标识符，在程序运行时，不会被修改的量。\n定义 常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。\n1 const identifier [type] = value 其中type可以省略，go可以通过类型推断 常量不能用 := 语法声明。 自增长 在 golang 中，一个方便的习惯就是使用 iota 标示符，它简化了常量用于增长数字的定义，给以上相同的值以准确的分类。\n1 2 3 4 5 const ( CategoryBooks = iota // 0 CategoryHealth // 1 CategoryClothing // 2 ) 底层原理：当你在一个 const 组中仅仅有一个标示符在一行的时候，它将使用增长的 iota 取得前面的表达式并且再运用它\n","date":"2025-06-11T16:57:17+08:00","permalink":"https://Tyritic.github.io/p/go%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F/","title":"Go的数据类型和变量"},{"content":"Go语言的语法标准 Go 源文件以 go 为扩展名。 Go 应用程序的执行入口是 main函数，和其它编程语言(比如 iava/c) Go 语言严格区分大小写。 Go 方法由一条条语句构成，每个语句后不需要分号(Go 语言会在每行后自动加分号) Go编译器是逐行编译语句，一行就写一句语句，不能把多条语句放在一行 Go中定义的变量或者import的包没有用到则会编译失败 Go语言的语法，定义函数的时候，{ 必须和函数名在同一行，不能另起一行。 Go程序的语言结构 1 2 3 4 5 6 7 package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } package main 定义了包名。必须在源文件中非注释的第一行指明这个文件属于哪个包。package main 表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。 import \u0026quot;fmt\u0026quot; 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。 func main() 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。 fmt.Println(...) ：可以将字符串输出到控制台，并在最后自动增加换行字符 \\n Go的文件组织结构 Go 的包结构和模块结构是 Go 项目组织和模块化的基础\n包（Package） 定义：Go 中的 最小代码组织单位。\n特点\n每个 Go 源文件都必须以 package 包名 开头。 一个目录中的所有 .go 文件构成一个包（package），只能有一个包名。 Go 程序的执行入口是 main 包中的 main() 函数。 包名通常与目录名相同，包路径以 模块名 + 目录名 表示 典型的Go项目文件结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 myapp/ ← 模块名（go.mod） ├── go.mod ← 模块定义 ├── main.go ← main 包（入口） ├── config/ ← 配置相关代码包 │ └── config.go ├── handler/ ← HTTP/API 处理逻辑 │ └── user_handler.go ├── service/ ← 核心业务逻辑 │ └── user_service.go ├── model/ ← 数据结构和实体 │ └── user.go ├── repository/ ← 数据库访问层（DAO） │ └── user_repo.go ├── utils/ ← 通用工具函数 │ └── hash.go └── internal/ ← 内部包（只限本模块内使用） └── secret.go 导出形式\n首字母大写的标识符是可导出的（外部可访问），可以被外部包的代码所使用（客户端程序需要先导入这个包）类似于Java中的 public 。 首字母小写的标识符只能在本包内使用，则对包外是不可见的，类似于Java中的 protected 。 模块（Module） Go 1.11+ 引入的新概念，用于管理项目依赖，由 go.mod 文件定义\nGo的基本语法 注释 行注释\n1 //注释内容 块注释\n1 /*注释内容*/ 代码缩进 通常使用Tab来解决缩进 可以使用 gofmt 命令行命令来自动格式化代码 空格 在 Go 语言中，空格通常用于分隔标识符、关键字、运算符和表达式，以提高代码的可读性。\nGo 语言中变量的声明必须使用空格隔开如\n1 2 var x int const Pi float64 = 3.14159265358979323846 在运算符和操作数之间要使用空格能让程序更易阅读\n1 fruit = apples + oranges; 在关键字和表达式之间要使用空格\n1 2 3 if x \u0026gt; 0 { // do something } 格式化字符串 Go 语言中使用 fmt.Sprintf 或 fmt.Printf 格式化字符串并赋值给新串：\nSprintf 根据格式化参数生成格式化的字符串并返回该字符串。 Printf 根据格式化参数生成格式化的字符串并写入标准输出。 ","date":"2025-06-10T13:36:50+08:00","permalink":"https://Tyritic.github.io/p/go%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/","title":"Go的基本语法和项目结构"},{"content":"Go的语言特点 Go 语言保证了既能到达静态编译语言的安全和性能，又达到了动态语言开发维护的高效率使用一个表达式来形容 Go 语言：Go=C+Python，说明 Go 语言既有类似C语言这类静态语言的运行速度，又能达到 Python 动态语言的快速开发\n继承C语言的理念 Go语言从C语言中继承了很多理念，包括表达式语法，控制结构，基础数据类型，调用参数传值，指针等等，也保留了和C语言一样的编译执行方式及弱化的指针\n引入了包的概念 引入包的概念，用于组织程序结构，Go语言的一个文件都要归属于一个包，而不能单独存在。\n类似Java的自动GC Go语言提供了垃圾回收机制，内存自动回收，不需开发人员管理\n天然支持并发 从语言层面支持并发，实现简单 goroutine ：轻量级线程，可实现大并发处理，高效利用多核。 基于 CPS 并发模型(Communicating Sequential Processes )实现 吸收了管道通信机制，形成 Go 语言特有的管道 channel 通过管道 channel ，可以实现不同的 goroute 之间的相互通信。 类似Python的语法 函数可以返回多个值 编译部署效率快 编译速度快：Go 的编译器非常高效，即使是大型项目也能快速编译。 生成静态链接的二进制文件：无需依赖外部动态库，部署极为简单 面向接口而非面向继承 接口（interface）是隐式实现 ：只要实现了接口的方法集合，就自动实现该接口。\n组合优于继承 ：通过结构体嵌套实现代码复用，避免传统 OOP 中继承的复杂性。\nGo和Java的联系和区别 Go和Java的相似之处\n静态类型语言 ：Java 和 Go 都是静态类型语言，变量类型在编译时确定，便于类型检查。 支持跨平台 Java 运行于 JVM，由JVM将统一的字节码解释成机器码 Go 编译器允许通过设置环境变量，编译出适用于 不同操作系统和架构 的二进制文件，从而支持跨平台开发。 自动垃圾回收 ：两者都具备 GC（Garbage Collection）机制，自动管理内存。 Go和Java的区别\n并发模型 Java：使用线程 + 线程池，较重，需显式管理 Go：使用 goroutine + channel，轻量且原生支持 CSP 模型 面向对象 Java：典型的 OOP（支持继承、多态、接口） Go：不支持类和继承，使用结构体 + 接口组合实现面向对象 部署难度 Java：通常打包为 .jar、.war，依赖 JRE 环境运行 Go：编译为单个可执行文件，部署非常方便 Go的环境变量 可通过命令查看和修改环境变量\n1 2 go env #查看环境变量 go env -w #永久修改全局环境变量 基本路径 GOROOT ：Go 安装目录（包含编译器、标准库等）默认由安装器自动设置，一般不需要修改 GOPATH ：工作目录，用于存放源码、依赖、可执行文件 GOBIN ：安装可执行文件的目录 模块管理 GOPROXY ：模块代理地址，解决模块下载慢的问题 GO111MODULE ：模块启用策略 Go的编译执行过程 命令行执行 编译 ：通过 go build 命令将 .go 文件编译成 .exe 文件，go build -o 可以指定可执行文件的名称 执行 ：运行 .exe 文件 编译同时执行：go run 将 .go 文件直接编译同时运行 Go支持跨平台构建，因此可以在一个平台上构建出针对不同平台的可执行文件\n通过临时修改环境变量来构建出针对不同平台的可执行文件\n1 2 3 set GOOS=linux set GOARCH=amd64 set CGO_ENABLED=0 可执行文件的类型\nWindows：.exe 文件 Mac OS/Linux：无后缀名的文件 跨平台性 Go和Java一样支持 一次编译，处处运行\n相比于Java根据不同平台设计不同的虚拟机来解释字节码的做法，Go 采用 静态编译（Static Compilation） 的策略\n源代码 → 本地平台的完整二进制可执行文件，不依赖任何外部动态库或虚拟机。\n这意味着生成的程序在目标平台上运行时不需要安装 Go 语言环境，也不需要共享库（.so/.dll），从而使跨平台部署变得非常容易。\nGo实现跨平台性的原理是因为Go 编译器（主要是 cmd/compile 和 cmd/link）支持多个目标平台架构（GOOS + GOARCH），并且这些后端已经内置在 Go 安装包中，不需要你手动安装交叉编译工具链（如 gcc-arm）。\n比如，在 macOS 上安装 Go 后，你就能直接构建 Linux、Windows、Android、WASM 等平台的可执行文件。\n在构建可执行文件时，通过设置环境变量实现平台切换\nGOOS ： 控制目标操作系统（如 linux、windows、darwin、android 等） GOARCH ：控制目标架构（如 amd64、arm64、386 等） Go 编译器根据这两个变量，选择对应的：\n标准库实现（如 syscall_linux.go、syscall_windows.go） 汇编指令集 系统调用桥接层 链接器策略 go build和go run的区别 如果先使用 go build 编译生成了可执行文件，那么可以将该可执行文件拷贝到没有 go 开发环境的机器上，仍然可以运行 如果我们是直接 go run 源代码，那么如果要在另外一个机器上这么运行，也需要 go 开发环境，否则无法执行。相当于编译到临时目录 + 执行后删除 在编译时，编译器会将程序运行依赖的库文件包含在可执行文件中，所以，可执行文件变大了很多。 ","date":"2025-06-10T10:50:08+08:00","permalink":"https://Tyritic.github.io/p/golang%E7%9A%84%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/","title":"Golang的语言特性"},{"content":"策略模式 在策略模式（Strategy Pattern）中一个类的行为或其算法可以在运行时更改。它定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，让算法独立于使用它的客户端（调用方）而变化。主要目的是为了解耦多个策略，并方便调用方在针对不同场景灵活切换不同的策略。\n特点 算法封装：将算法的实现与使用算法的代码分离，通过封装提高代码的灵活性和可扩展性。 动态替换：可以在运行时选择和替换算法。 遵循开闭原则：新增策略无需修改现有代码。 组成 策略接口（Strategy）：定义算法的通用接口。 具体策略（ConcreteStrategy）：实现具体的算法。 上下文类（Context）：持有策略接口的引用，调用具体策略的方法 具体实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // 策略接口 interface Strategy { void execute(); } // 具体策略A class ConcreteStrategyA implements Strategy { @Override public void execute() { System.out.println(\u0026#34;Executing Strategy A\u0026#34;); } } // 具体策略B class ConcreteStrategyB implements Strategy { @Override public void execute() { System.out.println(\u0026#34;Executing Strategy B\u0026#34;); } } // 上下文类 class Context { private Strategy strategy; public void setStrategy(Strategy strategy) { this.strategy = strategy; } public void executeStrategy() { if (strategy != null) { strategy.execute(); } else { System.out.println(\u0026#34;No strategy set\u0026#34;); } } } // 客户端 public class Main { public static void main(String[] args) { Context context = new Context(); Strategy strategyA = new ConcreteStrategyA(); Strategy strategyB = new ConcreteStrategyB(); context.setStrategy(strategyA); context.executeStrategy(); // Output: Executing Strategy A context.setStrategy(strategyB); context.executeStrategy(); // Output: Executing Strategy B } } 观察者模式 观察者模式（发布订阅模式）是一种行为型设计模式，用于定义对象之间的一种一对多的依赖关系，使得一个对象状态发生变化时，所有依赖它的对象都会收到通知并自动更新。它的目的就是将观察者和被观察者代码解耦，使得一个对象或者说事件的变更，让不同观察者可以有不同的处理，非常灵活，扩展性很强，是事件驱动编程的基础。\n特点 松耦合：观察者和被观察者之间是松耦合的，便于扩展和维护。 动态订阅：可以动态添加或移除观察者，灵活性高。 单向通信：被观察者通知观察者，观察者不能反向修改被观察者的状态。 结构 Subject（抽象主题/被观察者）：状态发生变化时，通知所有注册的观察者。 Observer（抽象观察者）：接收来自主题的更新通知，并进行相应的操作。 ConcreteSubject（具体主题）：实现具体的主题对象，保存需要被观察的状态。 ConcreteObserver（具体观察者）：实现具体的观察者对象，更新自己以与主题的状态同步。 具体实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 import java.util.ArrayList; import java.util.List; // 抽象观察者 interface Observer { void update(String message); } // 抽象被观察者接口 interface Subject { void addObserver(Observer observer); void removeObserver(Observer observer); void notifyObservers(); } // 具体被观察者 class ConcreteSubject implements Subject { private List\u0026lt;Observer\u0026gt; observers = new ArrayList\u0026lt;\u0026gt;(); private String state; @Override public void addObserver(Observer observer) { observers.add(observer); } @Override public void removeObserver(Observer observer) { observers.remove(observer); } @Override public void notifyObservers() { for (Observer observer : observers) { observer.update(state); } } public void setState(String state) { this.state = state; notifyObservers(); } } // 具体观察者 class ConcreteObserver implements Observer { private String name; public ConcreteObserver(String name) { this.name = name; } @Override public void update(String message) { System.out.println(name + \u0026#34; received update: \u0026#34; + message); } } // 客户端 public class Main { public static void main(String[] args) { ConcreteSubject subject = new ConcreteSubject(); Observer observer1 = new ConcreteObserver(\u0026#34;Observer1\u0026#34;); Observer observer2 = new ConcreteObserver(\u0026#34;Observer2\u0026#34;); subject.addObserver(observer1); subject.addObserver(observer2); subject.setState(\u0026#34;New State 1\u0026#34;); subject.setState(\u0026#34;New State 2\u0026#34;); } } ","date":"2025-05-05T19:01:20+08:00","permalink":"https://Tyritic.github.io/p/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","title":"行为型设计模式"},{"content":"适配器模式 适配器模式（Adapter Pattern）充当两个不兼容接口之间的桥梁，属于结构型设计模式。它通过一个中间件（适配器）将一个类的接口转换成客户期望的另一个接口，使原本不能一起工作的类能够协同工作。\n特点 接口转换：适配器提供一种中间层，将一个类的接口转换为客户端需要的接口。 解耦性：通过适配器模式，客户端不需要修改现有的代码，即可使用不同接口的类。 结构 适配器模式包含以下几个主要角色：\n目标接口（Target）：定义客户需要的接口。 适配者类（Adaptee）：定义一个已经存在的接口，这个接口需要适配。 适配器类（Adapter）：实现目标接口，并通过组合或继承的方式调用适配者类中的方法，从而实现目标接口。 具体实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 目标接口 interface Target { void request(); } // 被适配者 class Adaptee { void specificRequest() { System.out.println(\u0026#34;Called specificRequest from Adaptee\u0026#34;); } } // 适配器类 class Adapter implements Target { private final Adaptee adaptee; public Adapter(Adaptee adaptee) { this.adaptee = adaptee; } @Override public void request() { adaptee.specificRequest(); } } // 客户端 public class Main { public static void main(String[] args) { Adaptee adaptee = new Adaptee(); Target adapter = new Adapter(adaptee); adapter.request(); // Output: Called specificRequest from Adaptee } } 代理模式 在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。代理模式通过引入一个代理对象来控制对原对象的访问。代理对象在客户端和目标对象之间充当中介，负责将客户端的请求转发给目标对象，同时可以在转发请求前后进行额外的处理。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。\n特点 间接访问：客户端通过代理访问实际对象，代理对象负责对实际对象的控制。 功能增强：代理对象可以在访问实际对象之前或之后添加额外的功能。 解耦性：客户端不直接与实际对象交互，通过代理对象可以透明地扩展实际对象的功能。 结构 **抽象主题（Subject）:**定义了真实主题和代理主题的共同接口，这样在任何使用真实主题的地方都可以使用代理主题。 **真实主题（Real Subject）:**实现了抽象主题接口，是代理对象所代表的真实对象。客户端直接访问真实主题，但在某些情况下，可以通过代理主题来间接访问。 **代理（Proxy）:**实现了抽象主题接口，并持有对真实主题的引用。代理主题通常在真实主题的基础上提供一些额外的功能，例如延迟加载、权限控制、日志记录等。 **客户端（Client）:**使用抽象主题接口来操作真实主题或代理主题，不需要知道具体是哪一个实现类。 具体实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 抽象主题 interface Subject { void request(); } // 真实主题 class RealSubject implements Subject { @Override public void request() { System.out.println(\u0026#34;RealSubject: Handling request.\u0026#34;); } } // 代理 class ProxySubject implements Subject { private RealSubject realSubject; @Override public void request() { if (realSubject == null) { realSubject = new RealSubject(); // 延迟初始化 } System.out.println(\u0026#34;Proxy: Logging before delegating request.\u0026#34;); realSubject.request(); System.out.println(\u0026#34;Proxy: Logging after delegating request.\u0026#34;); } } // 客户端 public class Main { public static void main(String[] args) { Subject proxy = new ProxySubject(); proxy.request(); } } 装饰器模式 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。它是作为现有的类的一个包装。装饰器模式通过将对象包装在装饰器类中，以便动态地修改其行为。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。\n结构 抽象组件（Component）：定义了原始对象和装饰器对象的公共接口或抽象类，可以是具体组件类的父类或接口。 具体组件（Concrete Component）：是被装饰的原始对象，它定义了需要添加新功能的对象。 抽象装饰器（Decorator）：实现或者继承抽象组件，它包含了一个抽象组件对象，并定义了与抽象组件相同的接口，同时可以通过组合方式持有其他装饰器对象。 具体装饰器（Concrete Decorator）：实现了抽象装饰器的接口，负责向抽象组件添加新的功能。具体装饰器通常会在调用原始对象的方法之前或之后执行自己的操作。 具体实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 // 抽象组件 interface Component { void operation(); } // 具体组件 class ConcreteComponent implements Component { @Override public void operation() { System.out.println(\u0026#34;ConcreteComponent operation\u0026#34;); } } // 装饰器抽象类 abstract class Decorator implements Component { protected Component component; public Decorator(Component component) { this.component = component; } @Override public void operation() { component.operation(); } } // 具体装饰器A class ConcreteDecoratorA extends Decorator { public ConcreteDecoratorA(Component component) { super(component); } @Override public void operation() { super.operation(); System.out.println(\u0026#34;ConcreteDecoratorA added behavior\u0026#34;); } } // 具体装饰器B class ConcreteDecoratorB extends Decorator { public ConcreteDecoratorB(Component component) { super(component); } @Override public void operation() { super.operation(); System.out.println(\u0026#34;ConcreteDecoratorB added behavior\u0026#34;); } } // 客户端 public class Main { public static void main(String[] args) { Component component = new ConcreteComponent(); Component decoratorA = new ConcreteDecoratorA(component); Component decoratorB = new ConcreteDecoratorB(decoratorA); decoratorB.operation(); // Output: // ConcreteComponent operation // ConcreteDecoratorA added behavior // ConcreteDecoratorB added behavior } } ","date":"2025-05-05T16:45:49+08:00","permalink":"https://Tyritic.github.io/p/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","title":"结构型设计模式"},{"content":"单例模式 单例模式（Singleton Pattern）提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。它确保一个类在整个程序运行过程中只有一个实例，并提供全局访问点以获取该实例。\n特点 唯一性：类的实例在整个程序生命周期内只存在一个。 全局访问：提供一个全局访问点，让所有代码可以访问同一个实例。 延迟加载：可以延迟实例化，在需要时才创建实例（如使用懒汉式实现）。 实现方式 主要实现方式有如下方式\n饿汉式：实例在类加载时就创建，线程安全，但如果实例初始化较重或没有被使用会浪费资源。 懒汉式：实例在首次访问时创建，节约资源，但需要确保线程安全。 双重检查锁定：在懒汉式的基础上优化，直接加锁效率太低，双重检查锁只在第一次检查实例为空时加锁，提高性能。 静态内部类：利用类加载机制实现懒加载和线程安全，推荐使用。 饿汉式实现 1 2 3 4 5 6 7 8 9 public class Singleton { private static final Singleton instance = new Singleton(); //在类加载时就立即创建了这个唯一的实例 private Singleton() {} public static Singleton getInstance() { return instance; } } 定义一个私有的、静态的、不可更改（final）的类实例，在类加载时就立即创建了这个唯一的实例 构造函数被定义为私有的，这样外部类无法通过 new Singleton() 来创建新对象 提供一个公共的静态方法来获取唯一实例 饿汉式特点：类加载时就立即创建了这个唯一的实例 懒汉式实现 1 2 3 4 5 6 7 8 9 10 11 12 public class Singleton { private static Singleton instance; private Singleton() {} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 定义一个私有的、静态的、不可更改（final）的类实例，初始值为null，表示尚未初始化 构造函数被定义为私有的，这样外部类无法通过 new Singleton() 来创建新对象 提供一个 公共的静态方法，用于获取唯一实例 懒加载特性：只有在第一次调用 getInstance() 时才会创建对象 如果已经创建过了，后续调用直接返回该实例 线程不安全问题\n在多线程环境下，可能出现两个线程同时进入 if (instance == null) 判断，结果都创建了对象，破坏了单例模式。结果导致创建了两个实例\n双重锁定检查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } 定义一个私有的、静态的、不可更改（final），共享（volatile）的类实例，初始值为null，表示尚未初始化 volatile ：防止指令重排，确保在多线程下对象创建过程的可见性，保证不会有半初始化的对象被看见 构造函数被定义为私有的，这样外部类无法通过 new Singleton() 来创建新对象 提供一个 公共的静态方法，用于获取唯一实例 懒加载特性：只有在第一次调用 getInstance() 时才会创建对象 第一次非同步检查 singleton == null 提高性能：如果已经创建了实例，就直接返回，避免进入同步块。 第二次加锁进行同步检查再次判断 singleton == null 使用场景 在 Spring Boot 中，单例模式是 默认的 Bean 作用域，也就是说，你在使用 @Component、@Service、@Repository、@Controller 等注解时，Spring 默认就以单例方式管理它们的实例\n工厂模式 工厂模式（Factory Pattern）提供了一种创建对象的方式，使得创建对象的过程与使用对象的过程分离。工厂模式提供了一种创建对象的方式，而无需指定要创建的具体类。通过使用工厂模式，可以将对象的创建逻辑封装在一个工厂类中，而不是在客户端代码中直接实例化对象，这样可以提高代码的可维护性和可扩展性。\n特点 优点 调用者只需要知道对象的名称即可创建对象。 扩展性高，如果需要增加新产品，只需扩展一个工厂类即可。 屏蔽了产品的具体实现，调用者只关心产品的接口。 缺点 每次增加一个产品时，都需要增加一个具体类和对应的工厂，使系统中类的数量成倍增加，增加了系统的复杂度和具体类的依赖，不符合开闭原则 结构 抽象产品（Abstract Product）：定义了产品的共同接口或抽象类。它可以是具体产品类的父类或接口，规定了产品对象的共同方法。 具体产品（Concrete Product）：实现了抽象产品接口，定义了具体产品的特定行为和属性。 抽象工厂（Abstract Factory）：声明了创建产品的抽象方法，可以是接口或抽象类。它可以有多个方法用于创建不同类型的产品。 具体工厂（Concrete Factory）：实现了抽象工厂接口，负责实际创建具体产品的对象。 具体实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 // 抽象产品 public interface Shape { void draw(); } // 具体产品 public class Rectangle implements Shape { @Override public void draw() { System.out.println(\u0026#34;Inside Rectangle::draw() method.\u0026#34;); } } public class Square implements Shape { @Override public void draw() { System.out.println(\u0026#34;Inside Square::draw() method.\u0026#34;); } } public class Circle implements Shape { @Override public void draw() { System.out.println(\u0026#34;Inside Circle::draw() method.\u0026#34;); } } // 具体工厂 public class ShapeFactory { //使用 getShape 方法获取形状类型的对象 public Shape getShape(String shapeType){ if(shapeType == null){ return null; } if(shapeType.equalsIgnoreCase(\u0026#34;CIRCLE\u0026#34;)){ return new Circle(); } else if(shapeType.equalsIgnoreCase(\u0026#34;RECTANGLE\u0026#34;)){ return new Rectangle(); } else if(shapeType.equalsIgnoreCase(\u0026#34;SQUARE\u0026#34;)){ return new Square(); } return null; } } // 使用工厂模式创建对象 public class FactoryPatternDemo { public static void main(String[] args) { ShapeFactory shapeFactory = new ShapeFactory(); //获取 Circle 的对象，并调用它的 draw 方法 Shape shape1 = shapeFactory.getShape(\u0026#34;CIRCLE\u0026#34;); //调用 Circle 的 draw 方法 shape1.draw(); //获取 Rectangle 的对象，并调用它的 draw 方法 Shape shape2 = shapeFactory.getShape(\u0026#34;RECTANGLE\u0026#34;); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取 Square 的对象，并调用它的 draw 方法 Shape shape3 = shapeFactory.getShape(\u0026#34;SQUARE\u0026#34;); //调用 Square 的 draw 方法 shape3.draw(); } } 抽象工厂模式 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。抽象工厂模式提供了一种创建一系列相关或相互依赖对象的接口，而无需指定具体实现类。通过使用抽象工厂模式，可以将客户端与具体产品的创建过程解耦，使得客户端可以通过工厂接口来创建一族产品。\n特点 和简单工厂模式的区别：工厂模式关注的是创建单一类型对象，定义一个抽象方法，由子类实现具体对象的实例化。抽象工厂模式关注的是创建一族相关对象，提供一个接口来创建一组相关的或互相依赖的对象，而无需指定它们的具体类。\n应用实例 假设有不同类型的衣柜，每个衣柜（具体工厂）只能存放一类衣服（成套的具体产品），如商务装、时尚装等。每套衣服包括具体的上衣和裤子（具体产品）。所有衣柜都是衣柜类（抽象工厂）的具体实现，所有上衣和裤子分别实现上衣接口和裤子接口（抽象产品）。\n结构 抽象工厂（Abstract Factory）：声明了一组用于创建产品对象的方法，每个方法对应一种产品类型。抽象工厂可以是接口或抽象类。 具体工厂（Concrete Factory）：实现了抽象工厂接口，负责创建具体产品对象的实例。 抽象产品（Abstract Product）：定义了一组产品对象的共同接口或抽象类，描述了产品对象的公共方法。 具体产品（Concrete Product）：实现了抽象产品接口，定义了具体产品的特定行为和属性。 具体实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 // 抽象产品A public interface ProductA { void use(); } // 具体产品A1 public class ConcreteProductA1 implements ProductA { @Override public void use() { System.out.println(\u0026#34;Using ConcreteProductA1\u0026#34;); } } // 具体产品A2 public class ConcreteProductA2 implements ProductA { @Override public void use() { System.out.println(\u0026#34;Using ConcreteProductA2\u0026#34;); } } // 抽象产品B public interface ProductB { void eat(); } // 具体产品B1 public class ConcreteProductB1 implements ProductB { @Override public void eat() { System.out.println(\u0026#34;Eating ConcreteProductB1\u0026#34;); } } // 具体产品B2 public class ConcreteProductB2 implements ProductB { @Override public void eat() { System.out.println(\u0026#34;Eating ConcreteProductB2\u0026#34;); } } // 抽象工厂 public interface AbstractFactory { ProductA createProductA(); ProductB createProductB(); } // 具体工厂1 public class ConcreteFactory1 implements AbstractFactory { @Override public ProductA createProductA() { return new ConcreteProductA1(); } @Override public ProductB createProductB() { return new ConcreteProductB1(); } } // 具体工厂2 public class ConcreteFactory2 implements AbstractFactory { @Override public ProductA createProductA() { return new ConcreteProductA2(); } @Override public ProductB createProductB() { return new ConcreteProductB2(); } } // 使用抽象工厂创建产品 public class Client { public static void main(String[] args) { AbstractFactory factory1 = new ConcreteFactory1(); ProductA productA1 = factory1.createProductA(); ProductB productB1 = factory1.createProductB(); productA1.use(); productB1.eat(); AbstractFactory factory2 = new ConcreteFactory2(); ProductA productA2 = factory2.createProductA(); ProductB productB2 = factory2.createProductB(); productA2.use(); productB2.eat(); } } 建造者模式 建造者模式是一种创建型设计模式，用于将复杂对象的构建过程与其表示分离。通过使用建造者模式，可以一步一步地创建一个复杂的对象，同时允许不同的建造者创建不同的对象表示。\n特点 分离构建过程和表示，使得构建过程更加灵活，可以构建不同的表示。 可以更好地控制构建过程，隐藏具体构建细节。 代码复用性高，可以在不同的构建过程中重复使用相同的建造者。 结构 产品（Product）：要构建的复杂对象。产品类通常包含多个部分或属性。 抽象建造者（Builder）：定义了构建产品的抽象接口，包括构建产品的各个部分的方法。 具体建造者（Concrete Builder）：实现抽象建造者接口，具体确定如何构建产品的各个部分，并负责返回最终构建的产品。 指导者（Director）：负责调用建造者的方法来构建产品，指导者并不了解具体的构建过程，只关心产品的构建顺序和方式。 具体实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 // 产品类 class Product { private String partA; private String partB; public void setPartA(String partA) { this.partA = partA; } public void setPartB(String partB) { this.partB = partB; } @Override public String toString() { return \u0026#34;Product [PartA=\u0026#34; + partA + \u0026#34;, PartB=\u0026#34; + partB + \u0026#34;]\u0026#34;; } } // 抽象建造者 abstract class Builder { protected Product product = new Product(); public abstract void buildPartA(); public abstract void buildPartB(); public Product getResult() { return product; } } // 具体建造者 class ConcreteBuilder extends Builder { @Override public void buildPartA() { product.setPartA(\u0026#34;Custom Part A\u0026#34;); } @Override public void buildPartB() { product.setPartB(\u0026#34;Custom Part B\u0026#34;); } } // 指挥者 class Director { private Builder builder; public Director(Builder builder) { this.builder = builder; } public void construct() { builder.buildPartA(); builder.buildPartB(); } } // 客户端 public class Main { public static void main(String[] args) { Builder builder = new ConcreteBuilder(); Director director = new Director(builder); director.construct(); Product product = builder.getResult(); System.out.println(product); // Output: Product [PartA=Custom Part A, PartB=Custom Part B] } } ","date":"2025-05-05T10:53:36+08:00","permalink":"https://Tyritic.github.io/p/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","title":"创建型设计模式"},{"content":"什么是设计模式 设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。\n设计模式的作用\n帮助我们快速解决常见问题：设计模式提供了解决特定软件设计问题的通用方法，拿来套上即用，例如单例模式、代理模式、责任链模式等等。 提升代码可扩展性：设计模式通常考虑了软件的扩展性，将不同的功能和功能变化分离开来实现，使得未来添加新功能更加容易。 提高代码可重用性：设计模式本身就是经验的总结，按照设计模式的思路，很多代码封装的很好，便于复用，减少重复工作。 提升代码可维护性：通过使用设计模式，使得代码结构更加清晰，易于理解和维护。 设计模式的原则 单一职责原则（SRP）：一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例子：考虑一个员工类，它应该只负责管理员工信息，而不应负责其他无关工作。 开放封闭原则（OCP）：软件实体应该对扩展开放，对修改封闭 。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。例子：通过制定接口来实现这一原则，比如定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身。 里氏替换原则（LSP）：任何父类可以出现的地方，子类一定可以出现，子类对象应该能够替换掉所有父类对象。 例子：一个正方形是一个矩形，但如果修改一个矩形的高度和宽度时，正方形的行为应该如何改变就是一个违反里氏替换原则的例子。 接口隔离原则（ISP）：客户端（指调用者或者使用者）不应该被迫依赖它不使用的方法，即一个类对另一个类的依赖应该建立在最小接口上。例子：通过接口抽象层来实现底层和高层模块之间的解耦，比如使用依赖注入。 依赖倒置原则（DIP）：高层模块不应该依赖低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。 最少知识原则 (Law of Demeter)：一个对象应当对其他对象有最少的了解，只与其直接的朋友交互。一个对象应尽量少地了解其他对象的内部细节。一个对象只应与直接的朋友通信，而不与朋友的朋友通信。直接的朋友指的是那些直接与当前对象进行交互的对象。 设计模式的分类 创建型模式 用于创建对象的模式，同时隐藏对象创建的逻辑，避免代码中出现大量 new 操作和复杂的创建逻辑。目的是解耦对象的创建和使用\n常见模式\n工厂模式（Factory Pattern）：定义一个创建对象的接口，但由子类决定实例化哪个类。 抽象工厂模式（Abstract Factory Pattern）：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。 单例模式（Singleton Pattern）：确保一个类只有一个实例，并提供一个全局访问点。 建造者模式（Builder Pattern）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 原型模式（Prototype Pattern）：通过复制现有的实例来创建新的实例。 结构型模式 这些模式关注对象之间的组合和关系，旨在解决如何构建灵活且可复用的类和对象结构。\n常见模式\n适配器模式（Adapter Pattern）：将一个类的接口转换成客户希望的另外一个接口。 桥接模式（Bridge Pattern）：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 组合模式（Composite Pattern）：将对象组合成树形结构以表示“部分-整体”的层次结构。 装饰器模式（Decorator Pattern）：动态地给一个对象添加一些额外的职责。 外观模式（Facade Pattern）：为子系统中的一组接口提供一个一致的界面。 享元模式（Flyweight Pattern）：运用共享技术有效地支持大量细粒度的对象。 代理模式（Proxy）：为其他对象提供一种代理以控制对这个对象的访问 行为型模式 这些模式关注对象之间的通信和交互，旨在解决对象之间的责任分配和算法的封装。\n常见模式\n责任链模式（Chain of Responsibility Pattern）：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。 命令模式（Command Pattern）：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。 解释器模式（Interpreter Pattern）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 迭代器模式（Iterator Pattern）：提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 中介者模式（Mediator Pattern）：用一个中介对象来封装一系列的对象交互。 备忘录模式（Memento Pattern）：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 观察者模式（Observer Pattern）：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 状态模式（State Pattern）：允许一个对象在其内部状态改变时改变它的行为。 策略模式（Strategy Pattern）：定义一系列的算法,把它们一个个封装起来, 并且使它们可互相替换。 模板方法模式（Template Method Pattern）：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 访问者模式（Visitor Pattern）：为一个对象结构中的各元素提供一个在不改变元素类的前提下定义作用于这些元素的新操作。 ","date":"2025-05-05T10:31:24+08:00","permalink":"https://Tyritic.github.io/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%A1%80/","title":"设计模式基础"},{"content":"RAG的业务场景 随着自然语言处理技术的发展，纯生成模型虽然可以生成流畅的文本，但是存在以下问题。\n知识的局限性 ：大模型自身的知识完全源于它的训练数据，基本都是构建于网络公开的数据，对于一些实时性的、非公开的或离线的数据是无法获取到的，这部分知识也就无从具备。 幻觉问题： 所有的 AI 大模型的底层原理都是基于数学概率，其模型输出实质上是一系列数值运算，大模型也不例外，所以它有时候会一本正经地胡说八道，尤其是在大模型自身不具备某一方面的知识或不擅长的场景。 什么是RAG RAG（检索增强生成，Retrieval-Augmented Generation） 是一种结合 信息检索（Retrieval） 和 文本生成（Generation） 的 AI 方法，主要用于 提高大语言模型（LLM）的知识覆盖范围和回答准确性。个人理解为RAG 让 AI 在回答问题时，先从外部知识库中检索相关信息，再结合检索到的内容生成最终回答，而无需重新训练模型 这样可以减少 AI 依赖自身训练数据的局限性，并提供最新、准确的信息。\n检索 ：基于用户的输入，从外部知识库中检索与查询相关的文本片段，通常使用向量化表示和向量数据库进行语义匹配。 增强生成 ：将检索到的知识送给大语言模型以此来优化大模型的生成结果 ，使得大模型在生成更精确、更贴合上下文答案的同时，也能有效减少产生误导性信息的可能。 RAG的流程 RAG（检索增强生成）的完整流程可分为5个核心阶段\n数据准备：清洗文档、分块处理（如PDF转文本切片）； 向量化：使用嵌入模型（如BERT、BGE）将文本转为向量； 索引存储：向量存入数据库（如Milvus、Faiss、Elasticsearch）； 检索增强：用户提问向量化后检索相关文档； 生成答案：将检索结果与问题组合输入大模型生成回答。 可以简化为三个阶段（索引-检索-生成）\n索引阶段 在索引阶段，对原始文档进行解析，并将其拆分成多个较小的文本块。随后，这些文本块会通过嵌入模型进行向量化处理，生成的向量将被存储在向量数据库中，供后续检索使用。\n提示\n嵌入模型，文本向量化，向量数据库\n嵌入模型：将文本数据（如词汇、短语或句子）转换为数值向量（文本向量化）的工具 ，这些向量捕捉了文本的语义信息，可用于各种自然语言处理（NLP）任务。例如在识物探趣项目中使用嵌入模型为 bge-small-zh-v1.5（向量维度为 512 ）\n文本向量化： 将文本映射到高维空间中的点，使语义相似的文本在这个空间中距离较近。 例如，“猫”和”狗”的向量可能会比”猫”和”汽车”的向量更接近。总而言之，语义相近的对象在向量空间中彼此邻近，而语义相异的对象则相距较远。\n向量数据库：专门设计用来存储和管理嵌入向量的数据库系统。它可以将非结构化数据(如文本、图片、音频等)转换成高维向量的形式进行存储，并提供高效的相似性搜索功能。\n检索阶段 将用户的查询通过嵌入模型转换成向量 ，以便与向量数据库中存储的知识相关的向量进行比对。通过语义相似度匹配，从向量数据库中找出最匹配的前 K 个数据。\n增强生成阶段 系统将用户查询与检索到的相关文本块进行组合，通过提示工程（Prompt Engineering）设计适当的输入格式，将用户的查询内容和检索到的相关知识 一起嵌入到一个预设的提示词模板，将经过检索增强的提示词内容输入到大语言模型中，以此生成所需的输出。\nRAG的优化策略 索引阶段的优化策略 分块策略 分块就是把原始长文本（比如一本书、一篇论文）拆成若干个 “小块”（通常几百字到上千字，比如500-1000字），每个小块包含相对完整的语义单元，比如一个段落、几个段落或一个小节。\n为什么需要分块\n模型处理能力限制：大语言模型一次能处理的文本长度有限，太长的文本塞进去会“消化不良”，分块后每个小块能塞进模型的“肚子”里。 精准定位信息：用户提问通常针对局部内容，分块后每个小块像“信息卡片”，检索时能快速找到最相关的卡片，避免在整本大书里“大海捞针”。 平衡上下文与效率：小块既能保留足够上下文（比如前后句子的逻辑），又能让计算机高效存储和检索（小块的向量计算更快）。 所以分块就是将输入文档或大段文本切分成多个较小的、可控粒度的“块”，以便后续的向量化检索和生成模块高效调用与组合。\n常见的分块策略\n自然结构分块 ：按文档原有格式拆分，比如遇到标题、空行、章节编号、标点符号分块。 固定大小分块 ：将文本按固定字符数、词数或 token 数等均匀切分，简单易实现。 滑动窗口分块 ：在固定大小基础上为相邻的块保留一定重叠，以减少上下文出现断裂 递归分块 ：先按段落/章节粗分，超长部分再递归细化（按句子或空行），适合复杂文档。 语义分块 ：用 NLP 模型（如 BERT、GPT）判断文本语义边界，确保每个块是完整的语义单元（比如一个论点、一个案例）。 选取合适的嵌入模型 选择嵌入模型的时候主要考虑以下因素\n语义准确性：模型能否精准捕捉文本语义（比如长句理解、上下文关联、同义词区分），直接影响向量相似度计算的可靠性。 部分模型擅长短文本（如 Sentence-BERT），但长文本下会丢失上下文。 通用模型（如 text-embedding-ada-002）在专业领域可能“词不达意”（比如“主诉”在医疗文本中是专有名词，通用模型可能理解为“主要诉求”） 模型效率：推理速度是否满足业务实时性要求（比如 QPS 高的场景不能用太大的模型），显存/内存占用是否适配硬件资源。 轻量级模型（如 MiniLM、DistilBERT）速度快（毫秒级/句），适合实时问答； 重型模型（如 BERT-large、GPT-4 Embedding）速度慢（秒级/句），适合离线批量处理。 领域适配：是否针对垂直领域做过预训练或微调，原生支持特定术语和逻辑（比如金融模型懂“PE 估值”，通用模型可能误解为“体育器材”）。简而言之就是让模型懂行话 直接选领域专用模型 用通用模型+领域数据微调（适合有私有语料的场景，比如用公司内部客服对话数据微调） 添加领域适配器（如 LoRA 技术，在不改变原模型的前提下，新增少量参数适配领域）。 多语言支持：是否支持业务所需语言（尤其是小语种），以及跨语言对齐能力（比如中英混合文本能否正确嵌入）。 数据规模匹配：模型参数量和训练数据规模是否匹配你的语料复杂度（小数据用大模型可能过拟合，大数据用小模型可能语义坍缩） 检索阶段的优化策略 进行重排序 Rerank 是一个对初步检索返回的候选文档列表进行再次排序的过程。因为初步检索需要快速地在海量的文档中找出大致相关的文档，其需要考虑效率，所以查找出的文档不会非常准确，这步是粗排。在已经筛选的相关的文档中再进行精筛，找出匹配度更高的文档让其排在前面，选其中的 Top-K 然后扔给大模型，提高答案的准确性，这就是 Rerank，也是精排。\n初步检索生成候选文档：使用速度较快的传统检索方法获得一组候选文档。 根据Rerank模型重新排序：根据Rerank模型匹配得分对候选文档进行排序，选出最相关的 Top-K 文档。 交给生成模块：Top-K 候选文档传递给大模型，帮助生成更精准、更富信息量的回答。 增强生成阶段的优化策略 提示词优化 设计合适的提示词可以提高RAG的效果\n明确角色和任务：提示中要清楚说明 AI 的身份、能力边界和目标任务。比如“你是一个专业法律助手，只能基于提供的材料回答问题”，可以有效限制模型的自由发挥。 结构化提示：用明确的格式指导 AI 输出，比如：“背景 + 问题 + 输出格式”。 加上下文约束：明确告知 AI 只能基于检索到的资料回答，避免“幻觉”。 提示中明确“不要使用自己的知识推断”。 加入冗余兜底机制：如没检索到相关内容，就让 AI 显式回复 “未找到相关资料” 在 prompt 中加入 “如果找不到资料，请回复‘未找到相关内容’”。 查询重写 利用 LLM 从不同视角生成多个查询，优化用户输入\n多查询检索时进行重排序 采用类似检索阶段的重排序策略\n","date":"2025-05-04T19:29:50+08:00","permalink":"https://Tyritic.github.io/p/%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA%E7%94%9F%E6%88%90rag/","title":"检索增强生成（RAG）"},{"content":"LLM的一些缺陷 市面上的LLM大部分是基于网络上通用知识训练得来的，缺乏对垂直领域相关的知识，类似一个盲目自信的人对于不了解不理解的问题也会编造一些内容（ 幻觉 问题） LLM的知识不具备实时性，例如向LLM询问今天的天气时LLM无法给出正确答案 LLM无法主动从网络等各种来源主动获取知识，即LLM目前只能作为 规划者 而无法成为 执行者 传统解决方案——函数调用 Function-Call于2023年由OpenAI提出。在此之前，LLM 主要通过自然语言回答问题，无法直接执行 API 调用或插件交互。这一机制的核心在于 模型能够以结构化的 JSON 格式输出函数参数 。\n工作流程如下\n模型识别用户输入的意图判断是否需要使用Function-Call 模型生成一个结构化的JSON对象来包装函数的相关参数并转发到应用程序的对应函数中 应用程序执行函数并将结果返回给模型 模型将应用程序返回的结果进行整理并以自然语言整理出最终回答、 但是 function call 也有其局限性，重点在于function call 平台依赖性强，不同 LLM 平台的 function call API 实现差异较大。例如，OpenAI 的函数调用方式与 Google 的不兼容，开发者在切换模型时需要重写代码，增加了适配成本。\nMCP协议是什么 MCP全称模型上下文协议，是由Claude公司推出的标准化LLM与外部数据源与工具的交互形式。跳转官方文档\n引用Claude对此的描述\nMCP is an open protocol that standardizes how applications provide context to LLMs. Think of MCP like a USB-C port for AI applications. Just as USB-C provides a standardized way to connect your devices to various peripherals and accessories, MCP provides a standardized way to connect AI models to different data sources and tools.\nMCP（模型上下文协议）是一种开放协议，它对应用程序向大语言模型（LLM）提供上下文的方式进行了标准化。可以把 MCP 想象成人工智能应用程序的 USB-C 接口。就像 USB-C 接口为将设备连接到各种外围设备和配件提供了一种标准化的方式一样，MCP 也为将人工智能模型连接到不同的数据源和工具提供了一种标准化的方式。\nMCP旨在为大型语言模型（LLMs）和 AI 助手提供一个统一、标准化的接口，使其能够无缝连接并交互各种外部数据源、工具等，让模型不依赖于预训练数据，还能在需要时动态获取最新的上下文信息、调用外部工具、执行特定任务。\n可以从以下角度理解MCP协议\nMCP协议类似于一个人工智能应用程序的拓展坞，通过拓展坞可以以标准化的形式将LLM连接到各种外部工具和数据源 同时也可以将MCP协议理解为Function-Call的标准化和优化，MCP协议依然是建立在Function-Call的基础上的 MCP的作用\n标准化数据接入：通过 MCP，我们无需为每个模型编写单独的代码，而是通过统一的协议接口，实现一次集成，随处连接。这大大简化了模型与外部系统的集成过程。 增强模型能力：MCP 使得模型能够实时访问最新的数据和工具，例如直接从 GitHub 获取代码库信息，或从本地访问文件。这不仅提升了模型的实用性，也拓展了其应用场景。 提升系统可维护性：通过标准化的协议，系统的各个组件可以更加模块化地协作，降低了维护成本和出错概率。 MCP协议相较于Function-Call的改进 Tool ：基于Function-Call实现对外部工具的调用，使得模型可以进行具体的操作\n服务器定义好工具（比如“计算两点距离”或者“发个邮件”），客户端发现这些工具后，LLM 就能根据需要调用。调用完结果会返回给 LLM，继续推理或者输出。 Resource ：LLM可以读取的数据，比如文件内容、数据库查询结果或API的响应\n服务器（MCP Server）把这些数据暴露出来，客户端（比如 LLM 应用）可以读取它们，然后塞进模型的上下文里去推理或者生成内容。 Prompt ：服务器提供给AI的预写消息或模板，帮助AI理解如何使用资源和工具\n服务器定义好一堆 Prompt 模板（比如“写个产品描述”或者“调试错误”），客户端可以直接选一个，填入参数，然后丢给 LLM 执行。 MCP的相关概念 核心架构 MCP 遵循客户端-服务器架构，所有传输都使用 JSON-RPC 2.0 来交换消息。\n主机 ：启动连接的 LLM 应用程序 客户端 ：嵌入在主机内，在主机应用程序内与服务器保持一比一连接 服务器 ：连接到具体的数据源或工具，向客户端提供资源、工具和提示 资源（Resources）：类似文件的数据，可以被客户端读取，如 API 响应或文件内容。 工具（Tools）：可以被 LLM 调用的函数（需要用户批准）。 提示（Prompts）：预先编写的模板，帮助用户完成特定任务。 资源 ：服务器可以访问到的资源 本地资源 : MCP 服务器可以安全访问的计算机资源（数据库、文件、服务） 远程资源 : MCP 服务器可以连接到的互联网上可用的资源（API） MCP支持两者模式\n标准输入输出（Stdio）模式：基于 stdio 的实现是最常见的 MCP 客户端方案，它通过标准输入输出流与 MCP 服务器进行通信。这种方式简单直观，能够直接通过进程间通信实现数据交互，避免了额外的网络通信开销。特别适用于本地部署的 MCP 服务器，可以在同一台机器上启动 MCP 服务器进程，与客户端无缝对接。 服务器发送事件（SSE）模式：这个方案相较于 stdio 方式，SSE 更适用于远程部署的 MCP 服务器，比如分布式系统或需要网络实时推送的场景。客户端可以通过标准 HTTP 协议与服务器建立连接，实现单向的实时数据推送。基于 SSE 的 MCP 服务器支持被多个客户端的远程调用。 工作流程 初始化：主机应用程序启动并初始化MCP Client，每个MCP Client与一个服务器建立连接。 功能协商：MCP Client和MCP Server之间进行功能协商，确定它们可以相互提供哪些功能和服务。 请求处理：MCP Client根据用户请求或AI模型的需要，向服务器发送请求。服务器处理这些请求，并可能与本地或远程资源进行交互。 构造Function-calling请求：将用户的查询连同工具描述通过 Function calling发送给 LLM。 LLM智能判断是否调用工具：LLM 决定是否需要使用工具以及使用哪些工具。 工具调用执行：如果需要使用工具，MCP Client会通过MCP Server执行相应的工具调用。MCP Server 去实际跑工具的逻辑，并把结果返回给MCP Client。 模型整合：工具执行结果被传回 LLM，由模型将这个结果与原始用户问题、已有上下文等信息整合，生成最终的自然语言回应。 响应返回：MCP Client再将信息传递回主机应用程序。 安全性设计 MCP的安全性设计体现在以下方面\n用户同意和控制：所有模型对工具、资源和提示的访问请求都必须经过用户的授权。主机负责管理权限、提示用户批准，并在必要时阻止未经授权的访问。用户必须知道哪些数据是需要提供给大模型的，用户在授权使用之前应该了解每个工具的功能。 隔离与沙箱机制：MCP 的设计将实际工具调用封装在 MCP Server 内部，模型本身无法直接访问敏感数据，这种 “中间层”设计有效地降低了直接暴露内部业务系统的风险。同时，沙箱机制可以限制工具调用的执行环境，防止任意代码执行或恶意操作对系统造成破坏。 加密传输与来源验证：MCP 内置了安全机制，确保只有经过验证的请求才能访问特定资源，相当于在数据安全又加上了一道防线。同时，MCP协议还支持多种加密算法，以确保数据在传输过程中的安全性。 ","date":"2025-03-27T10:00:39+08:00","permalink":"https://Tyritic.github.io/p/%E6%A8%A1%E5%9E%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8D%8F%E8%AE%AEmcp/","title":"模型上下文协议（MCP）"},{"content":"Kafka高性能的原因 批量收发消息 零拷贝 磁盘顺序读写 页缓存 批量收发消息 Kafka 收发消息都是批量进行处理的。\n生产者发送消息时，不会直接把消息发送出去，而是把消息缓存起来，缓存消息量达到配置的批量大小后，才会发送出去。 Broker 收到消息后，并不会把批量消息解析成单条消息后落盘，而是作为批量消息进行落盘，同时也会把批量消息直接同步给其他副本。 消费者拉取消息，也不会按照单条进行拉取，而是按照批量进行拉取，拉取到一批消息后，再解析成单条消息进行消费。 磁盘顺序读写 Kafka 采用不断追加写文件的方式来实现顺序写，从而提高磁盘的性能。顺序读写省去了寻址的时间，只要一次寻址，就可以连续读写。Kafka 的 Broker 在写消息数据时，首先为每个 Partition 创建一个文件，然后把数据顺序地追加到该文件对应的磁盘空间中，如果这个文件写满了，就再创建一个新文件继续追加写。这样大大减少了寻址时间，提高了读写性能。\n页缓存 在 Linux 系统中，PageCache 是磁盘文件在内存中建立的缓存。当应用程序读写文件时，并不会直接读写磁盘上的文件，而是操作 PageCache。应用程序写文件时，都先会把数据写入 PageCache，然后操作系统定期地将 PageCache 的数据写到磁盘上。而应用程序在读取文件数据时，首先会判断数据是否在 PageCache 中，如果在则直接读取，如果不在，则读取磁盘，并且将数据缓存到 PageCache。\n零拷贝 Kafka Broker 将消息发送给消费端时，即使命中了 PageCache，也需要将 PageCache 中的数据先复制到应用程序的内存空间，然后从应用程序的内存空间复制到 Socket 缓存区，将数据发送出去。Kafka 采用了零拷贝技术把数据直接从 PageCache 复制到 Socket 缓冲区中，这样数据不用复制到用户态的内存空间，同时 DMA 控制器直接完成数据复制，不需要 CPU 参与。\n零拷贝的技术原理参见往期博客\n","date":"2025-03-18T20:23:01+08:00","permalink":"https://Tyritic.github.io/p/kafka%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E5%8E%9F%E5%9B%A0/","title":"Kafka的高性能原因"},{"content":"消息顺序性的保证 Kafka 通过分区机制和消息键来保证消息的顺序性。在 Kafka 中，每个 Topic 可以分为多个分区，每个分区内的消息都是有序的。消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。Kafka 通过偏移量（offset）来保证消息在分区内的顺序性。\n对于生产者端，因为在同一个分区内，消息是有序的。 因此可以使用消息键和指定分区将相关消息分配到同一分区，可以保证这些消息在同一分区内依然有序。\n对于消费者端：消费者在消费消息时，同一个消费者线程只能同时消费一个分区的消息，这样可以保证消费端在处理某个分区内的消息时是按顺序的。如果 Kafka 集群中没有足够的消费者线程，某个消费者线程可能需要同时消费多个分区的消息，但这些分区之间的顺序是无法保证的。\n消息可靠性的保证 生产者端的保证 生产者在发送消息时，需要通过消息确认机制来确保消息成功到达。生产者发送消息至 Broker ，需要处理 Broker 的响应，如果 Broker 返回写入失败等错误消息，重试发送。\n设置合适的重试次数 retries 和重试间隔：决定生产者端的重试次数 配置合适的 acks 参数：决定生产者在收到多少个副本的确认后认为消息发送成功。 acks=0：生产者不会等待任何服务器的确认。消息可能会丢失，但性能最高。 acks=1：生产者会在领导者副本（leader）成功接收到数据后收到确认。数据可靠性得到了基本保障，但如果领导者副本崩溃，仍有可能丢失消息。 acks=all（或 -1）：生产者会等待所有同步副本（ISR）接收到数据后收到确认。数据可靠性最高，但性能会有所下降，因为需要等多个副本都确认接收。 消费者端的保证 消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset）表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。\n自动提交offset会导致以下问题：当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。\n通常的解决方法：手动关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset 。 但是这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。\nBroker的保证 Broker通过 多副本机制 来保证消息不丢失。Kafka 中的每个分区都有多个副本（Replicas），这些副本分布在不同的 Broker 上。当一个 Broker 宕机时，其他持有该分区副本的 Broker 能够接管工作。\nKafka 的副本分为leader副本和follower副本。每个主题（topic）中的分区（partition）会有一个leader副本和多个follower副本。\nleader副本：每个 Kafka 分区都有一个 Leader，负责处理所有的读写请求 follower副本：定期从领导者副本中拉取数据，保持数据的一致性。 当leader副本宕机时，会在follower副本中选出一个新的领导者，确保数据的连续性和可用性。\n提示\n在 Kafka 中，ISR (In-Sync Replica) 是一组与 Leader 副本保持同步的所有副本。具体来说，ISR 包含那些能够及时复制 Leader 副本中最新消息的副本。ISR 中的副本保证了它们的数据与 Leader 的数据一致或者仅仅落后很少量的数据，这些副本在副本集合中被认为是“同步”的。\n一个副本如果长时间无法与 Leader 同步（可能因为网络延迟、故障等原因），它就会被移出 ISR 集合。只有在其再次追上 Leader 后，才会被重新加入 ISR 集合。\n选举机制 Kafka的选举有以下几种\nKafka Controller的选举 Partition Leader的选举 Consumer Group Coordinator(消费组协调者)的选举。 Kafka Controller的选举过程\n启动竞争 ：集群启动时，各个 Broker 节点会尝试在 ZooKeeper 中创建一个临时节点/controller。ZooKeeper 是一个分布式协调服务，可保障只有一个节点能成功创建该节点。 确定控制器 ：成功创建/controller节点的 Broker 会成为控制器，并在该节点中记录自身的 Broker ID 等信息。 故障处理 ：若控制器所在节点发生故障，其创建的临时节点会自动消失。其他 Broker 监听到这一变化后，会重新竞争创建/controller节点，从而选出新的控制器。 Partition Leader的选举过程\n控制器主导 ：分区首领选举由控制器负责。控制器会维护分区的状态信息，当检测到首领副本不可用时，会触发选举流程。 优先副本选择 ：Kafka 优先选择分区的优先副本作为首领。优先副本是在分区创建时指定的第一个副本。 存活副本选举 ：若优先副本不可用，控制器会从同步副本集合（ISR）中选择一个副本作为新的首领。同步副本是指与首领副本保持同步的副本。 元数据更新 ：选举出新首领后，控制器会更新集群元数据，通知其他 Broker 新的首领信息。 Consumer Group Coordinator(消费组协调者)的选举\n协调器确定：消费者组中的消费者在启动时，会向 Kafka 集群发送请求，Kafka 根据消费者组 ID 的哈希值选择一个 Broker 作为协调器。 注册与通知 ：消费者向选定的协调器注册自己，协调器会维护消费者组的成员信息，并将分区分配方案通知给各个消费者。 故障处理 ：若协调器所在 Broker 故障，消费者会收到通知，重新发起协调器选举。 消息重复消费的处理方案 Kafka中会出现消息重复的情况，根本原因：服务端侧已经消费的数据没有成功提交 offset\n严格意义上是无法从根本上解决重复的消息，因为为了保证消息的可靠性会产生重复的消息。只能从业务层面解决重复消息的影响\n只有让消费者的处理逻辑具有 幂等性 ，保证无论同一条消息被消费多少次，结果都是一样的，从而避免因重复消费带来的副作用。\n","date":"2025-03-18T19:40:28+08:00","permalink":"https://Tyritic.github.io/p/kafka%E7%9A%84%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F%E6%80%A7%E5%92%8C%E5%AE%8C%E6%95%B4%E6%80%A7/","title":"Kafka的消息顺序性和完整性"},{"content":"SpringBoot中整合Kafka的流程 引入依赖 引入 Spring for Apache Kafka 依赖\n1 2 3 4 5 6 7 8 9 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.kafka\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-kafka\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 配置Kafka相关参数 在application.xml中配置Kafka的相关参数\n创建生产者 通常生产者作为Service类，使用 KafkaTemplate 的相关API来调用相关方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import org.springframework.kafka.core.KafkaTemplate; import org.springframework.stereotype.Service; @Service public class KafkaProducer { private final KafkaTemplate\u0026lt;String, String\u0026gt; kafkaTemplate; public KafkaProducer(KafkaTemplate\u0026lt;String, String\u0026gt; kafkaTemplate) { this.kafkaTemplate = kafkaTemplate; } public void sendMessage(String topic, String message) { kafkaTemplate.send(topic, message); System.out.println(\u0026#34;Sent message: \u0026#34; + message); } } 创建消费者 对监听的方法使用 @KafkaListener 注解，指定消息主题和消费者组\n1 2 3 4 5 6 7 8 9 10 11 12 import org.apache.kafka.clients.consumer.ConsumerRecord; import org.springframework.kafka.annotation.KafkaListener; import org.springframework.stereotype.Service; @Service public class KafkaConsumer { @KafkaListener(topics = \u0026#34;test-topic\u0026#34;, groupId = \u0026#34;my-group\u0026#34;) public void listen(ConsumerRecord\u0026lt;String, String\u0026gt; record) { System.out.println(\u0026#34;Received message: \u0026#34; + record.value()); } } ","date":"2025-03-18T19:22:46+08:00","permalink":"https://Tyritic.github.io/p/springboot%E6%95%B4%E5%90%88kafka/","title":"SpringBoot整合Kafka"},{"content":"Kafka是什么 Kafka是一种分布式流事件处理平台，严格意义上不是一个纯消息队列，但是可以胜任消息队列的所有任务。\n主要的应用场景\n消息队列：用作高吞吐量的消息系统，将消息从一个系统传递到另一个系统。 日志收集：集中收集日志数据，然后通过Kafka传递到实时监控系统或存储系统。 流计算：处理实时数据流，将数据传递给实时计算系统 事件溯源：记录事件发生的历史，以便稍后进行数据回溯或重新处理。 Kafka的基本组件 生产者（Producer) Producer 是生产者，负责创建消息并将其发送到 Kafka 主题（Topic）。 同时Producer 可以配置消息的分区策略，从而控制消息发送到在哪个分区中。 Producer 可以配置不同的持久化与可靠性策略。\n消费者（Consumer) Consumer 是消费者，负责从 Kafka 主题中读取消息，通过订阅一个或多个 Topic，动态地拉取消息进行处理。Consumer 通常属于一个 Consumer Group，同一个 Group 中的各 Consumer 可以分配处理特定分区的数据，实现并行处理。\n消息代理（Broker) Broker是 Kafka 的核心，用于消息存储和管理。每个 Kafka 集群可以包含一个或多个 Broker，负责接收、存储、以及发送数据。\n协调器（ZooKeeper) Zookeeper用于 Kafka 的分布式协调和管理任务， 确保 Kafka 集群的高可用性和一致性。\nBroker 注册 ：在 Zookeeper 上会有一个专门 用来进行 Broker 服务器列表记录 的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到 /brokers/ids 下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去 Topic 注册 ：在 Kafka 中，同一个 Topic 的消息会被分成多个分区 并将其分布在多个 Broker 上， 这些分区信息及与 Broker 的对应关系 也都是由 Zookeeper 在维护。比如我创建了一个名字为 my-topic 的主题并且它有两个分区，对应到 zookeeper 中会创建这些文件夹： 负载均衡：Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。 Kafka的基本概念 Topic（主题） Topic是用来区分和隔离不同类型消息的单位。每一个 Topic 都有一个名称，生产者将消息发送到某个特定的 Topic 上，而消费者从某个特定的 Topic 接收消息。\n主要作用\n消息分类：Kafka 通过 Topic 来对消息进行分类管理，生产者和消费者通过 Topic 来组织和订阅消息。 隔离数据：不同业务或模块的数据可以通过不同的 Topic 隔离开，保证数据之间的独立性和安全性。 分区并行：每个 Topic 可以有多个分区，消息会被分布到不同分区上，实现并行处理，提升系统的吞吐量和伸缩性。 Partition（分区） Partition 是指一个Topic中的一个分区。Kafka 主题可以划分为多个分区，每个分区是一个有序的、不可变的消息序列。不同分区中的消息是并行地存储和处理的，这使得 Kafka 能够实现高吞吐量。\n主要作用\n并行处理 ：更多的分区可以让多个消费者实例并行处理消息，从而提升系统的吞吐量。 负载均衡 ：通过增加分区数量，可以更好地分配负载，避免某个节点成为瓶颈。 数据局部性 ：分区可以分布在不同的代理节点上，提高数据的可用性和可靠性。 Consumer Group（消费者组） Consumer Group 是一组消费者（Consumer），它们共同协作来消费一个或多个主题（Topic）中的消息。每个Consumer Group都有一个唯一的标识符。所有属于同一组的消费者会协同工作，以保证一个组内的每条消息仅会被消费一次。\n每个Consumer Group内的每个消费者独立消费不同的分区（Partition）中的数据，一个分区只能被一个Consumer消费。 即使有多个消费者在同一个组内消费同一个Topic，Kafka也会确保每条消息只会被组内的其中一个消费者处理。这样极大地提高了消费的并发能力和处理速度，保证了消息的高效处理。 Consumer Group可以实现负载均衡。当有新的消费者加入或离开组时，Kafka会自动均衡分区的消费，将需要消费的分区重新分配给现存的消费者。 分区的分配规则 生产者分配规则 开发者手动指定partition 指定 key（Kafka 自动 hash 取模） 相同 key 会落到同一个 partition（实现“局部有序”） key 不同的消息可能落到不同 partition，接近均匀分布 既不指定 key，也没 partition（默认轮询 Round-Robin） 消费者分配规则 发生在 Consumer Group 内部 的事情。每个 Topic 下有多个 Partition，Kafka 会把这些分区 均匀地分配给组内的消费者。\nKafka 默认的消费者分区分配策略是\nRange ：按 partition 序号分组（容易不均） RoundRobin ：分区轮着分 Sticky（默认）：尽可能稳定地分区（减少重平衡影响），和 RoundRobin 类似，但尽量保持和上一次分配一致 ","date":"2025-03-18T11:52:55+08:00","permalink":"https://Tyritic.github.io/p/kafka%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","title":"Kafka的架构设计"},{"content":"什么是消息队列 消息队列是一种 异步通信机制 ，用于在 分布式系统 中解耦发送方和接收方之间的通信。它通过在消息生产者和消费者之间引入一个 中间缓冲区 ，将消息存储在 broker 中，然后由消费者从 broker 中读取和处理消息。\n消息队列中的核心概念 生产者（Producer） ：负责向消息队列中发送消息的应用程序或服务。生产者将消息发送到指定的队列或主题（Topic），供消费者消费。 消费者（Consumer） ：从消息队列中读取和处理消息的应用程序或服务。消费者根据业务逻辑处理收到的消息，并可以向消息队列发送确认。 Broker ：消息队列的核心组件，负责接收、存储和分发消息。 队列（Queue） ：存储消息的容器，消息按照先进先出（FIFO）的顺序在队列中存储。队列中的每条消息通常只能被一个消费者消费一次。 主题（Topic） ：用于在发布/订阅模型中，消息生产者将消息发布到一个主题，多个订阅该主题的消费者可以接收到相同的消息。 消息队列的模型 队列模型（点对点模型） 在队列模型中，消息从生产者发送到队列，并且每条消息只能被一个消费者消费一次。消费之后，消息在队列中被删除。适用于任务处理类场景，如一个任务只需要一个处理者执行。\n存在问题：生产者向队列中投放消息，但是队列会有多个消费者，多个消费者之间存在竞争关系，即 每条消息只能被一个消费者消费\n会造成数据冗余的问题\n发布-订阅模型 在发布/订阅模型中，生产者将消息发布到某个主题（Topic），所有订阅了该主题的消费者都会接收到该消息。每个订阅者都会接收到相同的消息，适用于广播通知、实时推送等场景。可以将发布-订阅模型理解为将消费者都加入了一个群聊中，生产者发一条消息，加入了这个群聊的消费者都能收到这条消息。\n消息队列的作用 服务解耦 生产者和消费者无需同时在线，生产者可以发送消息后立即返回，而消费者在合适的时机处理消息。消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合 ，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。 对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现可扩展性设计。\n削峰填谷和流量限制 在高并发场景下，消息队列可以暂存大量请求，平滑高峰流量，避免系统过载。在项目开发中，后端服务相对而言都是比较「弱」的，因为业务较重，处理时间较长。消息队列作为中间件可以起到缓冲的作用。网关的请求先放入消息队列中，后端服务尽自己最大能力去消息队列中消费请求。超时的请求可以直接返回错误。\n异步处理 将用户请求中包含的耗时操作，通过消息队列实现异步处理。\n生产者将对应的消息发送到消息队列之后就立即返回结果，减少响应时间，提高用户体验。随后，消费者再对消息进行消费。请求数据在后续的业务校验、写数据库等操作中可能失败。因此，使用消息队列进行异步处理之后，需要适当修改业务流程进行配合\n推模式和拉模式 推模式和拉模式指的是消费者和Broker之间的交互过程\n推模式（Push） ：消息队列将消息主动推送给消费者，适合实时性要求高、消费者能够及时处理消息的场景。\n优点 ：实时性好，消息可立即送达消费者。\n缺点 ：难以控制消费速度，容易导致消费者过载，尤其是在高并发时。\n拉模式（Pull） ：消费者主动从消息队列中拉取消息，适合消费能力有限、需要根据自身处理能力调控速率的场景。\n优点 ：消费者可以根据自身负载决定拉取频率，避免过载；更适合批量处理。\n缺点 ：可能会导致消息延迟，实时性不如推模式，尤其是拉取频率较低时。\n选择策略 个人认为相较于推模式，拉模式更加适应当下的需求。因为现在的消息队列都有持久化消息的需求，也就是说本身它就有个存储功能，它的使命就是接受消息，保存好消息使得消费者可以消费消息即可，身为 Broker 不应该有依赖于消费者的倾向。\n在Kafka中的实现 Kafka通过长轮询来实现拉模式。具体的做法都是通过消费者去 Broker 拉取消息时，当有消息的情况下 Broker 会直接返回消息，如果没有消息都会采取延迟处理的策略，即保持连接，暂时 hold 主请求，然后在对应队列或者分区有新消息到来的时候都会提醒消息来了，通过之前 hold 主的请求及时返回消息，保证消息的及时性。\n在Kafka中设置了超时参数，消费者去 Broker 拉消息，定义了一个超时时间，也就是说消费者去请求消息，如果有的话马上返回消息，如果没有的话消费者等着直到超时，然后再次发起拉消息请求。并且 Broker 也得配合，如果消费者请求过来，有消息马上返回，没有消息那就建立一个延迟操作，等条件满足了再返回。\n","date":"2025-03-18T11:04:57+08:00","permalink":"https://Tyritic.github.io/p/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80/","title":"消息队列基础"},{"content":"常见的IO模型 同步IO型 阻塞型IO模型 应用程序发起I/O操作后会被阻塞，直到操作完成才返回结果。期间调用方会被挂起，不能继续执行其他任务，直到请求的操作完成\n此时 阻塞等待的是内核数据准备好和数据从内核态拷贝到用户态这两个过程。\n优点：实现简单，逻辑直观；调用后直接等待数据就绪。 缺点：每个连接都需要一个线程，即使没有数据到达，线程也会被占用，导致资源浪费，不适合高并发场景。 非阻塞型IO模型 I/O操作不会阻塞进程，在非阻塞操作中，调用方在发出请求后立即返回。在没数据的时候，用户程序可以不再阻塞等着，而是直接返回错误，告知暂无准备就绪的数据，用户程序会通过轮询操作，不断发起 read 调用，直到内核中的数据拷贝就绪，才会停止发起 read 调用，这时调用方可以继续执行其他任务。\n但是 从内核拷贝到用户空间这一步，用户线程还是会被阻塞的。\n优点：线程不会长时间阻塞，可以在无数据时执行其他任务；适用于部分实时性要求较高的场景。 缺点：轮询方式会频繁进行系统调用，上下文切换开销较大，CPU 占用率较高，不适合大规模连接。 IO复用模型 使用 select 、poll、epoll 等系统调用，允许程序同时等待多个I/O操作，当其中任意一个就绪时进行处理。当其中任何一个I/O操作准备就绪时，应用程序会被通知。通常使用select线程 ，可以往 select 线程注册需要被监听的连接，由 select 线程来监控它所管理的连接是否有数据已就绪，如果有则可以通知别的线程来 read 读取数据。\n但是 从内核拷贝到用户空间这一步，用户线程还是会被阻塞的。\n异步IO型 应用程序发起I/O操作后可以立即做其他事情，当I/O操作完成时，应用程序会得到通知。异步I/O模型由操作系统内核完成I/O操作，应用程序只需等待通知即可。\n异步 I/O 是 内核数据准备好 和 数据从内核态拷贝到用户态 这两个过程都不⽤等待。\n与多路复用模型的区别就是让内核直接把数据拷贝到用户空间之后再告知用户线程\n同步和异步的区别 同步和异步（Asynchronous） 是两种不同的任务执行方式，主要区别在于任务的执行是否需要等待其他任务完成\n同步 ：在同步操作中，任务需要等待前一个任务完成后才能继续。调用者发起请求后，会被阻塞，直到任务完成并返回结果。调用者必须等待结果才能进行后续操作。 异步 ：在异步操作中，任务在发出请求后可以立即继续执行，不需要等待请求的完成。请求的结果会通过回调机制在任务完成后通知调用者。 零拷贝技术 解放CPU的技术-DMA技术 传统的IO流程\n用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态 CPU 发出对应的指令给磁盘控制器，然后返回 磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个中断 CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。 整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。\nDMA（直接内存访问技术）：在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，CPU 就可以去处理别的事务 。\nDMA的工作流程\n用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态 CPU收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务 DMA 进一步将 I/O 请求发送给磁盘； 磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中 DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务 当 DMA 读取了足够多的数据，就会发送中断信号给 CPU； CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回 CPU 不再参与将数据从 磁盘控制器缓冲区搬运到内核空间 的工作，这部分工作全程由 DMA 完成。\nDMA的模式\n突发传输模式\n一旦DMA控制器由处理器授权可以使用总线，就将系统总线的控制权交还給处理器之前传输数据块中的所有数据\n使用场合：将程序或数据文件加载到内存中\n缺点：使处理器在相对较长的时间内处于活动状态\n循环窃取模式\n一旦DMA控制器获得对系统总线的使用权就传输一个字节的数据然后将系统总线的控制权返还给处理器\n多次发出请求直到填满整个数据块\n透明模式\nDMA控制器只在CPU执行不使用系统总线的操作时传输数据，DMA控制器不需要请求系统总线的控制权\n优点：处理器不用停止执行程序\n缺点：确定处理器何时需要使用系统总线所需硬件相对复杂\n传统文件传输技术 传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入\n期间共发生了 4 次用户态与内核态的上下文切换 ，因为发生了两次系统调用，一次是 read() ，一次是 write() ，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。\n第一次上下文切换：把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。 第二次上下文切换：把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。 第三次拷贝：把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。 第四次拷贝：把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。 零拷贝技术 零拷贝（Zero-Copy） 是一种高效的数据传输技术，它可以将数据从内核空间直接传输到应用程序的内存空间中，避免了不必要的数据拷贝，从而提高了数据传输的效率和性能。数据可以直接从外部设备复制到应用程序的内存空间中，避免了中间的内核空间缓冲区，减少了不必要的数据拷贝，提高了数据传输的效率和性能。\nmmap + write mmap() 系统调用函数会直接把内核缓冲区里的数据映射到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。\n应用进程调用了 mmap() 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核共享这个缓冲区； 应用进程再调用 write()，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据； 最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。 sendfile sendfile() 可以替代前面的 read() 和 write() 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。这个系统调用可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态\n对于支持网卡支持 SG-DMA 技术的情况下， sendfile() 系统调用的过程得到优化，具体过程如下：\n通过 DMA 将磁盘上的数据拷贝到内核缓冲区里； 缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝； 网络模型 基本的Socket模型 服务端 服务端首先调用 socket() 函数，创建网络协议为 IPv4，以及传输协议为 TCP 的 Socket 接着调用 bind() 函数，给这个 Socket 绑定一个 IP 地址 和 端口 绑定端口的目的：当内核收到 TCP 报文，通过 TCP 头里面的端口号，来找到应用程序，然后把数据传递给我们。 绑定 IP 地址的目的：一台机器是可以有多个网卡的，每个网卡都有对应的 IP 地址，当绑定一个网卡时，内核在收到该网卡上的包，才会发给我们 调用 listen() 函数进行监听 服务端进入了监听状态后，通过调用 accept() 函数，来从内核获取客户端的连接，如果没有客户端连接，则会阻塞等待客户端连接的到来。 在 TCP 连接的过程中，服务器的内核实际上为每个 Socket 维护了两个队列：\n一个是「还没完全建立」连接的队列，称为 TCP 半连接队列 ，这个队列都是没有完成三次握手的连接，此时服务端处于 syn_rcvd 的状态； 一个是「已经建立」连接的队列，称为 TCP 全连接队列 ，这个队列都是完成了三次握手的连接，此时服务端处于 established 状态； 当 TCP 全连接队列不为空后，服务端的 accept() 函数，就会从内核中的 TCP 全连接队列里拿出一个已经完成连接的 Socket 返回应用程序，后续数据传输都用这个 Socket。\n客户端 客户端创建好 Socket 后 调用 connect() 函数发起连接，指明服务端的 IP 地址和端口号 连接建立后，客户端和服务端就开始相互传输数据了，双方都可以通过 read() 和 write() 函数来读写数据。\n模型的限制 文件描述符 ：Socket 实际上是一个文件，也就会对应一个文件描述符。在 Linux 下，单个进程打开的文件描述符数是有限制的 系统内存 ：每个 TCP 连接在内核中都有对应的数据结构，意味着每个连接都是会占用一定内存的； 多进程模型 服务器的主进程负责监听客户的连接，一旦与客户端连接完成，accept() 函数就会返回一个「已连接 Socket」，这时就通过 fork() 函数创建一个子进程。\n子进程会 复制父进程的文件描述符 ，于是就可以直接使用已连接 Socket 和客户端通信了 父进程将客户端服务交给子进程来处理，因此父进程不需要关心已连接 Socket，只需要关心监听 Socket 多线程模型 当服务器与客户端 TCP 完成连接后，通过 pthread_create() 函数创建线程，然后将已连接 Socket的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。\n线程池 可以避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出「已连接 Socket 」进行处理。\nIO多路复用模型 select/poll模型 IO 多路复用是指将已连接的 Socket 都放到一个文件描述符集合 ，然后调用函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生。\n检查的方式，就是通过遍历文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 Socket，然后再对其处理。\nselect 模型和 poll 模型没有本质区别，都是使用线性结构存储socket\nselect 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，\npoll 使用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制\nepoll模型 epoll 是Linux系统对 select 和 poll 的优化。优化在以下方面。\n红黑树的使用：epoll 在内核里使用 红黑树 代替线性结构跟踪进程所有待检测的文件描述符。红黑树的增删改一般时间复杂度是 $O(logn)$。相较于select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket，当事件发生时只需要传递活跃的文件描述符而不需要传递所有的文件描述符，减少了内核和用户空间大量的数据拷贝和内存分配。\n事件驱动的机制： epoll 使用 事件驱动 的机制，内核里维护了一个链表来记录就绪事件 ，当某个 socket 有事件发生时，通过 回调函数 内核会将其加入到这个就绪事件列表中，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。\nepoll提供了两种事件触发机制 边缘触发 和 水平触发\n边缘触发：当被监控的 Socket 描述符上有事件发生时， 服务器端只会从 epoll_wait 中苏醒一次，只会当事件发生时传递一次事件 ，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完 水平触发：当被监控的 Socket 上有可读事件发生时，服务器端不断地从 epoll_wait 中苏醒，一直不断地把这个事件传递给用户，直到内核缓冲区数据被 read 函数读完才结束 ，目的是告诉我们有数据需要读取 高性能网络模式 Reactor模式 Reactor模式是对 I/O 多路复用作了一层封装，让使用者不用考虑底层网络 API 的细节，只需要关注应用代码的编写。\nReactor模式的核心思想是 将I/O事件与相应的处理程序解耦 ，并通过 事件分发器 来管理事件和响应操作。\n组成部分 Reactor 模式主要由 Reactor 和处理资源池这两个核心部分组成\nReactor： 负责监听和分发事件，它通常封装了一个多路复用器（如 select 、epoll ），在事件到达时将其分发给相应的事件处理器。 Handler：负责处理事件，每个事件处理器与一个具体的I/O事件绑定，定义了在事件发生时应该执行的逻辑。 Acceptor：在服务器端，Acceptor 用于接受新的客户端连接，并为每个新连接分配一个Handler进行后续的数据处理 工作流程 Reactor 通过多路复用器监听多个通道，等待事件（如连接到达、数据可读等）的发生。 当某个通道有事件发生时，Reactor将事件分发给相应的 Handler 。 Handler 根据事件类型执行相应的操作，如读取数据、写入数据或处理业务逻辑。 事件处理完成后，Reactor 继续监听其他事件。 Proactor模式 Proactor 是异步网络模式， 感知的是已完成的读写事件 。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read/write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。\n工作流程 Proactor Initiator 负责创建 Proactor 和 Handler 对象，并将 Proactor 和 Handler 都通过 Asynchronous Operation Processor 注册到内核； Asynchronous Operation Processor 负责处理注册请求，并处理 I/O 操作 Asynchronous Operation Processor 完成 I/O 操作后通知 Proactor Proactor 根据不同的事件类型回调不同的 Handler 进行业务处理 Handler 完成业务处理 Reactor模式和Proactor模式的区别 Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件 ：在每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。 Proactor 是异步网络模式， 感知的是已完成的读写事件 ：在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read/write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。 ","date":"2025-03-16T14:47:26+08:00","permalink":"https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84io%E6%A8%A1%E5%9E%8B/","title":"操作系统的IO模型"},{"content":"RAG技术的应用 检索增强生成（Retrieval-Augmented Generation，RAG）是一种结合大型语言模型（LLM）和外部知识库的技术，旨在提高生成文本的准确性和相关性。 RAG的核心思想是通过引入外部知识源来增强LLM的输出能力。传统的LLM通常基于其训练数据生成响应，但这些数据可能过时或不够全面。RAG允许模型在生成答案之前，从特定的知识库中检索相关信息，从而提供更准确和上下文相关的回答。展馆提供了相关的文档\n模型和向量数据库选择 LLM：qwen2.5:32b Embedding Model：bge-small-zh-v1.5（向量维度为 512 ） 向量数据库：Qdrant RAG实现方案 本项目使用langchain4j来实现RAG功能，langchain4j提供了构建RAG管道的解决方案\nRAG管道的构建 总体构建流程 加载并解析文档：从文件系统中加载本地知识库的文件，使用 ApachePoiDocumentParser 解析本地知识库的文件 转换文档：文件比较简单，暂时不需要进行清理和增强 拆分文档：根据文档特点选择，将文档拆分为小片段 嵌入文档：配置摄取器将被拆分后的文档进行向量化后存储在向量数据库中 检索相关内容：配置检索增强器来增强检索效果 聚合注入内容：在检索增强器中配置注入器来优化用户查询 加载转换文档 本地知识库由以下部分构成\n展馆方提供的展品资料文档，存储在文件系统中。本地知识库中大部分为docx文件 网络上的相关资料 对于本地文件系统的文档，使用 FileSystemDocumentLoader 作为文件加载器，使用 ApachePoiDocumentParser 作为文件解析器\n拆分文档 根据对本地知识库的文档进行分析，文档具有以下特点\n段落结构明显 每个段落描述完整的思想单元 因此文档的划分策略选择为 按照段落进行划分 ，使用的文档划分器为 DocumentByParagraphSplitter\n嵌入文档 根据本地文档的大小选择嵌入模型为 bge-small-zh-v1.5 ，该嵌入模型可以将文本块转换为维度为 512 ，同时选择 Qdrant 作为向量数据库。通过配置摄取器将本地文档嵌入到向量知识库中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 摄取器 @Bean public EmbeddingStoreIngestor embeddingStoreIngestor(EmbeddingModel embeddingModel, InMemoryEmbeddingStore\u0026lt;TextSegment\u0026gt; embeddingStore) { return EmbeddingStoreIngestor.builder() .embeddingModel(embeddingModel) .embeddingStore(embeddingStore) .documentSplitter(new DocumentByParagraphSplitter(300,0)) .build(); } // 向量数据库的配置 @Bean public EmbeddingStore\u0026lt;TextSegment\u0026gt; embeddingStore() { return QdrantEmbeddingStore.builder() .host(\u0026#34;xxx\u0026#34;) .port(6334) .collectionName(\u0026#34;xxx\u0026#34;) .build(); } // 配置嵌入模型 @Bean public EmbeddingModel embeddingModel() { return OllamaEmbeddingModel.builder() .baseUrl(\u0026#34;http://127.0.0.1:11434\u0026#34;) .modelName(\u0026#34;quentinz/bge-small-zh-v1.5\u0026#34;) .build(); } 检索内容 知识库有多个数据源，因此需要为不同的数据源构建 内容检索器 ，同时也要为不同的内容源配置 查询路由器 。\n内容检索器的配置中定义\n设置 最大检索结果数量，最多返回 2条匹配内容。 设置 最小匹配分数，只有相似度大于 0.75 的内容才会返回。 设置 动态过滤器 ，确保只是检索当前用户的资料 其中本地文档的内容检索器和网络资源的内容检索器定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 本地文档的内容检索器 @Bean public EmbeddingStoreContentRetriever contentRetriever(EmbeddingModel embeddingModel, InMemoryEmbeddingStore\u0026lt;TextSegment\u0026gt; embeddingStore){ return EmbeddingStoreContentRetriever.builder() .embeddingStore(embeddingStore) .embeddingModel(embeddingModel) .dynamicFilter(query -\u0026gt; { String userId = getUserId(query.metadata().chatMemoryId()); return metadataKey(\u0026#34;userId\u0026#34;).isEqualTo(userId); }) .minScore(0.75) .maxResults(2) .build(); } // 网络资源的内容检索器 @Bean public WebSearchEngine webSearchEngine(){ return TavilyWebSearchEngine.builder() .apiKey(\u0026#34;XXX\u0026#34;) .build(); } @Bean public WebSearchContentRetriever webSearchContentRetriever(WebSearchEngine webSearchEngine) { return WebSearchContentRetriever.builder() .webSearchEngine(webSearchEngine) .maxResults(3) .build(); } 由于知识库有多个数据源，可以实现结构重排，在 内容聚合器 上有两种策略可以选择\n默认实现：使用RRF策略进行结果重排 ReRankingContentAggregator ：使用重排序进行结果重排 在策略的选择方面，通过查阅资料可知\nRRF 策略更加适合多数据源的融合排序，但是会对语义匹配略有损失 Rerank 策略基于深度学习模型需要足够大的知识库进行结果重排，同时在长文本的匹配上具有优势 经过对比选择默认的 RRF 策略进行内容聚合\n为了将内容聚合后的结果注入到用户查询中，需要配置 内容注入器 ，内容注入器采用默认策略即可\n同时根据项目中上下文的场景，配置 查询转换器 ，使用LLM来压缩查询和对话上下文，提高查询的质量\n由此可以构建出一个完整的检索增强器\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Bean public DefaultRetrievalAugmentor defaultRetrievalAugmentor(EmbeddingStoreContentRetriever embeddingStoreContentRetriever,OllamaChatModel ollamaChatModel,WebSearchContentRetriever webSearchContentRetriever){ return DefaultRetrievalAugmentor.builder() // 配置压缩查询转换器:使用ollamaChatModel压缩查询 .queryTransformer(new CompressingQueryTransformer(ollamaChatModel)) // 配置内容注入器:默认实现 .contentInjector(new DefaultContentInjector()) // 配置内容聚合器:采用默认实现的RRF策略进行结果重排 .contentAggregator(new DefaultContentAggregator()) // 配置查询路由器:采用默认实现 .queryRouter(new DefaultQueryRouter(embeddingStoreContentRetriever, webSearchContentRetriever)) .build(); } 流式响应的实现方案 出于对用户使用体验的考虑，使用流式响应比一次性响应在用户体验上表现更好。\nlangchain4j提供了实现流式响应的方法，Flux\u0026lt;String\u0026gt; chat(@V(\u0026quot;question\u0026quot;) String question)\n可以使用Flux流式响应+SSE协议实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @RestController @RequiredArgsConstructor @CrossOrigin(origins = \u0026#34;*\u0026#34;) @RequestMapping(\u0026#34;/common\u0026#34;) public class DemoController { @Autowired private final StreamChatAssistant chatAssistant; @Autowired EmbeddingStore\u0026lt;TextSegment\u0026gt; embeddingStore; @Autowired EmbeddingModel embeddingModel; @GetMapping(value=\u0026#34;/chat\u0026#34;,produces = MediaType.TEXT_EVENT_STREAM_VALUE) public Flux\u0026lt;String\u0026gt; chat(@RequestParam(\u0026#34;message\u0026#34;) String message) { Document document = FileSystemDocumentLoader.loadDocument(\u0026#34;xxxxxx\u0026#34;); EmbeddingStoreIngestor.ingest(document, embeddingStore); return chatAssistant.chat(message); } } 多用户的上下文隔离和持久化的解决方案 langchain4j提供多用户的上下文隔离和持久化方案。上下文隔离使用langchain4j提供的 MessageWindowChatMemory 。它采用滑动窗口的方式,保留最新的N条消息,并淘汰旧消息。同时使用 ChatMemoryProvider 实现多用户的上下文隔离\n本项目的用户上下文的持久化采用Redis。、\n具体实现\n1 2 3 4 5 6 7 8 9 // 上下文隔离 @Bean public ChatMemoryProvider chatMemory(){ return memoryId -\u0026gt; MessageWindowChatMemory.builder() .id(memoryId)// 指定ID .maxMessages(10) // 保存10条上下文消息 .chatMemoryStore(store) // 上下文持久化 .build(); } 并发问题的解决方案 初步解决方案 通过查阅网上资料，ollama的自身支持多模型加载和并发请求。\n可以通过调整环境变量初步解决并发问题\n最多同时加载到内存中模型的数量：OLLAMA_MAXLoaded_MODELS 请求处理的并发数量： OLLAMA_NUM_PARALLEL 但是受限于算力有限，假设前端传过来的请求数过大，可能会导致后端服务应付不过来了。\n目前的解决方案 经过和师兄和老师的研讨，初次迭代考虑采用限流算法实现”削峰填谷“的作用。目前常用的限流算法有以下两种\n令牌桶算法 ：维护一个固定容量的令牌桶，每秒钟会向令牌桶中放入一定数量的令牌。当有请求到来时，如果令牌桶中有足够的令牌，则请求被允许通过并从令牌桶中消耗一个令牌，否则请求被丢弃 漏桶算法 ：对于每个到来的请求，都将其加入到漏桶中，并检查漏桶中当前的水量是否超过了漏桶的容量。如果超过了容量，就将多余的数据包丢弃。如果漏桶中还有水，就以一定的速率从桶底输出请求，保证输出的速率不超过预设的速率，从而达到限流的目的。 经过权衡之后决定选择令牌桶算法\n令牌桶算法使用基于Guava的实现，Guava提供了限速器，支持设置预热时间和每秒产生的令牌数。在过滤器中实现令牌桶算法的主要逻辑\n","date":"2025-03-15T20:49:08+08:00","permalink":"https://Tyritic.github.io/p/%E8%AF%86%E7%89%A9%E6%8E%A2%E8%B6%A3%E4%BA%94%E5%86%85%E5%AE%B9%E7%94%9F%E6%88%90%E6%A8%A1%E5%9D%97/","title":"识物探趣（五）内容生成模块"},{"content":"文件系统的概念 文件系统是操作系统中负责管理持久数据的子系统\n文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。\n对于Linux系统 一切皆文件，除了普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。\n文件的结构 Linux 文件系统会为每个文件分配两个数据结构：索引节点（index node）和目录项（directory entry），它们主要用来记录文件的元信息和目录层次结构。\n索引节点：用来记录文件的元信息，比如文件大小、访问权限、创建时间、修改时间、 数据在磁盘的位置 等等。索引节点是文件的 唯一 标识，它们之间一一对应，也同样都会被存储在硬盘中，所以 索引节点同样占用磁盘空间 。 目录项：用来记录文件的名字、索引节点指针 以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是， 目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存 。 目录项和索引节点的关系是多对一，一个文件可以有多个别名\n提示\n目录项和目录的关系和区别\n目录是个文件，持久化存储在磁盘\n目录项是内核维护数据结构，缓存在内存。\n如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。\n虚拟文件系统 操作系统 对用户提供一个统一的接口 ，于是在用户层与文件系统层引入了虚拟文件系统作为中间层\n虚拟文件系统定义了一组所有文件系统都支持的数据结构和标准接口\n磁盘的文件系统：直接把数据存储在磁盘中 内存的文件系统：数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 /proc 和 /sys 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据。 网络的文件系统：用来访问其他计算机主机数据的文件系统 文件系统首先要先挂载到某个目录才可以正常使用\nLinux系统的目录树 目录树由根目录（/）作为起始点，向下延伸，形成一系列的目录和子目录。\n/bin： 存放二进制可执行文件(ls、cat、mkdir 等)，常用命令一般都在这里； /etc： 存放系统管理和配置文件； /home： 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是/home/user，可以用~user 表示； /usr： 用于存放系统应用程序； /opt： 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里； /proc： 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息； /root： 超级用户（系统管理员）的主目录（特权阶级^o^）； /sbin: 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等； /dev： 用于存放设备文件； /mnt： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统； /boot： 存放用于系统引导时使用的各种文件； /lib 和/lib64： 存放着和系统运行相关的库文件 ； /tmp： 用于存放各种临时文件，是公用的临时文件存储点； /var： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等； /lost+found： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。 软链接和硬链接 在 Linux系统上，文件链接是一种特殊的文件类型，可以在文件系统中指向另一个文件。\n硬链接 硬链接是为 同一个文件创建多个目录项 ，也就是指向同一个索引节点。由于多个目录项都是指向一个索引节点，那么 只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。 硬链接具有一些限制，不能对目录以及不存在的文件创建硬链接，并且，硬链接也不能跨越文件系统。\n提示\n为什么硬链接不能跨域文件系统\n硬链接是 多个目录项中的索引节点指向一个文件 ，也就是指向同一个索引节点。索引节点是不可能跨越文件系统的，每个文件系统都有各自的索引节点数据结构和列表，所以硬链接是不可用于跨文件系统的。\n软链接 软链接本质上是一个特殊类型的文件，这个文件有 独立的索引节点 ，但是这个 文件的内容是另外一个文件的路径 ，类似于Windows系统的快捷方式，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以 软链接是可以跨文件系统的 ，即使目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。\n","date":"2025-03-14T17:35:09+08:00","permalink":"https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","title":"操作系统的文件系统"},{"content":"虚拟内存 虚拟内存的定义 虚拟内存 是计算机系统内存管理非常重要的一个技术，本质上来说它只是逻辑存在的，是一个假想出来的内存空间，主要作用是作为进程访问主存（物理内存）的桥梁并简化内存管理。每个程序在运行时认为自己拥有的内存空间就是虚拟内存，其大小可以远远大于物理内存的大小。\n虚拟内存的存在意义 如果直接操作物理地址的话，存在以下的问题\n用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易破坏操作系统，造成操作系统崩溃。 同时运行多个程序会特别困难，当两个用户程序引用同一个物理地址时会导致程序崩溃 而在进程和物理内存之间添加一个中间层虚拟地址，就可以解决这个问题。因为进程不会直接操作物理地址，导致多个进程不会同时引用同一个物理地址\n虚拟地址的原理 虚拟地址作为中间层把进程所使用的地址隔离开来（让操作系统为每个进程分配独立的一套 虚拟地址 ，进程之间的地址是隔离的，互不干涉。前提每个进程都不能访问物理地址。至于虚拟地址最终怎么映射到物理内存里，对进程来说是透明的，操作系统将决定虚拟地址和物理地址的映射关系\n程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。\n提示\n虚拟内存地址 ：程序所使用的内存地址，由CPU生成，用于内存的访问和操作。逻辑地址在程序编写和编译时使用，并由操作系统通过地址转换机制（如页表）映射到物理地址。 物理内存地址 ：实际存在硬件里面的空间地址，由内存管理单元（MMU）直接访问。它表示数据在物理内存中的实际存储位置，是由硬件层面决定的。物理地址直接对应到内存芯片上的某个位置，它是CPU在访问内存时经过地址转换后的实际地址 操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存\n虚拟内存的优点 内存扩展能力：\n虚拟内存允许程序运行在比实际物理内存大的地址空间上。即使物理内存不足，系统也可以通过交换（swapping）将不常用的内存页移到磁盘中，使得多个程序能够同时运行。 进程隔离：\n每个进程拥有独立的虚拟地址空间，防止进程间的内存访问冲突，提高系统稳定性和安全性。\n使用虚拟内存，操作系统可以通过页面表设置访问权限，防止非法访问。\n简化内存管理：\n操作系统可以更灵活地分配和回收内存，无需手动考虑物理内存布局问题。\n虚拟内存可以将程序逻辑地址与物理地址解耦。\n物理地址和虚拟地址的映射管理方式 分段管理 将程序视为若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，同时具有实际意义和逻辑信息。将程序以段的形式进行划分，连续 的物理内存的形式管理/分配物理内存\n分段管理下的虚拟地址 分段机制下的虚拟地址由两部分组成：段选择因子 和 段内偏移量。\n段选择因子 ：保存在段寄存器里面 段号 ：用作段表的索引，标识这个段在虚拟地址的哪一段 段标志位 ：某些特权位 段内偏移量 ：相对于该段的起始地址的偏移量，位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。 分段管理下的地址映射 虚拟地址是通过 段表 与物理地址进行映射的。段表 里面保存的是这个 段的基地址、段的界限和特权等级 等。\n分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，由MMU进行地址翻译\nMMU 首先解析得到虚拟地址中的段号 通过段号去该应用程序的段表中取出对应的段信息（找到对应的段表项） 从段信息中取出该段的起始地址（物理地址）加上虚拟地址中的段内偏移量得到最终的物理地址 分段管理的缺点 分段管理会产生 外部碎片 。每个段的长度不固定，所以多个段未必能恰好使用所有的内存空间，会产生了多个不连续的小物理内存，导致新的程序无法被装载\n解决方法：内存交换\n可以通过将整块的内存先写入硬盘然后在读入内存，但是读入内存时不会占据原来的内存位置而是尽量和其他的整块内存相连，使得原来碎片化的内存合并起来。\n分页管理 分页管理是把整个虚拟和物理内存空间切成⼀段段连续且尺寸固定的内存空间。其中在虚拟内存称为 页 ，在物理内存的称为 页框 。\n页和页框的大小相同，在Linux系统中大小为4KB。页表保存了页和页框之间的映射关系\n分页管理下的虚拟地址 在分页机制下，虚拟地址分为两部分，页号 和 页内偏移 。页号作为页表的索引，页表 包含物理页每页所在 物理内存的基地址 ，这个基地址与页内偏移的组合就形成了物理内存地址。地址翻译依然由MMU完成\n分页管理下的地址映射 MMU 首先解析得到虚拟地址中的虚拟页号 通过虚拟页号去该应用程序的页表中取出对应的物理页号（找到对应的页表项） 用该物理页号对应的物理页起始地址（物理地址）加上虚拟地址中的页内偏移量得到最终的物理地址 当页表中的页表项未被命中时，代表物理内存中没有对应的物理页或者物理内存中有对应的物理页但虚拟页还未和物理页建立映射（对应的页表项不存在）就会抛出缺页异常。此时系统进入内核态，针对不同类型的缺页中断进行操作\n硬性页缺失 ：物理内存中没有对应的物理页。于是，Page Fault Handler 会指示 CPU 从已经打开的磁盘文件中读取相应的内容到物理内存，而后交由 MMU 建立相应的虚拟页和物理页的映射关系。 软性页缺失 ：物理内存中有对应的物理页，但虚拟页还未和物理页建立映射。于是，Page Fault Handler 会指示 MMU 建立相应的虚拟页和物理页的映射关系。 如果没有空闲的物理内存，那么内核就会开始进行 回收内存 的工作，回收的方式主要是两种：直接内存回收和后台内存回收。\n后台内存回收 ：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程异步的，不会阻塞进程的执行。 直接内存回收 ：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是同步的，会阻塞进程的执行。 分页管理下的内存交换 当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间会被临时保存到磁盘，等到那些程序要运行时，再从磁盘中恢复保存的数据到内存中。\n内存交换 就是把一块磁盘空间或者本地文件，当成内存来使用，它包含换出和换入两个过程\n换出 ：把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存 换入 ：在进程再次访问这些内存的时候，把它们从磁盘读到内存中来 提示\n当内存资源不足时，Linux 把某些页的内容转移至磁盘上的一块空间上，以释放内存空间。磁盘上的那块空间叫做交换空间（swap space），而这一过程被称为交换。物理内存和交换空间的总容量就是虚拟内存的可用容量。\n分页管理的优缺点 优点 解决了外部碎片的问题 ：由于页和页框大小固定，可以有效避免分段方式中段间未使用内存造成的外部碎片问题。 内存管理灵活：页表支持页的按需加载和交换（如虚拟内存机制），可以将不常用的页交换到磁盘上，从而扩大进程的可用内存空间 缺点 内部碎片 ：如果程序使用的内存量不足一个页的大小，会造成页内未使用部分的浪费，即内部碎片问题。 页表管理开销大 ：每个进程都需要维护自己的页表，页表的大小与逻辑地址空间成正比。多级页表虽然节省了内存，但增加了地址转换的复杂性。 页面置换算法 先进先出置换算法 ：基本思路是，优先淘汰最早进入内存的页面。FIFO 算法维护一个队列，新来的页面加入队尾，当发生页面置换时，队头的页面（即最早进入内存的页面）被移出。 最少使用页面置换算法（LFU） : 置换算法选择的是之前一段时间内使用最少的页面作为淘汰页。 时钟页面置换算法 ：LRU 的一种近似和实现简单的形式。它通过一个循环列表（类似时钟的指针）遍历页面，每个页面有一个使用位，当页面被访问时，使用位设置为 1。当需要页面置换时，时钟指针会顺时针移动，直到找到使用位为 0 的页面进行置换。这个过程类似于给每个页面一个二次机会。算法执行时，会先将使用位从 1 清零，如果该页面再次被访问，它的使用位再次被设置为 1。 最近最久未使用页面置换算法（LRU） ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。 ","date":"2025-03-14T14:46:12+08:00","permalink":"https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","title":"操作系统的内存管理"},{"content":"垃圾回收机制 垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存爆掉。有效的使用可以使用的内存，对内存中已经死亡的或者长时间没有使用的对象进行清除和回收。\n垃圾回收的触发条件\n内存不足时 ：当JVM检测到堆内存不足，无法为新的对象分配内存时，会自动触发垃圾回收。 手动请求 ：虽然垃圾回收是自动的，但是可以通过调用 System.gc() 或 Runtime.getRuntime().gc() 建议 JVM 进行垃圾回收。不过这只是一个建议，并不能保证立即执行。 JVM参数 ：启动 Java 应用时可以通过 JVM 参数来调整垃圾回收的行为，比如：-Xmx（最大堆大小）、-Xms（初始堆大小）等。 对象数量或内存使用达到阈值 ：垃圾收集器内部实现了一些策略，以监控对象的创建和内存使用，达到某个阈值时触发垃圾回收。 堆的空间分配 堆是垃圾收集器管理的主要区域。\n在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：\n新生代(Young Generation)：存放新创建的对象。 Eden 区：所有新创建的对象首先分配到 Eden 区 Survivor 区：Eden 区中的存活对象会被复制到 Survivor 区（一般分为两个区域，S0 和 S1），经过多次 GC 存活的对象会逐渐晋升到老年代。 From区 To区 老生代(Old Generation)：存放存活时间较长的对象，通常是从新生代晋升过来的对象。 永久代(Permanent Generation)：存放类的元数据信息，包括类的静态变量、方法等 JDK 8 版本之后 永久代已被 元空间 取代，元空间使用的是直接内存\n提示\n分代回收的原因\n主要是为了提高垃圾回收效率，依据对象的生命周期特点来进行优化。\n对象的生命周期特点：\n大多数对象存活时间短 ：大部分对象会很快变成垃圾，不再被使用，这些短生命周期的对象会分配在新生代。 少部分对象存活时间长 ：一些长期存活的对象不会很快被回收，分配在新生代的对象经过多次垃圾回收仍存活的，将晋升到老年代。 不同的回收算法：\n新生代的回收 ：新生代通常采用 复制算法，因为新生代中大部分对象生命周期短，大部分会在一次 GC 中被回收，复制算法只需要在内存中保留少量存活对象，并将它们复制到 Survivor 空间，回收剩余区域。这种算法效率很高，适合新生代对象频繁创建和回收的特点。 老年代的回收：老年代中对象存活时间长，回收频率低，使用 标记-整理算法 或 标记-清除算法，更加适合老年代对象的特性。 新生代 新生代用来接收新创建的对象\n新生代的分区逻辑 主要是为了提供内存利用率。\n由于新生代对象朝生夕死的特性，天然适合复制算法。如果将新生代一分为二，划两块区域，每次只使用其中一个，GC 后将存活的复制到另一个区域，然后清理老区域非存活对象，这样替换使用两块区域可以避免内存碎片的存在。内存利用率只用一半\n因此要将新生代划分为Eden区和Survivor区，其中Survivor区被分S0和S1两个区域来执行标记-复制算法，轮流执行标记-复制算法\nEden区 多数情况下，对象会在新生代 Eden 区中进行分配，当 Eden 区没有足够空间进行分配时，JVM 会发起一次 Minor GC，Minor GC 相比 Major GC 更频繁，回收速度也更快。\n通过 Minor GC 之后，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区，如果 From 区不够，则直接进入 To 区。\nSurvivor区 Survivor 的存在意义就是减少被送到老年代的对象，进而减少 Major GC 的发生。Survivor 的预筛选保证，只有经历 16 次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。\n老年代 老年代占据着 2/3 的堆内存空间，只有在 Major GC 的时候才会进行清理，每次 GC 都会触发“Stop-The-World”。\n由于复制算法在对象存活率较高的老年代会进行很多次的复制操作，效率很低，所以老年代这里采用的是标记整理算法。\n对于某些对象直接进入老年代\n大对象： 需要大量连续内存空间的对象，这部分对象都会直接进到老年代。这样做主要是为了避免在 Eden 区及 2 个 Survivor 区之间发生大量的内存复制。 长期存活对象 ：虚拟机给每个对象定义了一个对象年龄（Age）计数器。正常情况下对象会不断的在 Survivor 的 From 区与 To 区之间移动，对象在 Survivor 区中每经历一次 Minor GC，年龄就增加 1 岁。当年龄增加到 15 岁时，这时候就会被转移到老年代。 动态对象年龄 ：如果 Survivor 空间中某个年龄段的对象总大小超过了 Survivor 空间的一半，那么该年龄段及以上年龄段的所有对象都会在下一次垃圾回收时被晋升到老年代，无需等到15岁。 垃圾判断算法 引用计数法 原理：为每个对象分配一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1。当计数器为0时，表示对象不再被任何变量引用，可以被回收。 缺点 ：无法处理循环引用的问题，两个对象互相引用时，引用计数器永远不会为 0 可达性分析算法 原理 ：从GC Roots（垃圾收集根）的对象出发，向下追溯它们引用的对象，以及这些对象引用的其他对象，以此类推。如果一个对象到GC Roots没有任何引用链相连（即从GC Roots到这个对象不可达），那么这个对象就被认为是不可达的，可以被回收。 前置操作（Stop the world） ：在进行垃圾回收之前，JVM 会暂停所有正在执行的应用线程。可达性分析过程必须确保在执行分析时，内存中的对象关系不会被应用线程修改。如果不暂停应用线程，可能会出现对象引用的改变，导致垃圾回收过程中判断对象是否可达的结果不一致，从而引发严重的内存错误或数据丢失。 提示\n可以作为GC ROOT的对象\n线程栈中的引用 ：每个线程栈中的局部变量、参数等。 类的静态变量 ：被类加载器加载后的类会存储在方法区，类的静态变量可以作为 GC Roots。 JNI 全局引用 ：通过 JNI 创建的全局引用可以作为 GC Roots。 运行时常量池中的常量（String 或 Class 类型） 垃圾回收算法 标记-清除算法 标记-清除算法是最基础的垃圾回收算法，分为“标记（Mark）”和“清除（Sweep）”阶段。\n首先标记出所有不需要回收的对象\n在标记完成后统一回收掉所有没有被标记的对象。\n优缺点\n优点：易于实现，可以处理所有对象 缺点 效率问题 ：标记和清除的过程效率都不高 内存碎片 ：清除结束后会造成大量的碎片空间。有可能会造成在申请大块内存的时候因为没有足够的连续空间导致再次 GC。 标记-复制算法 为了解决碎片空间的问题，出现了对标记-清除算法的改进。\n原理：\n将内存分成两块，每次申请内存时都使用其中的一块 当内存不够时，将这一块内存中所有存活的复制到另一块上。然后将然后再把已使用的内存整个清理掉。 优缺点\n优点 无需处理内存碎片，分配效率高。 缺点： 内存利用率严重不足 ：需要双倍的内存空间，浪费了一半的空间。 提示\n新生代中主要使用标记复制算法\n标记-整理算法 标记整理算法（Mark-Compact），标记过程仍然与标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。\nStop The World \u0026ldquo;Stop The World\u0026quot;是 Java 垃圾收集中的一个重要概念。在垃圾收集过程中，JVM 会暂停所有的用户线程.。主要原因是为了防止在垃圾收集过程中，用户线程修改了堆中的对象，导致垃圾收集器无法准确地收集垃圾。\n分代垃圾回收机制 根据对象的分代机制，针对各代有不同的垃圾回收机制\nYoung GC（Minor GC）：针对新生代的垃圾回收 Major GC（Old GC）：针对老年代的垃圾回收 Full GC：全堆垃圾回收 Mix GC：混合垃圾回收，同时回收新生代和部分老年代区域 Minor GC 作用范围：只针对新生代进行回收，包括Eden区和两个Survivor区（S0和S1）。 触发条件： Eden区空间不足 ：当Eden区空间不足时，JVM会触发一次Minor GC，回收新生代中不再使用的对象 Eden 区和 Survivor 区的空间装满 ：如果 Eden 区和 Survivor 区的空间都不足以存放新分配的对象时，Young GC 也会被触发，清理空间并将幸存的对象转移到 Survivor 区或老年代。 特点：通常发生得非常频繁，因为年轻代中对象的生命周期较短，回收效率高，暂停时间相对较短。 Major GC 作用范围：只针对老年代。 触发条件：当老年代空间不足时触发，通常是当从新生代晋升到老年代的对象过多，或者老年代的存活对象数量达到一定阈值时。 执行方式：只回收老年代的对象，新生代不受影响。 特点：相比Minor GC，Major GC发生的频率较低，但每次回收可能需要更长的时间，因为老年代中的对象存活率较高。 Full GC 作用范围：对整个堆内存（包括新生代和老年代）进行回收。 触发条件： 命令调用 ：直接调用 System.gc() ,JVM会尝试执行Full GC。 永久代（元空间）内存不足：当永久代（Java 8之前的版本）或元空间（Java 8及以后的版本）空间不足时。 新生代到老年代晋升失败 ：Minor GC（新生代垃圾回收）时，如果存活的对象无法全部放入老年代，或者老年代空间不足以容纳存活的对象，则会触发Full GC，对整个堆内存进行回收。 执行方式：回收所有代（新生代、老年代）中的垃圾，并且可能会伴随着元空间的回收。 Full GC 会从 GC Root 出发，标记所有可达对象。新生代使用复制算法，清空 Eden 区。老年代使用标记-整理算法，回收对象并消除碎片。 特点：回收时间最长，会触发整个 JVM 的停顿（Stop-The-World），对性能有较大影响，通常不希望频繁发生。 Mixed GC Mixed GC（仅适用于 G1 GC 的混合垃圾回收）：\n作用范围：同时回收新生代和部分老年代区域。 触发条件：当 G1 垃圾回收器发现老年代区域的垃圾过多时触发。 执行方式：混合回收新生代和部分老年代区域，主要目的是减少老年代中的垃圾积压。 特点：结合了 YGC 的快速回收和 OGC 的深度回收，尽量减少停顿时间，适用于大内存应用。 垃圾收集器 新生代垃圾收集器 Serial 收集器 Serial（串行）收集器是最基本的垃圾收集器了。Serial收集器是单线程收集器，它只会使用一条垃圾收集线程去完成垃圾收集工作。同时在进行垃圾收集工作的时候必须触发 Stop-The-World（STW）操作，所有应用线程在 GC 时暂停。\n新生代采用标记-复制算法，老年代采用标记-整理算法。\nParNew 收集器 ParNew 收集器是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。与 CMS 收集器配合使用时，通常会选择 ParNew 收集器作为新生代收集器。\n新生代采用标记-复制算法，老年代采用标记-整理算法。\nParallel Scavenge 收集器 也称为 \u0026ldquo;吞吐量收集器\u0026rdquo;，追求最大化 CPU 时间的利用率。并行处理新生代垃圾回收，适合大规模后台任务处理，注重吞吐量而非延迟。\n新生代采用标记-复制算法，老年代采用标记-整理算法。\n老年代垃圾收集器 Serial Old 收集器 Serial 收集器的老年代版本，使用标记-整理（Mark-Compact）算法进行垃圾回收。\nParallel Old 收集器： Parallel Scavenge 收集器的老年代版本，使用多线程并行标记-整理算法。\nCMS收集器 CMS收集器是一种以获取最短回收停顿时间为目标的收集器。它实现了让垃圾收集线程与用户线程（基本上）同时工作。\n工作流程：CMS 使用 标记-清除 算法进行垃圾收集\n初始标记 ：标记所有从 GC Roots 直接可达的对象，这个阶段需要 STW，但速度很快 并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短 并发清除：清除未被标记的对象，回收它们占用的内存空间 提示\n三色标记法\n三色标记算法 是垃圾回收器中常用的一种 增量标记算法\n三色标记的基本概念：\n白色对象 ：表示还没有被垃圾回收器访问到的对象，这些对象有可能是垃圾。 灰色对象 ：表示已经被访问到，但其引用的其他对象还没有被处理完。 黑色对象 ：表示已经被访问到且其引用的所有对象也都已经标记完毕，这些对象不会被回收。 标记过程：\n初始标记：从 GC Roots 开始，标记所有直接可达的对象为灰色。 并发标记：在此阶段，标记所有灰色对象引用的对象为灰色，然后将灰色对象自身标记为黑色。这个过程是并发的，和应用线程同时进行。 重新标记：重新标记阶段的目标是处理并发标记阶段遗漏的引用变化。为了确保所有存活对象都被正确标记，remark 需要在 STW 暂停期间执行。 使用写屏障（Write Barrier）来捕捉并发标记阶段应用线程对对象引用的更新。通过遍历这些更新的引用来修正标记状态，确保遗漏的对象不会被错误地回收。 缺点\n对 CPU 资源敏感 无法处理浮动垃圾 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。 G1收集器 G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。\nG1 把 Java 堆划分为多个大小相等的独立区域Region，每个区域都可以扮演新生代或老年代的角色。同时，G1 还有一个专门为大对象设计的 Region，叫 Humongous 区。\nG1 基于标记\u0026ndash;整理 算法, 不会产生空间碎片\n工作流程\n初始标记： 短暂停顿（Stop-The-World，STW），标记从 GC Roots 可直接引用的对象，即标记所有直接可达的活跃对象 并发标记，G1 通过并发标记的方式找出堆中的垃圾对象。并发标记阶段与应用线程同时执行，不会导致应用线程暂停。 混合收集，在并发标记完成后，G1 会计算出哪些区域的回收价值最高（也就是包含最多垃圾的区域），然后优先回收这些区域。这种回收方式包括了部分新生代区域和老年代区域。选择回收成本低而收益高的区域进行回收，可以提高回收效率和减少停顿时间。 可预测的停顿 G1 在垃圾回收期间仍然需要「Stop the World」。不过，G1 在停顿时间上添加了预测机制，用户可以 JVM 启动时指定期望停顿时间，G1 会尽可能地在这个时间内完成垃圾回收。 G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)\nG1和CMS的区别和使用场景 区别 使用范围不一样 CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用 G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用 垃圾碎片 CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片 G1收集器使用的是“标记-整理”算法，进行了空间整合，没有内存空间碎片。 使用场景 CMS适用场景：\n低延迟需求 ：适用于对停顿时间要求敏感的应用程序。 老生代收集 ：主要针对老年代的垃圾回收。 碎片化管理 ：容易出现内存碎片，可能需要定期进行Full GC来压缩内存空间。 G1适用场景：\n大堆内存 ：适用于需要管理大内存堆的场景，能够有效处理数GB以上的堆内存。 对内存碎片敏感 ：G1通过紧凑整理来减少内存碎片，降低了碎片化对性能的影响。 比较平衡的性能 ：G1在提供较低停顿时间的同时，也保持了相对较高的吞吐量。 ","date":"2025-03-12T11:36:21+08:00","permalink":"https://Tyritic.github.io/p/jvm%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","title":"JVM的垃圾回收"},{"content":"类加载器的作用 Java 的类加载器（ClassLoader）是 JVM 中用于动态加载类文件的组件。它将 .class 文件中的字节码加载到内存中，并将其转换为 Class 对象，以供 JVM 执行。JVM 的操作对象是 Class 文件，JVM 把 Class 文件中描述类的数据结构加载到内存中，并对数据进行校验、解析和初始化，最终转化成可以被 JVM 直接使用的类型，这个过程被称为类加载机制。\n动态加载类 ：在运行时根据需要加载类，而不是在编译时加载所有类。 隔离不同的类命名空间 ：通过不同的类加载器，可以隔离同名类，使得它们不会相互冲突 类加载器加载原则 JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。\n对于已经加载的类会被放在 ClassLoader 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。\n类加载器的种类 启动类加载器：它是属于虚拟机自身的一部分，用 C++ 实现的（JDK9 后用 java 实现），主要负责加载\u0026lt;JAVA_HOME\u0026gt;\\lib目录中或被 -Xbootclasspath 指定的路径中的并且文件名是被虚拟机识别的文件，它是所有类加载器的父亲。 扩展类加载器：它是 Java 实现的，独立于虚拟机，主要负责加载\u0026lt;JAVA_HOME\u0026gt;\\lib\\ext目录中或被 java.ext.dirs 系统变量所指定的路径的类库。 应用程序类加载器：它是 Java 实现的，独立于虚拟机。主要负责加载用户类路径(classPath)上的类库，如果我们没有实现自定义的类加载器那这个加载器就是我们程序中的默认加载器。 提示\n除了 BootstrapClassLoader 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 ClassLoader抽象类。\n类加载过程 类从被加载到 JVM 开始，到卸载出内存，整个生命周期分为七个阶段，分别是加载、验证、准备、解析、初始化、使用和卸载。其中验证、准备和解析这三个阶段统称为连接。\n加载 JVM 在该阶段的目的是将字节码从不同的数据源（可能是 class 文件、也可能是 jar 包，甚至网络）转化为二进制字节流加载到内存中，将静态数据结构转化成方法区中运行时的数据结构，并生成一个代表该类的 java.lang.Class 对象\n链接 验证 JVM 会在该阶段对二进制字节流进行校验，只有符合 JVM 字节码规范的才能被 JVM 正确执行。该阶段是保证 JVM 安全的重要屏障，保证被校验类的方法在运行时不会做出危害虚拟机的事件。\n准备 JVM 会在该阶段对static 关键字修饰的静态变量，分配内存并初始化，对应数据类型的默认初始值。\n解析 该阶段将常量池中的符号引用转化为直接引用。\n提示\n符号引用和直接引用的区别\n符号引用 ：以一组符号（任何形式的字面量，只要在使用时能够无歧义的定位到目标即可）来描述所引用的目标。在编译时，Java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。 定义：包含了类、字段、方法、接口等多种符号的全限定名。 特点：在编译时生成，存储在编译后的字节码文件的常量池中。 独立性：不依赖于具体的内存地址，提供了更好的灵活性。 直接引用 ：通过对符号引用进行解析，找到引用的实际内存地址。 定义：直接指向目标的指针、相对偏移量或者能间接定位到目标的句柄。 特点：在运行时生成，依赖于具体的内存布局。 效率：由于直接指向了内存地址或者偏移量，所以通过直接引用访问对象的效率较高。 初始化 初始化阶段是执行初始化方法 \u0026lt;clinit\u0026gt; () 方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。\n初始化的时机\n创建类的实例时。 访问类的静态方法或静态字段时（除了 final 常量，它们在编译期就已经放入常量池）。 使用 java.lang.reflect 包的方法对类进行反射调用时。 初始化一个类的子类（首先会初始化父类）。 JVM 启动时，用户指定的主类（包含 main 方法的类）将被初始化。 卸载 卸载类即该类的 Class 对象被 GC。\n该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。 该类没有在其他任何地方被引用 该类的类加载器的实例已被 GC 双亲委派模型 双亲委派模型是 Java 类加载机制的设计模式之一。它的核心思想是：类加载器在加载某个类时，会先委派给父类加载器去加载，父类加载器无法加载时，才由当前类加载器自行加载。\n工作流程 在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。 类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 loadClass()方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 BootstrapClassLoader 中。 只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 findClass() 方法来加载类）。 如果子类加载器也无法加载这个类，那么它会抛出一个 ClassNotFoundException 异常。 提示\n双亲委派机制先自下而上委托，再自上而下加载，那为什么不直接自上而下加载？\n因为本来类加载器是组合关系，也就是子加载器只记录了父加载器，父加载器没记录子加载器（找不到子加载器）。\n其次如果先父加载器接活再传给子加载器，假设有 5 个子加载器 （比如 5 个平级的自定义加载器）传给哪个加载呢？每个试过去嘛？效率就不高了。\n好处 保证类的唯一性 ：通过委托机制，确保了所有加载请求都会传递到启动类加载器，避免了不同类加载器重复加载相同类的情况，保证了Java核心类库的统一性，也防止了用户自定义类覆盖核心类库的可能。 保证安全性 ：由于Java核心库被启动类加载器加载，而启动类加载器只加载信任的类路径中的类，这样可以防止不可信的类假冒核心类，增强了系统的安全性。例如，恶意代码无法自定义一个Java.lang.System类并加载到JVM中，因为这个请求会被委托给启动类加载器，而启动类加载器只会加载标准的Java库中的类。 支持隔离和层次划分 ：双亲委派模型支持不同层次的类加载器服务于不同的类加载需求，如应用程序类加载器加载用户代码，扩展类加载器加载扩展框架，启动类加载器加载核心库。这种层次化的划分有助于实现沙箱安全机制，保证了各个层级类加载器的职责清晰，也便于维护和扩展。 简化了加载流程 ：通过委派，大部分类能够被正确的类加载器加载，减少了每个加载器需要处理的类的数量，简化了类的加载过程，提高了加载效率。 提示\nJVM 判定两个 Java 类是否相同的具体规则 ：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。\n破环双亲委派模型的方法 重写 ClassLoader 的 loadClass() 方法。\nJDBC 的接口是类库定义的，但实现是在各大数据库厂商提供的 jar 包中，那通过顶层的启动类加载器是找不到这个实现类的，所以就需要通过底层的应用程序加载器去完成这个任务\n解决方案：使用线程上下文类加载器，通过 setContextClassLoader() 默认设置了应用程序类加载器，然后通过 Thread.current.currentThread().getContextClassLoader() 获得类加载器来加载。\n","date":"2025-03-10T16:27:55+08:00","permalink":"https://Tyritic.github.io/p/jvm%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/","title":"JVM的类加载机制"},{"content":"Java程序的执行流程 Java 程序的执行流程经历了从编译到字节码的生成，再到类加载和 JIT 编译的过程，最终在 JVM 中执行。并且在程序运行过程中，JVM 负责内存管理、垃圾回收和线程调度等工作。\n主要流程如下：\n源代码：编写 .java 文件。 编译：使用 javac 编译器生成 .class 字节码文件。 类加载：JVM 的类加载器加载 .class 文件到内存中。 解释执行：JVM 将字节码转为机器码执行。 JIT 编译：JVM 根据需要将热点代码编译为机器码。 运行：执行 main 方法中的逻辑。 垃圾回收：JVM 管理内存，并回收不再使用的对象。 程序结束：main 方法结束，JVM 清理资源，退出程序。 提示\n编译执行和解释执行\n编译执行：是指程序在执行之前，首先通过编译器将源代码编译为机器代码，然后直接在 CPU 上运行。常见的编译语言如 C、C++。\n优点：编译后的程序运行速度快，因为机器代码是针对目标平台直接生成的，且不需要在运行时再进行翻译。 缺点：程序必须针对每个平台重新编译，跨平台性差；另外，编译后生成的机器代码难以调试和逆向工程。 解释执行：解释执行是指源代码不经过编译器的预先编译，而是在运行时通过解释器逐行翻译并执行。常见的解释语言如 Python、Ruby。\n优点：跨平台性好，因为代码在每个平台上都是通过相应平台的解释器来运行的，且开发周期更短。 缺点：运行速度较慢，因为每次执行时都需要进行动态翻译和解释。 JVM 采用 编译执行 和 解释执行 相结合的方式：\n解释执行 ：JVM 会逐行解释执行字节码，尤其是程序初次运行时，这种方式有助于程序的跨平台性。 即时编译（JIT） ：JVM 引入了即时编译器（Just-In-Time Compiler），在程序运行时将热代码（经常执行的代码）编译为本地机器码，避免反复解释，提升性能。因此，JVM 实际上是混合使用解释执行和编译执行。 JVM的特性 JVM 可以自动管理内存，通过垃圾回收器回收不再使用的对象并释放内存空间。 JVM 包含一个即时编译器 JIT，它可以在运行时将热点代码缓存到 codeCache 中，下次执行的时候不用再一行一行的解释，而是直接执行缓存后的机器码，执行效率会大幅提高。 JVM 会Java 程序在编译后生成字节码（.class 文件），而不是直接生成特定于某一操作系统的机器代码。在不同操作系统上都有各自实现的 JVM，负责将字节码翻译为特定平台的机器代码并执行。这使得同一份 Java 字节码可以在任何支持 JVM 的平台上运行。实现了 Java 一次编译，处处运行的特性 JVM的组织架构 JVM 大致可以划分为三个部门，分别是类加载器（Class Loader）、运行时数据区（Runtime Data Areas）和执行引擎（Excution Engine）\n类加载器 类加载器子系统负责将 .class 文件加载到 JVM 中。它负责将 Java 类从文件系统或网络中加载，并将它们转化为 JVM 能理解的数据结构。类加载器的主要过程包括：\n加载（Loading）：找到并加载类文件到 JVM。 链接（Linking）：将类文件的数据合并到 JVM 中，分为验证（Verification）、准备（Preparation）和解析（Resolution）三个阶段。 初始化（Initialization）：执行类的静态初始化块和静态变量赋值。 运行时数据区 JVM 定义了 Java 程序运行期间需要使用到的内存区域，简单来说，这块内存区域存放了字节码信息以及程序执行过程的数据，垃圾收集器]也会针对运行时数据区进行对象回收的工作。\n执行引擎 执行引擎负责将字节码转换为机器指令并执行。执行引擎的主要组成部分包括：\n解释器：逐行解释字节码并执行，适用于程序首次运行时。 即时编译器：将热点代码（频繁执行的代码）编译为机器码，提升执行效率。 垃圾回收器 ：用来回收堆内存中的垃圾对象 本地方法接口（JNI） 本地方法接口允许 Java 程序调用非 Java 代码（如 C/C++），便于与操作系统或其他本地库交互。JNI 提供了跨语言调用能力，使 Java 程序可以访问操作系统级别的功能或高性能库。\n","date":"2025-03-10T15:56:14+08:00","permalink":"https://Tyritic.github.io/p/jvm%E7%9A%84%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84/","title":"JVM的组织架构"},{"content":"JVM内存区域的划分 JVM内存区域被划分为以下部分\n方法区 ：JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。以元空间的形式实现方法区 堆：堆内存是 JVM 所有线程共享的部分，在虚拟机启动的时候就已经创建。所有的对象实例和数组都在堆上分配，这部分空间可通过 GC 进行回收。 虚拟机栈 ：每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫 “栈帧” 的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息。栈的大小可以固定也可以动态扩展。 本地方法栈 ：与虚拟机栈类似，区别是虚拟机栈执行 Java 方法，本地方法栈执行 native 方法。 程序计数器：程序计数器可以看成是当前线程所执行的字节码的行号指示器。在任何一个确定的时刻，一个处理器（对于多内核来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器 直接内存 ：直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。 提示\n线程私有的：\n程序计数器 虚拟机栈 本地方法栈 线程共享的：\n堆 方法区 直接内存 (非运行时数据区的一部分) 程序计数器 程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。\n另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。\n字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。 Java虚拟机栈 每个线程有一个私有的栈，随着线程的创建而创建。除了一些 Native 方法调用是通过本地方法栈实现的，其他所有的 Java 方法调用都是通过栈来实现的（也需要和其他运行时数据区域比如程序计数器配合）。方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。\n栈由一个个栈帧组成，而每个栈帧中都对应一个被调用的方法。当线程执行一个方法时，会创建一个对应的栈帧，并将栈帧压入栈中。当方法执行完毕后，将栈帧从栈中移除。\n栈帧的结构\n局部变量表 ：主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。\n对于非静态方法，即使是一个完全空的方法，局部变量表中也会有一个用于存储 this 引用的变量。this 引用指向当前实例对象，在方法调用时被隐式传入。 对于静态方法，由于不需要访问实例对象 this，因此在局部变量表中不会有任何变量 操作数栈 ：主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。\n动态链接 ：主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 动态连接 。\n方法返回地址\n指向运行时常量池的引用\n栈中存储的 不是 对象，而是 对象的引用 。对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。\n本地方法栈 和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。\n本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。\n堆区 Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。 此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。\n堆区空间的进一步划分\n新生代 Eden 区：新对象最初会被分配到 Eden 区，频繁进行垃圾回收。 Survivor 区：通常分为两个相等大小的区域，称为S0（Survivor 0）和S1（Survivor 1）， S0 和 S1 交替使用，新对象在 Eden 区经过一次垃圾回收后存放到其中一个 Survivor 区，进一步存活的对象会移动到另一个 Survivor 区，最终晋升到老年代。 老年代 ：长生命周期对象经过多次垃圾回收后会被移到老年代，Major GC 在老年代进行，频率较低但耗时较长。 字符串常量池 ：为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。 提示\n堆区分代的原因\n主要原因是为了提高垃圾回收效率，依据对象的生命周期特点来进行优化。\n对象的生命周期特点：\n大多数对象存活时间短 ：大部分对象会很快变成垃圾，不再被使用，这些短生命周期的对象会分配在新生代。 少部分对象存活时间长 ：一些长期存活的对象不会很快被回收，分配在新生代的对象经过多次垃圾回收仍存活的，将晋升到老年代。 堆区和栈区的区别 栈：主要用于存储局部变量和方法的调用信息（如返回地址、参数等）。在方法执行期间，局部变量（包括引用变量，但不包括它们引用的对象）被创建在栈上，并在方法结束时被销毁。 堆：用于存储对象实例和数组。每当使用 new 关键字创建对象时，JVM 都会在堆上为该对象分配内存空间。 方法区和元空间 方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据。\nJDK 7 及之前，HotSpot 使用 永久代 实现方法区，主要存储类信息、静态变量等。\nJDK 8 之后，永久代被移除，改为使用元空间，元空间使用本地内存来提高性能和避免 OOM 错误。元空间可以动态调整大小，而永久代大小是固定的。\n提示\n为什么移除永久代引入元空间\n整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整（也就是受到 JVM 内存的限制），而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了 运行时常量池 在每个类或接口的 Class 文件中存储编译时生成的常量信息，并在类加载时进入 JVM 方法区。常量池主要 用于减少重复对象的创建，节省内存并提高效率\n对象创建的过程 类加载检查 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在 常量池 中定位到一个类的 符号引用 ，并且检查这个符号引用代表的类是否已被 加载过、解析和初始化 过。如果没有，那必须先执行相应的 类加载过程 。\n分配内存 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的 内存大小 在 类加载 完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。\n内存分配有以下两种方式\n指针碰撞 适用场合：堆内存规整（即没有内存碎片）的情况下。 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。 使用该分配方式的 GC 收集器：Serial, ParNew 空闲列表 适用场合：堆内存不规整的情况下。 原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。 使用该分配方式的 GC 收集器：CMS 初始化零值 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\n设置对象头 虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。\n执行init方法 JVM 会执行构造方法 \u0026lt;init\u0026gt; 完成赋值操作\n对象的内存结构 对象在内存中的布局可以分为 3 块区域：对象头（Header） 、实例数据（Instance Data） 和 对齐填充（Padding）。\n对象头 对象头是对象存储在内存中的元信息和运行时数据。\nMark Word ：用于存储运行时数据，例如对象的哈希码（HashCode）、GC 标记信息、锁状态标志等。它是一个多功能字段，会根据对象的状态动态变化。 类型指针（Class Pointer） ：指向对象对应的类的元数据，用于确定该对象的类型。 数组长度（只有数组才有） 实例数据 存储对象的实际数据，即类的字段（包括从父类继承的字段）。\n对齐填充 为了满足内存对齐要求（一般是 8 字节对齐），JVM 可能会在对象末尾添加填充字节。例如，一个对象大小为 12 字节，JVM 会增加 4 字节填充，使其达到 16 字节对齐。\n对象的访问定位 虚拟机访问对象的主要方式有以下方式\n使用句柄 直接指针 句柄访问 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。\n直接指针 在直接指针访问中，引用直接存储对象的内存地址；对象的实例数据和类型信息都存储在堆中固定的内存区域。\n提示\n句柄访问和直接指针访问的对比\n使用句柄来访问的最大好处是引用中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而引用本身不需要修改。 使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。 对象的引用类型 对象的引用类型有以下四种\n强引用 软引用 弱引用 虚引用 强引用 强引用是 Java 中最常见的引用类型。使用 new 关键字赋值的引用就是强引用，只要强引用关联着对象，垃圾收集器就不会回收这部分对象，即使内存不足。\n软引用 软引用指的是那些有用但是不是必须要的对象。当系统内存不足时，垃圾回收器会回收软引用指向的对象，避免内存溢出。在内存充足时，这些对象不会被回收。软引用通常用于实现缓存机制，允许程序在不影响性能的情况下利用多余内存。\n弱引用 弱引用是比软引用更弱的一种引用类型。只要垃圾回收器发现只有弱引用指向某个对象，该对象会立即被回收，无论系统内存是否充足。弱引用常用于防止内存泄漏，\n典型应用是 WeakHashMap ，其中键是弱引用，当键不再被其他强引用持有时，键值对会被自动移除。它的优势在于避免对象长时间占用内存，适合短命对象或者临时缓存数据\n虚引用 虚引用主要用来跟踪对象被垃圾回收的过程。虚引用对对象的生存时间没有任何影响。如果一个对象仅有虚引用，那么它与没有引用一样，随时会被垃圾回收。\n内存泄漏和内存溢出 内存泄漏 内存泄漏是指程序在使用完内存后，未能及时释放，导致占用的内存无法再被使用。随着时间的推移，内存泄漏会导致可用内存逐渐减少\n主要原因：通常是因为长期存活的对象持有短期存活对象的引用，又没有及时释放，从而导致短期存活对象无法被回收而导致的。\n内存泄漏的原因 静态集合：使用静态数据结构（如HashMap或ArrayList）存储对象，且未清理。 事件监听：未取消对事件源的监听，导致对象持续被引用。 线程：未停止的线程可能持有对象引用，无法被回收。（ThreadLocal） ThreadLocal 的内存泄漏问题 每个线程维护一个名为 ThreadLocalMap 的 map。 当使用 ThreadLocal 存储值时，实际上是将值存储在当前线程的 ThreadLocalMap 中，其中 ThreadLocal 实例本身作为 key，而要存储的值作为 value。\nkey和value具有不同的引用级别\nkey 是弱引用：ThreadLocalMap 中的 key 是 ThreadLocal 的弱引用 (WeakReference\u0026lt;ThreadLocal\u0026lt;?\u0026gt;\u0026gt;)。 这意味着，如果 ThreadLocal 实例不再被任何强引用指向，垃圾回收器会在下次 GC 时回收该实例，导致 ThreadLocalMap 中对应的 key 变为 null。 value 是强引用：ThreadLocalMap 中的 value 是强引用。 即使 key 被回收（变为 null），value 仍然存在于 ThreadLocalMap 中，被强引用，不会被回收。 当 ThreadLocal 实例失去强引用后，其对应的 value 仍然存在于 ThreadLocalMap 中，因为 Entry 对象强引用了它。如果线程持续存活（例如线程池中的线程），ThreadLocalMap 也会一直存在，导致 key 为 null 的 entry 无法被垃圾回收，造成内存泄漏。\n内存溢出 内存溢出是指当程序请求分配内存时，由于没有足够的内存空间，从而抛出 OutOfMemoryError。\n内存溢出的常见情况 堆内存溢出：原因是代码中可能存在大对象分配，或者发生了内存泄露，导致在多次GC之后，还是无法找到一块足够大的内存容纳当前对象。\n检查对象创建逻辑，确保及时释放无用对象，或增大堆内存大小（-Xmx 参数） 栈溢出：如果我们写一段程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。类似这种情况，JVM 实际会抛出 StackOverFlowError；当然，如果 JVM 试图去扩展栈空间的的时候失败，则会抛出 OutOfMemoryError。\n元空间溢出：系统会抛出Java.lang.OutOfMemoryError: Metaspace。出现这个异常的问题的原因是系统的代码非常多或引用的第三方包非常多或者通过动态代码生成类加载等方法，导致元空间的内存占用很大。\n增加元空间大小（-XX:MaxMetaspaceSize）；优化代码以减少类加载和反射的频率。 ","date":"2025-03-10T15:46:26+08:00","permalink":"https://Tyritic.github.io/p/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/","title":"Java内存区域"},{"content":"慢查询 慢 SQL 就是执行时间较长的 SQL 语句，MySQL 中 long_query_time 默认值是 10 秒，也就是执行时间超过 10 秒的 SQL 语句会被记录到慢查询日志中。\n慢SQL日志的启用 修改配置文件中慢SQL日志的开关和慢SQL日志的时间 show processlist ：查看当前正在执行的 SQL 语句，找出执行时间较长的 SQL count(*)，count(1)，count(主键)，count(列)的执行效率比较 结果：count(*)=count(1)\u0026gt;count(主键)\u0026gt;count(列)\ncount函数的执行过程\n在通过 count 函数统计有多少个记录时，MySQL 的 server 层会维护一个名叫 count 的变量。\nserver 层会循环向 InnoDB 读取一条记录，如果 count 函数指定的参数不为 NULL，那么就会将变量 count 加 1，直到符合查询的全部记录被读完，就退出循环。最后将 count 变量的值发送给客户端。\n执行过程\ncount(主键) 如果表里只有主键索引，没有二级索引时，那么，InnoDB 循环遍历聚簇索引，将读取到的记录返回给 server 层，然后读取记录中的 id 值，就会 id 值判断是否为 NULL，如果不为 NULL，就将 count 变量加 1。 如果表里有二级索引时，InnoDB 循环遍历的对象就不是聚簇索引，而是二级索引。 count(1) InnoDB 循环遍历聚簇索引（主键索引），将读取到的记录返回给 server 层，但是不会读取记录中的任何字段的值，因为 count 函数的参数是 1，不是字段，所以不需要读取记录中的字段值。参数 1 很明显并不是 NULL，因此 server 层每从 InnoDB 读取到一条记录，就将 count 变量加 1。 但是，如果表里有二级索引时，InnoDB 循环遍历的对象就二级索引了。 count(*)与count(1)基本一致 SQL的性能调优策略 查询优化 避免使用不必要的列 尽量避免使用 select *，只查询需要的列，减少数据传输量\n使用JOIN优化 对于 JOIN 操作，可以通过优化子查询、小表驱动大表、适当增加冗余字段、避免 join 太多表等方式来进行优化。\n尽量减少使用子查询，特别是在 select 列表和 where 子句中的子查询，往往会导致性能问题，因为它们可能会为每一行外层查询执行一次子查询。通常使用JOIN联表查询来代替子查询 小表驱动大表：在执行 JOIN 操作时，应尽量让行数较少的表（小表）驱动行数较多的表（大表），这样可以减少查询过程中需要处理的数据量。 避免使用JOIN关联太多表因为 JOIN 太多表会降低查询的速度，返回的数据量也会变得非常大，不利于后续的处理。 使用UNION优化 条件下推是指将 where、limit 等子句下推到 union 的各个子查询中，以便优化器可以充分利用这些条件进行优化。\n例如下列SQL语句\n1 2 3 4 5 6 SELECT * FROM ( SELECT * FROM A UNION SELECT * FROM B ) AS sub WHERE sub.id = 1; 可以将where子句的条件下推到union的各个子查询\n1 2 3 SELECT * FROM A WHERE id = 1 UNION SELECT * FROM B WHERE id = 1; 索引优化 参考往期博客\n","date":"2025-03-09T18:35:25+08:00","permalink":"https://Tyritic.github.io/p/mysql%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/","title":"MySQL的慢查询和性能调优"},{"content":"锁的类型 MySQL中的锁，按照锁的粒度分，分为以下三类：\n全局锁：锁定数据库中的所有表。 表级锁：每次操作锁住整张表。 行级锁：每次操作锁住对应的行数据。 全局锁 相关的SQL语句 使用全局锁\n1 flush tables with read lock 释放全局锁\n1 unlock tables 使用效果 执行后，整个数据库就处于只读状态了，这时其他线程执行以下操作，都会被阻塞：\n对数据的增删改操作，比如 insert、delete、update等语句； 对表结构的更改操作，比如 alter table、drop table 等语句。 应用场景 全局锁主要应用于做 全库逻辑备份 ，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。\n缺点和解决方案 缺点 ：使用全局锁，意味着整个数据库都是只读状态。那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。\n解决方案 ：将事务隔离级别改为可重复读，在备份数据库的同时开启事务。底层原理是开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View\n表级锁 表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低\n表锁 读锁：允许多个事务同时读取被锁定的表，但不允许任何事务进行写操作。 写锁：允许一个事务对表进行读写操作，其他事务不能对该表进行任何操作（读或写）。 表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。\n读锁：允许当前会话读取被锁定的表，但阻止其他会话对这些表进行写操作，同时 本线程不能访问其他表 写锁：允许当前会话对表进行读写操作，但阻止其他会话对这些表进行任何操作（读或写）。 应用场景\n在进行大规模的数据导入、导出或删除操作时，为了防止其他事务对数据进行并发操作，可以使用表锁。 在进行表结构变更（如添加列、修改列类型）时，为了确保变更期间没有其他事务访问或修改该表，可以使用表锁。 元数据锁（MDL） 不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL\n读锁 (MDL_SHARED)：当一个事务需要读取表的元数据时（如执行 SELECT 操作），会获取读锁。 多个事务可以同时持有读锁，不会互相阻塞。\n写锁 (MDL_EXCLUSIVE)：当一个事务需要修改表的元数据时（如执行 ALTER TABLE 操作），会获取写锁。 写锁会阻塞其他任何读锁和写锁，确保独占访问。\nMDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。\n锁的释放时机：锁在事务提交后才会释放，这意味着 事务执行期间，MDL 是一直持有的\n意向锁 假设业务上用到了表锁，那么表锁和行锁之间肯定会冲突，当 InnoDB 加表锁的时候，需要判断表里面是否已经有行锁，而意向锁就是用来协调表锁和行锁的\n在使用 InnoDB 引擎的表里对某些记录加上共享锁之前，需要先在表级别加上一个意向共享锁 在使用 InnoDB 引擎的表里对某些纪录加上独占锁之前，需要先在表级别加上一个意向独占锁 作用\n协调表锁和行锁：防止同时对表加排他锁和行加行锁造成冲突 快速判断表里是否有记录被加锁 如果没有意向锁，那么加独占表锁时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。 那么有了意向锁，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加独占表锁时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。 意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁和独占表锁发生冲突。\n行级锁 记录锁 相关SQL语句 1 2 3 4 5 //对读取的记录加共享锁 select ... lock in share mode; //对读取的记录加独占锁 select ... for update; 记录锁顾名思义就是锁住当前的记录，它是作用到索引上的。所以以 记录锁总是锁定索引记录 。\n间隙锁 Gap Lock 称为间隙锁，只存在于 可重复读 隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。间隙锁用于在范围查询时锁定记录之间的“间隙”，防止其他事务在该范围内插入新记录\n间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。\n临键锁 临键锁是记录锁和间隙锁的组合，锁定一个范围，并且锁定记录本身。临键指的是间隙加上它右边的记录组成的 左开右闭区间\n插入意向锁 一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。\n如果有的话，插入操作就会发生 阻塞 ，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个 插入意向锁 ，表明有事务想在某个区间插入新记录，但是现在处于等待状态。\n判断到插入的位置已经被事务 A 加了间隙锁，于是事务会生成一个插入意向锁，然后将锁的状态设置为等待状态\n行级锁的加锁机制 加锁的SQL语句 update 和 delete 操作都会加行级锁，且锁的类型都是独占锁(X型锁)。 普通的 select 语句是不会对记录加锁的 in share mode ：加读锁 for update：加写锁 加锁机制 加锁的对象是 索引 ，加锁的基本单位是 临键锁 ，它是由记录锁和间隙锁组合而成的，临键锁是前开后闭区间，而间隙锁是前开后开区间。\n唯一索引等值查询 当查询的记录是存在的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会 退化成记录锁。 由于主键具有唯一性，所以 其他事务插入的时候，会因为冲突，导致无法插入新记录 。这样事务 A 在多次查询 id = 1 的记录的时候，不会出现前后两次查询的结果集不同，也就避免了幻读的问题。 由于对唯一索引加了记录锁，其他事务无法删除该记录 ，这样事务 A 在多次查询 记录的时候，不会出现前后两次查询的结果集不同，也就避免了幻读的问题 当查询的记录是不存在的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会 退化成间隙锁。 间隙锁的范围：上一条小于索引值的记录到第一条大于索引值的记录 唯一索引范围查询 当唯一索引进行范围查询时，会对每一个扫描到的索引加 next-key 锁，然后如果遇到下面这些情况，会退化成记录锁或者间隙锁\n情况一：针对大于等于的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 next-key 锁会退化成记录锁。 情况二：针对小于或者小于等于的范围查询，要看条件值的记录是否存在于表中： 当条件值的记录不在表中，那么不管是小于还是小于等于条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。 当条件值的记录在表中 如果是小于条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁 如果小于等于条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。 ","date":"2025-03-09T18:30:04+08:00","permalink":"https://Tyritic.github.io/p/mysql%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/","title":"MySQL的锁机制"},{"content":"RAG基础 RAG概念 RAG（检索增强生成，Retrieval-Augmented Generation） 是一种结合 信息检索（Retrieval） 和 文本生成（Generation） 的 AI 方法，主要用于 提高大语言模型（LLM）的知识覆盖范围和回答准确性。个人理解为RAG 让 AI 在回答问题时，先从外部知识库中检索相关信息，再结合检索到的内容生成最终回答。 这样可以减少 AI 依赖自身训练数据的局限性，并提供最新、准确的信息。\n检索 ：检索外部知识库 增强生成 ：将检索到的知识送给大语言模型以此来优化大模型的生成结果 ，使得大模型在生成更精确、更贴合上下文答案的同时，也能有效减少产生误导性信息的可能。 RAG的业务场景 知识的局限性 ：大模型自身的知识完全源于它的训练数据，基本都是构建于网络公开的数据，对于一些实时性的、非公开的或离线的数据是无法获取到的，这部分知识也就无从具备。 幻觉问题： 所有的 AI 大模型的底层原理都是基于数学概率，其模型输出实质上是一系列数值运算，大模型也不例外，所以它有时候会一本正经地胡说八道，尤其是在大模型自身不具备某一方面的知识或不擅长的场景。 在之前的识物探趣的项目中，大模型不具备展馆内的展品相关知识，因此需要将展馆方提供的文档作为外部知识库。\n上下文学习 在上下文学习方法中，模型不仅考虑 当前任务所提供的信息 ，还会考虑 上下文环境中的其他信息 。例如先前的句子或文本段落。在这种情况下，模型可以更好地理解任务的背景和目的，从而输出更 准确的信息。例如，如果要求模型生成一段关于“猫”的文本，那么在Prompt 中加入一些关于“猫”的 上下文信息，例如“猫是一种宠物，它们很可爱” ”，可以帮助模型更好地理解任务的背景和目的，从而输出更准确的信息。 RAG其实就是上下文学习的一种，查询与问题相关的知识，并将该知识作为上下文传给大语言模型\nRAG的过程 索引阶段 嵌入模型是将文本数据（如词汇、短语或句子）转换为数值向量（文本向量化）的工具，这些向量捕捉了文本的语义信息，可用于各种自然语言处理（NLP）任务。文本向量化的本质 将文本映射到高维空间中的点，使语义相似的文本在这个空间中距离较近。 例如，“猫”和”狗”的向量可能会比”猫”和”汽车”的向量更接近。\n在索引阶段，文档经过向量化，以便在检索阶段实现高效搜索。对于向量搜索，这通常涉及用额外的数据和 元数据 丰富它们，将它们分成更小的片段，嵌入 这些片段，最后将它们存储在向量数据库中。\n检索阶段 将用户的查询通过嵌入模型转换成向量 ，以便与向量数据库中存储的知识相关的向量进行比对。通过相似性搜索 ，从向量数据库中找出最匹配的前 K 个数据。\n增强生成阶段 将用户的查询内容和检索到的相关知识 一起嵌入到一个预设的提示词模板，将经过检索增强的提示词内容输入到大语言模型中，以此生成所需的输出。\nLangChain4j提供的解决方案 EasyRAG langchain4j提供的最简单的RAG实现，只需提供文档和指定向量数据库即可实现最基础的RAG，langchain4j的默认嵌入模型bge-small-en-v1.5在量化后仅仅需要24MB内存\n引入依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;dev.langchain4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;langchain4j-easy-rag\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0-beta1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在AiService中配置向量数据库，内容检索器，easyrag中内置了嵌入模型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 嵌入存储 (简易内存存储) @Bean public InMemoryEmbeddingStore\u0026lt;TextSegment\u0026gt; embeddingStore() { return new InMemoryEmbeddingStore\u0026lt;\u0026gt;(); } @Bean public ChatAssistant assistant(ChatLanguageModel chatLanguageModel, EmbeddingStore\u0026lt;TextSegment\u0026gt; embeddingStore) { return AiServices.builder(ChatAssistant.class) .chatLanguageModel(chatLanguageModel) .chatMemory(MessageWindowChatMemory.withMaxMessages(10)) .contentRetriever(EmbeddingStoreContentRetriever.from(embeddingStore)) .build(); } 文档向量化后保存入向量数据库\n1 2 Document document = FileSystemDocumentLoader.loadDocument(\u0026#34;/Users/lengleng/Downloads/test.docx\u0026#34;); EmbeddingStoreIngestor.ingest(document,embeddingStore); 调用AIService即可\n自定义RAG 核心概念 Document：一个完整的文档,例如单个 PDF 文件或网页 Metadata ：存储文档的额外信息,如名称、来源、最后更新时间等。 TextSegment ：文档的一个片段,专用于文本信息。 Embedding ：封装了一个数值向量,表示嵌入内容的语义含义。 文档处理 Document Loader ：文档加载器用于从不同来源加载文档（可以不指定文档解析器，langchain4j会自动选择合适的文档解析器 Document Parser ：文档解析器用于解析不同格式的文档 DocumentTransformer ：文档转换器，用于对文档执行各种转换,如清理、过滤、增强或总结。 DocumentSplitter ：文档拆分器，用于将文档拆分成更小的片段: 嵌入处理 EmbeddingModel ：表示一种将文本转换为 Embedding 向量的模型。需要接入外部的嵌入模型进行文本向量化 EmbeddingStore ：表示一个嵌入存储库(向量数据库),用于存储和高效搜索相似的嵌入。 EmbeddingStoreIngestor ：负责将文档嵌入并存储到 EmbeddingStore 中的嵌入存储摄取器 内容检索 ContentRetriever ：内容检索器，根据用户的查询从底层数据源中获取内容 检索增强 RetrievalAugmentor ：检索增强器是 RAG的核心，它通过从不同的数据源中检索相关内容来增强用户的消息。\nQueryTransformer ：查询转换器用于将原始查询转换为一个或多个新的查询，以提高检索的准确性。常见的转换策略\n查询压缩：使用大语言模型（LLM）压缩查询和对话上下文，生成一个简明的查询。 查询扩展：将简单的查询扩展为多个相关的查询。 查询重写：对查询进行改写，使其更适合检索。 QueryRouter ：查询路由器负责将查询分配到合适的内容检索器。\n默认实现为查询会路由到所有的内容检索器中 目前的实现为使用LLM来决定路由 ContentAggregator ：内容聚合器，负责聚合多个来源的排序列表。它可以从多个查询和多个内容检索器中汇总结果，并将它们整合成一个统一的排序列表。\n默认的内容聚合器使用 两阶段倒数排名融合（Reciprocal Rank Fusion）方法来对多个排名列表进行融合。 Re-Ranking Content Aggregator ：这个聚合器使用特定的 评分模型 进行重新排序。 ContentInjector ：内容注入器负责将从内容聚合器返回的内容（s）注入到用户消息中。\n默认实现：将返回的内容简单地附加到用户消息的末尾，并为这些内容加上一个前缀。 RAG构建步骤 构建对应的大语言模型 构建嵌入模型EmbeddingModel和向量数据库EmbeddingStore 构建内容检索器，配置内容检索器中嵌入模型和向量数据库，同时根据需要构建内容检索器的其他属性 嵌入模型 向量数据库 返回结果条数 得分的最低值 构建查询转换器：使用压缩查询转换器的情况比较多 如果数据源只有一个可以不配置查询路由器和内容聚合器 构建检索增强器，需要配置以下属性 查询转换器：配置查询优化策略 内容检索器：配置数据源 查询路由器（可选）：配置多个数据源时的路由策略 内容聚合器（可选）：配置多个数据源时的内容聚合模型 内容注入器：配置提示词的注入策略 RAG管道 加载文档 ：使用适当的文档加载器和文档解析器载入文档 转换文档 ：使用文档转换器清理或增强文档 拆分文档 ：使用合适的文档拆分器将文档拆分为更小的片段 嵌入文档 ：使用嵌入模型将文档片段转换为嵌入向量再用摄取器将向量存储到向量数据库中 检索相关内容 : 使用配置好的检索增强器对文档进行检索 聚合注入内容 : 使用内容聚合器将检索到的相关内容进行结果重排后聚合再使用内容注入器注入到用户查询中，提供给语言模型,生成最终响应 ","date":"2025-03-07T10:05:10+08:00","permalink":"https://Tyritic.github.io/p/langchain4j%E5%AE%9E%E7%8E%B0rag%E7%B3%BB%E7%BB%9F/","title":"LangChain4j实现RAG系统"},{"content":"模型抽象： 大语言模型 LanguageModels ：早期的简单 API，只接受 String 输入并返回 String 输出。此 API 已过时（根据最新官方文档）\nChatLanguageModels ：目前推荐使用的主要 API，支持更复杂的输入和输出。接受单个或多个 ChatMessages 作为输入，并返回 AiMessage 作为输出。ChatMessage 通常包含文本，但还支持文本和Images 的混合。\n特定功能模型 EmbeddingModel：用于将文本转换为向量（Embedding），便于语义搜索和聚类。 ImageModel ：用于生成和编辑图像。 ModerationModel ：用于检测文本是否包含有害内容，确保内容安全。 ScoringModel ：用于根据查询对文本段落进行相关性评分，适用于 RAG（检索增强生成）任务 模型参数 langchain4j支持对大语言模型进行参数配置，这些参数将定义\n模型的输出：生成内容（文本、图像）中的创造力或确定性水平， 生成的内容量等。 连接性：基本 URL、授权密钥、超时、重试、日志记录等。 识物探趣项目是基于SpringBoot+Ollama实现的，实现步骤如下\n在application.yml中进行参数的配置从而实现自动配置 消息抽象 ChatMessage 作为所有聊天消息的父类\nUserMessage ：表示用户的消息。根据 LLM，UserMessage 可以只包含文本 (String) 或文本和/或图像 （Image）。 使用 UserMessage.from 方法创建对象 AiMessage ：由 AI 生成的响应消息，通常是为了响应 UserMessage。generate 方法返回一个 AiMessage（包装在 Response 对象中），可以包含文本响应或请求执行特定工具的命令（ToolExecutionRequest）。 ToolExecutionResultMessage ：表示 ToolExecutionRequest 的执行结果，将在后续内容中详细介绍。 SystemMessage ：由系统生成的消息。通常用于定义对话的上下文和规则。开发人员可以在此提供 AI 应该扮演的角色、回答的方式和对话的基调等说明。LLMs 通常更关注 SystemMessage，因此要谨慎编写此消息内容，避免最终用户任意定义或修改。在SpringBoot项目中以注解 @SystemMessage 提示\nUserMessage的多模态支持\nUserMessage 包含一个 List\u0026lt;Content\u0026gt; 类型的 contents。Content 是一个接口，具有以下几种实现：\nTextContent ：TextContent 是最简单的 Content 类型，表示纯文本，并包装一个单独的 String。 ImageContent ：ImageContent 可以通过远程图片的 URL 来创建也可以通过 Base64 编码的二进制数据来创建： AudioContent ：音频内容 VideoContent ：视频内容 PdfFileContent ：PDF 文件的二进制内容 模型交互方法 langchain4j提供了 generate（最新版本已经废弃）和 chat 方法来和大模型进行交互，\n模型交互Api chat 方法\n1 2 3 default String chat(String userMessage) // 接受单个userMessage default ChatResponse chat(ChatMessage... messages) // 接受多个userMessage default ChatResponse chat(List\u0026lt;ChatMessage\u0026gt; messages) // 接受一个列表 generate 方法\n1 2 3 default String generate(String userMessage) default Response\u0026lt;AiMessage\u0026gt; generate(ChatMessage... messages) Response\u0026lt;AiMessage\u0026gt; generate(List\u0026lt;ChatMessage\u0026gt; var1) 事件监听器 LangChain4j 支持通过 ChatModelListener 监听以下事件：\n请求到达 LLM LLM 返回的响应 错误处理 具体实现\n创建 ChatModelListener 的接口实现类 重写其中的所有方法 在对应的 ChatLanguageModel 的Bean类中添加 重试和超时机制 langchain4j支持通过在application.yml或者在model的Bean类中配置 maxRetries 来配置重试逻辑，指定重试次数和延迟等参数。通过**timeout** 配置超时机制\n聊天记忆 langchain4j提供了聊天记忆存储功能，ChatMemory是一个用于管理聊天上下文的组件,它可以解决以下问题:\n防止上下文超出大模型的token限制 隔离不同用户的上下文信息 简化ChatMessage的管理 提供功能 Eviction policy（逐出策略）：控制哪些消息应该从记忆中移除。逐出策略用于在达到令牌或消息数限制时，删除一些不再需要的消息。通常，最早的消息会被逐出，但也可以使用更复杂的算法来决定逐出策略。 Persistence（持久化）：将聊天记忆数据保存在外部存储（如数据库、文件系统等）中，以便在会话结束后保持对话状态。通过持久化，记忆数据可以在应用重启后恢复。 Special treatment of SystemMessage（系统消息的特殊处理）：系统消息通常用于提供背景信息、设置对话的规则或配置一些参数。LangChain4J 提供了对系统消息的特殊处理，以便它们在记忆中发挥特定的作用或不被逐出。 Special treatment of tool messages（工具消息的特殊处理）：工具消息通常与外部工具或API交互有关。LangChain4J 允许对工具消息进行特殊处理，比如确保它们在记忆中的处理方式与普通消息不同，或确保它们在记忆中的存储与其他消息的存储方式有所区分。 提示\n记忆与历史记录\n历史记录：保留了用户和 AI 之间的所有消息内容，并且这些内容是不可变的。历史记录是用户在界面中看到的内容，代表了实际的对话内容。 记忆 ：保留的是部分信息，这些信息被呈现给大型语言模型（LLM），让它看起来像是模型“记住”了之前的对话。记忆和历史记录的区别在于，记忆可能会通过不同的算法对历史记录进行修改，比如：逐出部分消息、汇总多条消息、删除不重要的细节、注入额外的信息（如用于 RAG 的信息）或指令（如用于生成结构化输出的指令）等。 相关实现类 MessageWindowChatMemory 类 基于消息数量的简单实现。它采用滑动窗口的方式,保留最新的N条消息,并淘汰旧消息。本质上是基于消息数量进行管理\n创建方式\n1 ChatMemory chatMemory = MessageWindowChatMemory.withMaxMessages(10); TokenWindowChatMemory类 同样采用滑动窗口的方式,但侧重于保留最新的tokens,而不是消息数量\n更精确的token控制 需要结合Tokenizer计算ChatMessage的token数量 适用于需要严格控制token使用的场景 1 2 Tokenizer tokenizer = new OpenAiTokenizer(GPT_3_5_TURBO); ChatMemory chatMemory = TokenWindowChatMemory.withMaxTokens(1000, tokenizer); 数据持久化 Langchain4j提供了 ChatMemoryStore 用于自定义数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class PersistentChatMemoryStore implements ChatMemoryStore { @Override public List\u0026lt;ChatMessage\u0026gt; getMessages(Object memoryId) { // TODO: 实现从持久化存储中根据 memoryId 获取所有消息。 // 可以使用 ChatMessageDeserializer.messageFromJson(String) 和 // ChatMessageDeserializer.messagesFromJson(String) 辅助方法 // 来方便地将聊天消息从 JSON 反序列化。 } @Override public void updateMessages(Object memoryId, List\u0026lt;ChatMessage\u0026gt; messages) { // TODO: 实现根据 memoryId 更新持久化存储中的所有消息。 // 可以使用 ChatMessageSerializer.messageToJson(ChatMessage) 和 // ChatMessageSerializer.messagesToJson(List\u0026lt;ChatMessage\u0026gt;) 辅助方法 // 来方便地将聊天消息序列化为 JSON。 } @Override public void deleteMessages(Object memoryId) { // TODO: 实现根据 memoryId 删除持久化存储中的所有消息。 } } ChatMemory chatMemory = MessageWindowChatMemory.builder() .id(\u0026#34;12345\u0026#34;) // 为 ChatMemory 指定唯一的 ID，用于区分不同的用户或会话 .maxMessages(10) // 设置最大消息数量 .chatMemoryStore(new PersistentChatMemoryStore()) // 设置自定义的持久化存储 .build(); 提示\n从 ChatMemory 中逐出的消息也会从 ChatMemoryStore 中逐出。当一条消息被逐出时，updateMessages() 方法会被调用，并且传入的消息列表中不包括被逐出的消息。\n项目中的聊天记忆功能实现 共享聊天 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public interface ChatAssistant { /** * 共享聊天 */ String chat(String message); } // 共享聊天 ChatMemory chatMemory = MessageWindowChatMemory.withMaxMessages(10); ChatAssistant assistant = AiServices.builder(ChatAssistant.class) .chatLanguageModel(chatLanguageModel) .chatMemory(chatMemory) .build(); String answer1 = assistant.chat(\u0026#34;你好！我的名字是冷冷.\u0026#34;); String answer2 = assistant.chat(\u0026#34;我的名字是什么？\u0026#34;); 隔离聊天 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public interface ChatAssistant { /** * 隔离聊天 */ String chat(@MemoryId Long userId, @UserMessage String message); } ChatAssistant assistant = AiServices.builder(ChatAssistant.class) .chatLanguageModel(chatLanguageModel) // 注意每个memoryId对应创建一个ChatMemory .chatMemoryProvider(memoryId -\u0026gt; MessageWindowChatMemory.withMaxMessages(10)) .build(); assistant.chat(1L, \u0026#34;你好！我的名字是冷冷1.\u0026#34;); assistant.chat(2L, \u0026#34;你好！我的名字是冷冷2.\u0026#34;); String chat = assistant.chat(1L, \u0026#34;我的名字是什么\u0026#34;); System.out.println(chat); chat = assistant.chat(2L, \u0026#34;我的名字是什么\u0026#34;); System.out.println(chat); 流式响应 langchain4j提供了流式响应的能力，支持逐个token流式传输来自 LLMs 的响应\n流式响应模型 在 ChatLanguageModel 和 LanguageModel 基础接口上，LangChain4j 提供了支持流式响应的 StreamingChatLanguageModel 和 StreamingLanguageModel 接口\n流式响应模型和之前的模型具有类似的Api\n流式请求处理 StreamingResponseHandler 流式响应的关键接口是 StreamingResponseHandler。它允许开发者定义在响应生成过程中的各个事件的处理逻辑。\n1 2 3 4 5 6 7 8 public interface StreamingResponseHandler\u0026lt;T\u0026gt; { void onNext(String token); default void onComplete(Response\u0026lt;T\u0026gt; response) {} void onError(Throwable error); } onNext(String token)：每当生成下一个令牌时触发，通常用于将实时生成的内容及时反馈给前端。 onComplete(Response response)：当模型生成完成时触发。此时返回一个完整的 Response 对象。对于 StreamingChatLanguageModel，T 为 AiMessage；对于 StreamingLanguageModel，T 为 String。 onError(Throwable error)：当生成过程中发生错误时触发。 TokenStream TokenStream 可以作为 generate 和 chat 的返回值\n需要对返回的 TokenStream 进行订阅，分别处理 onNext、onComplete 和 onError 事件，并启动流式处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 interface Assistant { TokenStream chat(String message); } StreamingChatLanguageModel model = OpenAiStreamingChatModel.builder() ... .build(); Assistant assistant = AiServices.create(Assistant.class, model); TokenStream tokenStream = assistant.chat(\u0026#34;讲个笑话\u0026#34;); tokenStream.onNext(System.out::println) .onComplete(System.out::println) .onError(Throwable::printStackTrace) .start(); Flux进行流式处理 引入依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;dev.langchain4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;langchain4j-reactor\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.35.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 可以将 Flux\u0026lt;String\u0026gt; 作为chat方法的返回值来实现基于SpringFlux的流式处理。使用 Flux.subscribe 来处理每个生成的令牌、错误和完成事件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 interface Assistant { Flux\u0026lt;String\u0026gt; chat(String message); } StreamingChatLanguageModel model = OpenAiStreamingChatModel.builder() ... .build(); Assistant assistant = AiServices.create(Assistant.class, model); Flux\u0026lt;String\u0026gt; tokenFlux = assistant.chat(\u0026#34;讲个笑话\u0026#34;); tokenFlux.subscribe( System.out::println, // onNext Throwable::printStackTrace, // onError () -\u0026gt; System.out.println(\u0026#34;onComplete\u0026#34;) // onComplete ); AI服务 为了简化开发，LangChain4j提供了高层API，使开发者能够更专注于业务逻辑，而无需关注底层实现细节。高层API中，AiService 用于定义一个集成大模型的服务。\n在Spring项目中，则需要将接口注册为Bean对象，使用 AiServices.builder(ChatAssistant.class).build() 初始化Bean\n在springboot中，langchain4j通过提供类似与 @Service 的注解 @AIService 来实现自动装配\n1 2 3 4 @AiService interface Assistant { String chat(String userMessage); } 装配机制 自动组件注入 如果这些组件在 Spring 的应用上下文（ApplicationContext）中存在，它们会被 自动注入 到 AI 服务：\nChatLanguageModel（聊天语言模型） StreamingChatLanguageModel（流式聊天语言模型） ChatMemory（对话记忆） ChatMemoryProvider（对话记忆提供器） ContentRetriever（内容检索器） RetrievalAugmentor（检索增强器） 所有被 @Component、@Service 以及 @Tool 注解的类，其中 @Tool 表示可以作为 AI 工具的方法。 显式组件注入 如果你有多个 AI 服务，并且希望将不同的 LangChain4j 组件连接到每个服务中， 可以指定要与显式注入模式 一起使用的组件。@AiService(wiringMode = EXPLICIT) ，同时显式指定使用的组件名\n1 2 3 4 5 6 7 8 9 10 11 12 13 @AiService(wiringMode = EXPLICIT, chatModel = \u0026#34;openAiChatModel\u0026#34;) interface OpenAiAssistant { @SystemMessage(\u0026#34;You are a polite assistant\u0026#34;) String chat(String userMessage); } @AiService(wiringMode = EXPLICIT, chatModel = \u0026#34;ollamaChatModel\u0026#34;) interface OllamaAssistant { @SystemMessage(\u0026#34;You are a polite assistant\u0026#34;) String chat(String userMessage); } 提示词工程 提示词工程 是指设计、优化和调整输入给语言模型（如 GPT、BERT 等）的问题或提示，以便模型能够生成最符合用户需求的输出。简单来说，提示词工程是一种通过精心设计输入文本来 引导 AI 模型产生高质量、准确的结果的过程。\n角色设定 角色设定是指导大语言模型(LLM)行为的重要手段。通过明确定义AI助手的身份和能力范围，我们可以使其更专注于特定领域的任务。在LangChain4j中，主要利用 @SystemMessage 来实现。因为SystemMessage具有高优先级，能有效地指导模型的整体行为。\n1 @SystemMessage(\u0026#34;你是一位专业的中国法律顾问，只回答与中国法律相关的问题。输出限制：对于其他领域的问题禁止回答，直接返回\u0026#39;抱歉，我只能回答中国法律相关的问题。\u0026#39;\u0026#34;) @SystemMessage 还支持从 resources 加载 Prompt 模板：@SystemMessage(fromResource = \u0026quot;my-prompt-template.txt\u0026quot;)\n提示词模板 提示词模板用于提供LLM输入输出的精确性。LangChain4j提供了多种方式来使用提示词模板，让我们能够灵活地构造输入并控制输出。\n@UserMessage 用于简单的提示词模板，配合 @V 注解修饰方法的形参实现简单的提示词模板（ @V 注解在SpringBoot项目中不需要使用）\n1 2 3 4 5 public interface AiAssistant { @SystemMessage(\u0026#34;你是一位专业的文化专家，只回答与本展馆展品相关的问题。输出限制：对于其他领域的问题禁止回答，直接返回\u0026#39;抱歉，我只能回答和展品相关的问题。\u0026#39;\u0026#34;) @UserMessage(\u0026#34;请回答以下问题：{{question}}\u0026#34;) String answerLegalQuestion(@V(\u0026#34;question\u0026#34;) String question); } 定义结构化输出：如果想从 LLM 接收结构化输出， 可以将 AI Service 方法的返回类型从更改为其他类型\nString AiMessage 自定义POJO（可以在POJO类的字段名中使用 @Description 让LLM更加理解字段名 工具调用 函数调用让 LLM 能够根据输入的提示,生成一个调用特定函数的请求。这个请求包含了函数名称和所需的参数信息。通过这种方式,我们可以将 LLM 的智能与外部工具或 API 无缝连接。通过Tools机制可以通过自然语言整合大模型和系统内部功能，使得大模型这个智能大脑拥有了灵活的四肢，从而可以处理更复杂的场景\nLLM 本身并不执行函数,它只是指示应该调用哪个函数以及如何调用\n工作流程 用户向系统输入提示词，然后系统将带有提示词的工具请求发送给LLM LLM根据提示词和工具的描述,返回带有需要调用的函数名称和参数函数调用请求 系统根据LLM返回的参数执行对应的工具方法，并将函数执行结果和原始提示词一起发给LLM LLM根据原始提示词和函数执行结果生成最终结果 低级抽象层次 在AIService的Bean类中实现ToolSpecification（工具说明）和 ToolExecutor（业务逻辑），然后在AIService中的tools字段中加入\nToolSpecification对象就代表一个工具，当用户把要问题UserMessage和工具ToolSpecification一起传递给大模型，大模型就知道要结合工具描述来解决用户的问题，此时大模型响应的AiMessage不再是一串文本\nToolExecutionRequest，表示一个工具执行请求，表示大模型在解决问题时，需要调用工具来解决用户的问题，由于可能传了多个工具给大模型，所以toolExecutionRequests是一个List，表示为了解决用户的问题需要调用哪些工具。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Bean public FunctionAssistant functionAssistant(ChatLanguageModel chatLanguageModel) { // 工具说明 ToolSpecification ToolSpecification toolSpecification = ToolSpecification.builder() .name(\u0026#34;invoice_assistant\u0026#34;) .description(\u0026#34;根据用户提交的开票信息，开具发票\u0026#34;) .addParameter(\u0026#34;companyName\u0026#34;, type(\u0026#34;string\u0026#34;), description(\u0026#34;公司名称\u0026#34;)) .addParameter(\u0026#34;dutyNumber\u0026#34;, type(\u0026#34;string\u0026#34;), description(\u0026#34;税号\u0026#34;)) .addParameter(\u0026#34;amount\u0026#34;, type(\u0026#34;number\u0026#34;), description(\u0026#34;金额\u0026#34;)) .build(); // 业务逻辑 ToolExecutor ToolExecutor toolExecutor = (toolExecutionRequest, memoryId) -\u0026gt; { String arguments1 = toolExecutionRequest.arguments(); System.out.println(\u0026#34;arguments1 =\u0026gt;\u0026gt;\u0026gt;\u0026gt; \u0026#34; + arguments1); return \u0026#34;开具成功\u0026#34;; }; return AiServices.builder(FunctionAssistant.class) .chatLanguageModel(chatLanguageModel) .tools(Map.of(toolSpecification, toolExecutor)) .build(); } 高级抽象层次 通过使用注解 @Tool，可以更方便地集成函数调用。LangChain4j 的 AI 服务会自动处理工具执行，无需手动管理工具请求。\n工具定义：只需将Java方法标注为 @Tool，LangChain4j 就会自动将其转换为 ToolSpecification，并且在与LLM交互时调用这些方法。\n@Tool 的字段\nname：工具的名称。如果未提供，则方法的名称将用作工具的名称。 value：工具的描述。 方法参数使用 @P 修饰\n@P 的字段\nvalue：参数的描述。必填字段。 required：参数是否为必填项，默认为 。可选字段。true @ToolMemoryId：当工具方法需要根据当前用户的聊天上下文来进行操作时\n@Description ：指定类和字段的描述\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Slf4j public class InvoiceHandler { @Tool(\u0026#34;根据用户提交的开票信息进行开票\u0026#34;) public String handle(String companyName, String dutyNumber,@P(\u0026#34;金额保留两位有效数字\u0026#34;) String amount) { log.info(\u0026#34;companyName =\u0026gt;\u0026gt;\u0026gt;\u0026gt; {} dutyNumber =\u0026gt;\u0026gt;\u0026gt;\u0026gt; {} amount =\u0026gt;\u0026gt;\u0026gt;\u0026gt; {}\u0026#34;, companyName, dutyNumber, amount); return \u0026#34;开票成功\u0026#34;; } } @Bean public FunctionAssistant functionAssistant(ChatLanguageModel chatLanguageModel) { return AiServices.builder(FunctionAssistant.class) .chatLanguageModel(chatLanguageModel) .tools(new InvoiceHandler()) .build(); } 动态工具调用配置 LangChain4j 支持动态工具配置，开发者可以基于用户输入的上下文，在运行时动态加载工具。通过 ToolProvider 接口，工具集会在每次请求时动态生成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ToolProvider toolProvider = (toolProviderRequest) -\u0026gt; { if (toolProviderRequest.userMessage().singleText().contains(\u0026#34;booking\u0026#34;)) { ToolSpecification toolSpecification = ToolSpecification.builder() .name(\u0026#34;get_booking_details\u0026#34;) .description(\u0026#34;Returns booking details\u0026#34;) .addParameter(\u0026#34;bookingNumber\u0026#34;, type(\u0026#34;string\u0026#34;)) .build(); return ToolProviderResult.builder() .add(toolSpecification, toolExecutor) .build(); } else { return null; } }; Assistant assistant = AiServices.builder(Assistant.class) .chatLanguageModel(model) .toolProvider(toolProvider) .build(); ","date":"2025-03-06T15:40:51+08:00","permalink":"https://Tyritic.github.io/p/langchain4j%E7%9A%84%E6%A8%A1%E5%9E%8B%E4%BA%A4%E4%BA%92/","title":"LangChain4j的模型交互"},{"content":"LangChain4j LangChain4j是LangChain的java版本，目的是简化将 LLM 集成到 Java 应用程序中的过程\n核心功能 统一API：LangChain4j提供了标准化的API，使得可以方便地接入主流的LLM提供商，可以轻松切换不同的模型和存储，而无需重写代码。 综合工具箱：该框架包含多种工具，从低级的提示模板、聊天记忆管理到高级模式（如AI服务和RAG）。这些工具帮助开发者构建从聊天机器人到完整的数据检索管道等多种应用。 多模态支持：LangChain4j支持文本和图像作为输入，能够处理更复杂的应用场景。 架构设计 langchain4j的软件架构采用模块结构和层次结构\n层次结构 从文档中可以看出langchain4j提供了两个层次：Low level 和 high level 。框架在两个抽象层次上运行，允许开发者根据需要选择低级或高级API进行开发，从而提高灵活性和可用性。\nlow level ：在这一抽象层次。可以最自由地访问所有低级组件，这些是 LLM 支持的应用程序的 “基元”。 可以完全控制如何组合它们，但您需要编写更多的代码。 high level : 在这一抽象层次，使用 AIService 等高级 API 与 LLM 进行交互。 隐藏了所有的复杂性和样板，以声明方式可以灵活地调整和微调行为。 模块结构 langchain4j-core 模块，定义了核心抽象 主模块：包含有用的工具，如文档加载器、聊天内存实现以及 AIService等高级特性。 一系列的langchain4j-{integration} 模块 ：每个提供与各种LLM的集成，并将存储嵌入到LangChain4j中。 基础使用 本项目以在本地Ollama部署的deepseek-r1模型作为基础LLM模型。Ollama本身作为基础LLM模型的抽象层\n在maven项目中导入相关依赖\n在SpringBoot框架中引入langchain4j-ollama支持\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;dev.langchain4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;langchain4j-ollama\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0-beta1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;dev.langchain4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;langchain4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0-beta1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 如果要通过application.yml中自动配置Bean才引入 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;dev.langchain4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;langchain4j-ollama-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0-beta1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 引入langchain4j的高级抽象层\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;dev.langchain4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;langchain4j-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0-beta1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 引入RAG的相关支持\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;dev.langchain4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;langchain4j-easy-rag\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0-beta1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在application.yml中设置ollama模型的元信息，包括模型名称，ollama服务的url等等\n","date":"2025-03-06T14:33:36+08:00","permalink":"https://Tyritic.github.io/p/langchain4j%E5%9F%BA%E7%A1%80%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","title":"Langchain4j基础和架构设计"},{"content":"Redis的集群模型 主从模式 Redis 的主从复制是指一个 Redis 实例（主节点）可以将数据复制到一个或多个从节点（从节点），从节点从主节点获取数据并保持同步。\n一个主节点负责读写操作 多个从节点负责读操作。 主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来写操作命令，然后执行这条命令。所有的数据修改只在主服务器上进行，然后将最新的数据同步给从服务器，这样就使得主从服务器的数据是一致的。\n第一次同步 主从服务器间的第一次同步的过程可分为三个阶段\n建立链接、协商同步 从服务器就会给主服务器发送 psync 命令，表示要进行数据同步 主服务器收到 psync 命令后，会用 FULLRESYNC 作为响应命令返回给对方，表示为使用全量复制 主服务器同步数据给从服务器 主服务器会执行 bgsave 命令来生成 RDB 文件，然后把文件发送给从服务器。 从服务器收到 RDB 文件后，会先清空当前的数据，然后载入 RDB 文件。 主服务器发送新写操作命令给从服务器 主服务器将缓冲区里所记录的写操作命令发送给从服务器，从服务器执行来自主服务器 replication buffer 缓冲区里发来的命令，这时主从服务器的数据就一致了。 命令传播 主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 连接。后续主服务器可以通过这个连接继续将写操作命令传播给从服务器，然后从服务器执行该命令，使得与主服务器的数据库状态相同。\n而且这个连接是长连接的，目的是避免频繁的 TCP 连接和断开带来的性能开销。\n增量复制 如果主从服务器间的网络连接断开了，那么就无法进行命令传播了，这时从服务器的数据就没办法和主服务器保持一致了，客户端就可能从服务器读到旧的数据。\n主从服务器会采用增量复制的方式继续同步，也就是只会把网络断开期间主服务器接收到的写操作命令，同步给从服务器。\n哨兵模式 哨兵模式基于主从模式，用于监控 Redis 主从集群，自动完成主从切换，以实现故障自动恢复和通知。\n主要功能包括：\n监控：哨兵不断监控 Redis 主节点和从节点的运行状态，定期发送 PING 请求检查节点是否正常。 自动故障转移：当主节点发生故障时，哨兵会选举一个从节点提升为新的主节点，并通知客户端更新主节点的地址，从而实现高可用。 通知：哨兵可以向系统管理员或其他服务发送通知，以便快速处理 Redis 实例的状态变化。 判断节点是否故障 哨兵会每隔 1 秒给所有主从节点发送 PING 命令，当主从节点收到 PING 命令后，会发送一个响应命令给哨兵，这样就可以判断它们是否在正常运行。\n主观下线：哨兵每隔 1s 会发送 ping 命令给所有的节点。如果哨兵超过一段时间还未收到对应节点的 pong 回复，就会认为这个节点主观下线。 客观下线：当一个哨兵判断主节点为主观下线后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。（只有主节点才有客观下线） 主从故障转移 为了更加“客观”的判断主节点故障了，一般不会只由单个哨兵的检测结果来判断，而是多个哨兵一起判断，这样可以减少误判概率，所以哨兵是以哨兵集群的方式存在的。\n哨兵leader的选举机制\n判断主节点主观下线的哨兵就是候选者，此时它想成为 leader。如果同时有两个哨兵判断主观下线，那么它们都是候选人，一起竞争成为 leader。 候选者们会先投自己一票，然后向其他哨兵发送命令让它们给自己投票。每个哨兵手里只有一票，投了一个之后就不能投别人了。 最后，如果某个候选者拿到哨兵集群半数及以上的赞成票，就会成为 leader。这里有一个注意的点，为了保证哨兵选举的时候尽量避免出现平票的情况，哨兵的节点个数一般都会是奇数，比如 3,5,7 这样。 主节点的选举过程\n把一些已经下线的节点全部剔除，从正常的从节点中选择主节点 根据从节点的优先级进行选择，优先选择优先级的值比较小的节点 如果节点的优先级相同，则查看进行主从复制的 offset 的值，即复制的偏移量，偏移量越大则表示其同步的数据越多，优先级越高。 如果 offset 也相同了，那只能比较 ID 号，选择 ID 号比较小的那个作为主节点（每个实例 ID 不同）。 主从故障转移的流程\n选举出新的主节点 将从节点指向新的主节点 哨兵 leader 向所有从节点发送命令，让它们成为新主节点的从节点。 通知客户端主节点已经更换：通过 Redis 的发布者/订阅者机制来实现 将旧主节点转换为从节点：继续监视旧主节点，当旧主节点重新上线时，哨兵集群就会向它发送命令，让它成为新主节点的从节点 cluster模式 Redis 集群（Redis cluster）是通过多个 Redis 实例组成的，每个实例存储部分的数据（即每个实例之间的数据是不重复的）。\n具体是采用哈希槽（Hash Slot）机制来分配数据，将整个键空间划分为 16384 个槽（slots）。每个 Redis 实例负责一定范围的哈希槽，数据的 key 经过哈希函数计算后对 16384 取余即可定位到对应的节点。\n客户端在发送请求时，会通过集群的任意节点进行连接，如果该节点存储了对应的数据则直接返回，反之该节点会根据请求的键值计算哈希槽并路由到正确的节点。\n节点信息同步 Redis 集群内每个节点都会保存集群的完整拓扑信息，包括每个节点的 ID、IP 地址、端口、负责的哈希槽范围等。\n节点之间使用 Gossip 协议 进行状态交换，以保持集群的一致性和故障检测。每个节点会周期性地发送 PING 和 PONG 消息，交换集群信息，使得集群信息得以同步。\n提示\nGossip协议的工作原理\n状态报告：每个节点在特定的时间间隔内，向随机选择的其他节点发送其自身的状态信息，包括节点的主从关系、槽位分布等。 信息更新：接收到状态信息的节点会根据所接收到的数据更新自己的状态，并将更新后的状态继续传播给其他节点。 节点检测：通过周期性交换状态信息，节点可以检测到其他节点的存活状态。如果某个节点未能在预定时间内响应，则该节点会被标记为故障节点。 容错处理：在检测到节点故障后，集群中的其他节点可以采取措施（如重新分配槽位）以保持系统的高可用性。 请求节点流程 计算哈希槽 使用 CRC16 哈希算法计算键的 CRC16 值 然后，计算该值对应的哈希槽 查询请求： 因为客户端连接的是集群中的 node1，所以客户端发送查询命令到 Node1。 Node1 响应： Node1 检测到请求的键属于 Node3，返回一个 MOVED 错误，指示客户端请求的键在另一个节点上。MOVED 错误会中返回目标节点的信息 重新连接： 客户端根据返回的目标节点信息，建立与 Node3 的连接。 再次发送查询请求： 客户端向 Node3 发送查询命令。 获取结果： Node3 查询到键的值并返回结果。 故障转移 主观下线：某个节点认为另一个节点不可用，即下线状态，这个状态并不是最终的故障判定，只能代表一个节点的意见，可能存在误判情况。 客观下线：指标记一个节点真正的下线，集群内多个节点都认为该节点不可用，从而达成共识的结果。如果是持有槽的主节点故障，需要为该节点进行故障转移。 当客观下线的是主节点时触发选举机制\n资格检查：检查从节点是否具备替换故障主节点的条件。 准备选举时间：资格检查通过后，更新触发故障选举时间。 发起选举：到了故障选举时间，进行选举。 选举投票：只有持有槽的主节点才有票，从节点收集到足够的选票（大于一半），触发替换主节点操 脑裂问题 脑裂是指在分布式系统中，由于网络分区或其他问题导致系统中的多个节点（特别是主节点）误以为自己是唯一的主节点。这种情况会导致多个主节点同时提供写入服务，从而引起数据不一致。\n例如发生了网络分区，主节点与哨兵、从节点分区了。此时哨兵发现联系不上主节点，于是发起选举，选了新的主节点，此时 Redis 就出现了两个主节点\n","date":"2025-03-02T16:48:15+08:00","permalink":"https://Tyritic.github.io/p/redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/","title":"Redis的高可用性"},{"content":"使用场景 通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时就要想到可以用单调栈了\n思路解析 用一个栈来记录我们遍历过的元素 ，因为遍历数组的时候，不知道之前都遍历了哪些元素，以至于遍历一个元素找不到是不是之前遍历过一个更小的，所以我们需要用一个容器（这里用单调栈）来记录我们遍历过的元素。\n单调栈里存放的元素是下标：如果需要使用对应的元素，直接T[i]就可以获取。\n单调栈里元素顺序取决是寻找元素右边第一个比自己大还是小的元素\n如果求一个元素右边第一个更大元素，单调栈就是从栈顶到栈底递增的 如果求一个元素右边第一个更小元素，单调栈就是从栈顶到栈底递减的 判断条件（以从栈顶到栈底递增）\n当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况 加入栈中 当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况 加入栈中 当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况 将前面所有小于当前遍历元素的栈元素出栈 循环内执行题目逻辑 将当前遍历元素入栈 代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int[] dailyTemperatures(int[] t) { Stack\u0026lt;Integer\u0026gt;stack=new Stack\u0026lt;\u0026gt;(); // 加入第一个元素下标 stack.push(0); for(int i=1;i\u0026lt;n;i++){ if(t[i]\u0026lt;ts[stack.peek()]){ stack.push(i); }else if(t[i]==t[stack.peek()]){ // 执行逻辑 } else{ while(!stack.isEmpty()\u0026amp;\u0026amp;temperatures[i]\u0026gt;temperatures[stack.peek()]){ // 题目逻辑 stack.pop(); } stack.push(i); } } return res; } } 经典例题 leetcode 739 每日温度 题目描述 力扣题目链接(opens new window)\n请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。\n例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。\n提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。\n思路解析 本题抽象为查找右边第一个比自己大的元素\n使用从栈顶到栈底递增的单调栈\n当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况 加入栈中 当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况 加入栈中 当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况 将前面所有小于当前遍历元素的栈元素出栈 计算栈顶元素和当前遍历元素之间的下标差值 再将当前遍历元素入栈 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int[] dailyTemperatures(int[] temperatures) { int n=temperatures.length; int[]res=new int[n]; Stack\u0026lt;Integer\u0026gt;stack=new Stack\u0026lt;\u0026gt;(); stack.push(0); for(int i=1;i\u0026lt;n;i++){ if(temperatures[i]\u0026lt;=temperatures[stack.peek()]){ stack.push(i); }else{ while(!stack.isEmpty()\u0026amp;\u0026amp;temperatures[i]\u0026gt;temperatures[stack.peek()]){ // 更新下标差值 res[stack.peek()]=i-stack.peek(); stack.pop(); } stack.push(i); } } return res; } } leetcode 496 下一个更大元素 题目描述 力扣题目链接(opens new window)\n给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。\n请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。\nnums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。\n示例 1:\n输入: nums1 = [4,1,2], nums2 = [1,3,4,2]. 输出: [-1,3,-1] 解释: 对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。 对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。 对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。\n示例 2: 输入: nums1 = [2,4], nums2 = [1,2,3,4]. 输出: [3,-1] 解释: 对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。 对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出-1 。\n提示：\n1 \u0026lt;= nums1.length \u0026lt;= nums2.length \u0026lt;= 1000 0 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 10^4 nums1和nums2中所有整数 互不相同 nums1 中的所有整数同样出现在 nums2 中 思路解析 本题抽象为在查找nums1元素在nums2对应位置查找nums2右边第一个比自己大的元素，然后将结果返回元素nums1的对应位置\n使用从栈顶到栈底递增的单调栈\n当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况 加入栈中 当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况 加入栈中 当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况 将前面所有小于当前遍历元素的栈元素出栈 查找nums2元素在nums1的对应位置的下标 将该下标的对应元素设置为当前遍历元素 再将当前遍历元素入栈 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public int[] nextGreaterElement(int[] nums1, int[] nums2) { Stack\u0026lt;Integer\u0026gt;stack=new Stack\u0026lt;\u0026gt;(); int n=nums1.length; int[]res=new int[n]; Arrays.fill(res,-1); // 记录nums2元素在nums1的对应位置 HashMap\u0026lt;Integer,Integer\u0026gt;map=new HashMap\u0026lt;\u0026gt;(); for(int i=0;i\u0026lt;n;i++){ map.put(nums1[i],i); } stack.push(0); for(int i=1;i\u0026lt;nums2.length;i++){ if(nums2[i]\u0026lt;=nums2[stack.peek()]){ stack.push(i); }else{ while(!stack.isEmpty()\u0026amp;\u0026amp;nums2[i]\u0026gt;nums2[stack.peek()]){ if(map.containsKey(nums2[stack.peek()])){ Integer index=map.get(nums2[stack.peek()]); res[index]=nums2[i]; } stack.pop(); } stack.push(i); } } return res; } } leetcode 503 下一个更大元素II 题目描述 力扣题目链接(opens new window)\n给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。\n示例 1:\n输入: [1,2,1] 输出: [2,-1,2] 解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数；第二个 1 的下一个最大的数需要循环搜索，结果也是 2。 提示:\n1 \u0026lt;= nums.length \u0026lt;= 10^4 -10^9 \u0026lt;= nums[i] \u0026lt;= 10^9 思路解析 本题与前面几题思路一致但是由于数组是循环的，需要在遍历的过程中模拟走了两边nums。然后用i % nums.size()代替i\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int[] nextGreaterElements(int[] nums) { //边界判断 if(nums == null || nums.length \u0026lt;= 1) { return new int[]{-1}; } int size = nums.length; int[] res = new int[size];//存放结果 Arrays.fill(res,-1); Stack\u0026lt;Integer\u0026gt;stack=new Stack\u0026lt;\u0026gt;(); stack.push(0); for(int i=1;i\u0026lt;2*size;i++){ if(nums[i%size]\u0026lt;=nums[stack.peek()]){ stack.push(i%size); }else { while(!stack.isEmpty()\u0026amp;\u0026amp;nums[i%size]\u0026gt;nums[stack.peek()]){ res[stack.peek()]=nums[i%size]; stack.pop(); } stack.push(i%size); } } return res; } } leetcode 42 接雨水 题目描述 力扣题目链接(opens new window)\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n示例 1：\n输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例 2：\n输入：height = [4,2,0,3,2,5] 输出：9 思路解析 本题需要寻找一个元素，右边最大元素以及左边最大元素，来计算雨水面积。\n一旦发现添加的柱子高度大于栈头元素了，此时就出现凹槽了，栈头元素就是凹槽底部的柱子，栈头第二个元素就是凹槽左边的柱子，而添加的元素就是凹槽右边的柱子。\n当前遍历的元素（柱子）高度小于栈顶元素的高度 height[i] \u0026lt; height[st.top()] 入栈 情况二：当前遍历的元素（柱子）高度等于栈顶元素的高度 height[i] == height[st.top()] 先出栈再入栈 情况三：当前遍历的元素（柱子）高度大于栈顶元素的高度 height[i] \u0026gt; height[st.top()] 先将栈顶元素出栈作为凹槽的中间元素 水池的高度是min(凹槽左边高度, 凹槽右边高度) - 凹槽底部高度 雨水的宽度是 凹槽右边的下标 - 凹槽左边的下标 - 1 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int trap(int[] height) { int n=height.length; Stack\u0026lt;Integer\u0026gt;stack=new Stack\u0026lt;\u0026gt;(); stack.push(0); int res=0; for(int i=1;i\u0026lt;n;i++){ if(height[stack.peek()]\u0026gt;height[i]){ stack.push(i); }else if(height[stack.peek()]==height[i]){ stack.pop(); stack.push(i); }else { while (!stack.isEmpty() \u0026amp;\u0026amp; height[stack.peek()] \u0026lt; height[i]) { int mid = stack.peek(); stack.pop(); if(!stack.isEmpty()){ int h = Math.min(height[i], height[stack.peek()]) - height[mid]; int w = i - stack.peek() - 1; res += h * w; } } stack.push(i); } } return res; } } leetcode 84 柱状图的最大矩形 题目描述 力扣题目链接(opens new window)\n给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n1 \u0026lt;= heights.length \u0026lt;=10^5 0 \u0026lt;= heights[i] \u0026lt;= 10^4 思路解析 上一题是找每个柱子左右两边第一个大于该柱子高度的柱子，而本题是找每个柱子左右两边第一个小于该柱子的柱子。\n将单调栈的顺序反转即可\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public int largestRectangleArea(int[] heights) { int [] newHeights = new int[heights.length + 2]; newHeights[0] = 0; newHeights[newHeights.length - 1] = 0; for (int index = 0; index \u0026lt; heights.length; index++){ newHeights[index + 1] = heights[index]; } heights = newHeights; int n=heights.length; int res=0; Stack\u0026lt;Integer\u0026gt;stack=new Stack\u0026lt;\u0026gt;(); stack.push(0); for(int i=1;i\u0026lt;n;i++){ if(heights[stack.peek()]\u0026lt;heights[i]){ stack.push(i); }else if(heights[stack.peek()]==heights[i]){ stack.pop(); stack.push(i); }else{ while(!stack.isEmpty()\u0026amp;\u0026amp;heights[stack.peek()]\u0026gt;heights[i]){ int mid=stack.peek(); stack.pop(); if(!stack.isEmpty()){ int left=stack.peek(); int right=i; int h=heights[mid]; int w=right-left-1; res=Math.max(h*w,res); } } stack.push(i); } } return res; } } ","date":"2025-03-02T13:26:11+08:00","permalink":"https://Tyritic.github.io/p/%E5%8D%95%E8%B0%83%E6%A0%88/","title":"单调栈"},{"content":"Redis的缓存 Redis最常见的用途就是作为缓存系统。通过将热门数据存储在内存中，可以极大地提高访问速度，减轻数据库负载，这对于需要快速响应时间的应用程序非常重要。\n用户的数据一般都是存储于数据库，数据库的数据是落在磁盘上的，磁盘的读写速度很慢了。当用户的请求，都访问数据库的话，请求数量一上来，数据库很容易就崩溃的了，所以为了避免用户直接访问数据库，会用 Redis 作为缓存层。\n因为 Redis 是内存数据库，我们可以将数据库的数据缓存在 Redis 里，相当于数据缓存在内存，内存的读写速度比硬盘快好几个数量级，这样大大提高了系统性能。\n缓存雪崩 定义 缓存雪崩：指多个缓存数据在同一时间过期或者Redis宕机，导致大量请求同时访问数据库，从而造成数据库瞬间负载激增。\n通常为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间，当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存。\n那么，当 大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机 时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃。\n数据大量过期的应对方法 均匀设置过期时间 如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时， 给这些数据的过期时间加上一个随机数 ，这样就保证数据不会在同一时间过期。\n互斥锁 当业务线程在处理用户请求时， 如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存 （从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。\n实现互斥锁的时候，最好设置超时时间，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。\nRedis故障宕机的应对方法 服务熔断和请求限流机制 服务熔断机制 ：因为 Redis 故障宕机而导致缓存雪崩问题时， 暂停业务应用对缓存服务的访问，直接返回错误 ，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。 请求限流 ：只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务 ，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。 令牌桶算法 漏斗算法 提示\n令牌桶算法的基本概念\n令牌桶（Token Bucket）：一个固定容量的桶，用于存放令牌。 令牌生成速率（Rate）：令牌按固定速率 r（个/秒）加入桶中。 桶的最大容量（Capacity）：最多可存放的令牌数量，超过部分被丢弃。 令牌桶算法的算法流程\n系统初始化\n令牌桶被创建，初始令牌数 C 每秒会 自动生成 r 个新令牌，但总令牌数不会超过 C。 请求到来\n如果桶内 T \u0026gt; 0，则允许请求通过，并消耗 1 个令牌。\n如果桶内 T == 0，请求被 拒绝（限流）。\n令牌自动填充\n每过1秒，系统会向桶内添加 r 个 新令牌。\n新增的令牌 不会超过桶的最大容量。\n突发流量处理\n当桶内 有足够令牌时，可支持短时间 高并发请求（比如 10 个请求瞬间到来）。\n但当桶内令牌 耗尽 时，系统会 严格按照 r 速率处理请求。\n多级缓存 对于关键数据，除了在主缓存中存储，还可以在备用缓存中保存一份。当主缓存不可用时，可以快速切换到备用缓存，确保系统的稳定性和可用性。\n构建Redis集群 服务熔断或请求限流机制是缓存雪崩发生后的应对方案，可以通过 主从节点的方式构建 Redis 缓存高可靠集群。如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。\n参考博客\n缓存击穿 定义 缓存击穿：指某个热点数据在缓存中失效，导致大量请求直接访问数据库。此时，由于瞬间的高并发，可能导致数据库崩溃。\n应对方案 互斥锁方案 使用互斥锁保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。\n假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。\n具体实现\n核心思路利用redis的 setnx 方法来表示获取锁\n若redis中如果没有这个key，则插入成功，返回1，在 stringRedisTemplate 中返回 true 如果有这个key则插入失败，则返回0，在 stringRedisTemplate 返回 false 缓存穿透 定义 缓存穿透：指查询一个不存在（ 既不在缓存中，也不在数据库中 ）的数据，缓存中没有相应的记录，每次请求都会去数据库查询，造成数据库负担加重。\n应对方案 限制非法请求 当有大量请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。\n缓存空值 当发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。客户端请求某个 ID 的数据，首先检查缓存是否命中。如果缓存未命中，查询数据库。如果数据库查询结果为空，将该空结果（如 null 或 {}）缓存起来，并设置一个合理的过期时间。当后续请求再访问相同 ID 时，缓存直接返回空结果，避免每次都打到数据库。\n布隆过滤器 在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行\n提示\n布隆过滤器是一种空间效率极高的概率型数据结构，用于快速检查一个元素是否存在于一个集合中。\n构造操作如下\n开始时，布隆过滤器的每个位都被设置为 0。 当一个元素被添加到过滤器中时，它会被 k 个哈希函数分别计算得到 k 个位置，然后将位数组中对应的位设置为 1。 当检查一个元素是否存在于过滤器中时，同样使用 k 个哈希函数计算位置，如果任一位置的位为 0，则该元素肯定不在过滤器中；如果所有位置的位都为 1，则该元素可能在过滤器中。 误判问题\n由于哈希冲突的原因，布隆过滤器存在误判问题，查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据。\n误判率的决定因素：\n位数组的大小（m）：位数组的大小决定了可以存储的标志位数量。如果位数组过小，那么哈希碰撞的几率就会增加，从而导致更高的误判率。 哈希函数的数量（k）：哈希函数的数量决定了每个元素在位数组中标记的位数。哈希函数越多，碰撞的概率也会相应变化。如果哈希函数太少，则过滤器很快会变得不精确；如果太多，误判率也会升高，效率下降。 存入的元素数量（n）：存入的元素越多，哈希碰撞的几率越大，从而导致更高的误判率。 优缺点\n优点\n高效性：插入和查询操作都非常高效，时间复杂度为 O(k)，k 为哈希函数的数量。 节省空间：相比于直接存储所有元素，布隆过滤器大幅度减少了内存使用。 可扩展性：可以根据需要调整位数组的大小和哈希函数的数量来平衡时间和空间效率。 缺点\n误判率：可能会误认为不存在的元素在集合中，但不会漏报（不存在的元素不会被认为存在）。 不可删除：一旦插入元素，不能删除，因为无法确定哪些哈希值是由哪个元素设置的。 需要多个哈希函数：选择合适的哈希函数并保证它们独立性并不容易。 与哈希表的比较\n布隆过滤器是一种基于位数组和多个哈希函数的概率型数据结构，适合在内存资源有限、数据量大且能容忍一定误判的场景下使用。\n相比哈希表，布隆过滤器的内存开销非常小，能快速判断一个元素是否存在。虽然它存在误判，但不会漏报，因此在防止缓存穿透、黑名单过滤和推荐系统去重等场景中广泛使用。\n缓存和数据库的一致性问题 旁路缓存策略 对于读操作：如果缓存不命中，则会从数据库读取数据，然后将数据库的数据回种到缓存中\n对于写操作：先更新数据库，再删除缓存，后续等查询把数据库的数据回种到缓存中\n缓存是通过牺牲强一致性来提高性能的。这是由 CAP理论 决定的。缓存系统适用的场景就是非强一致性的场景，它属于CAP中的AP。所以，如果需要数据库和缓存数据保持强一致，就不适合使用缓存。\n所以使用缓存提升性能，就是会有数据更新的延迟。这需要我们在设计时结合业务仔细思考是否适合用缓存。然后缓存一定要设置过期时间，这个时间太短、或者太长都不好：\n太短的话请求可能会比较多的落到数据库上，这也意味着失去了缓存的优势。 太长的话缓存中的脏数据会使系统长时间处于一个延迟的状态，而且系统中长时间没有人访问的数据一直存在内存中不过期，浪费内存。 提示\nCAP理论\n理论描述：描述了在分区（Partition）发生的情况下，系统无法同时保证一致性（Consistency）和可用性（Availability），只能在两者之间做权衡。\n核心属性\n一致性（Consistency） 所有节点对同一份数据的访问必须是最新的（或者说是同步的）。 任何一个读请求都应该返回最新的写入数据。 可用性（Availability） 每个请求都能在合理的时间内获得响应（无论返回的数据是否是最新的）。 不能因为某些节点故障而影响整个系统的正常运行。 分区容忍性（Partition Tolerance） 系统能在网络分区的情况下继续运行，即使部分节点之间的通信被中断。 分布式系统中，网络分区是不可避免的，因此任何实际系统都必须具备分区容忍性。 提示\n为什么选择删除缓存而不是更新缓存\n相对而言，删除缓存的速度比更新缓存的速度要快得多。假如是更新缓存，那么可能请求 A 更新完 MySQL 后在更新 Redis 中，请求 B 已经读取到 Redis 中的旧值返回了，又一次导致了缓存和数据库不一致。\n延时双删策略 更新数据库之前，删除一次缓存 更新完数据库后，再进行一次延迟删除 在 第一步删除缓存 后，仍然存在并发请求：\n另一个线程可能 读取旧数据并写回缓存 ，导致缓存回滚。 延迟一段时间 后，第二次删除可以清理这类脏数据，保证缓存不包含旧数据。 由图可知需要保证第二次删除缓存要在回写缓存之后，常见策略是 让请求 A 的最后一次删除，等待 500ms\n","date":"2025-03-01T19:56:40+08:00","permalink":"https://Tyritic.github.io/p/redis%E7%9A%84%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/","title":"Redis的缓存设计"},{"content":"过期删除策略 Redis 数据过期主要有两种删除策略，分别为 定期删除、惰性删除 两种：\n定期删除：Redis 每隔一定时间（默认是 100 毫秒）会随机检查一定数量的键，如果发现过期键，则将其删除。这种方式能够在后台持续清理过期数据，防止内存膨胀。 惰性删除：在每次访问键时，Redis 检查该键是否已过期，如果已过期，则将其删除。这种策略保证了在使用过程中只删除不再需要的数据，但在不访问过期键时不会立即清除。 定时删除 ：在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。 Key过期的判定 每当对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间存储到一个 过期字典 中，也就是说 过期字典 保存了数据库中所有 key 的过期时间。\n字典实际上是哈希表。当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：\n如果不在，则正常读取键值； 如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。 定期删除策略 定期删除策略的做法：每隔一段时间随机从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。\n优缺点 优点：\n通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。 缺点：\n内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。 难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略对CPU不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。 执行过程 从过期字典中随机抽取 20 个 key； 检查这 20 个 key 是否过期，并删除已过期的 key； 如果本轮检查的已过期 key 的数量，超过 5 个（20/4），也就是 已过期 key 的数量占比 随机抽取 key 的数量 大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。 惰性删除策略 惰性删除策略的做法是：不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。\n优缺点 优点：\nCPU友好：因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 CPU 时间最友好。 缺点：\n内存不友好：如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。 执行过程 Redis 在访问或者修改 key 之前，都会调用 expireIfNeeded 函数对其进行检查，检查 key 是否过期： 如果过期，则删除该 key，至于选择异步删除，还是选择同步删除，根据 lazyfree_lazy_expire 参数配置决定（Redis 4.0版本开始提供参数），然后返回 null 客户端； 如果没有过期，不做任何处理，然后返回正常的键值对给客户端； 内存淘汰策略 内存淘汰策略是在内存满了的时候，redis 会触发内存淘汰策略，来淘汰一些不必要的内存资源，以腾出空间，来保存新的内容\nRedis 的内存淘汰策略一共有 8 种。 分为以下几类\n开启数据淘汰 基于过期时间的淘汰策略 volatile-random：随机淘汰设置了过期时间的任意键值； volatile-ttl：优先淘汰更早过期的键值。 volatile-lru ：淘汰所有设置了过期时间的键值中，最久未使用的键值； volatile-lfu ：淘汰所有设置了过期时间的键值中，最少使用的键值； 全部数据的淘汰策略 allkeys-random：随机淘汰任意键值; allkeys-lru：淘汰整个键值中最久未使用的键值； allkeys-lfu ：淘汰整个键值中最少使用的键值。 不开启数据淘汰 noeviction ：当运行内存超过最大设置内存的时候，不会淘汰数据，而是直接返回报错禁止写入 ","date":"2025-03-01T17:51:38+08:00","permalink":"https://Tyritic.github.io/p/redis%E7%9A%84%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E5%92%8C%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/","title":"Redis的缓存淘汰策略和过期删除策略"},{"content":"主要的持久化机制 Redis 提供两种主要的持久化机制：\nRDB（Redis Database）快照：\nRDB 是通过生成某一时刻的数据快照来实现持久化的，可以在特定时间间隔内保存数据的快照。 适合灾难恢复和备份，能生成紧凑的二进制文件，但可能会在崩溃时丢失最后一次快照之后的数据。 AOF（Append Only File）日志：\nAOF 通过将每个写操作追加到日志文件中实现持久化，支持将所有写操作记录下来以便恢复。 数据恢复更为精确，但文件体积较大，重写时可能会消耗更多资源。 AOF持久化机制 AOF 持久化机制是指 将 Redis 写命令以追加的形式写入到磁盘中的 AOF 文件 ，AOF 文件记录了 Redis 在内存中的操作过程，只要在 Redis 重启后重新执行 AOF 文件中的写命令即可将数据恢复到内存中。\n执行过程 实际上Redis先执行写操作命令后，才将该命令记录到 AOF 日志里\n当 AOF 持久化机制被启用时，Redis 服务器会将接收到的所有写命令追加到 AOF 缓冲区的末尾。\n根据写回策略将缓冲区中的命令刷新到磁盘的 AOF 文件中，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；\n随着 AOF 文件的不断增长，Redis 会启用重写机制来生成一个更小的 AOF 文件\n当 Redis 服务器重启时，会读取 AOF 文件中的所有命令并重新执行它们，以恢复重启前的内存状态。\n优缺点\n优点 避免额外的检查开销。 因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。 而如果先执行写操作命令再记录日志的话，只有在该命令执行成功后，才将命令记录到 AOF 日志里，这样就不用额外的检查开销，保证记录在 AOF 日志里的命令都是可执行并且正确的。 不会阻塞当前写操作命令的执行 ：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。 缺点 丢失的风险 ：执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失风险 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是 可能会给下一个命令带来阻塞风险 。 恢复速度慢 ：因为记录了每一个写操作，所以AOF文件通常比RDB文件更大，消耗更多的磁盘空间。并且，频繁的磁盘IO操作可能会对Redis的写入性能造成一定影响。而且，当问个文件体积过大时，AOF会进行重写操作，AOF如果没有开启AOF重写或者重写频率较低，恢复过程可能较慢，因为它需要重放所有的操作命令。 写回策略 Always ：每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘； Everysec ：每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘； No ：不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。 三种写回策略的缺点\nAlways 策略：可以最大程度保证数据不丢失，但是由于它每执行一条写操作命令就同步将 AOF 内容写回硬盘，所以是不可避免会影响主进程的性能； No 策略：是交由操作系统来决定何时将 AOF 日志内容写回硬盘，相比于 Always 策略性能较好，但是操作系统写回硬盘的时机是不可预知的，如果 AOF 日志内容没有写回硬盘，一旦服务器宕机，就会丢失不定数量的数据。 Everysec 策略：是折中的一种方式，避免了 Always 策略的性能开销，也比 No 策略更能避免数据丢失，当然如果上一秒的写操作命令日志没有写回到硬盘，发生了宕机，这一秒内的数据自然也会丢失。 重写机制 Redis 为了避免 AOF 文件越写越大，提供了 AOF 重写机制，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。\nAOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到新的 AOF 文件，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。\n后台重写机制\n主进程在通过 fork 系统调用生成 bgrewriteaof 子进程时，操作系统会把主进程的页表复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。 当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发写保护中断，这个写保护中断是由于违反权限导致的，然后操作系统会在写保护中断处理函数里进行物理内存的复制，并重新设置其内存映射关系，将父子进程的内存读写权限设置为可读写，最后才会对内存进行写操作。 重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了。为了解决这个问题，Redis 设置了一个 AOF 重写缓冲区，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。\n在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会 同时将这个写命令写入到 AOF 缓冲区和 AOF 重写缓冲区 。\n当子进程完成 AOF 重写工作后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。\n主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：\n将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致； 新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。 RDB持久化机制 RDB 持久化通过创建快照来获取内存某个时间点上的副本，利用快照可以进行方便地进行主从复制。\nredis.conf 文件可以配置在 x 秒内如果至少有 y 个 key 发生变化就会触发命令进行持久化操作。\n优点 恢复速度快 ： RDB通过快照的形式保存某一时刻的数据状态，文件体积小，备份和恢复的速度非常快。 服务性能影响小 ：RDB是在主线程之外通过fork子进程来进行的，不会阻塞服务器处理命令请求，对Redis服务的性能影响较小。 文件小 ：由于是定期快照，RDB文件通常比AOF文件小得多。 缺点 数据丢失 ：RDB方式在两次快照之间，如果Redis服务器发生故障，这段时间的数据将会丢失。 数据不一致 ：如果在RDB创建快照到恢复期间有写操作，恢复后的数据可能与故障前的数据不完全一致 生成RDB快照的过程 执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，会阻塞主线程； 执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以避免主线程的阻塞 使用 bgsave 命令的流程\n检查子进程（检查是否存在 AOF/RDB 的子进程正在进行），如果有返回错误 触发持久化，调用 rdbSaveBackground 开始 fork ，子进程执行 rdb 操作，同时主进程响应其他操作。 RDB 完成后，替换原来的旧 RDB 文件，子进程退出。 生成RDB快照的请求处理 在 Redis 生成 RDB 文件时是异步的（使用 bgsave 命令），采用了 fork 子进程的方式来进行快照操作。生成 RDB 文件的过程由子进程执行，主进程继续处理客户端请求，所以可以保证 Redis 在生成快照的过程中依然对外提供服务，不会影响正常请求。\n在生成过程中依然能正常进行数据修改\n主要原理就是 写时复制\n当主进程 fork 出一个子进程后，并不会把主进程的所有内存数据重新复制一份给子进程，而是让主进程和子进程共享相同的内存页面。底层的实现仅仅复制了页表，但映射的物理内存还是同一个。 当主进程接收到写的请求时，主进程会将对应数据所在的页复制一份，对复制的副本进行修改。此时子进程指向的还是老的页，因此数据没有变化。 RDB和AOF的选择 如果需要尽可能减少数据丢失，AOF 是更好的选择。尤其是在频繁写入的环境下，设置 AOF 每秒同步可以最大限度减少数据丢失。 如果性能是首要考虑，RDB 可能更适合。RDB 的快照生成通常对性能影响较小，并且数据恢复速度快。 如果系统需要经常重启，并且希望系统重启后快速恢复，RDB 可能是更好的选择。虽然 AOF 也提供了良好的恢复能力，但重写 AOF 文件可能会比较慢。 两者的优劣势对比\nRDB 优势 **低资源占用：**RDB 在后台以 fork 进程****的方式生成快照，不会影响主线程处理请求，适合高吞吐量的应用。 **文件占用空间小：**RDB 是 二进制压缩存储，相较于 AOF 体积更小，直接加载 RDB 文件比解析 AOF 日志要快很多，适合 大规模数据恢复。 劣势 数据丢失风险（非实时持久化）：RDB 采用定期快照（snapshot），如果 Redis 在两次快照之间宕机，会丢失最近的写入数据。 AOF 优势 更高的数据安全性：AOF 记录每条写命令，保证尽量少的数据丢失，适用于高可靠性场景。 **AOF 采用追加模式，防止文件损坏：**即使 Redis 发生异常，AOF 也能通过 redis-check-aof 工具修复文件。 可读性强：AOF 以文本格式记录 Redis 命令，可以直接编辑修复错误数据。 劣势 **文件体积更大：**AOF 记录每次写操作，比 RDB 体积大很多，可能占用更多磁盘空间。 恢复速度慢：由于 AOF 需要逐条执行历史命令恢复数据，比直接加载 RDB 更慢。 BigKey问题 Redis 中的 Big Key 是指一个内存空间占用比较大的键（Key）\n工作线程阻塞 ：由于 Redis 单线程执行命令，操作大 Key 时耗时较长，从而导致 Redis 出现其它命令阻塞的问题。 网络阻塞 ：大 Key 对资源的占用巨大，在你进行网络 I/O 传输的时候，导致你获取过程中产生的网络流量较大，从而产生网络传输时间延长甚至网络传输发现阻塞的现象 客户端超时 ：因为操作大 Key 时耗时较长，可能导致客户端等待超时。 阻塞线程 当 AOF 写回策略配置了 Always 策略，如果写入是一个大 Key，主线程在执行 fsync() 函数的时候，阻塞的时间会比较久，因为当写入的数据量很大的时候，数据同步到硬盘这个过程是很耗时的。 创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长； 创建完子进程后，如果父进程修改了共享数据中的大 Key，就会发生写时复制，这期间会拷贝物理内存，由于大 Key 占用的物理内存会很大，那么在复制物理内存这一过程，就会比较耗时，所以有可能会阻塞父进程。 对持久化的影响 对AOF的影响 对写回策略的影响\n当使用 Always 策略的时候：如果写入是一个大 Key，主线程在执行 fsync() 函数的时候，阻塞的时间会比较久，因为当写入的数据量很大的时候，数据同步到硬盘这个过程是很耗时的。\n当使用 Everysec 策略的时候，由于是异步执行 fsync() 函数，所以大 Key 持久化的过程（数据同步磁盘）不会影响主线程。\n当使用 No 策略的时候，由于永不执行 fsync() 函数，所以大 Key 持久化的过程不会影响主线程。\n对AOF重写的影响\n当 AOF 日志写入了很多的大 Key，AOF 日志文件的大小会很大，那么很快就会触发 AOF 重写机制。 创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长； 创建完子进程后，如果父进程修改了共享数据中的大 Key，就会发生写时复制，这期间会拷贝物理内存，由于大 Key 占用的物理内存会很大，那么在复制物理内存这一过程，就会比较耗时，所以有可能会阻塞父进程。 对RDB的影响 创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长； 创建完子进程后，如果父进程修改了共享数据中的大 Key，就会发生写时复制，这期间会拷贝物理内存，由于大 Key 占用的物理内存会很大，那么在复制物理内存这一过程，就会比较耗时，所以有可能会阻塞父进程。 解决方案 对要存储的数据进行压缩，压缩之后再进行存储\n大化小，即把大对象拆分成小对象，即将一个大 Key 拆分成若干个小 Key，降低单个 Key 的内存大小\n采用 Redis 集群方式进行 Redis 的部署，然后将大 Key 拆分散落到不同的服务器上面，加快响应速度\n","date":"2025-03-01T16:36:44+08:00","permalink":"https://Tyritic.github.io/p/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/","title":"Redis的持久化策略"},{"content":"Redis的Java客户端 Jedis 适用于简单的同步操作和单线程环境。 Lettuce 适用于高并发、高性能和多线程环境，尤其是需要异步和响应式编程的场景。 Redisson 适用于复杂的分布式系统，提供丰富的分布式对象和服务，简化开发。 Jedis Jedis 是一款比较经典的 Java 客户端了，提供了比较全面的 Redis 命令。\n简单易用：提供了直观的 API，使得开发者能够方便地与 Redis 进行交互。 使用广泛：在 Java 社区中被广泛采用，有丰富的文档和示例可供参考。 性能良好：在大多数情况下能够提供高效的 Redis 操作。 功能丰富：支持常见的 Redis 操作，如字符串、列表、哈希、集合等数据结构的操作。 缺点\n线程安全问题：线程不安全，每个线程需独立使用 Jedis 实例。 不支持自动重连：在网络异常或 Redis 服务器重启时，需要手动处理重连。 阻塞操作：同步的 API，因此高并发下可能会发生阻塞 Lettuce Lettuce 其相对于 Jedis，其最突出的点就是线程安全，且其扩展性较高，它支持异步和响应式 API，底层基于 Netty 实现。\nLettuce 具有以下优点：\n多线程安全 ：在多线程环境中可以安全使用。 自动重连 ：当网络连接出现问题时，能够自动重新连接。 支持多种编程模型：同步、异步、响应式，适应不同的应用场景 Redisson Redisson 是一个高级的 Redis 客户端，提供分布式和并行编程的支持，提供了丰富的分布式对象和服务，底层也是基于 Netty 实现通信。\n优点：\n高级特性 ：支持分布式锁、缓存、队列等常见场景。\n支持集群 ：支持 Redis 集群模式，适应大规模分布式应用。\n线程安全 ：无需手动处理多线程问题。\nSpringBoot集成Redis SpringData 是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块 SpringDataRedis\n提供了对不同Redis客户端的整合（Lettuce和Jedis） 提供了RedisTemplate统一API来操作Redis 支持Redis的发布订阅模型 支持Redis哨兵和Redis集群 支持基于Lettuce的响应式编程 支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化 支持基于Redis的JDKCollection实现 使用过程 引入对应依赖\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!--Redis依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--连接池依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-pool2\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 修改 application.yml 的spring.data.redis的字段配置连接信息\n将 RedisTemplate 进行依赖注入和泛型\n常用方法 API 返回值类型 说明 redisTemplate.opsForValue() ValueOperations 操作String类型数据 redisTemplate.opsForHash() HashOperations 操作Hash类型数据 redisTemplate.opsForList() ListOperations 操作List类型数据 redisTemplate.opsForSet() SetOperations 操作Set类型数据 redisTemplate.opsForZSet() ZSetOperations 操作SortedSet类型数据 redisTemplate 通用的命令 对象序列化 RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化\n缺点：\n可读性差 内存占用较大 自定义序列化 RedisTemplate可以自定义序列化方式。设置一个配置类来自定义RedisTemplate的序列方式\n通常对key采用string序列化 对value采用json序列化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Bean public RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)throws UnknownHostException {\t// 创建Template RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate = new RedisTemplate\u0026lt;\u0026gt;(); // 设置连接工厂 redisTemplate.setConnectionFactory(redisConnectionFactory);// 设置序列化工具 GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer(); // key和 hashKey采用 string序列化 redisTemplate.setKeySerializer(RedisSerializer.string()); redisTemplate.setHashKeySerializer(RedisSerializer.string()); // value和 hashValue采用 JSON序列化 redisTemplate.setValueSerializer(jsonRedisSerializer); redisTemplate.setHashValueSerializer(jsonRedisSerializer);\u000breturn redisTemplate; } 保存结果\n1 {\u0026#34;@class\u0026#34;:\u0026#34;org.example.redisdemo.pojo.User\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;zhangsan\u0026#34;,\u0026#34;age\u0026#34;:18,\u0026#34;id\u0026#34;:1} 使用StringRedisTemplate 使用StringRedisTemplate 写入Redis时，使用 ObjectMapping 手动把对象序列化为JSON 读取Redis时，ObjectMapping 手动把读取到的JSON反序列化为对象 ","date":"2025-02-27T16:57:13+08:00","permalink":"https://Tyritic.github.io/p/redis%E7%9A%84java%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E4%B8%8Espringboot%E7%9A%84%E9%9B%86%E6%88%90/","title":"Redis的Java客户端和与SpringBoot的集成"},{"content":"Nginx是什么 Nginx（Engine-X） 是一个 高性能的 Web 服务器，同时也可以用作 反向代理、负载均衡、缓存服务器 等。\n正向代理 Nginx 可以被用作正向代理服务器。\nNginx 位于 客户端（用户）和目标服务器 之间，代表客户端向外部服务器请求资源。简而言之，正向代理就是代理客户端，代理客户端向服务端发送请求\n隐藏客户端 IP（目标服务器看不到用户的真实 IP）。 突破网络限制。 缓存资源（加快访问速度）。 过滤内容（企业可限制员工访问某些网站）。 反向代理 反向代理是一种 代理服务器 的配置模式，它代表服务器向客户端提供服务。客户端发送请求到反向代理服务器，然后反向代理服务器将请求转发到后端的真实服务器上，并将响应返回给客户端。简单理解为用户直接访问反向代理服务器就可以获得目标服务器的资源。这一过程叫反向代理\n隐藏后端服务器 IP（用户只知道代理服务器，不知道具体服务器）。 负载均衡（将请求分发到多台服务器，防止单点故障）。 安全防护（过滤恶意流量，保护后端服务器）。 缓存加速（缓存静态资源，提高访问速度）。 Nginx配置文件 主文件格式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //主配置文件格式 main block：主配置段，即全局配置段，对http,mail都有效 //配置Nginx服务器的事件模块相关参数 events { ... } //http/https 协议相关配置段 http { ... } //默认配置文件不包括下面两个模块 //mail 协议相关配置段 mail { ... } //stream 服务器相关配置段 stream {负载均衡 ... } 子配置文件（一般在主配置文件的http部分）\nserver块：用于配置HTTP服务器的具体行为，包括监听的端口、虚拟主机的配置、请求处理逻辑等。 location块：用于指定不同URL请求的处理方式，例如静态文件的服务、反向代理等。 upstream块：用于配置反向代理的目标服务器列表。 include指令：用于引入其他的子配置文件，可以将一些通用的配置项单独放在一个文件中，然后通过include指令引入。 通常修改server块中的内容\nserver块定义虚拟主机的配置，每个虚拟主机可以独立配置不同的域名、端口和目录。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 server { # 指定监听的端口和IP地址。 listen 80; # 指定虚拟主机的主机名。 server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { # 根目录 root html; # 起始页 index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # # 转发到后端服务器 location ~ \\.php$ { proxy_pass http://127.0.0.1; } # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache\u0026#39;s document root # concurs with nginx\u0026#39;s one # #location ~ /\\.ht { # deny all; #} } Nginx部署项目 Nginx既可以部署前端项目也可以部署后端项目\nNginx部署前端项目 作用 Nginx 作为静态文件服务器，直接向浏览器返回 HTML、CSS、JS、图片 等文件，前端不依赖后端服务器。\n配置过程 将前端项目打包 将打包好的前端项目放入配置文件中对应目录root目录 修改配置文件 ","date":"2025-02-26T21:11:53+08:00","permalink":"https://Tyritic.github.io/p/nginx%E6%9C%8D%E5%8A%A1%E5%99%A8/","title":"Nginx服务器"},{"content":"ZSet的定义 Redis的ZSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。ZSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。ZSet具备下列特性：可排序元素不重复查询速度快\n常用命令 查看 ZSCORE key member ：返回有序集合key中元素member的分值 ZCARD key ：返回有序集合key中元素个数 ZRANGE key start stop [WITHSCORES] ：正序获取有序集合key从start下标到stop下标的元素 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] ：返回有序集合中指定分数区间内的成员，分数由低到高排序。 ZCOUNT key min max ：计算有序集合中指定分数区间的成员数量。 加入元素 ZADD KEY_NAME SCORE1 VALUE1.. SCOREN VALUEN ：将一个或多个成员元素及其分数值加入到有序集当中 删除元素 ZREM key member [member ...] ：移除有序集中的一个或多个成员，不存在的成员将被忽略。 底层实现 Redis 中的 ZSet（有序集合，Sorted Set） 是一种由 跳表（Skip List） 和 哈希表（Hash Table） 组成的数据结构。ZSet 结合了集合（Set）的特性和排序功能，能够存储具有唯一性的成员，并根据成员的分数（score）进行排序。\nZSet 的实现由两个核心数据结构组成：\n跳表（Skip List）：用于存储数据的排序和快速查找。 哈希表（Hash Table）：用于存储成员与其分数的映射，提供快速查找。 当 Zset 元素数量较少时，Redis 会使用压缩列表（Zip List）来节省内存\n跳表的实现原理 跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表\n跳表的查找复杂度就是 $O(logN)$。\n跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的 zskiplistLevel 结构体类型的 level 数组 。\n数据结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 typedef struct zskiplistNode { //Zset 对象的元素值 sds ele; //元素权重值 double score; //后向指针 struct zskiplistNode *backward; //节点的level数组，保存每层上的前向指针和跨度 struct zskiplistLevel { struct zskiplistNode *forward; //每一层的前进指针 unsigned long span; } level[]; } zskiplistNode; 对象的元素值ele\n元素的权重值score\n后向指针\n层：跳跃表节点的 level 数组可以包含多个元素，每个元素都包含一个指向其它节点的指针，程序可以通过这些层来加快访问其它节点的速度，一般来说，层的数量越多，访问其它节点的速度就越快。每次创建一个新的跳跃表节点的时候，程序都根据幂次定律，随机生成一个介于 1 和 32 之间的值作为 level 数组的大小，这个大小就是层的“高度”\n前进指针：每个层都有一个指向表尾的前进指针（ level[i].forward 属性），用于从表头向表尾方向访问节点。 跨度：用于记录两个节点之间的距离。跨度是用来计算排位（rank）的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。 查找操作 从最高层开始，逐层向下，直到找到目标元素或确定元素不存在。查找效率高，时间复杂度为$ O(logn)$\n跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：\n如果当前节点的权重小于要查找的权重时，跳表就会访问该层上的下一个节点。 如果当前节点的权重等于要查找的权重时，并且当前节点的 SDS 类型数据小于要查找的数据时，跳表就会访问该层上的下一个节点。 如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。\n插入操作 首先从最高层开始查找插入位置 随机决定新节点的层数 跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数。 在相应的层中插入节点并更新指针。 示例\n1 2 3 4 5 Level 4: 1 3 5 9 15 Level 3: 1 3 5 9 Level 2: 1 3 5 7 9 Level 1: 1 3 5 7 9 11 13 Level 0: 1 3 5 7 9 11 13 15 定位插入位置：需要定位新节点 8 应该插入的位置。我们从跳表的最高层开始，逐层向下查找。\n第 4 层\n从 1 -\u0026gt; 3 -\u0026gt; 5 -\u0026gt; 9 -\u0026gt; 15 开始。 由于 8 小于 15 且大于 9，我们向下跳到第 3 层。 第 3 层\n从 1 -\u0026gt; 3 -\u0026gt; 5 -\u0026gt; 9 开始。\n由于 8 小于 9 且大于 5，我们向下跳到第 2 层。\n第 2 层\n从 1 -\u0026gt; 3 -\u0026gt; 5 -\u0026gt; 7 -\u0026gt; 9 开始。\n由于 8 小于 9 且大于 7，我们向下跳到第 1 层。\n第 1 层\n从 1 -\u0026gt; 3 -\u0026gt; 5 -\u0026gt; 7 -\u0026gt; 9 -\u0026gt; 11 -\u0026gt; 13 开始。\n由于 8 小于 9 且大于 7，我们找到应该插入的位置，向下跳到第 0 层。\n确定新节点的层数：随机确定新节点的层数。假设我们通过概率方法，决定新节点 8 将有 3 层（在最高的层数为 3 层）。\n插入新节点\n第 0 层（最底层） 在第 0 层，我们插入节点 8，保持有序性。8 位于 7 和 9 之间，因此我们将 7 的指针指向 8，8 的指针指向 9，然后更新链表。更新后的第 0 层指针：1 -\u0026gt; 3 -\u0026gt; 5 -\u0026gt; 7 -\u0026gt; 8 -\u0026gt; 9 -\u0026gt; 11 -\u0026gt; 13 -\u0026gt; 15 第 1 层 在第 1 层，我们插入节点 8，8 位于 7 和 9 之间。我们将 7 的指针指向 8，8 的指针指向 9，更新链表。更新后的第 1 层指针1 -\u0026gt; 3 -\u0026gt; 5 -\u0026gt; 7 -\u0026gt; 8 -\u0026gt; 9 -\u0026gt; 11 -\u0026gt; 13 第 2 层 在第 2 层，我们插入节点 8，8 位于 7 和 9 之间。我们将 7 的指针指向 8，8 的指针指向 9，更新链表。更新后的第 2 层指针：1 -\u0026gt; 3 -\u0026gt; 5 -\u0026gt; 7 -\u0026gt; 8 -\u0026gt; 9 第 3 层 在第 3 层，我们插入节点 8，8 位于 7 和 9 之间。我们将 7 的指针指向 8，8 的指针指向 9，更新链表。更新后的第 3 层指针：1 -\u0026gt; 3 -\u0026gt; 5 -\u0026gt; 7 -\u0026gt; 8 -\u0026gt; 9 最终跳表结构\n插入节点 8 后，跳表的结构应该如下所示：\n1 2 3 4 5 Level 4: 1 3 5 7 8 9 15 Level 3: 1 3 5 7 8 9 Level 2: 1 3 5 7 8 9 Level 1: 1 3 5 7 8 9 11 13 Level 0: 1 3 5 7 8 9 11 13 15 删除操作 查找删除操作 对于每一层，检查该层是否存在待删除的节点。如果该节点存在，则需要更新该层中前后节点的指针，将它们连接起来。 继续往下处理，直到删除节点的层次遍历完毕。 示例\n1 2 3 4 5 Level 4: 1 3 5 9 15 Level 3: 1 3 5 9 Level 2: 1 3 5 7 9 Level 1: 1 3 5 7 9 11 13 Level 0: 1 3 5 7 9 11 13 15 定位节点：需要找到节点 9 在各层的位置。假设我们从最高层开始：\n在第 4 层（最上层），节点 9 存在。 在第 3 层，节点 9 存在。 在第 2 层，节点 9 存在。 在第 1 层，节点 9 存在。 在第 0 层（底层），节点 9 存在。 删除节点并更新指针：从最高层开始删除节点 9，并逐层更新指针。\n删除第 4 层的节点 9\n在第 4 层，节点 9的前驱是 5，后继是 15。我们需要将 5 的指针指向 15，即跳过 9。 更新后的第 4 层指针：1 -\u0026gt; 3 -\u0026gt; 5 -\u0026gt; 15。 删除第 3 层的节点 9\n在第 3 层，节点 9的前驱是 5，后继是 None。我们需要将 5 的指针指向 None。\n更新后的第 3 层指针：1 -\u0026gt; 3 -\u0026gt; 5。\n删除第 2 层的节点 9\n在第 2 层，节点 9的前驱是 7，后继是 None。我们需要将 7 的指针指向 None。\n更新后的第 2 层指针：1 -\u0026gt; 3 -\u0026gt; 5 -\u0026gt; 7。\n删除第 1 层的节点 9\n在第 1 层，节点 9的前驱是 7，后继是 11。我们需要将 7 的指针指向 11，即跳过 9。\n更新后的第 1 层指针：1 -\u0026gt; 3 -\u0026gt; 5 -\u0026gt; 7 -\u0026gt; 11 -\u0026gt; 13。\n删除第 0 层的节点 9\n在第 0 层（最底层），节点 9的前驱是 7，后继是 11。我们需要将 7 的指针指向 11，即跳过 9。\n更新后的第 0 层指针：1 -\u0026gt; 3 -\u0026gt; 5 -\u0026gt; 7 -\u0026gt; 11 -\u0026gt; 13 -\u0026gt; 15。\n跳表和B+树的区别 Redis 是内存数据库，跳表在实现简单性、写入性能、内存访问模式等方面的综合优势，使其成为更合适的选择。\n维度 跳表优势 B+ 树劣势 内存访问 符合CPU缓存局部性，指针跳转更高效 节点结构复杂，缓存不友好 实现复杂度 代码简洁，无复杂平衡操作 节点分裂/合并逻辑复杂，代码量大 写入性能 插入/删除仅需调整局部指针 插入可能触发递归节点分裂，成本高 内存占用 结构紧凑，无内部碎片 节点预分配可能浪费内存 Redis 选择使用跳表（Skip List）而不是 B+ 树来实现有序集合（Sorted Set）等数据结构，是经过多方面权衡后的结果。\n内存结构和访问模式差异\nB+ 树的特性 磁盘友好 ：B+ 树的设计目标是优化磁盘I/O，通过减少树的高度来降低磁盘寻道次数（例如，一个3层的B+树可以管理数百万数据）。 节点填充率高 ：每个节点存储多个键值（Page/Block），适合批量读写。 范围查询高效 ：叶子节点形成有序链表，范围查询（如 ZRANGE）性能极佳。 跳表的特性 内存友好 ：跳表基于链表，通过多级索引加速查询，内存访问模式更符合CPU缓存局部性（指针跳跃更少）。 简单灵活 ：插入/删除时仅需调整局部指针，无需复杂的节点分裂与合并。 概率平衡 ：通过随机层高实现近似平衡，避免了严格的平衡约束（如红黑树的旋转）。 实现复杂度\nB+ 树的实现复杂度：\n节点分裂与合并 ：插入/删除时可能触发节点分裂或合并，需要复杂的再平衡逻辑。 锁竞争 ：在并发环境下，B+ 树的锁粒度较粗（如页锁），容易成为性能瓶颈。 跳表的实现复杂度：\n无再平衡操作 ：插入时只需随机生成层高，删除时直接移除节点并调整指针。\n细粒度锁或无锁 ：跳表可以通过分段锁或无锁结构（如 CAS）实现高效并发。\n常见应用 实现延时队列 任务添加到 zset 中，score 为任务的执行时间戳，value 为任务的内容。 定期（例如每秒）从 zset 中获取 score 小于当前时间戳的任务，然后执行任务。 任务执行后，从 zset 中删除任务。 ","date":"2025-02-26T19:53:16+08:00","permalink":"https://Tyritic.github.io/p/redis%E4%B8%AD%E7%9A%84zset/","title":"Redis中的Zset"},{"content":"set的定义 Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。\nset的常见命令 添加元素 SADD KEY_NAME VALUE1..VALUEN ：将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略。 被添加到集合中的新元素的数量 SMOVE SOURCE DESTINATION MEMBER ：将指定成员 member 元素从 source 集合移动到 destination 集合。 移除元素 SPOP key [count] ：移除集合中的指定 key 的一个或多个随机元素 被移除的随机元素。 当集合不存在或是空集时，返回 nil 。 SREM KEY MEMBER1..MEMBERN ：移除集合中的一个或多个成员元素，不存在的成员元素会被忽略。 获取元素 SMEMBERS key ：返回集合中的所有成员 SISMEMBER KEY VALUE ：判断成员元素是否是集合的成员 集合运算 SDIFF FIRST_KEY OTHER_KEY1..OTHER_KEYN ：计算差集 SDIFFSTORE destination key [key ...] SINTER KEY KEY1..KEYN ：计算交集 SINTERSTORE destination key [key ...] SUNION KEY KEY1..KEYN ：计算并集 SUNIONSTORE destination key [key ...] 底层实现 Set 类型的底层数据结构是由哈希表或整数集合实现的：\n如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries 配置）个，Redis 会使用整数集合作为 Set 类型的底层数据结构； 如果集合中的元素不满足上面条件，则 Redis 使用哈希表作为 Set 类型的底层数据结构。 ","date":"2025-02-26T19:19:37+08:00","permalink":"https://Tyritic.github.io/p/redis%E4%B8%AD%E7%9A%84set/","title":"Redis中的Set"},{"content":"Hash的定义 Hash 是一个键值对（key - value）集合，其中 value 的形式如： value=[{field1，value1}，...{fieldN，valueN}] 。Hash 适合用于存储对象。\n常用命令 设置键值对\nHSET KEY_NAME FIELD VALUE ：为哈希表中的字段赋值 如果字段是哈希表中的一个新建字段，并且值设置成功，返回 1 。 如果哈希表中域字段已经存在且旧值已被新值覆盖，返回 0 HMSET KEY_NAME FIELD1 VALUE1 ...FIELDN VALUEN ：同时将多个 field-value (字段-值)对设置到哈希表中。 如果命令执行成功，返回 OK 。 查看\nHGET KEY_NAME FIELD_NAME ：返回哈希表中指定字段的值 返回给定字段的值。如果给定的字段或 key 不存在时，返回 nil 。 HKEYS key ：获取哈希表中的所有域（field） HMGET KEY_NAME FIELD1...FIELDN ：返回哈希表中，一个或多个给定字段的值。 HGETALL KEY_NAME ：返回哈希表中，所有的字段和值。 HEXISTS KEY_NAME FIELD_NAME ：查看哈希表的指定字段是否存在。 删除\nHDEL KEY_NAME FIELD1.. FIELDN ：删除哈希表 key 中的一个或多个指定字段，不存在的字段将被忽略。 底层实现 Hash 类型的底层数据结构是由 压缩列表或哈希表 实现的：\n如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用 压缩列表 作为 Hash 类型的底层数据结构； 如果哈希类型元素不满足上面条件，Redis 会使用 哈希表 作为 Hash 类型的 底层数据结构。 后面版本使用 ListPack 实现\n提示\nListPack 是 Redis 内部的一种数据结构，用于高效存储短小的字符串或整数集合。它是一种 紧凑型的序列化数据结构 ，旨在减少内存占用和提升性能。直接以字节序列的形式存储数据。\n相较于Ziplist，Listpack 没有压缩列表中记录前一个节点长度的字段了，Listpack 只记录当前节点的长度，当我们向 Listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题。\n扩容机制 Redis的哈希扩容是渐进式的\n在正常服务请求阶段，插入的数据，都会写入到哈希表 1，此时的哈希表 2 并没有被分配空间。\n随着数据逐步增多，触发了 rehash 操作，这个过程分为三步：\n给哈希表 2分配空间，一般会比哈希表 1大 2 倍；\n将哈希表 1 的数据迁移到哈希表 2中；\n在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将哈希表 1中索引位置上的所有 key-value 迁移到哈希表 2上； 迁移完成后，哈希表 1 的空间会被释放，并把哈希表 2设置为哈希表 1，然后在哈希表 2新创建一个空白的哈希表，为下次 rehash 做准备。\n在进行渐进式 rehash 的过程中，会有两个哈希表，所以在渐进式 rehash 进行期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。查找操作时先会在哈希表 1里面进行查找，如果没找到，就会继续到哈希表 2 里面进行找到。\n","date":"2025-02-26T17:00:26+08:00","permalink":"https://Tyritic.github.io/p/redis%E4%B8%AD%E7%9A%84hash/","title":"Redis中的Hash"},{"content":"List类型定义 List 列表是简单的字符串列表，按照插入顺序排序，可以从头部或尾部向 List 列表添加元素。\n列表的最大长度为 $2^{32} - 1$，也即每个列表支持超过 40 亿个元素。\n特点与LinkedList一致\n有序 元素可以重复 插入和删除快 查询速度一般 常见命令 获取元素 LINDEX KEY_NAME INDEX_POSITION ：通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素 插入元素 LPUSH KEY_NAME VALUE1.. VALUEN ：将一个或多个值插入到列表头部。 如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。 当 key 存在但不是列表类型时，返回一个错误。 LPUSHX KEY_NAME VALUE1.. VALUEN ：将一个值插入到已存在的列表头部，列表不存在时操作无效。 LINSERT key BEFORE|AFTER pivot value ：将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。 RPUSH KEY_NAME VALUE1..VALUEN ：将一个或多个值插入到列表的尾部(最右边) RPUSHX KEY_NAME VALUE1..VALUEN ：将一个值插入到已存在的列表尾部(最右边)。如果列表不存在，操作无效 BRPOPLPUSH LIST1 ANOTHER_LIST TIMEOUT ：Redis Brpoplpush 命令从列表中取出最后一个元素，并插入到另外一个列表的头部； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 删除元素 BLPOP LIST1 LIST2 .. LISTN TIMEOUT ：移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止 如果列表为空，返回一个 nil 。 否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。 BRPOP LIST1 LIST2 .. LISTN TIMEOUT ：移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。 Lpop KEY_NAME ：移除并返回列表的第一个元素 RPOP KEY_NAME ：用于移除列表的最后一个元素，返回值为移除的元素 底层实现原理 List 类型的底层数据结构是由 双向链表或压缩列表 实现的：\n如果列表的元素个数小于 512 个（默认值，可由 list-max-ziplist-entries 配置），列表每个元素的值都小于 64 字节（默认值，可由 list-max-ziplist-value 配置），Redis 会使用 压缩列表（ziplist） 作为 List 类型的底层数据结构； 如果列表的元素不满足上面的条件，Redis 会使用双向链表作为 List 类型的底层数据结构 在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表。\n提示\nZiplist：压缩列表是 由连续内存块组成的顺序型数据结构 ，有点类似于数组\n优点：简单、紧凑、连续存储，适用于小数据量场景 缺点：压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的占用空间都发生变化，从而引起连锁更新问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降。 Quicklist：\n通过将链表和 Ziplist 结合，既实现了链表的灵活操作，又能节省内存 Quicklist 是为了替代纯链表而设计的，适用于需要频繁对列表进行插入、删除、查找等操作的场景，并且数据量可能较大。它在存储多个元素时，既保留了链表的灵活性，又具备压缩列表的内存优势。 Quicklist 由 list 和 ziplist 结合而成，它是一个由 ziplist 充当节点的双向链表。 应用场景 简单消息队列 消息保序性：使用 LPUSH + RPOP 生产者使用 LPUSH key value[value...] 将消息插入到队列的头部，如果 key 不存在则会创建一个空的队列再插入消息。 消费者使用 RPOP key 依次读取队列的消息，先进先出。 消息重复性：自行为每个消息生成一个全局唯一ID 消息可靠性：让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存。 ","date":"2025-02-26T16:28:56+08:00","permalink":"https://Tyritic.github.io/p/redis%E4%B8%AD%E7%9A%84list/","title":"Redis中的List"},{"content":"String的定义 字符串是最基础的数据类型，value 可以是：\n字符串（简单的字符串、复杂的字符串（例如 JSON、XML）） 数字 （整数、浮点数） 是二进制（图片、音频、视频），但最大不能超过 512MB。 String的常见命令 设置键值对\nSET KEY_NAME VALUE ：设置给定 key 的值。如果 key 已经存储其他值， SET 就覆写旧值，且无视类型。\nGETSET KEY_NAME VALUE ：设置指定 key 的值，并返回 key 的旧值\nSETEX KEY_NAME TIMEOUT VALUE ：为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值。\nMSET key1 value1 key2 value2 .. keyN valueN :同时设置一个或多个 key-value 对\n根据键查找值： GET KEY_NAME\n返回 key 的值，如果 key 不存在时，返回 nil。 如果 key 不是字符串类型，那么返回一个错误。 获取指定 key 所储存的字符串值的长度：STRLEN KEY_NAME\nString的底层实现 Redis 中的 String 类型底层实现主要基于 SDS（Simple Dynamic String 简单动态字符串）结构，并结合 int、embstr、raw 等不同的编码方式进行优化存储。\nSDS的结构 len，记录了字符串长度。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要$O(1)$。 alloc，分配给字符数组的空间长度。这样在修改字符串的时候，可以通过 alloc - len 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。 flags，用来表示不同类型的 SDS。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。 buf[]，字符数组，用来保存实际数据。不仅可以保存字符串，也可以保存二进制数据。 相比于C语言的字符串表示的优势 SDS 不仅可以保存文本数据，还可以保存二进制数据。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。 SDS 获取字符串长度的时间复杂度是$O(1)$。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为$O(n)$；而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为$O(1)$。 Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。 编码方式 如果一个字符串对象保存的是整数值，并且这个整数值可以用 long 类型来表示，那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将void转换成 long），并将字符串对象的编码设置为 int 如果字符串对象保存的是一个短字符串，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为 embstr ， embstr 编码是专门用于保存短字符串的一种优化编码方式 如果字符串对象保存的是一个长字符串，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为 raw ","date":"2025-02-26T15:51:21+08:00","permalink":"https://Tyritic.github.io/p/redis%E4%B8%AD%E7%9A%84string/","title":"Redis中的String"},{"content":"动态规划的思考步骤 思考过程 确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组 基本代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int solover(int n) { if(n\u0026lt;=1)return n; // 确定dp的含义 int[]dp=new int[n+1]; // 对dp数字初始化 dp[0]=0; dp[1]=1; // 遍历顺序，利用状态转移方程求解dp数组 for(int i=2;i\u0026lt;=n;i++){ dp[i]=dp[i-1]+dp[i-2]; } return dp[n]; } } 一维动态规划 leetcode 509 斐波那契数 题目描述 力扣题目链接(opens new window)\n斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n \u0026gt; 1 给你n ，请计算 F(n) 。\n示例 1：\n输入：2 输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1 示例 2：\n输入：3 输出：2 解释：F(3) = F(2) + F(1) = 1 + 1 = 2 示例 3：\n输入：4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3 提示：\n0 \u0026lt;= n \u0026lt;= 30 思路解析 确定dp数组（dp table）以及下标的含义\ndp[i]的定义为：第i个数的斐波那契数值是dp[i] 确定递推公式\n状态转移方程： dp[i] = dp[i - 1] + dp[i - 2]; dp数组如何初始化\n1 2 dp[0] = 0; dp[1] = 1; 确定遍历顺序\ndp[i]是依赖 dp[i - 1] 和 dp[i - 2]，遍历的顺序一定是从前到后遍历的 举例推导dp数组\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int fib(int n) { if(n\u0026lt;=1)return n; // dp[i]为F[i] int[]dp=new int[n+1]; // 初始化 dp[0]=0; dp[1]=1; for(int i=2;i\u0026lt;=n;i++){ dp[i]=dp[i-1]+dp[i-2]; } return dp[n]; } } leetcode 70 爬楼梯 题目描述 力扣题目链接(opens new window)\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n注意：给定 n 是一个正整数。\n示例 1：\n输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1 阶 + 1 阶 2 阶 示例 2：\n输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1 阶 + 1 阶 + 1 阶 1 阶 + 2 阶 2 阶 + 1 阶 思路解析 确定dp数组以及下标的含义\ndp[i]： 爬到第i层楼梯，有dp[i]种方法 确定递推公式\n第一种情况：dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶。 第二种情况：dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶。 所以dp[i] = dp[i - 1] + dp[i - 2] 。 dp数组如何初始化\n1 2 dp[0]=1; dp[1]=1; 确定遍历顺序：遍历顺序一定是从前向后遍历的\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int climbStairs(int n) { // dp[i]为到达第i阶台阶的方式，第n阶为楼顶 int[]dp=new int[n+1]; // 初始化 dp[0]=1; dp[1]=1; // 状态转移方程:dp[i]=dp[i-1]+dp[i-2] for(int i=2;i\u0026lt;=n;i++){ dp[i]=dp[i-1]+dp[i-2]; } return dp[n]; } } leetcode 746 使用最小花费爬楼梯 题目描述 力扣题目链接\n给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。\n你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。\n请你计算并返回达到楼梯顶部的最低花费。\n思路解析 确定dp数组以及下标的含义 dp[i]的定义：到达第i台阶所花费的最少体力为dp[i]。 确定递推公式 第一种情况：dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。 第二种情况：dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。 所以dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); dp数组如何初始化 题目描述中明确说明“你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。” 也就是说 到达 第 0 个台阶是不花费的，但从 第0 个台阶 往上跳的话，需要花费 cost[0]。所以初始化 dp[0] = 0，dp[1] = 0; 确定遍历顺序 dp[i]由dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组即可 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int minCostClimbingStairs(int[] cost) { int n=cost.length; // dp[i]为到达第i阶台阶的最小花费，第n阶为楼顶 int[]dp=new int[n+1]; // 初始化 dp[0]=0; dp[1]=0; // 状态转移方程推导 // 从第i-1阶爬1个台阶:dp[i-1]+cost[i-1] // 从第i-2阶爬2个台阶:dp[i-2]+cost[i-2] for(int i=2;i\u0026lt;=n;i++){ dp[i]=Math.min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]); } return dp[n]; } } leetcode 343 整数拆分 题目描述 力扣题目链接(opens new window)\n给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。\n示例 1:\n输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2:\n输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。 思路解析 确定dp数组（dp table）以及下标的含义\ndp[i]：分拆数字i，可以得到的最大乘积为dp[i]。 确定递推公式\n第一种情况：j * (i - j) 直接相乘。单纯的把整数拆分为两个数相乘\n第二种情况：j * dp[i - j]，相当于是拆分(i - j)，拆分成两个以及两个以上的个数相乘\n递推公式：dp[i] = max({dp[i], (i - j) * j, dp[i - j] * j})\ndp的初始化\n初始化dp[2] = 1= 确定遍历顺序\n确定遍历顺序，递归公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j)); i从3开始遍历到n j从1开始遍历到i-1 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int integerBreak(int n) { // 分拆数字i可以得到的最大乘积 int[]dp=new int[n+1]; // 初始化 dp[2]=1; // 遍历过程 // 被拆成i*(i-j) // 被拆成dp[i-j]*j for(int i=3;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;i;j++){ dp[i]=Math.max(dp[i],Math.max((i-j)*j,dp[i-j]*j)); } } return dp[n]; } } leetcode 96 不同的二叉搜索树 题目描述 力扣题目链接(opens new window)\n给定一个整数 n，求以 1 \u0026hellip; n 为节点组成的二叉搜索树有多少种？\n示例:\n思路解析 确定dp数组（dp table）以及下标的含义\ndp[i] ： i个不同元素节点组成的二叉搜索树的个数。 确定递推公式\ndp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] j表示选取的根节点结点的元素，从1遍历到i为止。 左子树：[1,j-1] 右子树：[j+1,i]; 所以递推公式：dp[i] += dp[j - 1] * dp[i - j] ; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量 dp数组初始化\n初始化dp[0]=1 确定遍历顺序\n首先遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。 那么遍历i里面每一个数作为头结点的状态，用j来遍历。 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int numTrees(int n) { // dp[i]代表i个节点的不同二叉树数量 int[]dp=new int[n+1]; // 初始化 dp[0]=1; // i表示考虑i个节点的情况 for(int i=1;i\u0026lt;=n;i++){ // j表示选取的根节点编号 for(int j=1;j\u0026lt;=i;j++){ dp[i]+=dp[j-1]*dp[i-j]; } } return dp[n]; } } 二维动态规划 leetcode 62 不同路径 题目描述 力扣题目链接(opens new window)\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n问总共有多少条不同的路径？\n示例 1：\n输入：m = 3, n = 7 输出：28 示例 2：\n输入：m = 2, n = 3 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。\n向右 -\u0026gt; 向右 -\u0026gt; 向下 向右 -\u0026gt; 向下 -\u0026gt; 向右 向下 -\u0026gt; 向右 -\u0026gt; 向右 示例 3：\n输入：m = 7, n = 3 输出：28 示例 4：\n输入：m = 3, n = 3 输出：6 提示：\n1 \u0026lt;= m, n \u0026lt;= 100 题目数据保证答案小于等于 2 * 10^9 思路解析 确定dp数组（dp table）以及下标的含义 dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有 dp[i][j] 条不同的路径。 确定递推公式 dp[i - 1][j] 表示是从(0, 0)的位置到(i - 1, j)有几条路径， dp[i][j - 1] 同理。 dp[i][j] = dp[i - 1][j] + dp[i][j - 1] dp数组的初始化 首先 dp[i][0] 一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条（竖直向下走），那么 dp[0][j] 也同理（水平向右走。 确定遍历顺序 看一下递推公式 dp[i][j] = dp[i - 1][j] + dp[i][j - 1] ，dp[i][j] 都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int uniquePaths(int m, int n) { int[][]dp=new int[m][n]; // 初始化 // [0,0]到[m,0]的路径只有一条，竖直向下走 for(int i=0;i\u0026lt;m;i++){ dp[i][0]=1; } // [0,0]到[0,n]的路径只有一条，向右走 for(int i=0;i\u0026lt;n;i++){ dp[0][i]=1; } // 转移方程 dp[i[[j]=dp[i-1][j]+dp[i][j-1] for(int i=1;i\u0026lt;m;i++){ for(int j=1;j\u0026lt;n;j++){ dp[i][j]=dp[i-1][j]+dp[i][j-1]; } } return dp[m-1][n-1]; } } leetcode 63 不同路径II 题目描述 力扣题目链接(opens new window)\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n网格中的障碍物和空位置分别用 1 和 0 来表示。\n示例 1：\n输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] 输出：2 解释： 3x3 网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径： 向右 -\u0026gt; 向右 -\u0026gt; 向下 -\u0026gt; 向下 向下 -\u0026gt; 向下 -\u0026gt; 向右 -\u0026gt; 向右 示例 2：\n输入：obstacleGrid = [[0,1],[0,0]] 输出：1 提示：\nm == obstacleGrid.length n == obstacleGrid[i].length 1 \u0026lt;= m, n \u0026lt;= 100 obstacleGrid[i][j] 为 0 或 1 思路解析 与上一题的大体思路相同，只是在初始化和遍历过程略有不同。\n初始化时将遇到障碍物之前的dp数字置为1 遍历过程中遇到障碍物跳过该dp数组 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import java.util.Arrays; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { // m行n列 int m=obstacleGrid.length; int n=obstacleGrid[0].length; if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) { return 0; } int[][]dp=new int[m][n]; // 初始化 // 从[0,0]到[i,0]只有一条，遇到障碍物停止 for(int i=0;i\u0026lt;m\u0026amp;\u0026amp;obstacleGrid[i][0]==0;i++){ dp[i][0]=1; } // 从[0,0]到[0,i]只有一条，遇到障碍物停止 for(int i=0;i\u0026lt;n\u0026amp;\u0026amp;obstacleGrid[0][i]==0;i++){ dp[0][i]=1; } //遍历过程 for(int i=1;i\u0026lt;m;i++){ for(int j=1;j\u0026lt;n;j++){ if(obstacleGrid[i][j]==1) continue; else dp[i][j]=dp[i-1][j]+dp[i][j-1]; } } return dp[m-1][n-1]; } } 0-1背包问题 题目描述 有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。\n思路解析 二维dp解法 确定dp数组以及下标的含义 有两个维度需要分别表示：物品 和 背包容量 dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大 确定递推公式 第一种情况：不放物体则 dp[i][j]=dp[i-1][j] 第二种情况：放入物体则 dp[i][j]=dp[i-1][j-weight[i]]+value[i] 取上面的较大值 dp数组的初始化 i=0时 j \u0026lt; weight[0]的时候，dp[0][j] 是 0，因为背包容量比编号0的物品重量还小。 当j \u0026gt;= weight[0]时，dp[0][j] 是value[0] j=0时 背包容量为0，dp[i][0]=0 确定遍历顺序 先遍历物品再遍历容量，注意判断当背包容量小于物品容量时不放入物品 代码模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import java.util.*; public class Main{ public static void main (String[] args) { Scanner sc=new Scanner(System.in); int M=sc.nextInt(); int N=sc.nextInt(); int[]weight=new int[M]; int[]value=new int[M]; for(int i=0;i\u0026lt;M;i++){ weight[i]=sc.nextInt(); } for(int i=0;i\u0026lt;M;i++){ value[i]=sc.nextInt(); } // dp[i][j]表示放入[0-i]的物品，背包容量为j的最大价值 int[][]dp=new int[M][N+1]; // 初始化 // 背包空间为0，价值为0 for(int i=0;i\u0026lt;M;i++){ dp[i][0]=0; } // 被背包容量大于weight[0]价值为value[0] for(int i=weight[0];i\u0026lt;=N;i++){ dp[0][i]=value[0]; } for(int i=1;i\u0026lt;M;i++){ for(int j=1;j\u0026lt;=N;j++){ if(j\u0026lt;weight[i]){ dp[i][j]=dp[i-1][j]; }else{ dp[i][j]=Math.max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i]); } } } System.out.println(dp[M-1][N]); } } 一维dp解法 在使用二维数组的时候，递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);\n其实可以发现如果把dp[i - 1]那一层复制到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])\n因此可以推出\ndp[j] = max(dp[j], dp[j - weight[i]] + value[i])\n确定dp数组的定义 dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。 递推公式 递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) 初始化 全部初始化为0即可 遍历顺序 顺序遍历物品，同时逆序遍历容量 倒序遍历是为了保证物品i只被放入一次 ，从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了 代码模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import java.util.*; public class Main{ public static void main (String[] args) { Scanner sc=new Scanner(System.in); int M=sc.nextInt(); int N=sc.nextInt(); int[]weight=new int[M]; int[]value=new int[M]; for(int i=0;i\u0026lt;M;i++){ weight[i]=sc.nextInt(); } for(int i=0;i\u0026lt;M;i++){ value[i]=sc.nextInt(); } // dp[j]背包容量为j的最大价值 int[]dp=new int[N+1]; for(int i=0;i\u0026lt;M;i++){ for (int j = N; j \u0026gt;= weight[i]; j--) { dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]); } } System.out.println(dp[N]); } } 经典例题 板子题：https://kamacoder.com/problempage.php?pid=1046\nleetcode 416 分割等和子集 题目描述\n力扣题目链接(opens new window)\n题目难易：中等\n给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200\n示例 1:\n输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例 2:\n输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集. 提示：\n1 \u0026lt;= nums.length \u0026lt;= 200 1 \u0026lt;= nums[i] \u0026lt;= 100 思路解析\n本题可以将其视为一个0-1背包问题。nums中的数字为重量和价值的物品\n既有一个 只能装重量为 sum / 2 的背包，商品为数字，这些数字能不能把 这个背包装满。\n即为求解装满 承载重量为 sum / 2 的背包，价值最大是多少？如果最大价值是 sum / 2，说明正好被商品装满了。\n确定dp数组以及下标的含义 如果背包所载重量为target， dp[target]就是装满 背包之后的总价值，因为 本题中每一个元素的数值既是重量，也是价值，所以，当 dp[target] == target 的时候，背包就装满了。 确定递推公式 本题相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。所以递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); dp数组如何初始化 dp[0]=0 遍历顺序与0-1背包相同 注意当sum是一个奇数是不存在该种方式的\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public boolean canPartition(int[] nums) { int sum=0; for(int i=0;i\u0026lt;nums.length;i++){ sum+=nums[i]; } if(sum%2!=0){ return false; } int target=sum/2; int[]dp=new int[target+1]; for(int i=0;i\u0026lt;nums.length;i++){ for(int j=target;j\u0026gt;=nums[i];j--){ dp[j]=Math.max(dp[j],dp[j-nums[i]]+nums[i]); } if(dp[target]==target){ return true; } } return dp[target]==target; } } leetcode 494 目标和 题目描述\n力扣题目链接(opens new window)\n难度：中等\n给定一个非负整数数组，a1, a2, \u0026hellip;, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。\n返回可以使最终数组和为目标数 S 的所有添加符号的方法数。\n示例：\n输入：nums: [1, 1, 1, 1, 1], S: 3 输出：5 解释：\n-1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3 一共有5种方法让最终目标和为3。\n提示：\n数组非空，且长度不会超过 20 。 初始的数组的和不会超过 1000 。 保证返回的最终结果能被 32 位整数存下。 思路解析\n本题依然可以转换为0-1背包问题，设加法部分为left，减法部分为right $$ left+right=sum, left-right=target \\to left=(sum+target)/2 $$ 此时问题就转化为，用nums装满容量为left的背包有多少种方法\n确定dp数组以及下标的含义 dp[i]：使用容量为i的包装满，有dp[j]种方法。 确定递推公式 不放物品i：即背包容量为j，里面不放物品i，装满有dp[j]中方法。 放物品i： 即：先空出物品i的容量，背包容量为（j - 物品i容量），放满背包有 dp[[j - 物品i容量] 种方法。 递推公式：dp[j] = dp[j] + dp[j - nums[i]] 遍历顺序：同0-1背包 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int findTargetSumWays(int[] nums, int target) { int sum=0; for(int i=0;i\u0026lt;nums.length;i++){ sum+=nums[i]; } // left+right=sum // left-right=target // left=(sum+target)/2 if (Math.abs(target) \u0026gt; sum) return 0; if ((target + sum) % 2 == 1) return 0; int bagSize=(sum+target)/2; int[]dp=new int[bagSize+1]; dp[0]=1; for(int i=0;i\u0026lt;nums.length;i++){ for(int j=bagSize;j\u0026gt;=nums[i];j--){ dp[j]+=dp[j-nums[i]]; } } return dp[bagSize]; } } leetcode 474 一和零 题目描述\n力扣题目链接(opens new window)\n给你一个二进制字符串数组 strs 和两个整数 m 和 n 。\n请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。\n如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。\n示例 1：\n输入：strs = [\u0026ldquo;10\u0026rdquo;, \u0026ldquo;0001\u0026rdquo;, \u0026ldquo;111001\u0026rdquo;, \u0026ldquo;1\u0026rdquo;, \u0026ldquo;0\u0026rdquo;], m = 5, n = 3 输出：4 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {\u0026ldquo;10\u0026rdquo;,\u0026ldquo;0001\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;} ，因此答案是 4 。 其他满足题意但较小的子集包括 {\u0026ldquo;0001\u0026rdquo;,\u0026ldquo;1\u0026rdquo;} 和 {\u0026ldquo;10\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;} 。{\u0026ldquo;111001\u0026rdquo;} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。 示例 2：\n输入：strs = [\u0026ldquo;10\u0026rdquo;, \u0026ldquo;0\u0026rdquo;, \u0026ldquo;1\u0026rdquo;], m = 1, n = 1 输出：2 解释：最大的子集是 {\u0026ldquo;0\u0026rdquo;, \u0026ldquo;1\u0026rdquo;} ，所以答案是 2 。 提示：\n1 \u0026lt;= strs.length \u0026lt;= 600 1 \u0026lt;= strs[i].length \u0026lt;= 100 strs[i] 仅由 \u0026lsquo;0\u0026rsquo; 和 \u0026lsquo;1\u0026rsquo; 组成 1 \u0026lt;= m, n \u0026lt;= 100 思路解析\n本题其实也是一个01背包问题。本题中strs 数组里的元素就是物品，每个物品都是一个！\n而m 和 n相当于是一个背包，两个维度的背包。而重量也是两个维度（0的个数和1的个数）\n确定dp数组（dp table）以及下标的含义 dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]。 确定递推公式 dp[i][j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。 然后我们在遍历的过程中，取dp[i][j]的最大值。 递推公式：dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1); 遍历顺序：倒序遍历m和n，类似0-1背包 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int findMaxForm(String[] strs, int m, int n) { // 最多有i个0和j个1的strs的最大子集的大小为dp[i][j] int[][]dp=new int[m+1][n+1]; int oneNum; int zeroNum; for(String str:strs){ oneNum=0; zeroNum=0; for(char ch:str.toCharArray()){ if(ch==\u0026#39;0\u0026#39;){ zeroNum++; }else{ oneNum++; } } for(int i=m;i\u0026gt;=zeroNum;i--){ for(int j=n;j\u0026gt;=oneNum;j--){ dp[i][j]=Math.max(dp[i][j],dp[i-zeroNum][j-oneNum]+1); } } } return dp[m][n]; } } 完全背包问题 题目描述 有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品可以使用无数次，求解将哪些物品装入背包里物品价值总和最大。\n思路解析 二维dp解法 确定dp数组以及下标的含义 有两个维度需要分别表示：物品 和 背包容量 dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大 确定递推公式 第一种情况：不放物体则 dp[i][j]=dp[i-1][j] 第二种情况：放入物体则 dp[i][j]=dp[i][j-weight[i]]+value[i] 取上面的较大值 dp数组的初始化 i=0时 j \u0026lt; weight[0] 的时候，dp[0][j] 是 0，因为背包容量比编号0的物品重量还小。 当 j \u0026gt;= weight[0] 时，dp[0][j] 可以一直装物品0，dp[0][j] = dp[0][j - weight[0]] + value[0] j=0时 背包容量为0，dp[i][0]=0 确定遍历顺序 先遍历物品再遍历容量，注意判断当背包容量小于物品容量时不放入物品 求解组合数的时候，先遍历物品还是先遍历背包容量不重要 求解排列数的时候，必须先遍历背包再遍历物品 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.util.*; public class Main{ public static void main (String[] args) { Scanner sc=new Scanner(System.in); int n=sc.nextInt(); int v=sc.nextInt(); int[] weight=new int[n]; int[] value=new int[n]; for(int i=0;i\u0026lt;n;i++){ weight[i]=sc.nextInt(); value[i]=sc.nextInt(); } int[][]dp=new int[n][v+1]; // i=0,初始化 for(int i=weight[0];i\u0026lt;=v;i++){ dp[0][i]=dp[0][i-weight[0]]+value[0]; } for(int i=1;i\u0026lt;n;i++){ for(int j=1;j\u0026lt;=v;j++){ if(j\u0026lt;weight[i]){ dp[i][j]=dp[i-1][j]; }else{ dp[i][j]=Math.max(dp[i-1][j],dp[i][j-weight[i]]+value[i]); } } } System.out.println(dp[n-1][v]); } } 一维dp解法 同理0-1背包问题的一维DP解法，递推公式可以转换为 dp[j] = max(dp[j], dp[j - weight[i]] + value[i])\n确定dp数组的定义 dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。 递推公式 递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) 初始化 全部初始化为0即可 遍历顺序 顺序遍历物品，同时顺序遍历容量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import java.util.*; public class Main{ public static void main (String[] args) { Scanner sc=new Scanner(System.in); int n=sc.nextInt(); int v=sc.nextInt(); int[] weight=new int[n]; int[] value=new int[n]; for(int i=0;i\u0026lt;n;i++){ weight[i]=sc.nextInt(); value[i]=sc.nextInt(); } int[]dp=new int[v+1]; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;=v;j++){ if(j\u0026lt;weight[i]){ dp[j]=dp[j]; }else{ dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]); } } } System.out.println(dp[v]); } } 经典例题 leetcode 518 零钱兑换II 题目描述\n力扣题目链接(opens new window)\n给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。\n示例 1:\n输入: amount = 5, coins = [1, 2, 5] 输出: 4 解释: 有四种方式可以凑成总金额:\n5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1 示例 2:\n输入: amount = 3, coins = [2] 输出: 0 解释: 只用面额2的硬币不能凑成总金额3。 示例 3:\n输入: amount = 10, coins = [10] 输出: 1 注意，你可以假设：\n0 \u0026lt;= amount (总金额) \u0026lt;= 5000 1 \u0026lt;= coin (硬币面额) \u0026lt;= 5000 硬币种类不超过 500 种 结果符合 32 位符号整数 思路解析\n本题实际上可以转换为完全背包问题。将总金额视为背包的容量，硬币作为重量和价值相同的物品\n确定dp数组的含义 dp[j]：凑成总金额j的货币组合数为dp[j] 确定递推公式 不放硬币：dp[j] 放入硬币：dp[j-coins[i]] dp[j] =dp[j] + dp[j - coins[i]] 初始化 装满背包容量为0 的方法是1，即不放任何物品，dp[0] = 1 遍历顺序 本题要求解的是组合数，应当先遍历物品再遍历背包容量 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int change(int amount, int[] coins) { int n=coins.length; int[]dp=new int[amount+1]; // 初始化 dp[0]=1; // 求组合数先遍历物品再遍历背包容量 for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;=amount;j++){ // 背包比硬币小，只能不放入硬币 if(j\u0026lt;coins[i]){ dp[j]=dp[j]; }else{ dp[j]=dp[j]+dp[j-coins[i]]; } } } return dp[amount]; } } leetcode 377 组合总和IV 题目描述\n力扣题目链接(opens new window)\n难度：中等\n给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。\n示例:\nnums = [1, 2, 3] target = 4 所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)\n请注意，顺序不同的序列被视作不同的组合。\n因此输出为 7。\n思路解析\n本题依然是完全背包问题，将目标正整数视为背包容量，数组中的元素视为重量和价值相同的物品\n确定dp数组以及下标的含义\ndp[i]: 凑成目标正整数为i的排列个数为dp[i] 确定递推公式\ndp[i]有两种可能 加入nums[j]即由 dp[i - nums[j]]推导 不加入nums[j]即由dp[i] 推导出来。 dp数组如何初始化\n递推公式dp[i] += dp[i - nums[j]]，dp[0]要初始化为1，这样递归其他dp[i]的时候才会有数值基础。 确定遍历顺序\n本题要求的是排列，要求先遍历背包容量再遍历物品 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int combinationSum4(int[] nums, int target) { int n=nums.length; // p[i]: 凑成目标正整数为i的排列个数为dp[i] int[]dp=new int[target+1]; dp[0]=1; // 求排列数先遍历背包容量再遍历物品 for(int i=0;i\u0026lt;=target;i++){ for(int j=0;j\u0026lt;n;j++){ if(i\u0026lt;nums[j]){ dp[i]=dp[i]; }else{ dp[i]=dp[i]+dp[i-nums[j]]; } } } return dp[target]; } } leetcode 322 零钱兑换 题目描述\n力扣题目链接(opens new window)\n给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。\n你可以认为每种硬币的数量是无限的。\n示例 1：\n输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1 示例 2：\n输入：coins = [2], amount = 3 输出：-1 示例 3：\n输入：coins = [1], amount = 0 输出：0 示例 4：\n输入：coins = [1], amount = 1 输出：1 示例 5：\n输入：coins = [1], amount = 2 输出：2 提示：\n1 \u0026lt;= coins.length \u0026lt;= 12 1 \u0026lt;= coins[i] \u0026lt;= 2^31 - 1 0 \u0026lt;= amount \u0026lt;= 10^4 思路解析\n确定dp数组以及下标的含义\ndp[j]：凑足总额为j所需钱币的最少个数为dp[j] 确定递推公式\n凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i] 即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]） 递推公式：dp[j] = min(dp[j - coins[i]] + 1, dp[j]); dp数组初始化\n凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0; 其他下标对应的数值，考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。 遍历过程\n本题是求解是组合数（硬币的顺序不重要） 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int coinChange(int[] coins, int amount) { int n=coins.length; // 凑足总额为j所需钱币的最少个数为dp[j] int[]dp=new int[amount+1]; // 初始化DP数值 Arrays.fill(dp,Integer.MAX_VALUE); dp[0]=0; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;=amount;j++){ if(j\u0026lt;coins[i]){ dp[j]=dp[j]; }else if(dp[j-coins[i]]!=Integer.MAX_VALUE){ dp[j]=Math.min(dp[j],dp[j-coins[i]]+1); } } } return dp[amount]==Integer.MAX_VALUE?-1:dp[amount]; } } leetcode 279 完全平方数 题目描述\n力扣题目链接(opens new window)\n给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, \u0026hellip;）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。\n给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。\n完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。\n示例 1：\n输入：n = 12 输出：3 解释：12 = 4 + 4 + 4 示例 2：\n输入：n = 13 输出：2 解释：13 = 4 + 9 提示：\n1 \u0026lt;= n \u0026lt;= 10^4 思路解析\n完全平方数就是物品（可以无限件使用），凑个正整数n就是背包，问凑满这个背包最少有多少物品？\n确定dp数组（dp table）以及下标的含义\ndp[j]：和为j的完全平方数的最少数量为dp[j] 确定递推公式\ndp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。 dp[j] = min(dp[j - i * i] + 1, dp[j]); dp数组如何初始化\ndp[0]表示 和为0的完全平方数的最小数量，那么dp[0]一定是0。 非0下标的dp[j]应该是很大的值，从递归公式dp[j] = min(dp[j - i * i] + 1, dp[j]);中可以看出每次dp[j]都要选最小的，所以非0下标的dp[j]一定要初始为最大值，这样dp[j]在递推的时候才不会被初始值覆盖。 确定遍历顺序\n本题求解的是组合数就是外层for循环遍历物品，内层for遍历背包。 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int numSquares(int n) { int[]dp=new int[n+1]; Arrays.fill(dp,Integer.MAX_VALUE); dp[0]=0; for(int i=1;i*i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=n;j++){ if(j\u0026lt;i*i){ dp[j]=dp[j]; }else{ dp[j]=Math.min(dp[j],dp[j-i*i]+1); } } } return dp[n]; } } leetcode 139 单词拆分 题目描述\n力扣题目链接(opens new window)\n给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。\n说明：\n拆分时可以重复使用字典中的单词。\n你可以假设字典中没有重复的单词。\n示例 1：\n输入: s = \u0026ldquo;leetcode\u0026rdquo;, wordDict = [\u0026ldquo;leet\u0026rdquo;, \u0026ldquo;code\u0026rdquo;] 输出: true 解释: 返回 true 因为 \u0026ldquo;leetcode\u0026rdquo; 可以被拆分成 \u0026ldquo;leet code\u0026rdquo;。 示例 2：\n输入: s = \u0026ldquo;applepenapple\u0026rdquo;, wordDict = [\u0026ldquo;apple\u0026rdquo;, \u0026ldquo;pen\u0026rdquo;] 输出: true 解释: 返回 true 因为 \u0026ldquo;applepenapple\u0026rdquo; 可以被拆分成 \u0026ldquo;apple pen apple\u0026rdquo;。 注意你可以重复使用字典中的单词。 示例 3：\n输入: s = \u0026ldquo;catsandog\u0026rdquo;, wordDict = [\u0026ldquo;cats\u0026rdquo;, \u0026ldquo;dog\u0026rdquo;, \u0026ldquo;sand\u0026rdquo;, \u0026ldquo;and\u0026rdquo;, \u0026ldquo;cat\u0026rdquo;] 输出: false 思路解析\n单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。\n确定dp数组以及下标的含义\ndp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词。 确定递推公式\n如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j \u0026lt; i ）。 递推公式是 if([j, i] 这个区间的子串出现在字典里 \u0026amp;\u0026amp; dp[j]是true) 那么 dp[i] = true。 dp数组如何初始化\ndp[0]一定要为true，否则递推下去后面都都是false了。 下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。 确定遍历顺序\n本题求的是排列数，先遍历背包再遍历物品 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public boolean wordBreak(String s, List\u0026lt;String\u0026gt; wordDict) { int m=wordDict.size(); int n=s.length(); // 存储字典 HashSet\u0026lt;String\u0026gt;set=new HashSet\u0026lt;\u0026gt;(wordDict); // 长度为i的字符串可以被划分 boolean[]dp=new boolean[n+1]; dp[0]=true; // 先遍历背包容量（字符串长度） // 后遍历物品 for(int i=1;i\u0026lt;=n;i++){ for(int j=0;j\u0026lt;i;j++){ String str=s.substring(j,j+(i-j)); if(dp[j]==true\u0026amp;\u0026amp;set.contains(str)){ dp[i]=true; } } } return dp[n]; } } 打劫问题 leetcode 198 打家劫舍 题目描述 力扣题目链接(opens new window)\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n示例 1： 输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。\n示例 2： 输入：[2,7,9,3,1] 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 提示：\n0 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 400 思路解析 确定dp数组（dp table）以及下标的含义\ndp[i]：考虑下标[0-i]以内的房屋，最多可以偷窃的金额为dp[i]。 确定递推公式\n决定dp[i]的因素就是第i房间偷还是不偷。\n如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。\n如果不偷第i房间，那么dp[i] = dp[i - 1]，即考虑i-1房\ndp[i]取最大值，即dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);\ndp数组如何初始化\n从递推公式dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1] dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值 确定遍历顺序\ndp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！ 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int rob(int[] nums) { int n=nums.length; // 从[0-i]房间可以偷的最大金额 int[]dp=new int[n]; if(n==1)return nums[0]; // 数值初始化 dp[0]=nums[0]; dp[1]=Math.max(nums[0],nums[1]); for(int i=2;i\u0026lt;n;i++){ dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i]); } return dp[n-1]; } } leetcode 213 打家劫舍II 题目描述 力扣题目链接(opens new window)\n你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。\n给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。\n示例 1：\n输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2： 输入：nums = [1,2,3,1] 输出：4 解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。偷窃到的最高金额 = 1 + 3 = 4 。 示例 3： 输入：nums = [0] 输出：0 提示：\n1 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 1000 思路解析 对于一个数组，成环的话主要有如下三种情况：\n考虑不包含首尾元素 考虑包含首元素，不包含尾元素 考虑包含尾元素，不包含首元素 因此可以将上一题的逻辑封装成方法，然后比较后两者方法的较大值\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int rob(int[] nums) { if(nums.length==1){ return nums[0]; } int result1=rob(0,nums.length-2,nums); int result2=rob(1,nums.length-1,nums); return Math.max(result1,result2); } public int rob(int start,int end,int[]nums){ if (end == start) return nums[start]; int n=nums.length; int[]dp=new int[n]; dp[start]=nums[start]; dp[start+1]=Math.max(nums[start],nums[start+1]); for(int i=start+2;i\u0026lt;=end;i++){ dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i]); } return dp[end]; } } 股票问题 leetcode 121 买卖股票的最佳时机 题目描述 力扣题目链接(opens new window)\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n示例 1： 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 思路解析 确定dp数组以及下标的含义\ndp[i][0] 表示第i天持有股票所得最多现金 dp[i][1] 表示第i天不持有股票所得最多现金 确定递推公式\n如果第i天持有股票即 dp[i][0] ， 那么可以由两个状态推出来\n第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]\n第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]\n如果第i天不持有股票即 dp[i][1] ， 也可以由两个状态推出来\n第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]\n第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] + dp[i - 1][0]\ndp数组初始化\n递推公式 dp[i][0] = max(dp[i - 1][0], -prices[i]); 和 dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]) 可以看出基础都是要从 dp[0][0] 和 dp[0][1] 推导出来。 dp[0][0] -= prices[0] dp[0][1] 表示第0天不持有股票，不持有股票那么现金就是0，所以 dp[0][1] = 0 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int maxProfit(int[] prices) { if (prices == null || prices.length == 0) return 0; int length = prices.length; // dp[i][0]代表第i天持有股票的最大收益 // dp[i][1]代表第i天不持有股票的最大收益 int[][] dp = new int[length][2]; int result = 0; dp[0][0] = -prices[0]; dp[0][1] = 0; for (int i = 1; i \u0026lt; length; i++) { dp[i][0] = Math.max(dp[i - 1][0], -prices[i]); dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]); } return dp[length - 1][1]; } } leetcode 122 买卖股票的最佳时机II 题目描述 力扣题目链接(opens new window)\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 提示：\n1 \u0026lt;= prices.length \u0026lt;= 3 * 10 ^ 4 0 \u0026lt;= prices[i] \u0026lt;= 10 ^ 4 思路解析 与上一题只有递推公式不一样\n在上一题中因为股票全程只能买卖一次，所以如果买入股票，那么第i天持有股票即 dp[i][0] 一定就是 -prices[i]。 而本题，因为一只股票可以买卖多次，所以当第i天买入股票的时候，所持有的现金可能有之前买卖过的利润。、那么第i天持有股票即 dp[i][0] 如果是第i天买入股票，所得现金就是昨天不持有股票的所得现金 减去 今天的股票价格 即：dp[i - 1][1] - prices[i] 。 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int maxProfit(int[] prices) { int n=prices.length; // dp[i][0]代表第i天持有股票的最大收益 // dp[i][1]代表第i天不持有股票的最大收益 int[][]dp=new int[n][2]; // 初始化 dp[0][0]=-prices[0]; dp[0][1]=0; for(int i=1;i\u0026lt;n;i++){ dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]-prices[i]); dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]+prices[i]); } return dp[n-1][1]; } } leetcode 123 买卖股票的最佳时机III 题目描述 力扣题目链接(opens new window)\n给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n示例 1: 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3。 示例 2： 输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为0。 示例 4： 输入：prices = [1] 输出：0 提示：\n1 \u0026lt;= prices.length \u0026lt;= 10^5 0 \u0026lt;= prices[i] \u0026lt;= 10^5 思路解析 关键在于至多买卖两次，这意味着可以买卖一次，可以买卖两次，也可以不买卖。\n接来下我用动态规划五部曲详细分析一下：\n确定dp数组以及下标的含义\n一天共有以下状态\n没有操作 （其实我们也可以不设置这个状态）\n第一次持有股票\n第一次不持有股票\n第二次持有股票\n第二次不持有股票\ndp[i][j] 中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j] 表示第i天状态j所剩最大现金。\n确定递推公式\n达到 dp[i][1] 状态，有两个具体操作：\n操作一：第i天买入股票了，那么 dp[i][1] = dp[i-1][0] - prices[i]\n操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]\ndp[i][2] 也有两个操作：\n操作一：第i天卖出股票了，那么 dp[i][2] = dp[i - 1][1] + prices[i]\n操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2]\n同理可推出剩下状态部分：\ndp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);\ndp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);\ndp数组如何初始化\n第0天没有操作，这个最容易想到，就是0，即：dp[0][0] = 0; 第0天做第一次买入的操作，dp[0][1] = -prices[0]; 第0天做第一次卖出的操作，初始值可以理解当天买入，当天卖出，dp[0][2] = 0 第0天做第二次买入操作，初始化为：dp[0][3] = -prices[0] ; 第0天做第二次卖出初始化 dp[0][4] = 0 遍历顺序\n从前向后遍历 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int maxProfit(int[] prices) { int n=prices.length; int[][]dp=new int[n][5]; // 初始化 dp[0][0]=0; dp[0][1]=-prices[0]; dp[0][2]=0; dp[0][3]=-prices[0]; dp[0][4]=0; for(int i=1;i\u0026lt;n;i++){ dp[i][0]=dp[i-1][0]; // 第一次持有股票 dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i]); // 第一次不持有股票 dp[i][2]=Math.max(dp[i-1][2],dp[i-1][1]+prices[i]); // 第二次持有股票 dp[i][3]=Math.max(dp[i-1][3],dp[i-1][2]-prices[i]); // 第二次不持有股票 dp[i][4]=Math.max(dp[i-1][4],dp[i-1][3]+prices[i]); } return dp[n-1][4]; } } leetcode 188 买卖股票的最佳时机IV 题目描述 力扣题目链接(opens new window)\n给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n示例 1： 输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2。 示例 2： 输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 提示：\n0 \u0026lt;= k \u0026lt;= 100 0 \u0026lt;= prices.length \u0026lt;= 1000 0 \u0026lt;= prices[i] \u0026lt;= 1000 思路解析 确定dp数组以及下标的含义 0 表示不操作 当 j 为奇数则是持有股票 当 j 为偶数则是不持有股票 确定递推公式 当 j 为奇数为持有股票，有两种情况 前一天依然持有股票：dp[i-1][j] 前一天不持有股票然后买入股票：dp[i-1][j-1]-prices[i] 当 j 为偶数为不持有股票，有两种情况 前一天依然不持有股票：dp[i-1][j] 前一天持有股票然后卖出股票：dp[i-1][j-1]+prices[i] 数组初始化 当 j 为奇数为持有股票则 dp[0][j]=-prices[0] 当 j 为偶数数为不持有股票则 dp[0][j]=0 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int maxProfit(int k, int[] prices) { int n=prices.length; int[][]dp=new int[n][2*k+1]; // 初始化 for(int i=0;i\u0026lt;=2*k;i+=2){ dp[0][i]=0; } for(int i=1;i\u0026lt;=2*k-1;i+=2){ dp[0][i]=-prices[0]; } for(int i=1;i\u0026lt;n;i++){ for(int j=1;j\u0026lt;2*k+1;j++){ if(j%2==1){ dp[i][j]=Math.max(dp[i-1][j],dp[i-1][j-1]-prices[i]); }else{ dp[i][j]=Math.max(dp[i-1][j],dp[i-1][j-1]+prices[i]); } } } return dp[n-1][2*k]; } } 子序列和子数组问题 子序列：不要求连续，是序列中删除部分元素或者不删除 子数组：要求连续 最长上升子序列 leetcode 300 最长上升子序列的长度 题目描述\n力扣题目链接(opens new window)\n给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n示例 1：\n输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2：\n输入：nums = [0,1,0,3,2,3] 输出：4 示例 3：\n输入：nums = [7,7,7,7,7,7,7] 输出：1 提示：\n1 \u0026lt;= nums.length \u0026lt;= 2500 -10^4 \u0026lt;= nums[i] \u0026lt;= 104 思路解析\ndp[i]的定义 dp[i]表示以nums[i]结尾的最长递增子序列的长度 递推方程 位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。 if (nums[i] \u0026gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1); dp[i]的初始化 每一个i，对应的dp[i]（即最长递增子序列）起始大小至少都是1. 遍历顺序 dp[i] 是有0到i-1各个位置的最长递增子序列推导而来，那么遍历i一定是从前向后遍历。 j其实遍历0到i-1， 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int lengthOfLIS(int[] nums) { int n=nums.length; //以下标为i结尾的子序列的最长严格递增子序列长度 if(n==0||n==1)return n; int[]dp=new int[n]; int res=Integer.MIN_VALUE; Arrays.fill(dp,1); for(int i=1;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;i;j++){ if(nums[j]\u0026lt;nums[i]){ dp[i]=Math.max(dp[j]+1,dp[i]); } res=Math.max(res,dp[i]); } } return res; } } leetcode 673 最长上升子序列的个数 题目描述\n力扣题目链接(opens new window)\n给定一个未排序的整数数组，找到最长递增子序列的个数。\n示例 1:\n输入: [1,3,5,4,7] 输出: 2 解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。 示例 2:\n输入: [2,2,2,2,2] 输出: 5 解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。 思路解析\n确定dp数组以及下标的含义\n这道题目需要一起维护两个数组。 dp[i]：i之前（包括i）最长递增子序列的长度为dp[i] count[i]：以nums[i]为结尾的字符串，最长递增子序列的个数为count[i] 确定递推公式\n更新dp[i]：在上一题中的状态转移是：if (nums[i] \u0026gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1); 更新count[i]： 那么在nums[i] \u0026gt; nums[j]前提下，如果在[0, i-1]的范围内，找到了j，使得dp[j] + 1 \u0026gt; dp[i]，说明找到了一个更长的递增子序列。那么以j为结尾的子串的最长递增子序列的个数，就是最新的以i为结尾的子串的最长递增子序列的个数，即：count[i] = count[j]。 在nums[i] \u0026gt; nums[j]前提下，如果在[0, i-1]的范围内，找到了j，使得dp[j] + 1 == dp[i]，说明找到了两个相同长度的递增子序列。那么以i为结尾的子串的最长递增子序列的个数 就应该加上以j为结尾的子串的最长递增子序列的个数，即：count[i] += count[j]; 数组初始化\ncount[i]记录了以nums[i]为结尾的字符串，最长递增子序列的个数。最少也就是1个，所以count[i]初始为1。 dp[i]记录了i之前（包括i）最长递增序列的长度。最小的长度也是1，所以dp[i]初始为1。 遍历顺序\n从左往右遍历 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public int findNumberOfLIS(int[] nums) { int res=0; int n=nums.length; if (n \u0026lt;= 1) return nums.length; int[]dp=new int[n]; int[]count=new int[n]; Arrays.fill(dp,1); Arrays.fill(count,1); int maxCount=0; for(int i=1;i\u0026lt;n;i++) { for (int j = 0; j \u0026lt; i; j++) { if (nums[i] \u0026gt; nums[j]) { if (dp[j] + 1 \u0026gt; dp[i]) { count[i] = count[j]; } else if (dp[j] + 1 == dp[i]) { count[i] += count[j]; } dp[i] = Math.max(dp[j] + 1, dp[i]); } if(dp[i]\u0026gt;maxCount){ maxCount=dp[i]; } } } int result = 0; for (int i = 0; i \u0026lt; n; i++) { if (maxCount == dp[i]) result += count[i]; } return result; } } 最长连续上升子序列 leetcode 674 最长上升连续序列 题目描述\n力扣题目链接(opens new window)\n给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。\n连续递增的子序列 可以由两个下标 l 和 r（l \u0026lt; r）确定，如果对于每个 l \u0026lt;= i \u0026lt; r，都有 nums[i] \u0026lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], \u0026hellip;, nums[r - 1], nums[r]] 就是连续递增子序列。\n示例 1：\n输入：nums = [1,3,5,4,7] 输出：3 解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 示例 2：\n输入：nums = [2,2,2,2,2] 输出：1 解释：最长连续递增序列是 [2], 长度为1。 思路解析\n确定dp数组以及下标的含义\ndp[i]：以下标i为结尾的连续递增的子序列长度为dp[i]。 确定递推公式\n如果 nums[i] \u0026gt; nums[i - 1]，那么以 i 为结尾的连续递增的子序列长度 一定等于 以i - 1为结尾的连续递增的子序列长度 + 1 。dp[i] = dp[i - 1] + 1 dp数组初始化\n以下标i为结尾的连续递增的子序列长度最少也应该是1。 确定遍历顺序\n从递推公式上可以看出， dp[i + 1]依赖dp[i]，所以一定是从前向后遍历。 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int findLengthOfLCIS(int[] nums) { int n=nums.length; if(n==0||n==1)return n; int res=0; // 结尾下标为i的连续递增子序列的长度 int[]dp=new int[n]; Arrays.fill(dp,1); for(int i=1;i\u0026lt;n;i++){ if(nums[i-1]\u0026lt;nums[i]){ dp[i]=dp[i-1]+1; } if(res\u0026lt;dp[i]){ res=dp[i]; } } return res; } } 最长重复子数组 leetcode 718 最长重复子数组 题目描述\n力扣题目链接(opens new window)\n给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。\n示例：\n输入：\nA: [1,2,3,2,1] B: [3,2,1,4,7] 输出：3 解释：长度最长的公共子数组是 [3, 2, 1] 。 提示：\n1 \u0026lt;= len(A), len(B) \u0026lt;= 1000 0 \u0026lt;= A[i], B[i] \u0026lt; 100 思路解析\n确定dp数组以及下标的含义 dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为 dp[i][j] 。 （特别注意： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ） 确定递推公式 当A[i - 1] 和B[j - 1]相等的时候，dp[i][j] = dp[i - 1][j - 1] + 1; dp数组初始化 dp[i][0] 和 dp[0][j] 初始化为0 确定遍历顺序 外层for循环遍历A，内层for循环遍历B 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int findLength(int[] nums1, int[] nums2) { int m=nums1.length; int n=nums2.length; // 结尾下标为i-1和j-1的公共最长子数组 int[][]dp=new int[m+1][n+1]; int res=Integer.MIN_VALUE; for(int i=1;i\u0026lt;=m;i++){ for(int j=1;j\u0026lt;=n;j++){ if(nums1[i-1]==nums2[j-1]){ dp[i][j]=dp[i-1][j-1]+1; } if(res\u0026lt;dp[i][j]){ res=dp[i][j]; } } } return res; } } 最长公共子序列 leetcode 1143 最长公共子序列 题目描述\n力扣题目链接(opens new window)\n给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。\n一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n例如，\u0026ldquo;ace\u0026rdquo; 是 \u0026ldquo;abcde\u0026rdquo; 的子序列，但 \u0026ldquo;aec\u0026rdquo; 不是 \u0026ldquo;abcde\u0026rdquo; 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。\n若这两个字符串没有公共子序列，则返回 0。\n示例 1:\n输入：text1 = \u0026ldquo;abcde\u0026rdquo;, text2 = \u0026ldquo;ace\u0026rdquo; 输出：3 解释：最长公共子序列是 \u0026ldquo;ace\u0026rdquo;，它的长度为 3。 示例 2:\n输入：text1 = \u0026ldquo;abc\u0026rdquo;, text2 = \u0026ldquo;abc\u0026rdquo; 输出：3 解释：最长公共子序列是 \u0026ldquo;abc\u0026rdquo;，它的长度为 3。 示例 3:\n输入：text1 = \u0026ldquo;abc\u0026rdquo;, text2 = \u0026ldquo;def\u0026rdquo; 输出：0 解释：两个字符串没有公共子序列，返回 0。 思路解析\n确定dp数组以及下标的含义 dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为 dp[i][j] 确定递推公式 如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以 dp[i][j] = dp[i - 1][j - 1] + 1; 如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。 dp数组初始化 dp[i][0] 应该0，text1[0, i-1]和空串的最长公共子序列自然是0 同理 dp[0][j] 也是0 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int longestCommonSubsequence(String text1, String text2) { int m=text1.length(); int n=text2.length(); char[]chars1=text1.toCharArray(); char[]chars2=text2.toCharArray(); int[][]dp=new int[m+1][n+1]; int res=Integer.MIN_VALUE; for(int i=1;i\u0026lt;=m;i++){ for(int j=1;j\u0026lt;=n;j++){ if(chars1[i-1]==chars2[j-1]){ dp[i][j]=dp[i-1][j-1]+1; }else{ dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]); } if(res\u0026lt;dp[i][j]){ res=dp[i][j]; } } } return res; } } leetcode 1035 不相交的线 题目描述\n力扣题目链接(opens new window)\n在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。\n现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足：\nnums1[i] == nums2[j] 且绘制的直线不与任何其他连线（非水平线）相交。 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。\n以这种方法绘制线条，并返回可以绘制的最大连线数。\n思路解析\n本题表面上是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int maxUncrossedLines(int[] nums1, int[] nums2) { int m=nums1.length; int n=nums2.length; // dp[i][j]是终点下标为i-1的nums1和终点下标为j-1的nums2的最长公共子序列 int[][]dp=new int[m+1][n+1]; // 递推公式根据dp[i-1][j-1]推理 for(int i=1;i\u0026lt;=m;i++){ for(int j=1;j\u0026lt;=n;j++){ if(nums1[i-1]==nums2[j-1]){ dp[i][j]=dp[i-1][j-1]+1; }else{ dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]); } } } return dp[m][n]; } } 最大子序和 leetcode 53 最大子序和 题目描述\n力扣题目链接(opens new window)\n给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n示例:\n输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 思路解析\n确定dp数组以及下标的含义\ndp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]。 确定递推公式：dp[i]只有两个方向可以推出来：\ndp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和\nnums[i]，即：从头开始计算当前连续子序列和\ndp数组如何初始化\n从递推公式可以看出来dp[i]是依赖于dp[i - 1]的状态，dp[0]就是递推公式的基础。根据dp[i]的定义，很明显dp[0]应为nums[0]即dp[0] = nums[0]。 确定遍历顺序\n递推公式中dp[i]依赖于dp[i - 1]的状态，需要从前向后遍历。 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int maxSubArray(int[] nums) { int res=nums[0]; int n=nums.length; if(n==1)return nums[0]; if (n == 0) { return 0; } // 以nums[i]结尾的子序列的最大和 int[]dp=new int[n]; // 数组初始化 dp[0]=nums[0]; for(int i=1;i\u0026lt;n;i++){ dp[i]=Math.max(dp[i-1]+nums[i],nums[i]); if(res\u0026lt;dp[i]){ res=dp[i]; } } return res; } } 编辑距离问题 leetcode 392 判断子序列 题目描述\n力扣题目链接(opens new window)\n给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，\u0026ldquo;ace\u0026quot;是\u0026quot;abcde\u0026quot;的一个子序列，而\u0026quot;aec\u0026quot;不是）。\n示例 1：\n输入：s = \u0026ldquo;abc\u0026rdquo;, t = \u0026ldquo;ahbgdc\u0026rdquo; 输出：true 示例 2：\n输入：s = \u0026ldquo;axc\u0026rdquo;, t = \u0026ldquo;ahbgdc\u0026rdquo; 输出：false 提示：\n0 \u0026lt;= s.length \u0026lt;= 100 0 \u0026lt;= t.length \u0026lt;= 10^4 两个字符串都只由小写字符组成。\n思路解析\n确定dp数组（dp table）以及下标的含义\ndp[i][j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]。 确定递推公式\nif (s[i - 1] == t[j - 1])：t中找到了一个字符在s中也出现了\ndp[i][j] = dp[i - 1][j - 1] + 1 ，因为找到了一个相同的字符，相同子序列长度自然要在 dp[i-1][j-1] 的基础上加1 if (s[i - 1] != t[j - 1])：相当于t要删除元素，继续匹配\n那么 dp[i][j] 的数值就是 看s[i - 1]与 t[j - 2]的比较结果了，即：dp[i][j] = dp[i][j - 1] dp数组如何初始化\n从递推公式可以看出 dp[i][j] 都是依赖于 dp[i - 1][j - 1] 和 dp[i][j - 1] ，所以 dp[0][0] 和 dp[i][0] 是一定要初始化的。 dp[i][0] 表示以下标i-1为结尾的字符串，与空字符串的相同子序列长度，所以为0. dp[0][j] 同理。 遍历顺序\ndp[i][j] 都是依赖于 dp[i - 1][j - 1] 和 dp[i][j - 1] ，那么遍历顺序也应该是从上到下，从左到右 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public boolean isSubsequence(String s, String t) { int m=s.length(); int n=t.length(); char[]s_chars=s.toCharArray(); char[]t_chars=t.toCharArray(); // dp[i][j]为下标为i-1的s和下标为j-1的t的相同子序列的长度 int[][]dp=new int[m+1][n+1]; for(int i=1;i\u0026lt;=m;i++){ for(int j=1;j\u0026lt;=n;j++){ if(s_chars[i-1]==t_chars[j-1]){ dp[i][j]=dp[i-1][j-1]+1; }else{ dp[i][j]=dp[i][j-1]; } } } return dp[m][n]==m?true:false; } } leetcode 115 不同的子序列 题目描述\n力扣题目链接(opens new window)\n给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。\n字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，\u0026ldquo;ACE\u0026rdquo; 是 \u0026ldquo;ABCDE\u0026rdquo; 的一个子序列，而 \u0026ldquo;AEC\u0026rdquo; 不是）\n题目数据保证答案符合 32 位带符号整数范围。\n提示：\n0 \u0026lt;= s.length, t.length \u0026lt;= 1000 s 和 t 由英文字母组成 思路解析\n确定dp数组（dp table）以及下标的含义\ndp[i][j] ：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数 确定递推公式\ns[i - 1] 与 t[j - 1]相等\n可以用用s[i - 1]来匹配，那么个数为 dp[i - 1][j - 1] 。即不需要考虑当前s子串和t子串的最后一位字母，所以只需要 dp[i-1][j-1] 。 一部分是不用s[i - 1]来匹配，个数为 dp[i - 1][j] 。 s[i - 1] 与 t[j - 1] 不相等\ns中删除这个元素即：dp[i - 1][j] dp数组初始化\n从递推公式 dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] ; 和 dp[i][j] = dp[i - 1][j] ; 中可以看出dp[i][j] 是从上方和左上方推导而来，如图：，那么 dp[i][0] 和 dp[0][j] 是一定要初始化的。 dp[i][0] 都是1，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1 dp[0][j] 都是0，s如论如何也变成不了t 确定遍历顺序\n从递推公式可以看出都是根据左上方和正上方推出来的。 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int numDistinct(String s, String t) { int m=s.length(); int n=t.length(); // 以i-1为结尾的s子序列中出现以j-1为结尾的t的个数 int[][]dp=new int[m+1][n+1]; // 数组初始化 for (int i = 0; i \u0026lt;= m; i++) { dp[i][0] = 1; } // 数组遍历 for(int i=1;i\u0026lt;=m;i++){ for(int j=1;j\u0026lt;=n;j++){ if(s.charAt(i-1)==t.charAt(j-1)){ dp[i][j]=dp[i-1][j-1]+dp[i-1][j]; }else { dp[i][j]=dp[i-1][j]; } } } return dp[m][n]; } } leetcode 583 两个字符串的删除操作 题目描述\n力扣题目链接(opens new window)\n给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。\n示例：\n输入: \u0026ldquo;sea\u0026rdquo;, \u0026ldquo;eat\u0026rdquo; 输出: 2 解释: 第一步将\u0026quot;sea\u0026quot;变为\u0026quot;ea\u0026rdquo;，第二步将\u0026quot;eat\u0026quot;变为\u0026quot;ea\u0026quot; 思路解析\n确定dp数组以及下标的含义\ndp[i][j] ：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。 确定递推公式\n当word1[i - 1] 与 word2[j - 1]相同的时候：dp[i][j] = dp[i - 1][j - 1] 两个字符串同时删除\n当word1[i - 1] 与 word2[j - 1]不相同的时候\n情况一：删word1[i - 1]，最少操作次数为 dp[i - 1][j] + 1 情况二：删word2[j - 1]，最少操作次数为 dp[i][j - 1] + 1 情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为 dp[i - 1][j - 1] + 2 dp数组如何初始化\n从递推公式中，可以看出来，dp[i][0] 和 dp[0][j] 是一定要初始化的。 dp[i][0] ：word2为空字符串，以i-1为结尾的字符串word1要删除多少个元素，才能和word2相同呢，很明显 dp[i][0] = i。dp[0][j] 的话同理 遍历顺序\n从递推公式 可以看出 dp[i][j] 都是根据左上方、正上方、正左方推出来的。 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int minDistance(String word1, String word2) { int m=word1.length(); int n=word2.length(); // 以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。 int[][]dp=new int[m+1][n+1]; // 初始化 for(int i=0;i\u0026lt;=m;i++){ dp[i][0]=i; } for(int j=0;j\u0026lt;=n;j++){ dp[0][j]=j; } // 遍历过程 for(int i=1;i\u0026lt;=m;i++){ for(int j=1;j\u0026lt;=n;j++){ if(word1.charAt(i-1)==word2.charAt(j-1)){ dp[i][j]=dp[i-1][j-1]; }else{ dp[i][j]=Math.min(dp[i-1][j]+1,dp[i][j-1]+1); } } } return dp[m][n]; } } leetcode 72 编辑距离 题目描述\n力扣题目链接(opens new window)\n给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。\n你可以对一个单词进行如下三种操作：\n插入一个字符 删除一个字符 替换一个字符 示例 1： 输入：word1 = \u0026ldquo;horse\u0026rdquo;, word2 = \u0026ldquo;ros\u0026rdquo; 输出：3 解释： horse -\u0026gt; rorse (将 \u0026lsquo;h\u0026rsquo; 替换为 \u0026lsquo;r\u0026rsquo;) rorse -\u0026gt; rose (删除 \u0026lsquo;r\u0026rsquo;) rose -\u0026gt; ros (删除 \u0026rsquo;e\u0026rsquo;) 示例 2： 输入：word1 = \u0026ldquo;intention\u0026rdquo;, word2 = \u0026ldquo;execution\u0026rdquo; 输出：5 解释： intention -\u0026gt; inention (删除 \u0026rsquo;t\u0026rsquo;) inention -\u0026gt; enention (将 \u0026lsquo;i\u0026rsquo; 替换为 \u0026rsquo;e\u0026rsquo;) enention -\u0026gt; exention (将 \u0026rsquo;n\u0026rsquo; 替换为 \u0026lsquo;x\u0026rsquo;) exention -\u0026gt; exection (将 \u0026rsquo;n\u0026rsquo; 替换为 \u0026lsquo;c\u0026rsquo;) exection -\u0026gt; execution (插入 \u0026lsquo;u\u0026rsquo;) 提示：\n0 \u0026lt;= word1.length, word2.length \u0026lt;= 500 word1 和 word2 由小写英文字母组成 思路解析\n确定dp数组以及下标的含义\ndp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2的最近编辑次数 确定递推公式\n若word1[i - 1] == word2[j - 1] 那么不用编辑。dp[i][j] = dp[i - 1][j - 1] 若word1[i - 1] != word2[j - 1] word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的编辑次数再加上一个操作，即 dp[i][j] = dp[i - 1][j] + 1 word1加入一个元素，相当于word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。dp[i][j] = dp[i][j - 1] + 1 word1替换一个元素：dp[i][j] = dp[i - 1][j - 1] + 1 数组初始化\n从递推公式中，可以看出来，dp[i][0] 和 dp[0][j] 是一定要初始化的。 dp[i][0] ：word2为空字符串，以i-1为结尾的字符串word1要删除多少个元素，才能和word2相同呢，很明显 dp[i][0] = i。dp[0][j] 的话同理 遍历顺序\ndp[i][j] 是依赖左方，上方和左上方元素，从左到右，从上到下遍历 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int minDistance(String word1, String word2) { int m=word1.length(); int n=word2.length(); // dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2的最近编辑次数 int[][]dp=new int[m+1][n+1]; // 初始化数组 for(int i=0;i\u0026lt;=m;i++){ dp[i][0]=i; } for(int j=0;j\u0026lt;=n;j++){ dp[0][j]=j; } for(int i=1;i\u0026lt;=m;i++){ for(int j=1;j\u0026lt;=n;j++){ if(word1.charAt(i-1)==word2.charAt(j-1)){ dp[i][j]=dp[i-1][j-1]; }else{ dp[i][j]=Math.min(dp[i-1][j]+1,Math.min(dp[i-1][j-1]+1,dp[i][j-1]+1)); } } } return dp[m][n]; } } 回文子串问题 leetcode 647 回文子串 题目描述\n力扣题目链接(opens new window)\n给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。\n具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。\n示例 1：\n输入：\u0026ldquo;abc\u0026rdquo; 输出：3 解释：三个回文子串: \u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;, \u0026ldquo;c\u0026rdquo; 示例 2：\n输入：\u0026ldquo;aaa\u0026rdquo; 输出：6 解释：6个回文子串: \u0026ldquo;a\u0026rdquo;, \u0026ldquo;a\u0026rdquo;, \u0026ldquo;a\u0026rdquo;, \u0026ldquo;aa\u0026rdquo;, \u0026ldquo;aa\u0026rdquo;, \u0026ldquo;aaa\u0026rdquo; 提示：输入的字符串长度不会超过 1000 。\n思路解析\n确定dp数组以及下标的含义 判断一个子字符串（字符串下标范围[i,j]）是否回文，依赖于，子字符串（下标范围[i + 1, j - 1]）） 是否是回文。 dp[i][j] :区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串 递推公式 当s[i]与s[j]不相等，dp[i][j] 一定是false。 当s[i]与s[j]相等时 情况一：下标i 与 j相同，同一个字符是回文子串 情况二：下标i 与 j相差为1，例如aa，也是回文子串 情况三：下标：i 与 j相差大于1的时候，此时s[i]与s[j]已经相同了，看i到j区间是不是回文子串，那么区间就是 i+1 与 j-1区间，这个区间是不是回文就看 dp[i + 1][j - 1] 是否为true。 dp数组初始化 dp[i][j] 初始化为false。 遍历顺序 从递推公式中可以看出依赖于 dp[i+1][j-1] ,所以一定要从下到上遍历i，从左到右遍历j 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int countSubstrings(String s) { int n=s.length(); boolean[][]dp=new boolean[n][n]; for(boolean[]t:dp){ Arrays.fill(t,false); } int res=0; for(int i=n-1;i\u0026gt;=0;i--){ for(int j=i;j\u0026lt;n;j++){ if(s.charAt(i)==s.charAt(j)) { if(j-i\u0026lt;=1){ res++; dp[i][j]=true; }else if(dp[i+1][j-1]){ res++; dp[i][j]=true; } } } } return res; } } leetcode 5 最长回文子串 题目描述\n力扣题目链接(opens new window)\n给你一个字符串 s，找到 s 中最长的回文子串。\n示例 1：\n输入：s = \u0026ldquo;babad\u0026rdquo; 输出：\u0026ldquo;bab\u0026rdquo; 解释：\u0026ldquo;aba\u0026rdquo; 同样是符合题意的答案。 示例 2：\n输入：s = \u0026ldquo;cbbd\u0026rdquo; 输出：\u0026ldquo;bb\u0026rdquo; 示例 3：\n输入：s = \u0026ldquo;a\u0026rdquo; 输出：\u0026ldquo;a\u0026rdquo; 示例 4：\n输入：s = \u0026ldquo;ac\u0026rdquo; 输出：\u0026ldquo;a\u0026rdquo; 思路解析\n与上一题大致思路一致但是在遍历过程中更新最大长度和起始位置 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public String longestPalindrome(String s) { int n=s.length(); if(n\u0026lt;2){ return s; } // 初始化 boolean[][]dp=new boolean[n][n]; for(boolean[]t:dp){ Arrays.fill(t,false); } // 起始点的最大长度 int maxLen=Integer.MIN_VALUE; int left=0; int right=0; for(int i=n-1;i\u0026gt;=0;i--){ for(int j=i;j\u0026lt;n;j++){ if(s.charAt(i)==s.charAt(j)){ if(j-i\u0026lt;=1){ dp[i][j]=true; }else if(dp[i+1][j-1]){ dp[i][j]=true; } } // 更新回文子串的长度和起始点 if(dp[i][j]==true\u0026amp;\u0026amp;j-i+1\u0026gt;maxLen){ maxLen=j-i+1; left=i; right=j; } } } return s.substring(left,right+1); } } leetcode 516 最长回文子序列的长度 题目描述\n力扣题目链接(opens new window)\n给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。\n示例 1: 输入: \u0026ldquo;bbbab\u0026rdquo; 输出: 4 一个可能的最长回文子序列为 \u0026ldquo;bbbb\u0026rdquo;。\n示例 2: 输入:\u0026ldquo;cbbd\u0026rdquo; 输出: 2 一个可能的最长回文子序列为 \u0026ldquo;bb\u0026rdquo;。\n提示：\n1 \u0026lt;= s.length \u0026lt;= 1000 s 只包含小写英文字母 思路解析\n确定dp数组以及下标的含义\ndp[i][j] ：字符串s在[i, j]范围内最长的回文子序列的长度为 dp[i][j] 。 确定递推公式\n如果s[i]与s[j]相同，那么 dp[i][j] = dp[i + 1][j - 1] + 2 如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子序列的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。 加入s[j]的回文子序列长度为 dp[i + 1][j]。 加入s[i]的回文子序列长度为 dp[i][j - 1]。 数组初始化\n从递推公式：dp[i][j] = dp[i + 1][j - 1] + 2 可以看出 递推公式是计算不到 i 和j相同时候的情况。\n当i与j相同，那么 dp[i][j] 一定是等于1的，即：一个字符的回文子序列长度就是1\n遍历顺序\n遍历i的时候一定要从下到上遍历，这样才能保证下一行的数据是经过计算的。 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int longestPalindromeSubseq(String s) { int n=s.length(); int[][]dp=new int[n][n]; for(int i=0;i\u0026lt;n;i++){ dp[i][i]=1; } for(int i=n-1;i\u0026gt;=0;i--){ for(int j=i+1;j\u0026lt;n;j++){ if(s.charAt(i)==s.charAt(j)){ dp[i][j]=dp[i+1][j-1]+2; }else{ dp[i][j]=Math.max(dp[i+1][j],dp[i][j-1]); } } } return dp[0][n-1]; } } leetcode 132 分割回文串II 题目描述\n力扣题目链接(opens new window)\n给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。\n返回符合要求的 最少分割次数 。\n示例 1：\n输入：s = \u0026ldquo;aab\u0026rdquo; 输出：1 解释：只需一次分割就可将 s 分割成 [\u0026ldquo;aa\u0026rdquo;,\u0026ldquo;b\u0026rdquo;] 这样两个回文子串。\n示例 2： 输入：s = \u0026ldquo;a\u0026rdquo; 输出：0\n示例 3： 输入：s = \u0026ldquo;ab\u0026rdquo; 输出：1\n提示：\n1 \u0026lt;= s.length \u0026lt;= 2000 s 仅由小写英文字母组成 思路解析\n确定dp数组以及下标的含义\ndp[i]：范围是[0, i]的回文子串，最少分割次数是dp[i]。 确定递推公式\n如果要对长度为[0, i]的子串进行分割，分割点为j。那么如果分割后，区间[j + 1, i]是回文子串，那么dp[i] 就等于 dp[j] + 1。 递推公式为：dp[i] = min(dp[i], dp[j] + 1); 判定回文子串采用上面的推导过程 dp数组如何初始化\ndp[0]一定是0，长度为1的字符串最小分割次数就是0。这个是比较直观的。 非零下标的dp[i]，如果非零下标的dp[i]初始化为0，在那么在递推公式中，所有数值将都是零。非零下标的dp[i]初始化为一个最大数i。 遍历过程\nj为分割点，从0遍历到i-1 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public int minCut(String s) { if(s==null||s.isEmpty()){ return 0; } int n=s.length(); int[]dp=new int[n]; boolean[][]check=new boolean[n][n]; for(int i=n-1;i\u0026gt;=0;i--){ for(int j=i;j\u0026lt;n;j++){ if(s.charAt(i)==s.charAt(j)){ if(j-i\u0026lt;=1){ check[i][j]=true; }else if(check[i+1][j-1]){ check[i][j]=true; } } } } for(int i=0;i\u0026lt;n;i++){ dp[i]=i; } for(int i = 1; i \u0026lt; n; i++){ if(check[0][i]){ dp[i] = 0; continue; } for(int j = 0; j \u0026lt; i; j++){ if(check[j + 1][i]){ dp[i] = Math.min(dp[i], dp[j] + 1); } } } return dp[n-1]; } } ","date":"2025-02-26T08:39:48+08:00","permalink":"https://Tyritic.github.io/p/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","title":"动态规划"},{"content":"Docker的定义 Docker 本质上就是一个将 程序和环境打包并运行 的工具软件。具体点来说就是，它通过 Dockerfile 描述环境和应用程序的依赖关系， docker build 构建镜像， docker pull/push 跟 Docker Registry 交互实现存储和分发镜像，docker run 命令基于镜像启动容器，基于容器技术运行程序和它对应的环境，从而解决环境依赖导致的各种问题。\n提示\n程序和环境\n程序是在操作系统上运行的 环境是操作系统上装了各种不同版本的依赖库和配置，这些被程序所依赖的信息 Docker的基本概念 镜像 基础镜像 Docker 容器的基础镜像（Base Image）是创建新容器时使用的起始点。基础镜像是一个层叠的文件系统，包含了一系列操作系统的基础层，这些层可以包含操作系统、运行时环境、工具和库等。\n选中一个基础操作系统和语言后，将对应的文件系统 依赖库 配置 将以上部分放一起打包成一个类似压缩包的文件，这就是所谓的 基础镜像 (Base Image)。\n容器镜像 当我们用命令行执行 docker build 的时候，Docker 软件就会按着 Dockerfile 的说明，一行行构建环境+应用程序。最终将这个环境+程序，打包成一个类似\u0026quot;压缩包\u0026quot;的东西，就是 容器镜像 (container image)。只要将容器镜像传到任意一台服务器上，对这个\u0026quot;压缩包\u0026quot;执行\u0026quot;解压缩\u0026quot;，就能同时运行环境和程序。总而言之，Docker 镜像是 Docker 容器的源代码，是镜像是一个只读的模板。，Docker 镜像用于创建容器。使用build 命令创建镜像。\nDockerfile Dockerfile相当于一个 todo list 。有了基础镜像之后还需要安装一些依赖，比如 yum install gcc，甚至还要创建一些文件夹。最后才是运行我们的目标 应用程序。创建自定义镜像的文件。通过编写 Dockerfile，你可以定义镜像中应该包含哪些内容以及如何配置。\n容器 在目的服务器上，执行 docker pull 拿到容器镜像。然后执行 docker run 命令，将这个类似\u0026quot;压缩包\u0026quot;的容器镜像给\u0026quot;解压缩\u0026quot;，获得一个 独立的环境和应用程序 并运行起来。这样一个独立的环境和应用程序，就是所谓的 容器 (container)。我们可以在一个操作系统上同时跑多个容器。且这些容器之间都是互相独立，互相隔离的。\n总而言之，Docker 容器包括应用程序及其所有依赖项，作为操作系统的独立进程运行。容器是动态的、可变的，可以启动、停止、移动和删除。在运行时，它拥有独立的文件系统、网络和进程空间，但与物理主机共享操作系统内核。\n镜像仓库 Docker 可以组建 镜像仓库 ，通过 docker push 将镜像推到仓库，有需要的时候再通过 docker pull 将镜像拉到机器上。这个负责管理镜像仓库推拉能力的服务，就叫 Docker Registry。\nDocker的构建过程 编写 Dockerfile：Dockerfile 是一个文本文件，其中包含了一系列的指令，描述了如何构建一个 Docker 镜像。 构建镜像：使用 docker build 命令，通过读取 Dockerfile 的内容，逐步执行其中的指令，最终生成一个 Docker 镜像。 保存镜像：构建完成的镜像会被保存到本地的 Docker 镜像库中，可以使用 docker images 命令查看。 发布镜像：如果需要共享镜像，可以将其推送到 Docker Hub 或其他镜像仓库，使用 docker push 命令完成发布。 使用镜像：最终用户可以使用 docker run 命令来启动基于该镜像的容器，完成应用的部署和运行。 Docker的数据管理 在容器中管理数据主要有两种方式：\n数据卷（Volumes） 挂载主机目录 (Bind mounts) 数据卷挂载 数据卷是一个虚拟目录，将宿主机的目录映射到容器内目录。具有以下特点\n可以在容器之间共享和重用。 即使容器被删除，数据卷中的数据也不会被自动删除，从而确保数据的持久性。 对数据卷的修改会立马生效。 对数据卷的更新，不会影响镜像。 挂载数据卷命令\n1 2 3 4 5 docker run -v 数据卷名:目录名 镜像名称 docker run -itd -- name 容器名字 -- mount source=数据卷名,target=容器中目录 镜像名 常见命令\n1 2 3 4 5 6 7 8 # 创建一个数据卷 docker volume create my-vol # 查看所有的数据卷 docker volume ls # 查看数据卷的具体信息 docker inspect web # 删除指定的数据卷 docker volume rm my-vol 目录挂载 目录挂载是直接将宿主机上的目录挂载到容器中，直接使用宿主机的文件系统\n挂载目录命令\n1 2 3 4 5 docker run -v 宿主机目录:容器内目录 镜像名称 docker run -itd -- name 容器名 -- mount type=bind,source=宿主机目录,target=容器中的目录 镜像名 Docker的底层原理 Docker是经典的 Client/Server 架构。Client 对应 Docker-cli， Server 对应 Docker daemon。\n架构原理 Docker-cli 会解析我们输入的 cmd 命令，然后调用 Docker daemon 守护进程提供的 RESTful API，守护进程收到命令后，会根据指令创建和管理各个容器。\nDocker Daemon 内部分为 Docker Server、Engine 两层。\nDocker Server 本质上就是个 HTTP 服务，负责对外提供操作容器和镜像的 api 接口，接收到 API 请求后，会分发任务给 Engine 层 Engine 层负责创建 Job，由 Job 实际执行各种工作。这是 Docker 的核心，它是一个轻量级的运行时和工具集，用于管理容器。Docker引擎包括服务器端的守护进程（daemon）、API，以及CLI工具。 容器化技术 Namespace 和 Cgroups：这两个是 Docker 能够实现隔离的核心 Linux 技术。\nNamespace 提供了进程、网络、挂载等资源的隔离， Cgroups 则负责限制和优先级分配，限制它能使用的计算资源，确保容器不会耗尽主机资源。 每个容器运行在它自己的命名空间中，但是，确实与其它运行中的容器共用相同的系统内核。隔离的产生是由于系统内核清楚地知道命名空间及其中的进程，且这些进程调用系统 API 时，内核保证进程只能访问属于其命名空间中的资源。\n提示\nDocker和虚拟机的关系\n传统虚拟机自带一个完整操作系统，虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程 容器本身不带完整操作系统，容器的基础镜像实际上只包含了操作系统的核心依赖库和配置文件等必要组件。容器本质上只是个自带独立运行环境的 特殊进程 ，底层用的其实是 宿主机的操作系统内核 。 VPS和ECS 云厂商一般会 将一台物理服务器分割成多个虚拟机 。每个虚拟机都拥有独立的操作系统、资源（比如 CPU、内存、存储空间）和公网 IP 地址。然后对外出售，这样的虚拟机就是所谓的 VPS（Virtual Private Server，虚拟专用服务器）。\n但传统 VPS 有个缺点，不支持用户自主升降级，它的资源是预先分配的，不易动态调整。\n而支持VPS自主升降级的功能就成了 ECS（Elastic Compute Service，弹性计算服务）。用户可以根据需要随时调整 CPU、内存、磁盘和带宽，主打一个\u0026quot;弹性\u0026quot;。\n而通常 物理服务器上跑 ecs，ecs 跑 Docker 容器。多个 Docker 容器共享一个 ecs 实例 操作系统内核 。\n容器服务编排——Docker Compose 使用场景：一次部署在同一个物理服务器 多个 容器组成的一套服务，且对这些容器的顺序有一定要求呢\nDocker Compose 是用于定义和运行多容器 Docker 应用程序的工具。Compose 使用 YAML 文件定义服务、网络和卷，通过一条简单的命令 docker-compose up 就可以启动并运行整个配置的应用环境。\n示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 version: \u0026#34;3.8\u0026#34; services: A: image: \u0026#34;some-image-for-a\u0026#34; deploy: resources: limits: cpus: \u0026#34;0.50\u0026#34; # 限制 CPU 使用率为 50% memory: 256M # 限制内存使用量为 256MB B: image: \u0026#34;some-image-for-b\u0026#34; depends_on: - A C: image: \u0026#34;some-image-for-c\u0026#34; depends_on: - B 常见命令 启动命令 1 2 3 4 5 6 7 8 9 10 11 # 在当前目录下寻找 docker-compose.yml 文件，并根据其中定义的服务启动应用程序 docker-compose up # 后台启动 docker-compose up -d # 强制重新创建所有容器，即使它们已经存在 docker-compose up --force-recreate # 重新构建镜像 docker-compose up --build # 指定要启动的服务名称，而不是启动所有服务 # 可以同时指定多个服务，用空格分隔。 docker-compose up service_name 暂停和停止命令 1 2 3 4 5 6 7 8 # 在当前目录下寻找 docker-compose.yml 文件 # 根据其中定义移除启动的所有容器，网络和卷。 docker-compose down # 停止容器但不移除 docker-compose down --stop # 指定要停止和移除的特定服务，而不是停止和移除所有服务 # 可以同时指定多个服务，用空格分隔。 docker-compose down service_name 查看命令 1 2 3 4 5 6 # 查看所有容器的状态信息 docker-compose ps # 只显示服务名称 docker-compose ps --services # 查看指定服务的容器 docker-compose ps service_name Docker 常见命令 基本命令 1 2 3 4 5 docker version # 查看docker版本 docker images # 查看所有已下载镜像，等价于：docker image ls 命令 docker container ls # 查看所有容器 docker ps #查看正在运行的容器 docker image prune # 清理临时的、没有被使用的镜像文件。-a, --all: 删除所有没有用的镜像，而不仅仅是临时文件； 拉取镜像 1 2 3 docker search mysql # 查看mysql相关镜像 docker pull mysql:5.7 # 拉取mysql镜像 docker image ls # 查看所有已下载镜像 构建镜像 1 2 # imageName 是镜像名称，1.0.0 是镜像的版本号或标签 docker build -t imageName:1.0.0 . 删除镜像 先将运行该镜像的容器暂停：docker stop CONTAINER ID 然后删除镜像：docker rmi IMAGE ID 或者 docker rmi REPOSITORY 推送镜像 1 docker push url/image_name:version 启动容器 1 2 3 4 5 docker run [Option] image_name -- name 容器名 -d 后台运行 -it 直接进入容器 -p 主机端口:容器端口 ","date":"2025-02-25T20:36:53+08:00","permalink":"https://Tyritic.github.io/p/docker%E4%B8%8E%E5%AE%B9%E5%99%A8%E5%8C%96/","title":"Docker与容器化"},{"content":"网际协议-IP地址 作用 在TCP/IP参考模型的作用 IP协议 在 TCP/IP 参考模型中处于第三层，也就是网络层。\n网络层的主要作用是：实现主机与主机之间的通信，也叫点对点（end to end）通信。\n寻址 ：每个连接到网络的设备都有一个唯一的 IP 地址。IP 协议使用这些地址来标识数据包的源地址和目的地址，确保数据包能够准确地传输到目标设备。 路由 ：IP 协议负责决定数据包在网络传输中的路径。比如说路由器使用路由表和 IP 地址信息来确定数据包的最佳传输路径。 分片和重组 ：当数据包过大无法在某个网络上传输时，IP 协议会将数据包分成更小的片段进行传输。接收端会根据头部信息将这些片段重新组装成完整的数据包。 与数据链路层的关系 MAC 的作用则是实现直连的两个设备之间通信 IP 则负责在没有直连的两个网络之间进行通信传输。 MAC地址\nMAC称为物理地址，也叫硬件地址，用来定义网络设备的位置，MAC地址是网卡出厂时设定的，是固定的（但可以通过在设备管理器中或注册表等方式修改，同一网段内的MAC地址必须唯一）。\nMAC地址采用十六进制数表示，长度是6个字节（48位），分为前24位和后24位。\nIP数据报 IPV4报文格式 首部 版本号：指定IP协议版本 首部长度：确定IP数据报中的载荷的实际开始位置 服务类型：指定不同类型的IP数据报 数据报长度 标识：用于分片后重新组装数据报 标志：决定是否进行分片 片偏移：较长的IP报文在分片后，某片在原分组中的相对位置 生存时间（TTL）：数据报在网络中的寿命。 协议：占8位，协议字段指出此数据报携带的数据是使用何种协议 首部检验和：帮助路由器检测收到的IP数据报中的比特错误 源IP地址 目的IP地址 载荷 提示\nIPV6的改进\n取消了首部校验和字段。 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。 取消了分片/重新组装相关字段。 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。 取消选项字段。 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 40 字节。 数据报分片 通常将链路层帧可以承载的最大数据量称为MTU。当IP数据报长度大于MTU会进行数据报分片，并使用单独的链路层帧进行封装。然后端系统接收后会进行重新组装\nIP地址 在 TCP/IP 网络通信时，为了保证能正常通信，每个设备都需要配置正确的 IP 地址，否则无法实现正常的通信。\nIP 地址（IPv4 地址）由 32 位正整数来表示，IP 地址在计算机是以二进制的方式处理的。\nIP地址的分类 $$ 最大主机数=2^{主机号}-2 $$ 其中要去除两个特殊的IP地址，主机号全为 1 和 全为 0 地址\n主机号全为 1 指定某个网络下的所有主机，用于广播 广播地址用于在 同一个链路中相互连接的主机之间发送数据包 。 主机号全为 0 指定某个网络 无分类IP地址CIDR IP地址由 网络号和主机号 构成\n表示形式 a.b.c.d/x，其中 /x 表示前 x 位属于网络号， x 的范围是 0 ~ 32，\n子网掩码用于指示IP地址的网络部分。将子网掩码和 IP 地址按位计算 AND，就可得到网络号。 两台主机要通信，首先要判断是否处于同一网段，即网络地址是否相同。\n如果相同，那么可以把数据包直接发送到目标主机，否则就需要路由网关将数据包转发送到目的地。\n子网划分 子网划分实际上是将主机号分为两个部分：子网号和子网主机号。\nIP协议的相关应用 ARP协议 作用 将 IP 地址转换为 MAC 地址，它工作在 网络层 和 数据链路层 之间，主要用于在局域网中确定一个特定 IP 地址对应的物理地址（MAC 地址）。因为最终需要找到 MAC 地址才能跟具体的设备通信。\n工作流程 ARP 请求：主机 A 需要发送数据包给主机 B，但只有主机 B 的 IP 地址，没有它的 MAC 地址。主机 A 发送一个 ARP 请求广播到网络。 ARP 响应：当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，回复一个 ARP 响应，告知主机 A 自己的 MAC 地址。 更新 ARP 表：主机 A 将主机 B 的 IP 和 MAC 地址的映射关系保存到 ARP 表中，以便以后使用。 DHCP协议 DHCP全称为动态主机配置协议，通过配置DHCP协议保证给定主机每次连接得到相同的IP地址或者分配到临时的IP地址\n工作流程 DHCP服务器发现 客户端首先发起 DHCP 发现报文（DHCP DISCOVER） 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP 广播 通信，其使用的广播目的地址是 255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。 DHCP服务器提供 DHCP 服务器收到 DHCP 发现报文时，用 DHCP 提供报文（DHCP OFFER） 向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 IP 地址租用期 。 DHCP请求 客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 DHCP 请求报文（DHCP REQUEST 进行响应，回显配置的参数。 DHCP ACK 服务端用 DHCP ACK 报文对 DHCP 请求报文进行响应，应答所要求的参数。 再次租用 如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP 请求报文： 服务器如果同意继续租用，则用 DHCP ACK 报文进行应答，客户端就会延长租期。 服务器如果不同意继续租用，则用 DHCP NACK 报文，客户端就要停止使用租约的 IP 地址。 NAT协议 网络地址转换协议，将私有IP地址转换为公有IP地址\nNAT将IP地址和端口号一起转换，保证所有离开专有网络的设备具有相同的源IP地址，所有进入专有网络的报文具有相同的目的IP地址\n两个私有 IP 地址都被路由器转换 IP 地址为公有地址 120.229.175.121，但是以不同的端口号作为区分。\n","date":"2025-02-25T19:32:28+08:00","permalink":"https://Tyritic.github.io/p/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/","title":"网络层协议"},{"content":"Redis性能强大的原因 基于内存的数据存储 ：Redis 将数据存储在内存中，提供快速的读写速度，使得数据的读写操作避开了磁盘 I/O。而内存的访问速度远超硬盘。相比于传统的磁盘数据库，内存访问速度快得多。 单线程模型 ：Redis 使用单线程事件驱动模型，避免了多线程上下文切换和竞争条件，提高了并发处理效率。 高效的数据结构 ：Redis 提供多种高效的数据结构（如字符串、哈希、列表、集合等），这些结构经过优化，能够快速完成各种操作 IO多路复用 ：基于 Linux 的 select/epoll 机制。该机制允许内核中同时存在多个监听套接字和已连接套接字，内核会一直监听这些套接字上的连接请求或者数据请求，一旦有请求到达，就会交给 Redis 处理，就实现了所谓的 Redis 单个线程处理多个 IO 读写的请求。 单线程模型 使用原因 Redis 的大部分操作都在内存中完成，并且采用了高效的数据结构，因此 Redis 瓶颈是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了。 Redis 采用单线程模型可以避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。 Redis 采用了 I/O 多路复用机制处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。 IO多路复用机制 IO 多路复用机制是指一个线程处理多个 IO 流，就是 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。\n这里“多路”指的是多个网络连接客户端，“复用”指的是复用同一个线程(单进程)。\n一个 socket 客户端与服务端连接时，会生成对应一个套接字描述符(套接字描述符是文件描述符的一种)，每一个 socket 网络连接其实都对应一个文件描述符。 多个客户端与服务端连接时，Redis 使用 I/O 多路复用程序 将客户端 socket 对应的 FD 注册到监听列表(一个队列)中。当客户端执行 read、write 等操作命令时，I/O 多路复用程序会将命令封装成一个事件，并绑定到对应的 FD 上。 文件事件处理器使用 I/O 多路复用模块同时监控多个文件描述符（fd）的读写情况，当 accept、read、write 和 close 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器进行处理相关命令操作。 提示\nselect，epoll和epoll的实现原理\nselect 使用位图管理 fd，每次调用都需要将 fd 集合从用户态复制到内核态。最大支持 1024 个文件描述符。 poll 使用动态数组管理 fd，突破了 select 的数量限制。 epoll 使用红黑树和链表管理 fd，每次调用只需要将 fd 集合从用户态复制到内核态一次，不需要重复复制。 多线程的引入 随着数据规模的增长、请求量的增多，Redis 的执行瓶颈主要在于⽹络 I/O。引入多线程处理可以提高网络 I/O处理速度。在 Redis 6.0 中，多线程主要用来处理网络 IO 操作，命令解析和执行仍然是单线程完成，这样既可以发挥多核 CPU 的优势，又能避免锁和上下文切换带来的性能损耗。\n","date":"2025-02-24T17:30:12+08:00","permalink":"https://Tyritic.github.io/p/redis%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90/","title":"Redis的读写效率分析"},{"content":"NoSQL型数据库 NoSQL（Not Only SQL）是指一类不使用传统关系型数据库结构的数据库。NoSQL数据库通常用于大规模数据存储、处理和快速访问的场景。与关系型数据库不同，NoSQL数据库不要求数据必须存储为表格形式，也不需要固定的模式（schema）。它们通常具有更高的扩展性、灵活性和适应性。\n四大分类 键值存储（Key-Value Stores）： 数据以键值对的形式存储。 适合快速访问单个值。 例如：Redis、Amazon DynamoDB。 列族存储（Column Family Stores）： 数据按列而非行来存储。 高效地存储和查询大规模的、非结构化的数据。 例如：Apache Cassandra、HBase。 文档存储（Document Stores）： 存储类似JSON、BSON或XML的文档数据，文档中可以包含嵌套的数据。 适合存储和查询灵活的、层次化的数据。 例如：MongoDB、CouchDB。 图数据库（Graph Databases）： 以图形结构（节点、边和属性）存储数据，用于表示实体之间的关系。 适合复杂的关系型数据查询。 例如：Neo4j、ArangoDB。 与SQL数据库的对比 SQL NoSQL 数据结构 结构化 非结构化 数据关联 不同数据之间具有关联性 无关联性 查询方式 SQL标准 无标准 事务特性 ACID BASE 存储方式 磁盘 内盘 拓展性 垂直 水平 使用场景 数据结构固定\n相关业务对数据安全性，一致性要求较高 数据结构不固定对一致性、安全性要求不高对性能要求 Redis缓存中间件 Redis（Remote Dictionary Server）是一个开源的内存数据库，遵守 BSD 协议，它提供了一个高性能的键值（key-value）存储系统，常用于缓存、消息队列、会话存储等应用场景。\n基本特点 性能极高： Redis 以其极高的性能而著称，能够支持每秒数十万次的读写操作24。这使得Redis成为处理高并发请求的理想选择，尤其是在需要快速响应的场景中，如缓存、会话管理、排行榜等。 丰富的数据类型： Redis 不仅支持基本的键值存储，还提供了丰富的数据类型，包括字符串、列表、集合、哈希表、有序集合等。这些数据类型为开发者提供了灵活的数据操作能力，使得Redis可以适应各种不同的应用场景。 原子性操作： Redis 的所有操作都是原子性的，这意味着操作要么完全执行，要么完全不执行。这种特性对于确保数据的一致性和完整性至关重要，尤其是在高并发环境下处理事务时。 持久化： Redis 支持数据的持久化，可以将内存中的数据保存到磁盘中，以便在系统重启后恢复数据。这为 Redis 提供了数据安全性，确保数据不会因为系统故障而丢失。 支持发布/订阅模式： Redis 内置了发布/订阅模式（Pub/Sub），允许客户端之间通过消息传递进行通信。这使得 Redis 可以作为消息队列和实时数据传输的平台。 单线程模型： 尽管 Redis 是单线程的，但它通过高效的事件驱动模型来处理并发请求，确保了高性能和低延迟。单线程模型也简化了并发控制的复杂性。 主从复制： Redis 支持主从复制，可以通过从节点来备份数据或分担读请求，提高数据的可用性和系统的伸缩性。 使用场景 缓存 ：Redis 最常用的场景是作为缓存层，以减少数据库的负载，提高数据读取速度。\n因为 Redis 是基于内存的，其读写速度比 MySQL 基于磁盘的方式要快很多，所以其作为热点数据的缓存是非常合适的。使用 Redis 缓存可以极大地提高应用的响应速度和吞吐量。 实时系统 ：\nRedis 支持快速的数据写入和读取，非常适合用于实时分析，如网站点击统计、实时排行榜等。 消息队列 ：\n利用 Redis 的 List 和 Pub/Sub 功能，可以实现轻量级的消息队列，适用于任务处理和异步消息传递。 分布式锁：\nRedis 可以用作分布式锁的实现，确保在分布式系统中资源的安全访问，避免竞态条件。 计数器 ：\nRedis 的原子性操作非常适合用作计数器。 Redis的服务端命令 进入redis的安装根目录的命令行可以启动redis服务\n启动临时redis服务（不会在window Service列表出现Redis服务名称和状态，此窗口关闭，服务会自动关闭。）：redis-server.exe redis.windows.conf 注册redis服务：redis-server.exe --service-install redis.windows.conf --service-name redisserver1 --loglevel verbose 启动服务：redis-server.exe --service-start --service-name redisserver1 停止服务：redis-server.exe --service-stop --service-name redisserver1 卸载服务：redis-server.exe --service-uninstall--service-name redisserver1 可以在主机中配置多个端口的redis服务，参见博客\nRedis的客户端命令 redis 在安装后就自带命令行客户端 redis-cli ，客户端的通用命令格式为\n1 redis-cli [option] [commands] 常见的option如下\n-h ip_address ：指定要连接的redis节点的IP地址，默认是127.0.0.1（回环地址，表示访问本机） -p port：指定要连接的redis节点的端口，默认是6379 -a password ：指定redis的访问密码 commands是redis的操作命令\nRedis的基本数据结构 Redis 提供了丰富的数据类型。\n基本的有五种数据类型\nString（字符串） ：Redis中最基本的数据类型，可以存储任何类型的数据，包括文本、数字和二进制数据。它的最大长度为512MB。 缓存：存储临时数据，如用户会话、页面缓存。 计数器：用于统计访问量、点赞数等，通过原子操作增加或减少。 Hash（哈希） ：哈希是一个键值对集合，适合存储对象的属性。Redis内部使用哈希表实现，适合小规模数据。 商品详情：存储商品的各个属性，方便快速检索。 List（列表） ：列表是有序的字符串集合，支持从两端推入和弹出元素，底层实现为双向链表。 消息队列：用于简单任务调度、消息传递等场景，通过LPUSH和RPOP操作实现生产者消费者模式。 历史记录：存储用户操作的历史记录，便于快速访问。 Set（集合） ：集合是无序且不重复的字符串集合，使用哈希表实现，支持快速查找和去重操作。 标签系统：存储用户的兴趣标签，避免重复。 唯一用户集合：记录访问过某个页面的唯一用户，方便进行分析。 Zset（有序集合） ：有序集合类似于集合，但每个元素都有一个分数（score），用于排序。底层使用跳表实现，支持快速的范围查询。 排行榜：存储用户分数，实现实时排行榜。 任务调度：根据任务的优先级进行排序，方便调度执行。 后面又支持了四种数据类型：\nBitMap ：BitMap 是一种以位为单位存储数据的高效方式，适合用来表示布尔值（如存在性、状态等）。每个 bit 可以表示一个状态（0 或 1），使用空间少且操作快速。 统计每天用户的在线状态，可以用 Bitmap 记录每个用户是否在线： HyperLogLog ：HyperLogLog 是一种概率性数据结构，主要用于估算基数（不同元素的数量），内存占用固定，适合处理大规模数据的去重和计数。 GEO ：GEO 是 Redis 提供的一种用于存储地理位置信息的数据结构，可以存储经纬度信息并支持空间查询，例如计算距离和获取范围内的坐标。 Stream ：Stream 是 Redis 提供的一种日志数据结构，适合于存储时间序列数据或消息流。支持高效的消息生产和消费模式，具有持久性和序列化特性。 Redis的通用命令 Keys命令 Redis 键命令用于管理 redis 的键。\n基本格式 1 redis 127.0.0.1:6379\u0026gt; COMMAND KEY_NAME 常见操作 删除键 删除已存在的键：DEL KEY_NAME 返回值：被删除 key 的数量。 不存在的 key 会被忽略 查找键 检查键是否存在：EXISTS KEY_NAME 返回值：若 key 存在返回 1 ，否则返回 0 。 查找符合格式的键：KEYS PATTERN 返回值：符合给定模式的 key 列表 (Array)。 查看键的过期时间：TTL KEY_NAME 返回值：当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以秒为单位，返回 key 的剩余生存时间。 设置键 设置键的过期时间：Expire KEY_NAME TIME_IN_SECONDS 返回值：设置成功返回 1 。 当 key 不存在返回 0 。 移除键的过期时间：PERSIST KEY_NAME 返回值：当过期时间移除成功时，返回 1 。 如果 key 不存在或 key 没有设置过期时间，返回 0 。 将当前数据库的 key 移动到给定的数据库 db 当中：MOVE KEY_NAME DESTINATION_DATABASE 返回值：移动成功返回 1 ，失败则返回 0 。 将键重新命名：RENAME OLD_KEY_NAME NEW_KEY_NAME 返回值 改名成功时提示 OK 失败时候返回一个错误。当 OLD_KEY_NAME 和 NEW_KEY_NAME 相同，或者 OLD_KEY_NAME 不存在时，返回一个错误。 提示\nKey的层级结构\n在 Redis 中，Key 的层级格式 其实是一种命名约定，并没有真正的“层级”结构（不像关系型数据库中的表或目录结构）。\n通常使用 : 分隔层级\n1 namespace:object_type:id:field 数据库命令 Redis默认有16个数据库，默认使用编号为0的数据库\n切换数据库：select db_num 查看当前数据库key的数量：DBSIZE 清除当前数据库：flushdb 清除所有数据库：flushall ","date":"2025-02-24T15:10:42+08:00","permalink":"https://Tyritic.github.io/p/redis%E5%9F%BA%E7%A1%80/","title":"Redis基础"},{"content":"SpringCache基础 Spring Cache是Spring框架提供的一种缓存解决方案，基于AOP原理，实现了基于注解的缓存功能，只需要简单地加一个注解就能实现缓存功能，对业务代码的侵入性很小。使用Spring Cache的方法很简单，只需要在方法上添加注解即可实现将方法返回数据存入缓存，以及清理缓存等注解的使用。\nSpringCache的大致原理 每次调用目标方法前，SpringCache都会先检查该方法是否正对给定参数执行，如果已经执行过，就直接返回缓存的结果。（通俗的讲，就是查看缓存里面是否有对应的数据，如果有就返回缓存的数据），而无需执行实际方法、如果该方法上位执行。则执行该方法（缓存中没有对应的数据就执行方法获取对应数据，并进行缓存），并缓存结果并返回给用户。这样就不用多次去执行数据库操作，减少cpu和io的消耗。\n与SpringBoot集成 引入相关的依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-cache\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在启动类上使用注解 @EnableCaching 表示开启缓存功能\n常用注解 @Cacheable： 作用：修饰方法，在方法执行前查看是否有缓存对应的数据，如果有直接返回数据，如果没有调用方法获取数据返回，并缓存起来。 字段 value：指定缓存的名称（或名称数组）。缓存名称与CacheManager中配置的缓存对应。 key：用于生成缓存键的表达式（可选）。如果不指定，则默认使用方法的参数值作为键。 condition：条件表达式（可选），用于决定是否执行缓存操作。 unless：否定条件表达式（可选），用于在方法执行后决定是否缓存返回值。 @CacheEvict： 作用：将一条或多条数据从缓存中删除。 字段 value：指定要删除的缓存的名称（或名称数组）。 key：用于指定要删除的缓存键（可选）。如果不指定，则默认使用方法的参数值作为键。 allEntries：布尔值，指定是否删除缓存中的所有条目（而不是仅删除与指定键匹配的条目）。 beforeInvocation：布尔值，指定是否在方法执行之前删除缓存（默认为false，即在方法执行之后删除）。 @CachePut 作用：更新缓存中的数据，无论方法是否成功执行，都会将结果放入缓存。 字段 value：指定缓存的名称（或名称数组）。缓存名称与CacheManager中配置的缓存对应。 key：用于生成缓存键的表达式（可选）。如果不指定，则默认使用方法的参数值作为键。 condition：条件表达式（可选），用于决定是否执行缓存操作。 unless：否定条件表达式（可选），用于在方法执行后决定是否缓存返回值。 ","date":"2025-02-23T17:07:39+08:00","permalink":"https://Tyritic.github.io/p/springcache/","title":"SpringCache"},{"content":"贪心的使用场景 贪心的本质是选择每一阶段的局部最优，从而达到全局最优。\n贪心算法一般分为如下四步：\n将问题分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解堆叠成全局最优解 leetcode 455 分发饼干 题目描述 力扣题目链接(opens new window)\n假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\n对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] \u0026gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n示例 1:\n输入: g = [1,2,3], s = [1,1] 输出: 1 解释:你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。所以你应该输出 1。 示例 2:\n输入: g = [1,2], s = [1,2,3] 输出: 2 解释:你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出 2. 提示：\n1 \u0026lt;= g.length \u0026lt;= 3 * 10^4 0 \u0026lt;= s.length \u0026lt;= 3 * 10^4 1 \u0026lt;= g[i], s[j] \u0026lt;= 2^31 - 1 思路解析 局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩。\n因此可以将胃口数组和饼干数组进行预先排序。然后从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int ans=0; int index=s.length-1; for(int i=g.length-1;i\u0026gt;=0;i--) { if(s[index]\u0026gt;g[i]) { ans++; index--; } } return ans; } } leetcode 376 摆动序列 题目描述 力扣题目链接(opens new window)\n如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。\n例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。\n给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。\n示例 1:\n输入: [1,7,4,9,2,5] 输出: 6 解释: 整个序列均为摆动序列。 示例 2:\n输入: [1,17,5,10,13,15,10,5,16,8] 输出: 7 解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。 示例 3:\n输入: [1,2,3,4,5,6,7,8,9] 输出: 2 思路解析 本题要求通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。\n局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。\n整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。\n而摆动序列的长度就是峰值的个数\n可以通过记录 prediff（nums[i] - nums[i-1]） 和 curdiff（nums[i+1] - nums[i]） ，如果prediff \u0026lt; 0 \u0026amp;\u0026amp; curdiff \u0026gt; 0 或者 prediff \u0026gt; 0 \u0026amp;\u0026amp; curdiff \u0026lt; 0 此时就有波动就需要统计。\n其中 prediff 用于记录上一个坡度的方向，curdiff 用于记录当前坡度的方向\n但是可能会出现平坡的情况\n上下坡中出现平坡\n在计数的时候统一删除左边的重复项（左边的3个2） prediff = 0 \u0026amp;\u0026amp; curdiff \u0026lt; 0 需要被记录为一个峰值 同理，prediff = 0 \u0026amp;\u0026amp; curdiff \u0026gt; 0 需要被记录为一个峰值 数组两端\n可以假设，数组最前面还有一个数字，那这个数字为本身。这样默认数组最右侧具有一个峰值 单调坡中出现平坡\n需要在 这个坡度 摆动变化的时候，更新 prediff 就行 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int wiggleMaxLength(int[] nums) { if(nums.length\u0026lt;=1)return nums.length; int prediff=0; int curdiff=0; int res=1; for(int i=0;i\u0026lt;nums.length-1;i++) { curdiff=nums[i+1]-nums[i]; if((prediff\u0026gt;=0\u0026amp;\u0026amp;curdiff\u0026lt;0)||(prediff\u0026lt;=0\u0026amp;\u0026amp;curdiff\u0026gt;0)) { res++; prediff=curdiff; } } return res; } } leetcode 53 最大子序和 题目描述 力扣题目链接(opens new window)\n给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n示例:\n输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 思路解析 如果 -2 1 在一起，计算起点的时候，一定是从 1 开始计算，因为负数只会拉低总和\n局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。\n全局最优：选取最大“连续和”\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int maxSubArray(int[] nums) { int res=Integer.MIN_VALUE; int count=0; for(int i=0;i\u0026lt;nums.length;i++) { count+=nums[i]; if(count\u0026gt;res) res=count; if(count\u0026lt;=0) { count=0; } } return res; } } leetcode 122 买卖股票的最佳时机II 题目描述 力扣题目链接(opens new window)\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。\n设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n示例 1:\n输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2:\n输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3:\n输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 提示：\n1 \u0026lt;= prices.length \u0026lt;= 3 * 10 ^ 4 0 \u0026lt;= prices[i] \u0026lt;= 10 ^ 4 思路解析 利润是可以分解的\n假如第 0 天买入，第 3 天卖出，那么利润为：prices[3] - prices[0]。\n相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。\n此时就是把利润分解为每天为单位的维度，而不是从 0 天到第 3 天整体去考虑\n收集正利润的区间，就是股票买卖的区间，而只需要关注最终利润，不需要记录区间。\n局部最优：收集每天的正利润，全局最优：求得最大利润。\n参考代码 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int maxProfit(int[] prices) { int res=0; for(int i=1;i\u0026lt;prices.length;i++) { if(prices[i]-prices[i-1]\u0026gt;0) res+=prices[i]-prices[i-1]; } return res; } } leetcode 55 跳跃游戏 题目描述 力扣题目链接(opens new window)\n给定一个非负整数数组，你最初位于数组的第一个位置。\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n判断你是否能够到达最后一个位置。\n示例 1:\n输入: [2,3,1,1,4] 输出: true 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。 示例 2:\n输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 思路解析 问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！\n每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。\n贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。\n每次在覆盖范围内移动指针，更新最大覆盖范围\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public boolean canJump(int[] nums) { int cover=0; for(int i=0;i\u0026lt;=cover;i++) { cover=Math.max(nums[i]+i,cover); if(cover\u0026gt;=nums.length-1) return true; } return false; } } leetcode 45 跳跃游戏II 题目描述 力扣题目链接(opens new window)\n给定一个非负整数数组，你最初位于数组的第一个位置。\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n你的目标是使用最少的跳跃次数到达数组的最后一个位置。\n示例:\n输入: [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 说明: 假设你总是可以到达数组的最后一个位置。\n思路解析 要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最少步数！\n统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖。\n如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点。\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int jump(int[] nums) { int currDistance=0; int maxDistance=0; int count=0; for(int i=0;i\u0026lt;nums.length-1;i++) { maxDistance=Math.max(maxDistance,i+nums[i]); if(i==currDistance) { currDistance=maxDistance; count++; } } return count; } } leetcode 1005 K次取反后最大化的数组和 题目描述 力扣题目链接(opens new window)\n给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）\n以这种方式修改数组后，返回数组可能的最大和。\n示例 1：\n输入：A = [4,2,3], K = 1 输出：5 解释：选择索引 (1) ，然后 A 变为 [4,-2,3]。 示例 2：\n输入：A = [3,-1,0,2], K = 3 输出：6 解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。 示例 3：\n输入：A = [2,-3,-1,5,-4], K = 2 输出：13 解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。 提示：\n1 \u0026lt;= A.length \u0026lt;= 10000 1 \u0026lt;= K \u0026lt;= 10000 -100 \u0026lt;= A[i] \u0026lt;= 100 思路解析 将数组进行排序，其中负数部分直接使用转换变为正数。如果K次还没有用完则将数组再次排序，将剩下的次数全部用在绝对值最小的数上。\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int largestSumAfterKNegations(int[] nums, int k) { Arrays.sort(nums); int res=0; for(int i=0;i\u0026lt;nums.length;i++) { if(nums[i]\u0026lt;0\u0026amp;\u0026amp;k\u0026gt;0) { nums[i]=-nums[i]; k--; } } if(k%2==1) { Arrays.sort(nums); nums[0]=-nums[0]; } for(int i=0;i\u0026lt;nums.length;i++) { res+=nums[i]; } return res; } } leetcode 134 加油站 题目描述 力扣题目链接(opens new window)\n在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。\n你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。\n如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。\n说明:\n如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。 示例 1: 输入:\ngas = [1,2,3,4,5] cost = [3,4,5,1,2] 输出: 3 解释:\n从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。 因此，3 可为起始索引。 示例 2: 输入:\ngas = [2,3,4] cost = [3,4,3] 输出: -1 解释: 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油。开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油。开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油。你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。 思路解析 思路一 如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。 i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。 若totalSum\u0026lt;0则说明断油了，返回-1 参考代码(思路一) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { int n=cost.length; // 从start出发的净油量 int curSum=0; // 从0开始的净油量 int totalSum=0; int start=0; for(int i=0;i\u0026lt;n;i++){ curSum+=gas[i]-cost[i]; totalSum+=gas[i]-cost[i]; if(curSum\u0026lt;0){ start=i+1; curSum=0; } } if(totalSum\u0026lt;0){ return -1; } return start; } } 思路二 从加油站x出发，每经过一个加油站就加一次油（包括起始加油站），最后一个可以到达的加油站是y（不妨设x\u0026lt;y）若x到y的净油量等于零（最后一个到达的加油站为y）则从x到y之间的任意一个加油站出发都无法到达y的下一个加油站\n首先检查第0个加油站，并试图判断能否环绕一周；如果不能，就从第一个无法到达的加油站开始继续检查。\n参考代码（思路二） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { int n=cost.length; int x=0; while(x\u0026lt;n){ int sumGas=0; int sumCost=0; int cnt=0; //覆盖的加油站数 while(cnt\u0026lt;n){ int y=(x+cnt)%n; // 计算加油站编号y // 计算x~y的油量和花费 sumGas+=gas[y]; sumCost+=cost[y]; // 无法到达则直接停止循环 if(sumGas\u0026lt;sumCost){ break; } cnt++; } // 成功环绕一圈则直接返回x if(cnt==n){ return x; }else{ x=x+cnt+1; // 更新x为x+y的下一个位置 } } return -1; } } leetcode 860 柠檬水找零 题目描述 力扣题目链接(opens new window)\n在柠檬水摊上，每一杯柠檬水的售价为 5 美元。\n顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。\n每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。\n注意，一开始你手头没有任何零钱。\n如果你能给每位顾客正确找零，返回 true ，否则返回 false 。\n示例 1：\n输入：[5,5,5,10,20] 输出：true 解释： 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。 由于所有客户都得到了正确的找零，所以我们输出 true。 示例 2：\n输入：[5,5,10] 输出：true 示例 3：\n输入：[10,10] 输出：false 示例 4：\n输入：[5,5,10,10,20] 输出：false 解释： 前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。 对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。 对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。 由于不是每位顾客都得到了正确的找零，所以答案是 false。 提示：\n0 \u0026lt;= bills.length \u0026lt;= 10000 bills[i] 不是 5 就是 10 或是 20 思路解析 情况一：账单是5，直接收下。 情况二：账单是10，消耗一个5，增加一个10 情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public boolean lemonadeChange(int[] bills) { int fiveCount=0; int tenCount=0; int twentyCount=0; for(int i=0;i\u0026lt;bills.length;i++) { if(bills[i]==5) fiveCount++; else if(bills[i]==10) { tenCount++; fiveCount--; if(fiveCount\u0026lt;0) { return false; } } else if(bills[i]==20) { twentyCount++; // 收下一张二十 // 优先找一张十块和一张五块 if(fiveCount\u0026gt;=1\u0026amp;\u0026amp;tenCount\u0026gt;=1) { fiveCount--; tenCount--; } // 其次找三张五块 else if(fiveCount\u0026gt;=3) { fiveCount-=3; } else{ return false; } } } return true; } } 多维度贪心 leetcode 135 分发糖果 题目描述 力扣题目链接(opens new window)\n老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。\n你需要按照以下要求，帮助老师给这些孩子分发糖果：\n每个孩子至少分配到 1 个糖果。 相邻的孩子中，评分高的孩子必须获得更多的糖果。 那么这样下来，老师至少需要准备多少颗糖果呢？\n示例 1:\n输入: [1,0,2] 输出: 5 解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。 示例 2:\n输入: [1,2,2] 输出: 4 解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。 思路解析 本题一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，如果两边一起考虑一定会顾此失彼。\n确定左边评分小于右边的情况（也就是从前向后遍历） 此时局部最优：只要右边评分比左边大，右边的孩子就多一个糖果 全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果 确定左边评分大于右边（从后向前遍历） candyVec[i]（第i个小孩的糖果数量）就有两个选择了 一个是candyVec[i + 1] + 1（从右边这个加1得到的糖果数量） 一个是candyVec[i]（之前比较右孩子大于左孩子得到的糖果数量）。 局部最优：取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，保证第i个小孩的糖果数量既大于左边的也大于右边的。 全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int candy(int[] ratings) { int n=ratings.length; int[]candy=new int[n]; Arrays.fill(candy,1); // 从左往右遍历，处理左孩子小于右孩子 for(int i=1;i\u0026lt;n;i++){ if(ratings[i-1]\u0026lt;ratings[i]){ candy[i]=candy[i-1]+1; } } // 从右往左遍历，处理左孩子大于右孩子 for(int i=n-2;i\u0026gt;=0;i--){ if(ratings[i]\u0026gt;ratings[i+1]){ candy[i]=Math.max(candy[i],candy[i+1]+1); } } int res=0; for(Integer i:candy){ res+=i; } return res; } } leetcode 406 根据身高重建队列 题目描述 力扣题目链接(opens new window)\n假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。\n请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。\n示例 1：\n输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]] 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 解释： 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。 示例 2：\n输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]] 输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]] 提示：\n1 \u0026lt;= people.length \u0026lt;= 2000 0 \u0026lt;= hi \u0026lt;= 10^6 0 \u0026lt;= ki \u0026lt; people.length 题目数据确保队列可以被重建\n思路解析 本题有两个维度，一个维度是排序，另一个维度是身高。因此需要先确定一个维度再来确定另一个维度。\n如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。\n那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。然后只需要按照k为下标重新插入队列就可以了\n局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性 全局最优：最后都做完插入操作，整个队列满足题目队列属性 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int[][] reconstructQueue(int[][] people) { Arrays.sort(people, new Comparator\u0026lt;int[]\u0026gt;() { @Override public int compare(int[] o1, int[] o2) { if(o1[0]==o2[0]) return o1[1]-o2[1]; return o2[0]-o1[0]; } }); LinkedList\u0026lt;int[]\u0026gt;que=new LinkedList\u0026lt;\u0026gt;(); for(int[]p:people){ que.add(p[1],p); } return que.toArray(new int[people.length][]); } } 重叠区间问题 代码模板（求解非重叠区间的个数） 将区间按照左端点进行排序 设置count=1（至少有一个非重叠区间） 从i=1开始遍历 若第i个区间的左端点大于第i-1个区间的右端点则两个区间不重叠 否则两个区间重叠，更新两个区间的右区间为重叠区间的右端点的最小值 代码模板（求解非重叠区间） 将区间按照左端点 先将第一个区间加入结果集合 从i=1开始遍历 若第i个区间的左端点和结果集的最后一个区间的右端点则两个区间不重叠直接加入结果集合 否则两个区间重叠，合并两个区间，更新结果集合的最后一个区间（左端点为结果集合的最后一个区间的左端点，右端点为结果集合的最后一个区间的右端点和第i个区间的右端点的较小值） leetcode 452 用最少数量的箭引爆气球 题目描述 力扣题目链接(opens new window)\n在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。\n一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。\n给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。\n示例 1：\n输入：points = [[10,16],[2,8],[1,6],[7,12]] 输出：2 解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球 示例 2：\n输入：points = [[1,2],[3,4],[5,6],[7,8]] 输出：4 示例 3：\n输入：points = [[1,2],[2,3],[3,4],[4,5]] 输出：2 示例 4：\n输入：points = [[1,2]] 输出：1 示例 5：\n输入：points = [[2,3],[2,3]] 输出：1 提示：\n0 \u0026lt;= points.length \u0026lt;= 10^4 points[i].length == 2 -2^31 \u0026lt;= xstart \u0026lt; xend \u0026lt;= 2^31 - 1 思路解析 本题非重叠区间的个数就是箭的个数，套代码模板即可\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int findMinArrowShots(int[][] points) { // 对区间的左端点排序 Arrays.sort(points, new Comparator\u0026lt;int[]\u0026gt;() { @Override public int compare(int[] o1, int[] o2) { return Integer.compare(o1[0],o2[0]); } }); int count=1; for(int i=1;i\u0026lt;points.length;i++){ if(points[i][0]\u0026gt;points[i-1][1]){ // 不重叠的情况 count++; }else{ points[i][1]=Math.min(points[i-1][1],points[i][1]); // 重叠的情况更新右节点 } } return count; } } leetcode 435 无重叠区间 题目描述 力扣题目链接(opens new window)\n给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。\n注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。\n示例 1:\n输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2:\n输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3:\n输入: [ [1,2], [2,3] ] 输出: 0 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 思路解析 移除非重叠的区间即可，因此求出非重叠区间个数，然后数组长度-非重叠区间即可\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // 求解个数 class Solution { public int eraseOverlapIntervals(int[][] intervals) { Arrays.sort(intervals, new Comparator\u0026lt;int[]\u0026gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[0]-o2[0]; } }); int count=1; for(int i=1;i\u0026lt;intervals.length;i++){ if(intervals[i][0]\u0026gt;=intervals[i-1][1]){ count++; }else{ intervals[i][1]=Math.min(intervals[i][1],intervals[i-1][1]); } } return intervals.length-count; } } // 求解区间 class Solution { public int eraseOverlapIntervals(int[][] intervals) { Arrays.sort(intervals, new Comparator\u0026lt;int[]\u0026gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[0]-o2[0]; } }); LinkedList\u0026lt;int[]\u0026gt;res=new LinkedList\u0026lt;\u0026gt;(); res.add(intervals[0]); for(int i=1;i\u0026lt;intervals.length;i++){ if(intervals[i][0]\u0026gt;=res.getLast()[1]){ res.add(intervals[i]); }else{ res.set(res.size()-1,new int[]{res.getLast()[0],Math.min(res.getLast()[1],intervals[i][1])}); } } return intervals.length-res.size(); } } leetcode 763 划分字母区间 题目描述 力扣题目链接(opens new window)\n字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。\n示例：\n输入：S = \u0026ldquo;ababcbacadefegdehijhklij\u0026rdquo; 输出：[9,7,8] 解释： 划分结果为 \u0026ldquo;ababcbaca\u0026rdquo;, \u0026ldquo;defegde\u0026rdquo;, \u0026ldquo;hijhklij\u0026rdquo;。 每个字母最多出现在一个片段中。 像 \u0026ldquo;ababcbacadefegde\u0026rdquo;, \u0026ldquo;hijhklij\u0026rdquo; 的划分是错误的，因为划分的片段数较少。 提示：\nS的长度在[1, 500]之间。 S只包含小写字母 \u0026lsquo;a\u0026rsquo; 到 \u0026lsquo;z\u0026rsquo; 。 思路解析 在遍历的过程中相当于是要找每一个字母的边界，如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了。此时前面出现过所有字母，最远也就到这个边界了。\n统计每一个字符最后出现的位置 从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public List\u0026lt;Integer\u0026gt; partitionLabels(String s) { // 统计每个字符最后出现的位置 int[]hash=new int[26]; List\u0026lt;Integer\u0026gt;res=new ArrayList\u0026lt;\u0026gt;(); for(int i=0;i\u0026lt;s.length();i++){ hash[s.charAt(i)-\u0026#39;a\u0026#39;]=i; } // 记录区间的起点和终点 int start=0; int end=0; for(int i=0;i\u0026lt;s.length();i++){ end=Math.max(end,hash[s.charAt(i)-\u0026#39;a\u0026#39;]); if(i==end){ res.add(end-start+1); start=end+1; } } return res; } } leetcode 56 合并区间 题目描述 力扣题目链接(opens new window)\n给出一个区间的集合，请合并所有重叠的区间。\n示例 1:\n输入: intervals = [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]] 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2:\n输入: intervals = [[1,4],[4,5]] 输出: [[1,5]] 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。 思路解析 先按左边界排序，让所有的相邻区间尽可能的重叠在一起。 先将第一个区间加入结果集合 从i=1开始遍历，判断和结果集合的最后一个区间的重叠情况 若不重叠则直接加入结果集合 若重叠和结果集合的最后一个区间进行合并 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int[][] merge(int[][] intervals) { Arrays.sort(intervals, new Comparator\u0026lt;int[]\u0026gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[0]-o2[0]; } }); LinkedList\u0026lt;int[]\u0026gt; res=new LinkedList\u0026lt;\u0026gt;(); res.add(intervals[0]); for(int i=1;i\u0026lt;intervals.length;i++){ // 不重叠 if(intervals[i][0]\u0026gt;res.getLast()[1]){ res.add(intervals[i]); }else{ int left=res.getLast()[0]; int right=Math.max(res.getLast()[1],intervals[i][1]); res.removeLast(); res.add(new int[]{left,right}); } } return res.toArray(new int[res.size()][]); } } leetcode 738 单调递增的数字 题目描述 力扣题目链接(opens new window)\n给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。\n（当且仅当每个相邻位数上的数字 x 和 y 满足 x \u0026lt;= y 时，我们称这个整数是单调递增的。）\n示例 1:\n输入: N = 10 输出: 9 示例 2:\n输入: N = 1234 输出: 1234 示例 3:\n输入: N = 332 输出: 299 说明: N 是在 [0, 10^9] 范围内的一个整数。\n思路解析 一旦出现strNum[i - 1] \u0026gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]\u0026ndash;，然后strNum[i]给为9。因此可以这样设计，从后向前遍历，遇到非单调递增的情况将strNum[i - 1]\u0026ndash;，然后将转折点的下一个位置以后的位置全部设为9\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int monotoneIncreasingDigits(int n) { String str=String.valueOf(n); char[]chars=str.toCharArray(); // 记录转折点 int start=chars.length; for(int i=chars.length-2;i\u0026gt;=0;i--){ // 非d if(chars[i]\u0026gt;chars[i+1]){ chars[i]--; start=i+1; } } for(int i=start;i\u0026lt;chars.length;i++){ chars[i]=\u0026#39;9\u0026#39;; } return Integer.valueOf(new String(chars)); } } ","date":"2025-02-21T16:00:23+08:00","permalink":"https://Tyritic.github.io/p/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","title":"贪心算法"},{"content":"数组旋转 leetcode 48 旋转数组 题目描述 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。\n你必须在** 原地** 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。\n示例 1：\n1 2 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[[7,4,1],[8,5,2],[9,6,3]] 示例 2：\n1 2 输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] 输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] 思路解析 对于矩阵中第i行的第j个元素，在旋转后，它出现在倒数第i列的第j个位置\n因此对于矩阵中的元素 matrix[row][col] ，在旋转后，它的新位置为 matrix_new[col][n−row−1] 。\n辅助数组法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public void rotate(int[][] matrix) { int n = matrix.length; int[][] matrix_new = new int[n][n]; for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; n; ++j) { matrix_new[j][n - i - 1] = matrix[i][j]; } } for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; n; ++j) { matrix[i][j] = matrix_new[i][j]; } } } } 翻转法\n可以先将矩阵通过水平轴翻转，再通过主对角线翻转 $$ 对于水平轴翻转而言，我们只需要枚举矩阵上半部分的元素，和下半部分的元素进行交换，即\\\\ matrix[row][col]\\to^{水平轴翻转}matrix[n−row−1][col] $$$$ 对于主对角线翻转而言，我们只需要枚举对角线左侧的元素，和右侧的元素进行交换，即\\\\ matrix[row][col] \\to^{主对角线翻转}matrix[col][row] $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public void rotate(int[][] matrix) { int n = matrix.length; // 水平翻转 for (int i = 0; i \u0026lt; n / 2; ++i) { for (int j = 0; j \u0026lt; n; ++j) { int temp = matrix[i][j]; matrix[i][j] = matrix[n - i - 1][j]; matrix[n - i - 1][j] = temp; } } // 主对角线翻转 for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; i; ++j) { int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; } } } } 数学 位运算 逻辑左移：\u0026lt;\u0026lt; 末尾补0等价于乘2\n逻辑右移：\u0026gt;\u0026gt;\u0026gt; 左端补0\n算术右移：\u0026gt;\u0026gt; 左端最低位填充\n按位求与：\u0026amp;\n按位求或：|\n按位异或： ^\n归零律：任何数与自身异或等于0，即 X ⊕ X = 0。 恒等律：任何数与0异或等于其自身，即 X ⊕ 0 = X。 按位求非： ~\nleetcode 338 比特位计数 题目描述\n给你一个整数 n ，对于 0 \u0026lt;= i \u0026lt;= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。\n示例 1：\n1 2 3 4 5 6 输入：n = 2 输出：[0,1,1] 解释： 0 --\u0026gt; 0 1 --\u0026gt; 1 2 --\u0026gt; 10 示例 2：\n1 2 3 4 5 6 7 8 9 输入：n = 5 输出：[0,1,1,2,1,2] 解释： 0 --\u0026gt; 0 1 --\u0026gt; 1 2 --\u0026gt; 10 3 --\u0026gt; 11 4 --\u0026gt; 100 5 --\u0026gt; 101 思路解析\n将n与1进行与操作，等价于得到n的二进制位的最后一位，然后再让n右移一位\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int[] countBits(int n) { int[]res=new int[n+1]; for(int i=0;i\u0026lt;=n;i++) { res[i]=count(i); } return res; } public int count(int n) { int count=0; while(n\u0026gt;0) { count+=n\u0026amp;1; n\u0026gt;\u0026gt;=1; } return count; } } 模拟大数加法 leetcode 415 字符串相加 题目描述\n题目链接\n给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。\n你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。\n示例 1：\n1 2 输入：num1 = \u0026#34;11\u0026#34;, num2 = \u0026#34;123\u0026#34; 输出：\u0026#34;134\u0026#34; 示例 2：\n1 2 输入：num1 = \u0026#34;456\u0026#34;, num2 = \u0026#34;77\u0026#34; 输出：\u0026#34;533\u0026#34; 示例 3：\n1 2 输入：num1 = \u0026#34;0\u0026#34;, num2 = \u0026#34;0\u0026#34; 输出：\u0026#34;0\u0026#34; 思路解析\n将相同数位对齐，从低到高逐位相加，如果当前位和超过 10，则向高位进一位。\n定义两个指针 i 和 j 分别指向 num1和num2的末尾，即最低位，同时定义一个变量 add 维护当前是否有进位，然后从末尾到开头逐位相加即可。你可能会想两个数字位数不同怎么处理，这里我们统一在指针当前下标处于负数的时候返回 0，等价于对位数较短的数字进行了补零操作，这样就可以除去两个数字位数不同情况的处理\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public String addStrings(String num1, String num2) { StringBuilder ans=new StringBuilder(); int i=num1.length()-1; int j=num2.length()-1; int carry=0; while(i\u0026gt;=0||j\u0026gt;=0){ int x=i\u0026gt;=0?num1.charAt(i)-\u0026#39;0\u0026#39;:0; int y=j\u0026gt;=0?num2.charAt(j)-\u0026#39;0\u0026#39;:0; int sum=x+y+carry; ans.append(sum%10); carry=sum/10; i--; j--; } if(carry==1){ ans.append(1); } return ans.reverse().toString(); } } 数位运算 leetcode 7 整数反转 题目描述\n题目链接\n给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。\n如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。\n假设环境不允许存储 64 位整数（有符号或无符号）。\n示例 1：\n1 2 输入：x = 123 输出：321 示例 2：\n1 2 输入：x = -123 输出：-321 示例 3：\n1 2 输入：x = 120 输出：21 示例 4：\n1 2 输入：x = 0 输出：0 思路解析\n设置res=0为结果 每次取数字的末尾数字temp 为了防止反转后溢出，当res大于整数的最大值/10或者整数的最小值/10则直接返回 将res乘以10+temp 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int reverse(int x) { int res=0; while(x!=0){ int temp=x%10; if(res\u0026gt;Integer.MAX_VALUE/10||res\u0026lt;Integer.MIN_VALUE/10){ return 0; } res=res*10+temp; x/=10; } return res; } } ","date":"2025-02-19T18:47:15+08:00","permalink":"https://Tyritic.github.io/p/%E6%A8%A1%E6%8B%9F/","title":"模拟"},{"content":"回溯算法的经典问题 回溯法，一般可以解决如下几种问题：\n组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 回溯算法的统一解题模板 确定回溯函数模板返回值以及参数\n1 void backtracking(参数) 回溯算法中函数返回值一般为void。结果集合使用全局变量 回溯算法需要的参数所以一般是先写逻辑，然后需要什么参数，就填什么参数。 确定回溯算法的终止条件\n1 2 3 4 if (终止条件) { 存放结果; return; } 一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。 确定单次遍历过程\n1 2 3 4 5 for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } 处理节点 递归处理 回溯 对于引用数据类型必须要回溯 对于基本数据类型如果在for循环内进行修改则需要回溯，因为递归返回后这个值是不会自动回滚，和递归前的值不一致 对于基本数据类型如果作为参数传入递归函数中则不需要回溯，因为每次递归调用使用的 sum 都是独立的，不影响上一层递归。 组合问题 统一解题模板 确定回溯函数模板返回值以及参数\n1 void backtracking(int startIndex,题目参数) 回溯算法中函数返回值一般为void。结果集合使用全局变量 回溯算法需要的参数中需要一个startIndex，记录记录本层递归的中，集合从哪里开始遍历 确定回溯算法的终止条件\n1 2 3 4 if (终止条件) { 存放结果; return; } 通常搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。 确定单次遍历过程\n1 2 3 4 5 for (int i=startIndex;i\u0026lt;nums.length;i++) { 处理节点; backtracking(i+1,选择列表); // 递归 回溯，撤销处理结果 } 处理节点 去重逻辑 先创建一个used数组作为全局变量 树层去重 利用used数组去重：先对数组排序，used[i - 1] == false，说明同一树层candidates[i - 1]使用过 利用set去重：先对数组排序，在for循环外创建一个set，用set检验是否使用过 树枝去重：used[i - 1] == true，说明同一树枝candidates[i - 1]使用过 递归处理 回溯 1 2 3 4 5 6 7 8 9 10 11 12 void backtracking(题目参数,int startIndex){ if (终止条件) { 存放结果; return; } // 在这里建立set集合进行树层去重 for (int i=startIndex;i\u0026lt;nums.length;i++) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } leetcode 77 组合 题目描述 力扣题目链接(opens new window)\n给定两个整数 n 和 k，返回 1 \u0026hellip; n 中所有可能的 k 个数的组合。\n示例: 输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]\n思路解析 确定回溯函数模板返回值以及参数 返回值为 void 参数为n，k，startIndex（记录下一层递归，搜索的起始位置） 确定回溯算法的终止条件 当path的大小为k时，将path加入res 确定单次遍历过程 遍历1\u0026hellip;n 将数字i加入路径中 递归处理i+1 回溯处理数字i，将i从path中移除 遍历过程中可以进行剪枝处理 已经选择的元素个数：path.size(); 还需要的元素个数为: k - path.size(); 在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;res; List\u0026lt;Integer\u0026gt;path; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { res=new ArrayList\u0026lt;\u0026gt;(); path=new ArrayList\u0026lt;\u0026gt;(); backtracking(n,k,1); return res; } public void backtracking(int n,int k,int startIndex) { // 终止条件 if(path.size()==k) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } for(int i=startIndex;i\u0026lt;=n-(k-path.size())+1;i++) { path.add(i); backtracking(n,k,i+1); path.remove(path.size()-1); } } } leetcode 216 组合总和III 题目描述 力扣题目链接(opens new window)\n找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且 每种组合中不存在重复的数字 。\n说明：\n所有数字都是正整数。 解集不能包含重复的组合。 示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]]\n示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]]\n思路解析 确定回溯函数模板返回值以及参数 返回值为 void 参数为n，k，startIndex（记录下一层递归，搜索的起始位置） 确定回溯算法的终止条件 当path的大小为k时判断是否sum==n 确定单次遍历过程 遍历1\u0026hellip;9 处理数字i 将数字i加入路径中 sum+=i 递归处理i+1 回溯处理数字i 将i从path中移除 sum-=i 遍历过程中可以进行剪枝处理 已经选择的元素个数：path.size(); 还需要的元素个数为: k - path.size(); 在集合n中至多要从该起始位置 : 9 - (k - path.size()) + 1，开始遍历 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;res; List\u0026lt;Integer\u0026gt;path; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum3(int k, int n) { res=new ArrayList\u0026lt;\u0026gt;(); path=new ArrayList\u0026lt;\u0026gt;(); backtracking(k,n,1,0); return res; } public void backtracking(int k,int n,int startIndex,int sum) { // 终止条件 if(path.size()==k) { if(sum==n) res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } // 单次遍历 for(int i=startIndex;i\u0026lt;=9-(k-path.size())+1;i++) { sum+=i; path.add(i); backtracking(k,n,i+1,sum); path.remove(path.size()-1); sum-=i; } } } leetcode 17 电话号码的数字组合 题目描述 力扣题目链接(opens new window)\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n示例:\n输入：\u0026ldquo;23\u0026rdquo; 输出：[\u0026ldquo;ad\u0026rdquo;, \u0026ldquo;ae\u0026rdquo;, \u0026ldquo;af\u0026rdquo;, \u0026ldquo;bd\u0026rdquo;, \u0026ldquo;be\u0026rdquo;, \u0026ldquo;bf\u0026rdquo;, \u0026ldquo;cd\u0026rdquo;, \u0026ldquo;ce\u0026rdquo;, \u0026ldquo;cf\u0026rdquo;]. 说明：尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。\n思路解析 建立数字和字母的映射关系 确定回溯函数模板返回值以及参数 返回值为 void 参数为index（记录选择遍历的第几个字母） 确定回溯算法的终止条件 当遍历的数字下标等于字符串长度，将局部字符串加入结果 确定单次遍历过程 获取遍历到的数字对应的字符串 遍历字符串的每个字符 将字符加入局部字符串 递归处理index+1 回溯处理 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { List\u0026lt;String\u0026gt;res=new ArrayList\u0026lt;\u0026gt;(); StringBuffer temp=new StringBuffer(); String[]map=new String[]{\u0026#34; \u0026#34;,\u0026#34; \u0026#34;,\u0026#34;abc\u0026#34;,\u0026#34;def\u0026#34;,\u0026#34;ghi\u0026#34;,\u0026#34;jkl\u0026#34;,\u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;,\u0026#34;tuv\u0026#34;,\u0026#34;wxyz\u0026#34;}; public List\u0026lt;String\u0026gt; letterCombinations(String digits) { if (digits == null || digits.length() == 0) { return res; } backtrack(digits,0); return res; } public void backtrack(String digits,int index) { // 终止条件 if(index==digits.length()) { res.add(temp.toString()); return; } //单次递归 char ch=digits.charAt(index); String str=map[ch-\u0026#39;0\u0026#39;]; for(int i=0;i\u0026lt;str.length();i++) { temp.append(str.charAt(i)); backtrack(digits,index+1); temp.deleteCharAt(temp.length()-1); } } } leetcode 39 组合总和 题目描述 力扣题目链接(opens new window)\n给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\ncandidates 中的数字可以无限制重复被选取。\n说明：\n所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1：\n输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ] 示例 2：\n输入：candidates = [2,3,5], target = 8, 所求解集为： [ [2,2,2,2], [2,3,3], [3,5] ] 思路解析 先对数组进行排序 确定回溯函数模板返回值以及参数 返回值为 void 参数为candidates，sum，target，startIndex（记录下一层递归，搜索的起始位置） 确定回溯算法的终止条件 当sum==target将path加入res 确定单次遍历过程 从startIndex开始遍历 若sum+candidates[i]\u0026gt;target可以直接停止循环 处理数字i 将数字i加入路径中 sum+=i 递归处理i 回溯处理数字i 将i从path中移除 sum-=i 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;res=new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt;path=new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target) { Arrays.sort(candidates); // 先进行排序 backtrack(candidates,target,0,0); return res; } public void backtrack(int[]candidates,int target,int startIndex,int sum) { if(sum==target) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } for(int i=startIndex;i\u0026lt;candidates.length;i++) { if(sum+candidates[i]\u0026gt;target) break; path.add(candidates[i]); sum+=candidates[i]; backtrack(candidates,target,i,sum); sum-=candidates[i]; path.removeLast(); } } } leetcode 40 组合总和II 题目描述 力扣题目链接(opens new window)\n给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\ncandidates 中的每个数字在每个组合中只能使用一次。\n说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。\n示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: 1 2 3 4 5 6 [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: 1 2 3 4 [ [1,2,2], [5] ] 思路解析 本题的重点在于如何去重，以及去重的角度。\n元素在同一个组合内是可以重复的，但两个组合不能相同。\n所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重。\nused[i - 1] == true，说明同一树枝candidates[i - 1]使用过 used[i - 1] == false，说明同一树层candidates[i - 1]使用过 先对数组进行排序 确定回溯函数模板返回值以及参数 返回值为 void 参数为candidates，sum，target，startIndex（记录下一层递归，搜索的起始位置） 确定回溯算法的终止条件 当sum==target将path加入res 确定单次遍历过程 从startIndex开始遍历 若sum+candidates[i]\u0026gt;target可以直接停止循环 若used[i - 1] == false，说明同一树层candidates[i - 1]使用过，continue之后的操作 处理数字i 将数字i加入路径中 sum+=i used[i]=true 递归处理i 回溯处理数字i 将i从path中移除 sum-=i used[i]=false 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 // 使用used数组 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;res=new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt;path=new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum2(int[] candidates, int target) { boolean[]used=new boolean[candidates.length]; Arrays.sort(candidates); backtrack(candidates,target,0,0,used); return res; } public void backtrack(int[]candidates,int target,int sum,int startIndex,boolean[]used) { if(target==sum) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); } for(int i=startIndex;i\u0026lt;candidates.length;i++) { if (sum + candidates[i] \u0026gt; target) { break; } if(i\u0026gt;0\u0026amp;\u0026amp;candidates[i]==candidates[i-1]\u0026amp;\u0026amp;used[i-1]==false) continue; sum+=candidates[i]; path.add(candidates[i]); used[i]=true; backtrack(candidates,target,sum,i+1,used); used[i]=false; path.removeLast(); sum-=candidates[i]; } } } // 使用set去重 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;res; List\u0026lt;Integer\u0026gt;path; public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum2(int[] candidates, int target) { res=new ArrayList\u0026lt;\u0026gt;(); path=new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(candidates); backtrack(candidates,target,0,0); return res; } public void backtrack(int[]candidates,int target,int startIndex,int sum) { // 终止条件 if(sum==target) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } HashSet\u0026lt;Integer\u0026gt;set=new HashSet\u0026lt;\u0026gt;(); for(int i=startIndex;i\u0026lt;candidates.length;i++) { if(sum+candidates[i]\u0026gt;target) break; if(set.contains(candidates[i])) continue; sum+=candidates[i]; set.add(candidates[i]); path.add(candidates[i]); backtrack(candidates,target,i+1,sum); path.removeLast(); sum-=candidates[i]; } } } 切割问题 统一解题模板 切割问题类似组合问题。\n例如对于字符串abcdef：\n组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中再选取第三个\u0026hellip;..。\n切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段\u0026hellip;..。\n确定回溯函数模板返回值以及参数\n1 void backtracking(int startIndex,题目参数) 回溯算法中函数返回值一般为void。结果集合使用全局变量 回溯算法需要的参数中需要一个startIndex，记录记录本层递归的切割位置，切割区间为左闭右闭的区间 确定回溯算法的终止条件\n1 2 3 4 if (终止条件) { 存放结果; return; } 通常搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。 确定单次遍历过程\n1 2 3 4 5 for (int i=startIndex;i\u0026lt;nums.length;i++) { 处理节点; backtracking(i+1，选择列表); // 递归 回溯，撤销处理结果 } 处理节点 递归处理 回溯 1 2 3 4 5 6 7 8 9 10 11 12 void backtracking(题目参数,int startIndex) { if (终止条件) { 存放结果; return; } for (int i=startIndex;i\u0026lt;nums.length;i++) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } leetcode 131 分割回文串 题目描述 力扣题目链接(opens new window)\n给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。\n返回 s 所有可能的分割方案。\n示例: 输入: \u0026ldquo;aab\u0026rdquo; 输出: [ [\u0026ldquo;aa\u0026rdquo;,\u0026ldquo;b\u0026rdquo;], [\u0026ldquo;a\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;] ]\n思路解析 总体思路\n递归函数参数 全局变量数组path存放切割后回文的子串，二维数组result存放结果集。 startIndex作为截取位置 递归函数终止条件 切割线切到了字符串最后面是本层递归的终止条件。 单次遍历 从startIndex开始遍历字符串 截取子串[startIndex，i]作为子串 验证是否为回文串若是 将子串加入结果集 递归处理i+1 回溯 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;res=new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt;path=new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; partition(String s) { backtrack(s,0); return res; } public boolean check(String str) { int left=0; int right=str.length()-1; while(left\u0026lt;=right) { if(str.charAt(left)!=str.charAt(right)) return false; left++; right--; } return true; } public void backtrack(String s,int startIndex) { //终止条件 if(startIndex\u0026gt;=s.length()) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } for(int i=startIndex;i\u0026lt;s.length();i++) { String str=s.substring(startIndex,i+1); if(check(str)) { path.add(str); backtrack(s,i+1); path.removeLast(); } } } } leetcode 93 复原IP地址 题目描述 力扣题目链接(opens new window)\n给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。\n有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 \u0026lsquo;.\u0026rsquo; 分隔。\n例如：\u0026ldquo;0.1.2.201\u0026rdquo; 和 \u0026ldquo;192.168.1.1\u0026rdquo; 是 有效的 IP 地址，但是 \u0026ldquo;0.011.255.245\u0026rdquo;、\u0026ldquo;192.168.1.312\u0026rdquo; 和 \u0026ldquo;192.168@1.1\u0026rdquo; 是 无效的 IP 地址。\n示例 1：\n输入：s = \u0026ldquo;25525511135\u0026rdquo; 输出：[\u0026ldquo;255.255.11.135\u0026rdquo;,\u0026ldquo;255.255.111.35\u0026rdquo;] 示例 2：\n输入：s = \u0026ldquo;0000\u0026rdquo; 输出：[\u0026ldquo;0.0.0.0\u0026rdquo;] 示例 3：\n输入：s = \u0026ldquo;1111\u0026rdquo; 输出：[\u0026ldquo;1.1.1.1\u0026rdquo;] 示例 4：\n输入：s = \u0026ldquo;010010\u0026rdquo; 输出：[\u0026ldquo;0.10.0.10\u0026rdquo;,\u0026ldquo;0.100.1.0\u0026rdquo;] 示例 5：\n输入：s = \u0026ldquo;101023\u0026rdquo; 输出：[\u0026ldquo;1.0.10.23\u0026rdquo;,\u0026ldquo;1.0.102.3\u0026rdquo;,\u0026ldquo;10.1.0.23\u0026rdquo;,\u0026ldquo;10.10.2.3\u0026rdquo;,\u0026ldquo;101.0.2.3\u0026rdquo;] 提示：\n0 \u0026lt;= s.length \u0026lt;= 3000 s 仅由数字组成 思路解析 递归函数参数 全局变量数组path存放切割后回文的子串，二维数组result存放结果集。 startIndex作为截取位置 pointnum记录点的个数 递归函数终止条件 点的个数为3时判断剩下的部分是否合格，合格则加入结果集 单次遍历 从startIndex开始遍历字符串 截取子串[startIndex，i]作为子串，加入逗号 验证截取的子串是否为合法若合法 将子串加入结果集 pointnum++ 递归处理i+2 回溯 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { List\u0026lt;String\u0026gt;res; public List\u0026lt;String\u0026gt; restoreIpAddresses(String s) { res=new ArrayList\u0026lt;\u0026gt;(); StringBuilder sb=new StringBuilder(s); backtrack(sb,0,0); return res; } public void backtrack(StringBuilder s,int startIndex,int pointNum) { if(pointNum==3) { if(isValid(s.toString(),startIndex,s.length()-1)) res.add(s.toString()); return; } for(int i=startIndex;i\u0026lt;s.length();i++) { if(isValid(s.toString(),startIndex,i)) { s.insert(i+1,\u0026#39;.\u0026#39;); pointNum++; backtrack(s,i+2,pointNum); pointNum--; s.deleteCharAt(i+1); }else{ break; } } } public boolean isValid(String s,int start,int end) { if(start\u0026gt;end) return false; if(s.charAt(start)==\u0026#39;0\u0026#39;\u0026amp;\u0026amp;start!=end) return false; int num=0; for(int i=start;i\u0026lt;=end;i++) { if(s.charAt(i)\u0026lt;\u0026#39;0\u0026#39;||s.charAt(i)\u0026gt;\u0026#39;9\u0026#39;) return false; num=num*10+(s.charAt(i)-\u0026#39;0\u0026#39;); if(num\u0026gt;255) return false; } return true; } } 子集问题 统一解题模板 确定回溯函数模板返回值以及参数\n1 void backtracking(int startIndex,参数) 回溯算法中函数返回值一般为void。结果集合使用全局变量 回溯算法的参数中需要一个startIndex，记录记录本层递归的中，集合从哪里开始遍历 确定回溯算法的终止条件\n1 2 3 4 将子集加入结果集 if (终止条件) { 存放结果; } 收集结果写在终止条件前，因为遍历到节点就要收集 严格意义上子集问题不需要写递归条件 确定单次遍历过程\n1 2 3 4 5 for (int i=startIndex;i\u0026lt;nums.length;i++) { 处理节点; backtracking(i+1，其他参数); // 递归 回溯，撤销处理结果 } 处理节点 递归处理 回溯 1 2 3 4 5 6 7 8 9 10 11 12 void backtracking(int startIndex,参数){ 收集子集 if (终止条件) { 存放结果; return; } for (int i=startIndex;i\u0026lt;nums.length;i++) { 处理节点; backtracking(i+1，其他参数); // 递归 回溯，撤销处理结果 } } leetcode 78 子集 题目描述 力扣题目链接(opens new window)\n给定一组 不含重复元素 的整数数组 nums，返回该数组所有可能的子集（幂集）。\n说明：解集不能包含重复的子集。\n示例: 输入: nums = [1,2,3] 输出: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ]\n思路解析 确定回溯函数模板返回值以及参数\n1 void backtracking(int startIndex,参数) 回溯算法的参数中需要一个startIndex，记录记录本层递归的中，集合从哪里开始遍历 确定回溯算法的终止条件\n收集结果写在终止条件前，因为遍历到节点就要收集 严格意义上子集问题不需要写终止条件 确定单次遍历过程\n1 2 3 4 5 for (int i=startIndex;i\u0026lt;nums.length;i++) { 处理节点; backtracking(i+1，其他参数); // 递归 回溯，撤销处理结果 } 将节点加入子集中 递归处理 回溯 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;res=new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt;path=new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { backtrack(nums,0); return res; } public void backtrack(int[]nums,int startIndex) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); if(startIndex\u0026gt;=nums.length) { return; } for(int i=startIndex;i\u0026lt;nums.length;i++) { path.add(nums[i]); backtrack(nums,i+1); path.removeLast(); } } } leetcode 90 子集II 题目描述 力扣题目链接(opens new window)\n给定一个 可能包含重复元素 的整数数组 nums，返回该数组所有可能的子集（幂集）。\n说明：解集不能包含重复的子集。\n示例:\n输入: [1,2,2] 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] 思路解析 本题采用树层去重\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;res=new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt;path=new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsetsWithDup(int[] nums) { Boolean[]used=new Boolean[nums.length]; Arrays.sort(nums); backtrack(nums,used,0); return res; } public void backtrack(int[]nums,Boolean[]used,int startIndex) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); if(startIndex\u0026gt;=nums.length) return; for(int i=startIndex;i\u0026lt;nums.length;i++) { if(i\u0026gt;0\u0026amp;\u0026amp;nums[i]==nums[i-1]\u0026amp;\u0026amp;used[i-1]==false) continue; used[i]=true; path.add(nums[i]); backtrack(nums,used,i+1); used[i]=false; path.removeLast(); } } } leetcode 491 递增子序列 题目描述 力扣题目链接(opens new window)\n给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。\n示例:\n输入: [4, 6, 7, 7] 输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]] 说明:\n给定数组的长度不会超过15。 数组中的整数范围是 [-100,100]。 给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。 思路解析 本题不能使用used数组进行去重，因为不能对数组进行排序，因此使用set集合进行树层排序\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;res=new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt;path=new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; findSubsequences(int[] nums) { backtrack(nums,0); return res; } public void backtrack(int[]nums,int startIndex) { if(path.size()\u0026gt;=2) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); } HashSet\u0026lt;Integer\u0026gt;res=new HashSet\u0026lt;\u0026gt;(); for(int i=startIndex;i\u0026lt;nums.length;i++) { if(!path.isEmpty()\u0026amp;\u0026amp;path.get(path.size()-1)\u0026gt;nums[i]||res.contains(nums[i])) continue; path.add(nums[i]); res.add(nums[i]); backtrack(nums,i+1); path.removeLast(); } } } 排列问题 统一解题模板 确定回溯函数模板返回值以及参数\n1 void backtracking(boolean[]used,参数) 回溯算法中函数返回值一般为void。结果集合使用全局变量 回溯算法的参数中需要的boolean数组 确定回溯算法的终止条件\n1 2 3 4 if (终止条件) { 存放结果; return; } 通常搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。 确定单次遍历过程\n1 2 3 4 5 6 for (int i=0;i\u0026lt;nums.length;i++) { 判断是否被选择过 处理节点; backtracking(used，其他参数); // 递归 回溯，撤销处理结果 } 判断元素是否被选择，被选择后直接跳过 处理节点 将used[i]置为true 放入排列中 递归处理 回溯 将used[i]置为false 移除排列中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void backtracking(boolean[]used,参数){ if (终止条件) { 存放结果; return; } for (int i=0;i\u0026lt;nums.length;i++) { if(used[i]==true) continue; 处理节点; used[i]=true; backtracking(used，其他参数); // 递归 used[i]=false; 回溯，撤销处理结果 } } leetcode 46 全排列 题目描述 力扣题目链接(opens new window)\n给定一个 没有重复 数字 的序列，返回其所有可能的全排列。\n示例:\n输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 思路解析 参考解题模板\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res=new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt;path=new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { if (nums.length == 0){ return res; } boolean[]used=new boolean[nums.length]; backtrack(nums,used); return res; } public void backtrack(int[]nums,boolean[]used) { // 终止条件 if(path.size()==nums.length) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } // 单层遍历 for(int i=0;i\u0026lt;nums.length;i++) { // 判断是否选择 if(used[i]==true) continue; // 处理节点 path.add(nums[i]); used[i]=true; backtrack(nums,used); // 回溯 used[i]=false; path.removeLast(); } } } leetcode 47 全排列II 题目描述 力扣题目链接(opens new window)\n给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。\n示例 1：\n输入：nums = [1,1,2] 输出： [[1,1,2], [1,2,1], [2,1,1]] 示例 2：\n输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 提示：\n1 \u0026lt;= nums.length \u0026lt;= 8 -10 \u0026lt;= nums[i] \u0026lt;= 10 思路解析 本题需要树层去重，依然可以套用之前的做法。先对数组进行排序，然后利用 i\u0026gt;0\u0026amp;\u0026amp;nums[i-1]==nums[i]\u0026amp;\u0026amp;used[i-1]==false\n进行树层去重\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;res=new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt;path=new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permuteUnique(int[] nums) { Arrays.sort(nums); boolean[]used=new boolean[nums.length]; backtrack(nums,used); return res; } public void backtrack(int[]nums,boolean[]used) { // 终止条件 if(path.size()==nums.length) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } for(int i=0;i\u0026lt;nums.length;i++) { // 树层去重 if(i\u0026gt;0\u0026amp;\u0026amp;nums[i-1]==nums[i]\u0026amp;\u0026amp;used[i-1]==false) continue; // 是否被选择 if(used[i]==true) continue; // 处理节点 path.add(nums[i]); used[i]=true; backtrack(nums,used); // 回溯 path.removeLast(); used[i]=false; } } } leetcode 332 重新安排行程 题目描述 力扣题目链接(opens new window)\n给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。\n提示：\n如果存在多种有效的行程，请你按字符自然排序返回最小的行程组合。例如，行程 [\u0026ldquo;JFK\u0026rdquo;, \u0026ldquo;LGA\u0026rdquo;] 与 [\u0026ldquo;JFK\u0026rdquo;, \u0026ldquo;LGB\u0026rdquo;] 相比就更小，排序更靠前 所有的机场都用三个大写字母表示（机场代码）。 假定所有机票至少存在一种合理的行程。 所有的机票必须都用一次 且 只能用一次。 示例 1：\n输入：[[\u0026ldquo;MUC\u0026rdquo;, \u0026ldquo;LHR\u0026rdquo;], [\u0026ldquo;JFK\u0026rdquo;, \u0026ldquo;MUC\u0026rdquo;], [\u0026ldquo;SFO\u0026rdquo;, \u0026ldquo;SJC\u0026rdquo;], [\u0026ldquo;LHR\u0026rdquo;, \u0026ldquo;SFO\u0026rdquo;]] 输出：[\u0026ldquo;JFK\u0026rdquo;, \u0026ldquo;MUC\u0026rdquo;, \u0026ldquo;LHR\u0026rdquo;, \u0026ldquo;SFO\u0026rdquo;, \u0026ldquo;SJC\u0026rdquo;] 示例 2：\n输入：[[\u0026ldquo;JFK\u0026rdquo;,\u0026ldquo;SFO\u0026rdquo;],[\u0026ldquo;JFK\u0026rdquo;,\u0026ldquo;ATL\u0026rdquo;],[\u0026ldquo;SFO\u0026rdquo;,\u0026ldquo;ATL\u0026rdquo;],[\u0026ldquo;ATL\u0026rdquo;,\u0026ldquo;JFK\u0026rdquo;],[\u0026ldquo;ATL\u0026rdquo;,\u0026ldquo;SFO\u0026rdquo;]] 输出：[\u0026ldquo;JFK\u0026rdquo;,\u0026ldquo;ATL\u0026rdquo;,\u0026ldquo;JFK\u0026rdquo;,\u0026ldquo;SFO\u0026rdquo;,\u0026ldquo;ATL\u0026rdquo;,\u0026ldquo;SFO\u0026rdquo;] 解释：另一种有效的行程是 [\u0026ldquo;JFK\u0026rdquo;,\u0026ldquo;SFO\u0026rdquo;,\u0026ldquo;ATL\u0026rdquo;,\u0026ldquo;JFK\u0026rdquo;,\u0026ldquo;ATL\u0026rdquo;,\u0026ldquo;SFO\u0026rdquo;]。但是它自然排序更大更靠后。 思路解析 本题的难点在于如何确定起点和重点的映射关系，同时还要按照字符的自然排序\n可以考虑使用一个嵌套的map，键为起点，值为一个键是终点，值为航班次数的treeMap。\n本题的目的是寻找一条符合条件的路径，不需要遍历完整个树，因此返回值为 boolean\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Solution { List\u0026lt;String\u0026gt;res=new LinkedList\u0026lt;\u0026gt;(); Map\u0026lt;String,Map\u0026lt;String,Integer\u0026gt;\u0026gt;map=new HashMap\u0026lt;\u0026gt;(); public List\u0026lt;String\u0026gt; findItinerary(List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; tickets) { // 建立映射关系(起点:(终点:航班次数)) for(List\u0026lt;String\u0026gt;ticket:tickets) { // 获取起点和终点 String src=ticket.get(0); String des=ticket.get(1); Map\u0026lt;String,Integer\u0026gt;temp; if(map.containsKey(src)) { temp=map.get(src); temp.put(des,temp.getOrDefault(des,0)+1); }else{ temp=new TreeMap\u0026lt;\u0026gt;(); temp.put(des,1); } map.put(src,temp); } res.add(\u0026#34;JFK\u0026#34;); backtrack(tickets.size()); return res; } public boolean backtrack(int ticketNum){ // 终止条件 if(res.size()==ticketNum+1) { return true; } // 获取队尾 String last=res.getLast(); // 查找以他为起点的航班情况 Map\u0026lt;String,Integer\u0026gt;target=map.get(last); for(String t:target.keySet()) { int count=target.get(t); if(count\u0026gt;0) { // 处理节点 res.add(t); target.put(t,count-1); if(backtrack(ticketNum)) return true; res.remove(res.size()-1); target.put(t,count); } } return false; } } 一维递归 leetcode 51 N皇后问题 题目描述 力扣题目链接(opens new window)\nn 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。\n每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 \u0026lsquo;Q\u0026rsquo; 和 \u0026lsquo;.\u0026rsquo; 分别代表了皇后和空位。\n示例 1：\n输入：n = 4 输出：[[\u0026quot;.Q..\u0026quot;,\u0026quot;\u0026hellip;Q\u0026quot;,\u0026ldquo;Q\u0026hellip;\u0026rdquo;,\u0026quot;..Q.\u0026quot;],[\u0026quot;..Q.\u0026quot;,\u0026ldquo;Q\u0026hellip;\u0026rdquo;,\u0026quot;\u0026hellip;Q\u0026quot;,\u0026quot;.Q..\u0026quot;]] 解释：如上图所示，4 皇后问题存在两个不同的解法。 示例 2：\n输入：n = 1 输出：[[\u0026ldquo;Q\u0026rdquo;]] 思路解析 递归函数参数 定义全局变量二维数组result来记录最终结果。 形参 参数n是棋盘的大小， row来记录当前遍历到棋盘的第几层了。 终止条件 遍历到最后一行停止 单层遍历 遍历每一列 若放入皇后后棋盘合法则 处理节点 递归处理 回溯 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class Solution { List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;res; public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; solveNQueens(int n) { res=new ArrayList\u0026lt;\u0026gt;(); char[][]chessboard=new char[n][n]; for(char[] ch:chessboard) { Arrays.fill(ch,\u0026#39;.\u0026#39;); } backtrack(n,0,chessboard); return res; } public void backtrack(int n,int row,char[][]chessboard) { // 终止条件 if(row==n){ res.add(ArrayToList(chessboard)); return; } // 遍历每一列 for(int col=0;col\u0026lt;n;col++) { // 判断是否合法 if(isValid(row,col,n,chessboard)) { chessboard[row][col]=\u0026#39;Q\u0026#39;; backtrack(n,row+1,chessboard); chessboard[row][col]=\u0026#39;.\u0026#39;; } } } // 检验假设放入皇后之后的棋盘是否合法 public boolean isValid(int row,int col,int n,char[][]chessboard) { // 检验同一列 for(int i=0;i\u0026lt;row;i++) { if(chessboard[i][col]==\u0026#39;Q\u0026#39;) return false; } // 检验左上对角线 for (int i=row-1, j=col-1; i\u0026gt;=0 \u0026amp;\u0026amp; j\u0026gt;=0; i--, j--) { if (chessboard[i][j] == \u0026#39;Q\u0026#39;) { return false; } } // 检验右上对角线 for (int i=row-1, j=col+1; i\u0026gt;=0 \u0026amp;\u0026amp; j\u0026lt;=n-1; i--, j++) { if (chessboard[i][j] == \u0026#39;Q\u0026#39;) { return false; } } return true; } // 将棋盘数字转换为List public List\u0026lt;String\u0026gt; ArrayToList(char[][]chessboard) { List\u0026lt;String\u0026gt;ans=new ArrayList\u0026lt;\u0026gt;(); for(char[] ch:chessboard) { ans.add(new String(ch)); } return ans; } } 二维递归 题目描述 力扣题目链接(opens new window)\n编写一个程序，通过填充空格来解决数独问题。\n一个数独的解法需遵循如下规则： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 空白格用 \u0026lsquo;.\u0026rsquo; 表示。\n一个数独。\n答案被标成红色。\n提示：\n给定的数独序列只包含数字 1-9 和字符 \u0026lsquo;.\u0026rsquo; 。 你可以假设给定的数独只有唯一解。 给定数独永远是 9x9 形式的。 思路解析 相比于N皇后，数独问题需要在一个位置选择9个数字中的一个。同时在检验中如何保证数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次也是难点。对于保证数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。要向确定每个3x3 的起始行和起始列。\n1 2 int startRow = (row / 3) * 3; int startCol = (col / 3) * 3; 可以用来标识起始行和起始列\n回溯函数的参数为boolean，因为本题只要找到一个符合的条件（就在树的叶子节点上）立刻就返回，相当于找从根节点到叶子节点一条唯一路径。\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Solution { public void solveSudoku(char[][] board) { backtrack(board); } public boolean backtrack(char[][]board) { // 确定每一个位置 for(int i=0;i\u0026lt;9;i++) { for(int j=0;j\u0026lt;9;j++) { // 已经放入数组则跳过下面操作 if(board[i][j]!=\u0026#39;.\u0026#39;) continue; for(char k=\u0026#39;1\u0026#39;;k\u0026lt;=\u0026#39;9\u0026#39;;k++) { if(isValid(i,j,k,board)) { board[i][j]=k; if(backtrack(board)) return true; board[i][j]=\u0026#39;.\u0026#39;; } } return false; } } return true; } // 检验放入数字前棋盘是否合法 public boolean isValid(int row,int col,char val,char[][]board) { // 同行是否重复 for (int i = 0; i \u0026lt; 9; i++){ if (board[row][i] == val){ return false; } } // 同列是否重复 for (int j = 0; j \u0026lt; 9; j++){ if (board[j][col] == val){ return false; } } // 9宫格里是否重复 int startRow = (row / 3) * 3; int startCol = (col / 3) * 3; for (int i = startRow; i \u0026lt; startRow + 3; i++){ for (int j = startCol; j \u0026lt; startCol + 3; j++){ if (board[i][j] == val){ return false; } } } return true; } } ","date":"2025-02-18T11:43:20+08:00","permalink":"https://Tyritic.github.io/p/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","title":"回溯算法"},{"content":"二叉树的统一解题模板 本质上二叉树的题目是递归的一种，与树相关的递归思路可以从以下方式思考\n确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。\n如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。\n如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。\n搜索一条边的写法\n1 2 if (递归函数(root-\u0026gt;left)) return ; if (递归函数(root-\u0026gt;right)) return ; 搜索整个树写法\n1 2 3 left = 递归函数(root-\u0026gt;left); // 左 right = 递归函数(root-\u0026gt;right); // 右 left与right的逻辑处理; // 中 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值boolean，因为遇到符合条件的路径了就要及时返回。\n对于需要回溯的问题，基本数据类型不需要回溯，而引用数据类型需要回溯\n确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。\n确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。\n二叉树的遍历方式 二叉树的大部分题目都是基于遍历来解决。二叉树的遍历方式有以下四种\n前序遍历：根左右 后序遍历：左右根 中序遍历：左根右 层序遍历：将树按照层次进行遍历 递归遍历思路 以前序遍历为例\n前序遍历 确定递归函数的参数和返回值：不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是void 确定终止条件：当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接return 确定单层递归的逻辑：前序遍历是中左右的顺序，所以在单层递归的逻辑，是要先取中节点的数值 leetcode 144 二叉树的前序遍历 题目描述\n题目链接\n给你二叉树的根节点 root ，返回它节点值的 前序 遍历。\n示例 1：\n输入： root = [1,null,2,3]\n输出：[1,2,3]\n解释：\n示例 2：\n输入： root = [1,2,3,4,5,null,8,null,null,6,7,9]\n输出：[1,2,4,5,6,7,3,8,9]\n解释：\n示例 3：\n输入： root = []\n输出：[]\n示例 4：\n输入： root = [1]\n输出：[1]\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt;res=new ArrayList\u0026lt;\u0026gt;(); preorder(root,res); return res; } public void preorder(TreeNode root,List\u0026lt;Integer\u0026gt;res) { // 终止条件 if(root==null) return; // 遍历过程 res.add(root.val); preorder(root.left,res); preorder(root.right,res); } } leetcode 145 二叉树的后序遍历 题目描述\n题目链接\n给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。\n示例 1：\n输入： root = [1,null,2,3]\n输出： [3,2,1]\n解释：\n示例 2：\n输入： root = [1,2,3,4,5,null,8,null,null,6,7,9]\n输出： [4,6,7,5,2,9,8,3,1]\n解释：\n示例 3：\n输入： root = []\n输出： []\n示例 4：\n输入： root = [1]\n输出： [1]\n提示：\n树中节点的数目在范围 [0, 100] 内 -100 \u0026lt;= Node.val \u0026lt;= 100 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt;res=new ArrayList\u0026lt;\u0026gt;(); transfer(root,res); return res; } public void transfer(TreeNode root,List\u0026lt;Integer\u0026gt;res) { // 终止条件 if(root==null) return; transfer(root.left,res); transfer(root.right,res); res.add(root.val); } } leetcode 94 二叉树的中序遍历 题目描述\n题目链接\n给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。\n示例 1：\n1 2 输入：root = [1,null,2,3] 输出：[1,3,2] 示例 2：\n1 2 输入：root = [] 输出：[] 示例 3：\n1 2 输入：root = [1] 输出：[1] 提示：\n树中节点数目在范围 [0, 100] 内 -100 \u0026lt;= Node.val \u0026lt;= 100 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt;res=new ArrayList\u0026lt;\u0026gt;(); transfer(root,res); return res; } public void transfer(TreeNode root,List\u0026lt;Integer\u0026gt;res) { if(root==null) return; transfer(root.left,res); res.add(root.val); transfer(root.right,res); } } 迭代遍历思路 使用一个栈作为存储结构，但是栈存在 无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况 。那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。 通常可以将要处理的节点后面放入一个空指针\n前序遍历 栈中的行为\n放入根节点，然后直接出栈，但是保留根节点的引用 右节点入栈，栈中元素[右节点] 左节点入栈，栈中元素[右节点，左节点] 根节点入栈，栈中元素[右节点，左节点，根节点] 出栈顺序：根节点，左节点，右节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new LinkedList\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; st = new Stack\u0026lt;\u0026gt;(); if (root != null) st.push(root); while (!st.empty()) { TreeNode node = st.peek(); if (node != null) { st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 } else { // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.peek(); // 重新取出栈中元素 st.pop(); result.add(node.val); // 加入到结果集 } } return result; } } 中序遍历 栈中行为\n放入根节点，然后直接出栈，但是保留根节点的引用 右节点入栈，栈中元素[右节点] 根节点入栈，栈中元素[右节点，根节点] 左节点入栈，栈中元素[右节点，根节点，左节点] 出栈顺序：左节点，根节点，右节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new LinkedList\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; st = new Stack\u0026lt;\u0026gt;(); if (root != null) st.push(root); while (!st.empty()) { TreeNode node = st.peek(); if (node != null) { st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） } else { // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.peek(); // 重新取出栈中元素 st.pop(); result.add(node.val); // 加入到结果集 } } return result; } } 后序遍历 栈中行为\n放入根节点，然后直接出栈，但是保留根节点的引用 根节点入栈，栈中元素[根节点] 右节点入栈，栈中元素[根节点，右节点] 左节点入栈，栈中元素[根节点，右节点，左节点] 出栈顺序：左节点，右节点，根节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; result = new LinkedList\u0026lt;\u0026gt;(); Stack\u0026lt;TreeNode\u0026gt; st = new Stack\u0026lt;\u0026gt;(); if (root != null) st.push(root); while (!st.empty()) { TreeNode node = st.peek(); if (node != null) { st.pop(); // 将该节点弹出，避免重复操作，下面再将中右左节点添加到栈中 st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） } else { // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.peek(); // 重新取出栈中元素 st.pop(); result.add(node.val); // 加入到结果集 } } return result; } } 层次遍历思路 使用一个队列来模拟遍历，每次出队时将节点的左右子节点放入队列中\n代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Queue\u0026lt;TreeNode\u0026gt;queue=new LinkedList\u0026lt;\u0026gt;(); queue.add(root); while (!queue.isEmpty()) { int size=queue.size(); // 以层为单位的操作，size是每一层的元素个数 for(int i=0;i\u0026lt;size;i++) { TreeNode temp=queue.poll(); // 题目中对单个元素特定操作 if(temp.left!=null) queue.offer(temp.left); if(temp.right!=null) queue.offer(temp.right); } // 每层结束后的操作 } leetcode 102 二叉树的层次遍历 题目描述\n力扣题目链接(opens new window)\n给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;res=new ArrayList\u0026lt;\u0026gt;(); if(root==null)return res; // 引入辅助队列 Queue\u0026lt;TreeNode\u0026gt;que=new LinkedList\u0026lt;\u0026gt;(); // 添加根节点 que.offer(root); while(!que.isEmpty()) { // 为每一层建立一个list存储每一层的结果 List\u0026lt;Integer\u0026gt;ans=new ArrayList\u0026lt;\u0026gt;(); // 每一层的操作，其中size是每一层的元素个数 int size=que.size(); for(int i=0;i\u0026lt;size;i++) { TreeNode temp=que.poll(); // 对单个元素的操作 ans.add(temp.val); if(temp.left!=null)que.offer(temp.left); if(temp.right!=null)que.offer(temp.right); } // 每一层遍历完之后的操作 res.add(ans); } return res; } } leetcode 637 二叉树的层平均值 题目描述\n力扣题目链接(opens new window)\n给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public List\u0026lt;Double\u0026gt; averageOfLevels(TreeNode root) { ArrayList\u0026lt;Double\u0026gt;res=new ArrayList\u0026lt;\u0026gt;(); if(root==null)return res; // 建立辅助队列 Queue\u0026lt;TreeNode\u0026gt;que=new LinkedList\u0026lt;\u0026gt;(); // 根节点入队 que.offer(root); while(!que.isEmpty()) { // 定义每层的变量 int size=que.size(); double count=0; // 层内遍历 for(int i=0;i\u0026lt;size;i++) { TreeNode temp=que.poll(); // 对层内元素求和 count+=temp.val; if(temp.left!=null) que.offer(temp.left); if(temp.right!=null) que.offer(temp.right); } // 每一层遍历结束后加入结果集 res.add(count/size); } return res; } } leetcode 515 在每个树行中找最大值 题目描述\n力扣题目链接(opens new window)\n您需要在二叉树的每一行中找到最大的值。\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public List\u0026lt;Integer\u0026gt; largestValues(TreeNode root) { List\u0026lt;Integer\u0026gt;res=new ArrayList\u0026lt;\u0026gt;(); if(root==null)return res; // 设置辅助队列 Queue\u0026lt;TreeNode\u0026gt;que=new LinkedList\u0026lt;\u0026gt;(); // 根节点入队 que.offer(root); while(!que.isEmpty()) { // 设置每一层的最大值 int max=Integer.MIN_VALUE; int size=que.size(); for(int i=0;i\u0026lt;size;i++) { TreeNode temp=que.poll(); if(temp.val\u0026gt;max) max=temp.val; if(temp.left!=null) que.offer(temp.left); if(temp.right!=null) que.offer(temp.right); } // 遍历完一层后将最大值放入队列中 res.add(max); } return res; } } 二叉树的深度问题 二叉树的最大深度是根节点到最远叶子节点的最长路径上的节点数。只有一个节点的二叉树深度为1\n最大深度问题 leetcode 104 二叉树的最大深度 题目描述\n力扣题目链接(opens new window)\n给定一个二叉树，找出其最大深度。\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n说明: 叶子节点是指没有子节点的节点。\n示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n返回它的最大深度 3 。\n思路解析\n本题可以从迭代和递归两个角度思考\n迭代法\n因为最大的深度就是二叉树的层数，和层序遍历的方式相似。在二叉树中，一层一层的来遍历二叉树，记录一下遍历的层数就是二叉树的深度\n迭代法参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int maxDepth(TreeNode root) { int depth=0; if(root==null)return 0; Queue\u0026lt;TreeNode\u0026gt;que=new LinkedList\u0026lt;\u0026gt;(); que.offer(root); while(!que.isEmpty()) { // 进行每一层遍历前的操作 int size=que.size(); depth++; for(int i=0;i\u0026lt;size;i++) { TreeNode temp=que.poll(); if(temp.left!=null)que.offer(temp.left); if(temp.right!=null)que.offer(temp.right); } } return depth; } } 递归法\n根据递归的模板逐步确定思路\n确定递归函数的参数和返回值： 由题可知递归函数的参数为树的根节点，返回值为根的深度 确定终止条件： 如果为空节点的话，就返回0，表示高度为0。 确定单层递归的逻辑： 求最大深度可以转换为求根高度，求高度通常采用后序遍历 左节点的处理：先计算左子树的高度 右节点的处理：再计算右子树的高度 中节点的处理：选取左右子树高度的最大值加1（中间节点） 本质上求深度应当使用前序遍历 中节点的处理：让当前层级递增，处理当前层级和最大深度的关系 左节点的处理：计算左子树的层数 右节点的处理：计算右子树的层数 最后回溯层数 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // 后序遍历法 class Solution { public int maxDepth(TreeNode root) { int depth=0; // 设置终止条件 if(root==null) return 0; // 单次遍历逻辑：后序遍历 int leftDepth=maxDepth(root.left); // 处理左子树 int rightDepth=maxDepth(root.right); // 处理右子树 return Math.max(leftDepth,rightDepth)+1; // 处理中间节点 } } // 前序遍历法 class Solution { int maxDepth=0; public int maxDepth(TreeNode root) { dfs(root,0); return maxDepth; } // depth为当前节点的层级 public void dfs(TreeNode root,int depth) { // 终止条件 if(root==null) return; // 中间节点处理 depth++; //层级递增 maxDepth=maxDepth\u0026gt;depth?maxDepth:depth; // 计算最大深度 // 处理左节点 dfs(root.left,depth); // 处理右节点 dfs(root.right,depth); } } 最小深度问题 二叉树的最小深度是从根节点到最近叶子节点的最短路径上的节点数量。。只有一个节点的二叉树深度为1。\nleetcode 111 二叉树的最小深度 题目描述\n力扣题目链接(opens new window)\n给定一个二叉树，找出其最小深度。\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n说明: 叶子节点是指没有子节点的节点。\n示例:\n给定二叉树 [3,9,20,null,null,15,7],\n返回它的最小深度 2.\n思路解析\n本题可以从迭代和递归两个角度思考\n迭代法\n因为深度可以用二叉树的层数，和层序遍历的方式相似。在二叉树中，一层一层的来遍历二叉树，遍历到没有左右子节点的节点就停止记录\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int minDepth(TreeNode root) { int depth=0; if(root==null)return depth; Queue\u0026lt;TreeNode\u0026gt;que=new LinkedList\u0026lt;\u0026gt;(); que.offer(root); while(!que.isEmpty()) { int size=que.size(); depth++; for(int i=0;i\u0026lt;size;i++) { TreeNode temp=que.poll(); if(temp.left==null\u0026amp;\u0026amp;temp.right==null) return depth; if(temp.left!=null)que.offer(temp.left); if(temp.right!=null)que.offer(temp.right); } } return depth; } } 递归法\n确定递归函数的参数和返回值： 由题可知递归函数的参数为树的根节点，返回值为根的深度 确定终止条件： 如果为空节点的话，就返回0，表示高度为0。 确定单层递归的逻辑： 求最大深度可以转换为求根高度，求高度通常采用后序遍历 左节点的处理：先计算左子树的高度 右节点的处理：再计算右子树的高度 中节点的处理： 当左节点为空选取右子树的高度 当右节点为空选取左子树的高度 选取左右子树高度的较小值+1 本质上求深度应当使用前序遍历 中节点的处理：让当前层级递增，判断是否为叶子节点，若为叶子节点处理当前层级和最大深度的关系 左节点的处理：计算左子树的层数 右节点的处理：计算右子树的层数 最后回溯层数 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // 前序遍历 class Solution { int minDepth=Integer.MAX_VALUE; public int minDepth(TreeNode root) { if(root==null) return 0; dfs(root,0); return minDepth; } public void dfs(TreeNode root,int depth) { // 设置终止条件 if(root==null) return; // 中节点处理 depth++; if(root.left==null\u0026amp;\u0026amp;root.right==null) // 判断是否为叶子节点 minDepth=Math.min(minDepth,depth); // 左节点处理 dfs(root.left,depth); // 右节点处理 dfs(root.right,depth); } } // 后序遍历 class Solution { public int minDepth(TreeNode root) { if(root==null) return 0; // 处理左节点 int leftLength=minDepth(root.left); // 处理右节点 int rightLength=minDepth(root.right); // 处理中节点 if(root.left==null) return rightLength+1; if(root.right==null) return leftLength+1; return Math.min(leftLength,rightLength)+1; } } 二叉树的翻转和对称操作 leetcode 226 翻转二叉树 题目描述 力扣题目链接(opens new window)\n翻转一棵二叉树。\n递归法解析 本题可以从递归的思路去思考\n从递归的角度思考，本题适合使用后序遍历。后序遍历的遍历顺序是左右中。本题只需要将每个节点的左右子节点反转即可。左右中的遍历顺序可以保证所有节点不会被反转两次\n参考代码（递归法） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public TreeNode invertTree(TreeNode root) { // 确定终止条件 if(root==null) return root; // 遍历过程（后序遍历） invertTree(root.left); // 处理左节点 invertTree(root.right);// 处理右节点 swapChildren(root);// 交换根节点的两个子节点 return root; } private void swapChildren(TreeNode root) { TreeNode tmp = root.left; root.left = root.right; root.right = tmp; } } 迭代法解析 本题可以从迭代的角度思考，本题只需要将每个节点的左右子节点反转即可，可以考虑使用层次遍历\n参考代码（迭代法） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public TreeNode invertTree(TreeNode root) { if(root==null)return root; Queue\u0026lt;TreeNode\u0026gt;que=new LinkedList\u0026lt;\u0026gt;(); que.offer(root); while(!que.isEmpty()) { int size=que.size(); for(int i=0;i\u0026lt;size;i++) { TreeNode temp=que.poll(); swapChildren(temp); if(temp.left!=null) que.offer(temp.left); if(temp.right!=null) que.offer(temp.right); } } return root; } private void swapChildren(TreeNode root) { TreeNode tmp = root.left; root.left = root.right; root.right = tmp; } } leetcode 101 对称二叉树 题目描述 力扣题目链接(opens new window)\n给定一个二叉树，检查它是否是镜像对称的。\n思路解析 本题从递归的角度思考，对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，其实要比较的是两个树（这两个树是根节点的左右子树）。因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。\n确定递归函数的参数和返回值： 由题可知递归函数的参数为两棵树的根节点，返回值为boolean变量表示以该节点为根节点的子树是否对称 确定终止条件： 若两棵树均为空节点的话，就返回true。 若两棵树的左右节点分别有一个为null，就返回false 若两棵树的左右节点均不为空，但是两个节点的值不同，就返回false 确定单层递归的逻辑： 比较外侧节点：比较左侧节点的左节点和右侧节点的右节点 比较内侧节点：比较左侧节点的右节点和左侧节点的左节点 返回外侧节点和内测节点的与运算 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public boolean isSymmetric(TreeNode root) { return compare(root,root); } public boolean compare(TreeNode left,TreeNode right) { // 设置终止条件 if(left==null\u0026amp;\u0026amp;right==null) return true; else if(left!=null\u0026amp;\u0026amp;right==null) return false; else if(left==null\u0026amp;\u0026amp;right!=null) return false; else if(left!=null\u0026amp;\u0026amp;right!=null\u0026amp;\u0026amp;left.val!=right.val) return false; boolean outSide=compare(left.left,right.right); boolean inSide=compare(left.right,right.left); return inSide\u0026amp;\u0026amp;outSide; } } 二叉树的比较问题 leetcode 100 相同的树 题目描述 力扣题目链接(opens new window)\n给定两个二叉树，编写一个函数来检验它们是否相同。\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n思路解析 本题使用后序遍历的方式进行递归，因为本题适合从左右节点开始比较，并将比较结果汇总中间节点\n确定递归函数的参数和返回值： 由题可知递归函数的参数为两棵树的根节点，返回值为boolean变量表示以该节点为根节点的子树是否对称 确定终止条件： 若两棵树均为空节点的话，就返回true。 若两棵树的左右节点分别有一个为null，就返回false 若两棵树的左右节点均不为空，但是两个节点的值不同，就返回false 确定单层递归的逻辑： 比较左侧节点：比较两棵树左侧节点 比较右侧节点：比较两棵树右侧节点 返回左侧节点和右测节点的与运算 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { //终止条件 if(p==null\u0026amp;\u0026amp;q==null)return true; else if(p==null\u0026amp;\u0026amp;q!=null)return false; else if(p!=null\u0026amp;\u0026amp;q==null)return false; else if(p.val!=q.val)return false; // 单次遍历逻辑（后序遍历） boolean left=isSameTree(p.left,q.left); // 处理左节点 boolean right=isSameTree(p.right,q.right);// 处理右节点 return left\u0026amp;\u0026amp;right; //处理中间节点 } } leetcode 572 另一棵树的子树 题目描述 给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。\n二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。\n示例 1：\n1 2 输入：root = [3,4,5,1,2], subRoot = [4,1,2] 输出：true 示例 2：\n1 2 输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2] 输出：false 提示：\nroot 树上的节点数量范围是 [1, 2000] subRoot 树上的节点数量范围是 [1, 1000] -104 \u0026lt;= root.val \u0026lt;= 104 -104 \u0026lt;= subRoot.val \u0026lt;= 104 思路解析 本题适合使用后序遍历，遍历 s 中的每一个节点，判断这个点的子树是否和 t 相等。这个过程单独作为一个递归函数\n判断一个节点的子树是否和 t 相等的过程则作为另一个递归函数\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public boolean isSubtree(TreeNode root, TreeNode subRoot) { // 设置终止条件 if(root==null) return false; if(subRoot==null) return true; // 单层遍历 boolean left=isSubtree(root.left,subRoot); // 左节点 boolean right=isSubtree(root.right,subRoot); // 右节点 return left||right||check(root,subRoot); // 中节点 } // 检测两个树是否相同 public boolean check(TreeNode root,TreeNode subRoot) { // 设置终止条件 if(root==null\u0026amp;\u0026amp;subRoot==null) return true; else if(root==null\u0026amp;\u0026amp;subRoot!=null) return false; else if(root!=null\u0026amp;\u0026amp;subRoot==null) return false; else if(root.val!=subRoot.val) return false; // 后序遍历 boolean left=check(root.left,subRoot.left); boolean right=check(root.right,subRoot.right); return left\u0026amp;\u0026amp;right; } } 二叉树的节点计数问题 leetcode 222 完全二叉树的节点个数 题目描述 力扣题目链接(opens new window)\n给出一个完全二叉树，求出该树的节点个数。\n示例 1：\n输入：root = [1,2,3,4,5,6] 输出：6 示例 2：\n输入：root = [] 输出：0 示例 3：\n输入：root = [1] 输出：1 提示：\n树中节点的数目范围是[0, 5 * 10^4] 0 \u0026lt;= Node.val \u0026lt;= 5 * 10^4 题目数据保证输入的树是 完全二叉树 思路解析 本题适合使用后序遍历，因为可以先分别统计左子树和右子树的节点个数，再将两个子树的节点个数相加再加一（中间节点）\n确定递归函数的参数和返回值： 由题可知递归函数的参数为树的根节点，返回值为int变量表示以该节点为根节点的子树的节点个数 确定终止条件： 若遍历到空节点的话，就返回0。 确定单层递归的逻辑： 处理左节点：计算左子树的节点个数 处理右节点：计算右子树节点个数 处理中间节点：将左右两个子树的节点个数相加再加一 参考代码 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int countNodes(TreeNode root) { // 设置终止条件 if(root==null) return 0; // 单层遍历(后序遍历) int leftCount=countNodes(root.left); // 计算左子树的节点个数 int rightCount=countNodes(root.right); // 计算右子树的节点个数 return leftCount+rightCount+1; // 处理中间节点 } } leetcode 404 左叶子之和 题目描述 力扣题目链接(opens new window)\n计算给定二叉树的所有左叶子之和。\n示例：\n思路解析 本题使用后序遍历，通过递归函数的返回值来累加求取左叶子数值之和\n确定递归函数的参数和返回值： 由题可知递归函数的参数为树的根节点，记录单个节点的左叶子之和\n确定终止条件：\n若遍历到空节点的话，返回0 确定单层递归的逻辑：\n处理左节点：\n递归计算左节点 处理右节点\n递归计算右节点 处理中间节点\n当中间节点的左节点没有子节点，加入该节点的值 最后加入中间节点的值和左右节点的计算结果 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int sumOfLeftLeaves(TreeNode root) { if(root==null)return 0; return sum(root); } public int sum(TreeNode root) { // 终止条件 if(root==null) return 0; // 单层遍历 int left=sum(root.left); int right=sum(root.right); int mid=0; if(root.left!=null\u0026amp;\u0026amp;root.left.left==null\u0026amp;\u0026amp;root.left.right==null) mid=root.left.val; return left+right+mid; } } leetcode 513 找树左下角的值 题目描述 力扣题目链接(opens new window)\n给定一个二叉树，在树的最后一行找到最左边的值。\n示例 1:\n示例 2:\n迭代法解析 可以使用层次遍历的方法，将每一层的最左边的值保留，并随着层次进行更新\n参考代码（迭代法） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public int findBottomLeftValue(TreeNode root) { int ans=0; if(root==null) return ans; Queue\u0026lt;TreeNode\u0026gt;queue=new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); while(!queue.isEmpty()) { int size=queue.size(); for(int i=0;i\u0026lt;size;i++) { TreeNode temp=queue.poll(); if(i==0) { ans=temp.val; } if(temp.left!=null) { queue.offer(temp.left); } if(temp.right!=null) { queue.offer(temp.right); } } } return ans; } } 递归法解析 确定递归函数的参数和返回值： 递归函数的参数为树的根节点以及当前节点的深度，返回值为void\n确定终止条件：\n若遍历到空节点的话，就返回 确定单层递归的逻辑：\n处理中节点：\n层级递增 更新最大深度 更新最左侧节点的值 处理左节点\n处理右节点\n回溯\n二叉树的高度问题 二叉树的高度通常使用后序遍历，因为高度是节点到根节点的距离，通常由由左右节点先中间节点开始计算\nleetcode 101 平衡二叉树 题目描述 力扣题目链接(opens new window)\n给定一个二叉树，判断它是否是高度平衡的二叉树。\n本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。\n示例 1:\n给定二叉树 [3,9,20,null,null,15,7]\n返回 true 。\n示例 2:\n给定二叉树 [1,2,2,3,3,null,null,4,4]\n返回 false 。\n思路解析 本题适合使用后序遍历，因为可以先分别统计左节点和右节点的高度，在中间节点将两个节点的高度进行比较，若平衡则返回节点的高度，不平衡返回-1\n确定递归函数的参数和返回值： 由题可知递归函数的参数为树的根节点，返回值为int变量表示以该节点的高度 确定终止条件： 若遍历到空节点的话，就返回0。 确定单层递归的逻辑： 处理左节点： 计算左节点的高度 若左节点不平衡直接返回-1 处理右节点 计算右节点的高度 若右节点不平衡直接返回-1 处理中间节点 计算左右节点的高度差 若不平衡返回-1 若平衡返回左右节点高度的较大者+1； 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public boolean isBalanced(TreeNode root) { return getHeight(root)!=-1; } public int getHeight(TreeNode root) { if(root==null) return 0; // 单层遍历 int left=getHeight(root.left); if(left==-1)return -1; int right=getHeight(root.right); if(right==-1)return -1; return Math.abs(left-right)\u0026gt;1?-1:Math.max(left,right)+1; } } 二叉树的路径问题 通常二叉树的路径计算使用前序遍历，因为通常路径的第一个节点为中间节点，遍历顺序为根左右，同时在左右节点的处理中注意回溯\n统一解题模板 自顶向下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // 一般路径,要求到叶子节点return void traversal(TreeNode root,List\u0026lt;String\u0026gt;res,List\u0026lt;Integer\u0026gt;path) { // 中 path.add(root.val); // 终止条件为到叶子节点 if(root.left==null\u0026amp;\u0026amp;root.right==null) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); } // 单层遍历 if(root.left!=null) { traversal(root.left,res,path); path.remove(path.size()-1); } if(root.right!=null) { traversal(root.right,res,path); path.remove(path.size()-1); } } // 给定和的路径 public void check(TreeNode root,int targetSum,List\u0026lt;Integer\u0026gt;path,List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;res) { path.add(root.val); targetSum-=root.val; // 终止条件 if(root.left==null\u0026amp;\u0026amp;root.right==null) { if(targetSum==0) { res.add(new ArrayList\u0026lt;\u0026gt;(path)); } return; } if(root.left!=null) { check(root.left,targetSum,path,res); // 基本数据类型不需要回溯 path.remove(path.size()-1); } if(root.right!=null) { check(root.right,targetSum,path,res); path.remove(path.size()-1); } } leetcode 257 二叉树的所有路径 题目描述 力扣题目链接(opens new window)\n给定一个二叉树，返回所有从根节点到叶子节点的路径。\n说明: 叶子节点是指没有子节点的节点。\n示例: 思路解析 确定递归函数的参数和返回值： 由题可知递归函数的参数为树的根节点，记录单条路径的集合，结果集，返回值为void\n确定终止条件：\n若遍历到叶子节点的话 先加入叶子节点 将路径集合中的路径转换为字符串 将字符串加入结果集 确定单层递归的逻辑：\n处理中间节点\n加入非叶子节点 处理左节点：\n递归加入左节点 执行完毕后回溯，从路径集合中删除最后一个元素 处理右节点\n递归加入右节点 执行完毕后回溯，从路径集合中删除最后一个元素 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public List\u0026lt;String\u0026gt; binaryTreePaths(TreeNode root) { List\u0026lt;String\u0026gt;res=new ArrayList\u0026lt;\u0026gt;(); if(root==null) return res; List\u0026lt;Integer\u0026gt;path=new ArrayList\u0026lt;\u0026gt;(); traversal(root,res,path); return res; } void traversal(TreeNode root,List\u0026lt;String\u0026gt;res,List\u0026lt;Integer\u0026gt;path) { // 终止条件 if(root.left==null\u0026amp;\u0026amp;root.right==null) { path.add(root.val); StringBuilder sb=new StringBuilder(); for(int i=0;i\u0026lt;path.size()-1;i++) { sb.append(path.get(i)).append(\u0026#34;-\u0026gt;\u0026#34;); } sb.append(path.get(path.size()-1)); res.add(sb.toString()); } // 单层遍历 // 添加非叶子节点 if(root.left!=null||root.right!=null) path.add(root.val); if(root.left!=null) { traversal(root.left,res,path); path.remove(path.size()-1); } if(root.right!=null) { traversal(root.right,res,path); path.remove(path.size()-1); } } } leetcode 112 路径总和 题目描述 力扣题目链接(opens new window)\n给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。\n说明: 叶子节点是指没有子节点的节点。\n示例: 给定如下二叉树，以及目标和 sum = 22，\n返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-\u0026gt;4-\u0026gt;11-\u0026gt;2。\n思路解析 本题应当使用前序遍历，因为路径从根节点开始。\n确定递归函数的参数和返回值： 由题可知递归函数的参数为树的根节点和目标和，记录单条路径的集合，结果集，返回值为boolean\n确定终止条件：\n若遍历到叶子节点的话 先加入叶子节点到路径和中 判断路径和和目标和的大小 确定单层递归的逻辑：\n处理中间节点\n加入非叶子节点 处理左节点：\n递归加入左节点，判断是否找到合适路径，直接返回 执行完毕后回溯，从路径和中删除最后一个元素 处理右节点\n递归加入右节点，判断是否找到合适路径，直接返回 执行完毕后回溯，从路径和中删除最后一个元素 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { int sum=0; public boolean hasPathSum(TreeNode root, int targetSum) { if(root==null)return false; // 设置终止条件 if(root.left==null\u0026amp;\u0026amp;root.right==null) { sum+=root.val; return sum==targetSum; } // 设置中间节点 if(root.left!=null||root.right!=null) { sum+=root.val; } // 处理左节点 if(root.left!=null) { boolean left=hasPathSum(root.left,targetSum); if(left)return true; sum-=root.left.val; } if(root.right!=null) { boolean right=hasPathSum(root.right,targetSum); if(right) return true; sum-=root.right.val; } return false; } } leetcode 113 路径总和 II 题目描述 力扣题目链接(opens new window)\n给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。\n说明: 叶子节点是指没有子节点的节点。\n示例: 给定如下二叉树，以及目标和 sum = 22，\n思路解析 本题应当使用前序遍历，因为路径从根节点开始。\n确定递归函数的参数和返回值： 由题可知递归函数的参数为树的根节点和目标和路径集合和答案集合，记录单条路径的集合，结果集，返回值为void\n确定终止条件：\n若遍历到叶子节点的话 先加入叶子节点到路径和，路径集合中 判断路径和与目标和的大小，符合条件加入答案集合中，注意要复制路径集，不然路径集会因为回溯而清空 确定单层递归的逻辑：\n处理中间节点\n加入非叶子节点到路径集合 加入非叶子节点的值 处理左节点：\n递归加入左节点 执行完毕后回溯 从路径和中删除最后一个元素的值 从路径集合中删除最后一个元素 处理右节点\n递归加入右节点\n执行完毕后回溯\n从路径和中删除最后一个元素的值\n从路径集合中删除最后一个元素\n参考代码 二叉树的构造 leetcode 106 从中序和后序遍历构造二叉树 题目描述 力扣题目链接(opens new window)\n根据一棵树的中序遍历与后序遍历构造二叉树。\n注意: 你可以假设树中没有重复的元素。\n例如，给出\n中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树： 思路解析 实现思路就是以后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来再切后序数组。一层一层切下去，每次后序数组最后一个元素就是节点元素。\n根据树的构造顺序可知本题使用前序遍历。同时在构造时注意数组的边界问题，建议使用左闭右闭的区间。\n确定递归函数的参数和返回值：\n递归函数的参数\n中序数组\n中序数组的起点\n中序数组的终点\n后序数组\n后序数组的起点\n后序数组的终点\n返回值为树节点\n确定终止条件：\n若终点\u0026lt;起点代表数组中不存在元素，返回null 确定单层递归的逻辑：\n处理中间节点\n选取后序数组的终点作为中间节点的值，并将根据这个值在中序数组的位置（ rootIndex ）切分为左右子树两个部分\n左子树部分（长度为 rootIndex-inStart ）\n中序数组\n起点：中序数组的起点\n终点：中序数组的 rootIndex 的前一位（ rootIndex-1 ）\n后序数组\n起点：后序数组的起点 终点：后序数组的起点+左子树的长度-1 右子树部分\n中序数组 起点： rootIndex+1 终点：中序数组的起点 后序数组 起点：后序数组的起点+左子树的长度 终点：后序数组的终点-1 处理左节点：\n递归处理左节点 处理右节点\n递归处理右节点 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { HashMap\u0026lt;Integer,Integer\u0026gt;map=new HashMap\u0026lt;\u0026gt;(); public TreeNode buildTree(int[] inorder, int[] postorder) { for(int i=0;i\u0026lt;inorder.length;i++) { map.put(inorder[i],i); } return findNode(inorder,0,inorder.length-1,postorder,0,postorder.length-1); } // 左闭右闭 public TreeNode findNode(int[]inorder,int inStart,int inEnd,int[] postorder,int postStart,int postEnd) { // 终止条件 if(inEnd\u0026lt;inStart||postEnd\u0026lt;postStart) return null; // 单层遍历：前序遍历 // 处理中间节点 int rootIndex=map.get(postorder[postEnd]); TreeNode root=new TreeNode(postorder[postEnd]); // 求解左子树的长度 int length=rootIndex-inStart; // 确定左子树的起点和终点 int leftInorderStart=inStart; int leftInorderEnd=rootIndex-1; int leftPostorderStart=postStart; int leftPostorderEnd=postStart+length-1; // 确定右子树的起点和终点 int rightInorderStart=rootIndex+1; int rightInorderEnd=inEnd; int rightPostorderStart=postStart+length; int rightPostorderEnd=postEnd-1; root.left=findNode(inorder,leftInorderStart,leftInorderEnd,postorder,leftPostorderStart,leftPostorderEnd); root.right=findNode(inorder,rightInorderStart,rightInorderEnd,postorder,rightPostorderStart,rightPostorderEnd); return root; } } leetcode 105 从中序和前序遍历构造二叉树 题目描述 力扣题目链接(opens new window)\n根据一棵树的前序遍历与中序遍历构造二叉树。\n注意: 你可以假设树中没有重复的元素。\n例如，给出\n前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树：\n思路解析 与上一题一样，但是顺序不同。以前序数组的第一个元素为切割点，先切中序数组，根据中序数组，反过来再切前序数组。一层一层切下去，每次前序数组第一个元素就是节点元素。\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { HashMap\u0026lt;Integer,Integer\u0026gt;map=new HashMap\u0026lt;\u0026gt;(); public TreeNode buildTree(int[] preorder, int[] inorder) { for(int i=0;i\u0026lt;inorder.length;i++) { map.put(inorder[i],i); } return findNode(preorder,0,preorder.length-1,inorder,0,inorder.length-1); } public TreeNode findNode(int []preorder,int preBegin,int preEnd,int[]inorder,int inBegin,int inEnd) { // 递归终止条件 if(preEnd\u0026lt;preBegin||inEnd\u0026lt;inBegin) { return null; } // 中间节点构造 int rootIndex=map.get(preorder[preBegin]); TreeNode root=new TreeNode(preorder[preBegin]); // 计算左子树的节点个数 int length=rootIndex-inBegin; // 确定左子树的起点和终点 int leftInorderBegin=inBegin; int leftInorderEnd=rootIndex-1; int leftPreorederBegin=preBegin+1; int leftPreorderEnd=preBegin+length; // 确定右子树的起点和终点 int rightInorderBegin=rootIndex+1; int rightInorderEnd=inEnd ; int rightPreorderBegin=preBegin+length+1; int rightPreorderEnd=preEnd; root.left=findNode(preorder,leftPreorederBegin,leftPreorderEnd,inorder,leftInorderBegin,leftInorderEnd); root.right=findNode(preorder,rightPreorderBegin,rightPreorderEnd,inorder,rightInorderBegin,rightInorderEnd); return root; } } leetcode 654 最大二叉树 题目描述 力扣题目地址(opens new window)\n给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：\n二叉树的根是数组中的最大元素。 左子树是通过数组中最大值左边部分构造出的最大二叉树。 右子树是通过数组中最大值右边部分构造出的最大二叉树。 通过给定的数组构建最大二叉树，并且输出这个树的根节点。\n示例 ：\n提示：\n给定的数组的大小在 [1, 1000] 之间。\n思路解析 本题依然是根据题意进行数组切割，但是要注意数组的边界问题。这是使用数组下标的左闭右闭区间\n确定递归函数的参数和返回值：\n参数 待切割的数组\n数组的左指针\n数组的右指针\n确定终止条件： 当左指针大于右指针说明数组没有元素了，递归终止\n确定单层递归的逻辑：\n对中间节点的处理 求解区间内的最大值及其下标，并建立中间节点 对左节点的处理 递归求解左半数组 对右节点的处理 递归求解右半数组 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public TreeNode constructMaximumBinaryTree(int[] nums) { return traversal(nums,0,nums.length-1); } public TreeNode traversal(int[]num,int left,int right) { // 递归终止条件 if(left\u0026gt;right) return null; // 求解最大值 int maxIndex=0; int maxVal=Integer.MIN_VALUE; for(int i=left;i\u0026lt;=right;i++) { if(num[i]\u0026gt;maxVal) { maxIndex=i; maxVal=num[i]; } } TreeNode root=new TreeNode(maxVal); root.left=traversal(num,left,maxIndex-1); root.right=traversal(num,maxIndex+1,right); return root; } } 二叉搜索树 根据二叉搜索树的特性，通常使用中序遍历。因为二叉搜索树的中序遍历结果是一个单调递增数列。通常为了保存前一个节点的指会设置一个全局遍历 pre 来保存\nleetcode 98 验证二叉搜索树 题目描述 力扣题目链接(opens new window)\n给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n假设一个二叉搜索树具有如下特征：\n节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 思路解析 可以利用二叉搜索树的性质，对二叉搜索树进行中序遍历，然后检验遍历结果是否为单调递增的数组\n但是可以在中序遍历的过程中判断，因为中序遍历的结果是递增，所以可以使用一个全局的pre值保存上一个节点的节点值，比较和上一个节点的大小关系\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { long maxVal = Long.MIN_VALUE; public boolean isValidBST(TreeNode root) { // 终止条件 if(root==null) return true; boolean left=isValidBST(root.left); if(root.val\u0026gt;maxVal) maxVal=root.val; else return false; boolean right=isValidBST(root.right); return left\u0026amp;right; } } leetcode 530 二叉搜索树的最小绝对差 题目描述 力扣题目链接(opens new window)\n给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。\n示例：\n提示：树中至少有 2 个节点。\n思路解析 根据二叉搜索树的性质，最小绝对值差是两个在中序遍历结果中相邻的节点。可以使用一个全局变量存储上一个节点，来进行比较\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { int res=Integer.MAX_VALUE; TreeNode pre; public int getMinimumDifference(TreeNode root) { if(root==null) return 0; traversal(root); return res; } public void traversal(TreeNode root) { // 终止条件 if(root==null) return; // 单层遍历 traversal(root.left); if(pre!=null) { // 更新结果 res=Math.min(res,root.val-pre.val); } pre=root; traversal(root.right); } } leetcode 501 二叉搜索树中的众数 题目描述 力扣题目链接(opens new window)\n给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。\n假定 BST 有如下定义：\n结点左子树中所含结点的值小于等于当前结点的值 结点右子树中所含结点的值大于等于当前结点的值 左子树和右子树都是二叉搜索树 例如：\n给定 BST [1,null,2,2],\n返回[2].\n提示：如果众数超过1个，不需考虑输出顺序\n进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）\n思路解析 确定递归函数的参数和返回值：\n参数：树节点 返回值：void 确定终止条件： 遍历到空节点，递归终止\n确定单层递归的逻辑：\n对中间节点的处理 若与上一个节点的值一致则重新计数，否则计数加一 若比众数大则清空原先的众数集合，并更新众数，同时更新众数的值 对左节点的处理 递归求解左节点 对右节点的处理 递归求解右节点 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { ArrayList\u0026lt;Integer\u0026gt;resList; int maxCount; int count; TreeNode pre; public int[] findMode(TreeNode root) { maxCount=0; count=0; resList=new ArrayList\u0026lt;\u0026gt;(); pre=null; check(root); int[]res=new int[resList.size()]; for(int i=0;i\u0026lt;resList.size();i++) { res[i]=resList.get(i); } return res; } public void check(TreeNode root) { // 终止条件 if(root==null) return; // 中序遍历 check(root.left); int rootVal=root.val; // 计数逻辑 if(pre==null||rootVal!=pre.val) { count=1; }else{ count++; } // 更新结果 if(maxCount\u0026lt;count) { resList.clear(); resList.add(rootVal); maxCount=count; }else if(maxCount==count) { resList.add(rootVal); } pre=root; check(root.right); } } leetcode 701 二叉搜索树的插入 题目描述 力扣题目链接(opens new window)\n给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。\n注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。\n提示：\n给定的树上的节点数介于 0 和 10^4 之间 每个节点都有一个唯一整数值，取值范围从 0 到 10^8 -10^8 \u0026lt;= val \u0026lt;= 10^8 新值和原始二叉搜索树中的任意节点值都不同 思路解析 确定递归函数参数以及返回值 参数就是根节点指针，以及要插入元素 返回值为树的节点 终止条件 遇到空节点时代表找到插入位置直接返回新节点 单次递归逻辑 若当前节点的值小于目标值，向右递归，将当前节点的右节点设置为递归结果 若当前节点的值大于目标值，向左递归，将当前节点的左节点设置为递归结果 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { //终止条件 if(root==null) return new TreeNode(val); // 单次递归 if(root.val\u0026lt;val) root.right=insertIntoBST(root.right,val); if(root.val\u0026gt;val) root.left=insertIntoBST(root.left,val); return root; } } leetcode 450 二叉搜索树中的删除工作 题目描述 力扣题目链接(opens new window)\n给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n一般来说，删除节点可分为两个步骤：\n首先找到需要删除的节点； 如果找到了，删除它。 说明： 要求算法时间复杂度为 $O(h)$，h 为树的高度。\n示例:\n思路解析 确定递归函数参数以及返回值 参数为树的节点和目标值 返回值为树的节点，代表删除节点的新子树 终止条件 遇到空返回null 单次遍历 要删除的节点左节点为空，返回右节点 要删除的节点右节点为空，返回左节点 要删除的节点左右不为空，将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public TreeNode deleteNode(TreeNode root, int key) { if(root==null) return null; if(root.val==key) { if(root.left==null) return root.right; else if(root.right==null) return root.left; else { TreeNode curr=root.right; while(curr.left!=null) curr=curr.left; curr.left=root.left; root=root.right; return root; } } if(root.val\u0026gt;key) root.left=deleteNode(root.left,key); else root.right=deleteNode(root.right,key); return root; } } 最近公共祖先问题 leetcode 236 二叉树的最近公共祖先 题目描述 力扣题目链接(opens new window)\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]\n示例 1: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。\n示例 2: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。\n说明:\n所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 思路解析 通常会想到从左右节点开始查找，再根据左右节点的返回值来指向中间节点的逻辑，所以适合后序遍历。\n判定情况有两种\n如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先 节点本身p(q)，它拥有一个子孙节点q(p) 总体思路如下\n确定递归函数返回值以及参数 返回值为树节点 终止条件 遇到空的话，返回空 如果 root == q，或者 root == p，说明找到 q p ，则将其返回 单层递归逻辑 处理左节点 递归处理左节点 处理右节点 递归处理右节点 处理中节点 若左节点为空，右节点不为空，返回右节点 若左节点不为空，右节点为空，返回左节点 若左右节点为空，返回null 若左右节点不为空，返回当前节点 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { // 终止条件 if(root==null||root==p||root==q) return root; // 后序遍历 TreeNode left=lowestCommonAncestor(root.left,p,q); TreeNode right=lowestCommonAncestor(root.right,p,q); if(left!=null\u0026amp;\u0026amp;right==null) return left; else if(left==null\u0026amp;\u0026amp;right!=null) return right; else if(left==null\u0026amp;\u0026amp;right==null) return null; else return root; } } leetcode 235 二叉搜索树的最近公共祖先 题目描述 力扣题目链接(opens new window)\n给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]\n示例 1:\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2:\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明:\n所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 思路解析 二叉搜索树具有有序性\n因为是有序树，所以 如果 中间节点是 q 和 p 的公共祖先，那么 中节点的数组 一定是在 [p, q]区间的。即 中节点 \u0026gt; p \u0026amp;\u0026amp; 中节点 \u0026lt; q 或者 中节点 \u0026gt; q \u0026amp;\u0026amp; 中节点 \u0026lt; p。\n确定递归函数返回值以及参数 参数就是当前节点，以及两个结点 p、q。 返回值是要返回最近公共祖先， 终止条件 遇到空返回 单层遍历条件 若当前节点的值同时大于p和q，向左遍历 若当前节点的值同时小于p和q，向右遍历 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { return dfs(root,p,q); } public TreeNode dfs(TreeNode root,TreeNode p,TreeNode q) { if(root==null) return null; if(root.val\u0026gt;p.val\u0026amp;\u0026amp;root.val\u0026gt;q.val) return dfs(root.left, p, q); if(root.val\u0026lt;p.val\u0026amp;\u0026amp;root.val\u0026lt;q.val) return dfs(root.right,p,q); return root; } } 二叉树与链表转换问题 leetcode 114 二叉树展开为链表 题目描述 题目链接\n给你二叉树的根结点 root ，请你将它展开为一个单链表：\n展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。 示例 1：\n1 2 输入：root = [1,2,5,3,4,null,6] 输出：[1,null,2,null,3,null,4,null,5,null,6] 示例 2：\n1 2 输入：root = [] 输出：[] 示例 3：\n1 2 输入：root = [0] 输出：[0] 提示：\n树中结点数在范围 [0, 2000] 内 -100 \u0026lt;= Node.val \u0026lt;= 100 **进阶：**你可以使用原地算法（O(1) 额外空间）展开这棵树吗？\n思路解析 利用递归的方法将树的前序遍历结果放入结果集合中，然后再基于结果集重新构建链表\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { List\u0026lt;TreeNode\u0026gt;res; public void flatten(TreeNode root) { res=new ArrayList\u0026lt;\u0026gt;(); dfs(root); for(int i=1;i\u0026lt;res.size();i++) { TreeNode prev=res.get(i-1); TreeNode curr=res.get(i); prev.left=null; prev.right=curr; } } public void dfs(TreeNode root) { if(root==null) return; res.add(root); dfs(root.left); dfs(root.right); } } BM30 二叉搜索树与双向链表 题目描述 题目链接\n输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示\n数据范围：输入二叉树的节点数 0≤n≤10000≤n≤1000，二叉树中每个节点的值 0≤val≤10000≤val≤1000 要求：空间复杂度O(1)O(1)（即在原树上操作），时间复杂度 O(n)O(n)\n注意:\n1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继 2.返回链表中的第一个节点的指针 3.函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构\n4.你不用输出双向链表，程序会根据你的返回值自动打印输出\n输入描述：\n二叉树的根节点\n返回值描述：\n双向链表的其中一个头节点。\n示例1\n输入：\n1 {10,6,14,4,8,12,16} 返回值：\n1 From left to right are:4,6,8,10,12,14,16;From right to left are:16,14,12,10,8,6,4; 说明：\n1 输入题面图中二叉树，输出的时候将双向链表的头节点返回即可。 示例2\n输入：\n1 {5,4,#,3,#,2,#,1} 返回值：\n1 From left to right are:1,2,3,4,5;From right to left are:5,4,3,2,1; 说明：\n1 2 3 4 5 6 7 8 9 10 5 / 4 / 3 / 2 / 1 树的形状如上图 思路解析 使用一个指针preNode指向当前结点root的前继 确定递归函数返回值以及参数 返回值为void，不需要利用递归值 终止条件 遇到空的话，返回空 单层递归逻辑：使用中序遍历 处理左节点 递归处理左节点 处理中节点 对于当前结点root，有root-\u0026gt;left要指向前继preNode preNode-\u0026gt;right要指向当前结点 更新preNode 处理右节点 递归处理右节点 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Solution { TreeNode preRoot; public TreeNode Convert(TreeNode pRootOfTree) { if (pRootOfTree == null) return null; TreeNode root = pRootOfTree; while (root.left != null) { root = root.left; } inorder(pRootOfTree); return root; } public void inorder(TreeNode root) { if (root == null) return; inorder(root.left); root.left = preRoot; if (preRoot != null) { preRoot.right = root; } preRoot = root; inorder(root.right); } } ","date":"2025-02-13T17:30:22+08:00","permalink":"https://Tyritic.github.io/p/%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"二叉树"},{"content":"进程 在系统中正在运行的一个应用程序；程序一旦运行会被载入内存。进程是资源分配的最小单位。在操作系统中能同时运行多个进程；\n进程可以分成以下两类\n用户态进程 ：通常是应用程序的副本 内核态进程 ：内核本身的进程。 如果用户态进程需要申请资源，比如内存，可以通过系统调用向内核申请。\n每个进程都有独立的内存空间，存放代码和数据段等，程序之间的切换会有较大的开销\n并发和并行 并发：在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行。 单核处理器做到的并发，其实是利用时间片的轮转，例如有两个进程 A 和 B，A 运行一个时间片之后，切换到 B，B 运行一个时间片之后又切换到 A。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。 并行：在同一时刻，有多个任务在执行。这个需要多核处理器才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。 行\n进程之间是独立和隔离的，一个进程崩溃不会导致所有进程崩溃\n进程隔离性：每个进程都有自己独立的内存空间，当一个进程崩溃时，其内存空间会被操作系统回收，不会影响其他进程的内存空间。这种进程间的隔离性保证了一个进程崩溃不会直接影响其他进程的执行。 进程独立性：每个进程都是独立运行的，它们之间不会共享资源，如文件、网络连接等。因此，一个进程的崩溃通常不会对其他进程的资源产生影响。 进程的状态 进程状态 创建状态（new）：进程正在被创建时的状态\n就绪状态（Ready）：进程处于可运行，进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。由于其他进程处于运行状态而暂时停止运行\n运行状态（Running）：进程正在处理器上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)\n阻塞状态（Blocked）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行\n结束状态（Exit）：进程正在从系统中消失时的状态\n进程挂起 如果有大量处于阻塞状态的进程，进程可能会占用着物理内存空间，出现浪费物理内存的行为。所以，在虚拟内存管理的操作系统中，通常会把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存。\n挂起状态用来描述 进程没有占用实际的物理内存空间的情况\n阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现 就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行 僵尸进程 僵尸进程是已完成且处于终止状态，但在进程表中却仍然存在的进程。（进程已经终止，但其父进程未对其进行回收）\n僵尸进程占用系统的进程表项，但不再消耗其他资源。操作系统会等待其父进程来获取它的终止状态信息，清除僵尸进程。\n僵尸进程一般发生有父子关系的进程中，一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid() ，那么子进程的进程描述符仍然保存在系统中。\n孤儿进程 父进程提前终止，子进程继续运行，这些子进程就成为孤儿进程。操作系统会将孤儿进程托管给 init 进程（Linux系统中的PID为1的进程），由 init 进程来收养并清理这些孤儿进程。\n进程控制块PCB PCB 是进程存在的唯一标识 。一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。\nPCB的结构 进程描述信息\n进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；\n用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；\n进程控制和管理信息\n进程当前状态\n进程优先级：进程抢占 CPU 时的优先级；\n资源分配清单\n有关内存地址空间或虚拟地址空间的信息\n所打开文件的列表和所使用的 I/O 设备信息。\nCPU 相关信息\nCPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。 PCB之间的组织 通常是通过 链表 的方式进行组织。相同状态的进程会被链接在一起，组成各种队列\n进程的控制 创建进程 操作系统提供了 fork 指令，允许一个进程创建另一个进程，而且允许子进程继承父进程所拥有的资源。\nfork 函数用于创建一个与当前进程一样的子进程，所创建的子进程将复制父进程的代码段、数据段、堆、栈等所有用户空间信息，在内核中操作系统会重新为其申请一个子进程执行的位置。但是会有自己的进程空间\nfork 函数被调用一次但返回两次，两次返回的唯一区别是子进程中返回0而父进程中返回子进程ID。\n提示\nfork函数为什么被调用一次但是返回两次\n因为复制时会复制父进程的堆栈段，所以两个进程都停留在 fork 函数中等待返回，因此会返回两次，一个是在父进程中返回，一次是在子进程中返回，两次返回值是不一样的。\n在父进程中将返回新建子进程的进程ID 在子进程中将返回0 若出现错误则返回一个负数 fork 的具体流程\n申请一个空白的 PCB，并向 PCB 中填写一些控制和管理进程的信息，比如进程的唯一标识等； 为该进程分配运行时所必需的资源，比如内存资源； 将 PCB 插入到就绪队列，等待被调度运行； 终止进程 进程有以下三种结束方式\n正常结束 异常结束 外界干预（信号 kill 掉） 当子进程被终止时，其在父进程处继承的资源应当还给父进程。而当父进程被终止时，该父进程的子进程就变为孤儿进程，会被 1 号进程收养，并由 1 号进程对它们完成状态收集工作。\n终止线程的过程\n查找需要终止的进程的 PCB； 如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程； 如果其还有子进程，则应将该进程的子进程交给 1 号进程接管； 将该进程所拥有的全部资源都归还给操作系统； 将其从 PCB 所在队列中删除； 阻塞线程 当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待。而一旦被阻塞等待，它只能由另一个进程唤醒。\n阻塞进程的过程如下：\n找到将要被阻塞进程标识号对应的 PCB； 如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行； 将该 PCB 插入到阻塞队列中去； 唤醒进程 进程只能被另一个进程唤醒，唤醒进程的过程如下\n在该事件的阻塞队列中找到相应进程的 PCB； 将其从阻塞队列中移出，并置其状态为就绪状态； 把该 PCB 插入到就绪队列中，等待调度程序调度； 进程的上下文切换 上下文切换的概念 上下文切换是一种将CPU资源从一个进程分配给另一个进程的机制。\n操作系统需要事先帮 CPU 设置好 CPU 寄存器和程序计数器。CPU 寄存器和程序计数是 CPU 在运行任何任务前所必须依赖的环境，这就是CPU上下文\nCPU 上下文切换就是先把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。\n系统内核会存储保持下来的上下文信息，当此任务再次被分配给 CPU 运行时，CPU 会重新加载这些上下文，这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。\n进程上下文切换过程 进程是由内核管理和调度的，所以进程的切换只能发生在内核态。进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。\n通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行\n进程上下文切换的场景 CPU调度 ：CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行； 系统资源不足 ：进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行； 进程主动挂起 ：当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度； 高优先级进程运行 ：当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行； 发生硬件中断 ：CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序； 进程间通信 每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走。\n命名管道/匿名管道 匿名管道 ：匿名管道是一种单向通信方式，用于在父进程和子进程之间或者同一主机上的不同进程之间传递数据，数据从一端写入，从另一端读取 命名管道 ：是匿名管道的改进版，支持无亲缘关系的进程之间的通信。命名管道是一种存在于文件系统中的特殊文件，通过管道名称可以进行读写操作。适用于需要跨进程通信但不具备亲缘关系的场景。 本质上管道是内核里面的一串缓存\n对于匿名管道来说，匿名管道没有实体，不存在管道文件，只能通过父进程和子进程的文件描述符来进行通信\n对于命名管道来说，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。\n共享内存 共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中 。这样这个进程写入的东西对于另外一个进程是可见的，不需要经过数据的拷贝和传输，大大提高了进程间通信的速度。\n消息队列 消息队列的通信模式适用于频繁地进行信息传输。消息队列允许一个进程向另一个进程发送消息，消息在队列中按顺序存储，并且接收方可以按需接收。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。\n消息队列是保存在内核中的消息链表 ，消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在\n消息队列具有以下缺点\n消息队列不适合比较大数据的传输 ：因为在内核中每个消息体都有一个最大长度的限制 消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销 ：因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。 信号 信号是一种 异步 的通信方式，用于通知目标进程发生了某个事件。信号常用于进程之间发送中断或终止命令。信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件\n套接字 套接字提供网络通信的端点，可以让不同机器上运行的进程之间进行双向通信。但是套接字实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信。\n信号量 进程间通信处理同步互斥的机制。是在多线程环境下使用的一种设施，它负责协调各个线程，以保证它们能够正确，合理的使用公共资源。\n对于信号量有两种操作\nP 操作，这个操作会把信号量减去 1，相减后如果信号量 \u0026lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 \u0026gt;= 0，则表明还有资源可使用，进程可正常继续执行 V 操作，这个操作会把信号量加上 1，相加后如果信号量 \u0026lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 \u0026gt; 0，则表明当前没有阻塞中的进程 信号量有两种类型\n互斥信号量 ：信号初始化为 1 ，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。 异步信号量 ：保证进程之间的顺序执行 进程调度 调度时机 以下状态的变化都会触发操作系统的调度\n从就绪态 -\u0026gt; 运行态：当进程被创建时，会进入到就绪队列，操作系统会从就绪队列选择一个进程运行； 从运行态 -\u0026gt; 阻塞态：当进程发生 I/O 事件而阻塞时，操作系统必须选择另外一个进程运行； 从运行态 -\u0026gt; 结束态：当进程退出结束后，操作系统得从就绪队列选择另外一个进程运行； 调度算法 调度算法分为以下两类\n非抢占式调度算法 ：挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。 抢占式调度算法 ：挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生 时钟中断 ，以便把 CPU 控制返回给调度程序进行调度，也就是常说的 时间片机制 。 对于单核CPU有以下常见的调度算法\n先来先服务（FCFS, First-Come, First-Served） ：按照进程到达的顺序进行调度，每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。 适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统 可能造成“长任务”拖延其他任务的执行。 短作业优先(SJF，Shortest Job First) : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。 很难准确预知进程的执行时间，并且可能因为短作业一直在执行，导致长作业持续被推迟执行。 最高响应比优先（HRRN, Highest Response Ratio Next） ：通过计算响应比来决定下一个被调度的进程 ，把响应比优先级最高的进程投入运行，平衡长短任务的等待时间，防止短任务过多导致长任务饥饿。响应比的公式为： (等待时间 + 服务时间) / 服务时间 其中，等待时间是进程在就绪队列中等待的时间，服务时间是进程预计需要的执行时间 对于短任务，其服务时间小，初始响应比就较高，容易被优先调度。 对于长任务，随着等待时间的增加，响应比逐渐提升，最终也会被调度，避免了长任务的饥饿。 时间片轮转（RR, Round Robin） ：为每个进程分配固定的时间片，时间片结束后调度下一个进程，如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程；如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换； 多级反馈队列调度（MLFQ, Multilevel Feedback Queue）：通过将进程放入不同优先级的队列，实现灵活的调度机制。优先级较高的进程先被调度，随着执行时间增加，进程可能被降至低优先级队列。适合多任务、多类型的操作系统。 设置了多个队列，赋予每个队列不同的优先级，每个 队列优先级从高到低 ，同时 优先级越高时间片越短 新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成 当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行 线程 线程的定义 线程（Thread） 可以被视为轻量级进程，是进程当中的一条执行流程，任务调度和执行的基本单位。线程的生命周期由进程控制，进程终止时，其所有线程也会终止。多个线程可以在同一个进程中同时执行，并且共享进程的资源比如内存空间、文件句柄、网络连接等。但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。\n线程的优缺点和存在意义 线程具有以下优缺点\n优点\n一个进程中可以同时存在多个线程\n各个线程之间可以并发执行\n各个线程之间可以共享地址空间和文件等资源\n缺点\n当进程中的一个线程崩溃时，可能影响其所属进程的所有线程 线程的存在意义\n进程切换是一个开销很大的操作，线程切换的成本较低。 线程更轻量，一个进程可以创建多个线程。 多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题比如 IO 阻塞就会挂起直到结果返回。 同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核。 进程和线程的区别 本质区别 进程是操作系统资源分配的基本单位 线程是任务调度和执行的基本单位 切换开销 每个进程都有独立的代码和数据空间（程序上下文），对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的 线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。 稳定性 进程中某个线程如果崩溃了可能会影响所属进程的其他进程 进程中的子进程崩溃，并不会影响其他进程。 通信方式 因为各自独立的内存空间，进程间通信（IPC）较为复杂，需要使用管道、消息队列、共享内存、套接字等方式 同一进程内的线程共享内存空间，因此线程直接读写内存即可，但注意需要使用同步机制避免数据错误。 线程的上下文切换 线程切换是指将 CPU 的控制权从一个线程转移到另一个线程的过程。与进程切换相比，线程切换的开销较小，因为同一进程内的线程共享相同的地址空间和资源。\n保存当前线程的上下文（如 CPU 寄存器、栈指针等）到线程控制块（TCB）中 更新当前线程的状态（如就绪、阻塞等）。 选择下一个要执行的线程，更新调度信息。 恢复下一个线程的上下文，恢复 CPU 寄存器、栈指针、程序计数器等信息，确保线程能够从上次中断的地方继续执行，开始执行其任务。 提示\n线程控制块 TCB\n类似于进程控制块PCB，TCB是操作系统用来管理线程的一个数据结构，它包含了与线程执行相关的所有必要信息，确保线程能够在系统中被正确调度和执行。每个线程都有一个对应的 TCB，操作系统通过 TCB 来管理和调度线程的执行。\nTCB的主要内容\n线程状态：操作系统通过线程状态来判断线程是否可以被执行或者需要被挂起。 程序计数器 ：程序计数器保存线程当前执行指令的地址，标识线程的执行位置。线程切换时，程序计数器的值需要被保存和恢复。 寄存器内容 ：线程的寄存器值（如通用寄存器、栈指针等）需要在上下文切换时保存和恢复。它们包含了线程执行期间的局部变量、函数调用的返回地址等信息。 线程栈指针（Stack Pointer, SP） ：每个线程都有一个栈，用于存储函数调用信息（如局部变量、返回地址等）。栈指针指向当前栈顶，线程切换时，栈指针需要被保存和恢复。 线程优先级（Thread Priority） ：操作系统通常根据线程的优先级来决定哪个线程应该被调度执行。 线程标识符（Thread ID） ：每个线程都有一个唯一的标识符（线程ID），操作系统通过它来区分不同的线程。 线程的调度信息 ：包括线程的调度策略、时间片（如果采用时间片轮转调度）、期望的调度器等。 线程的实现 用户线程 用户线程是在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理。操作系统内核并不知道它的存在，它完全是在用户空间中创建。所以 用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。\n用户线程的优缺点\n优点\n管理开销小：创建、销毁不需要系统调用。\n切换成本低：用户空间程序可以自己维护，不需要走操作系统调度。\n缺点\n与内核协作成本高：比如这种线程完全是用户空间程序在管理，当它进行 I/O 的时候，无法利用到内核的优势，需要频繁进行用户态到内核态的切换。 由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了。 当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行，因为用户态的线程没法打断当前运行中的线程，它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的。 内核线程 内核线程是由操作系统管理的，线程对应的 TCB 是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。\n优缺点\n优点\n在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行 分配给线程，多线程的进程获得更多的 CPU 运行时间 缺点\n在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB\n线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大\n线程的同步机制 竞态条件：指当多个线程同时访问和操作同一块数据时，最终结果依赖于线程的执行顺序，这可能导致数据的不一致性。\n临界区：对共享资源访问的程序片段，我们希望这段代码是互斥的，可以保证在某个时刻只能被一个线程执行，也就是说一个线程在临界区执行时，其它线程应该被阻止进入临界区。\n锁机制 互斥锁 使⽤加锁操作和解锁操作可以解决并发线程/进程的互斥问题。\n任何想进⼊临界区的线程，必须先执⾏加锁操作。若加锁操作顺利通过，则线程可进⼊临界区；在完成对临界资源的访问后再执⾏解锁操作，以释放该临界资源。\n锁有以下两类实现\n自旋锁：当一个线程试图获取锁时，如果该锁已经被其他线程持有，当前线程不会立即进入休眠或阻塞，而是不断地检查锁的状态，直到该锁可用为止。这个过程被称为忙等待（busy waiting），因为线程在等待锁时仍然占用 CPU 资源，处于活跃状态。优点是避免了线程的上下文切换。 非自旋锁：指当一个线程尝试获取锁时，如果锁已经被其他线程持有，当前线程不会忙等待，而是主动让出 CPU，进入阻塞状态或休眠状态，等待锁释放。当锁被释放时，线程被唤醒并重新尝试获取锁。这类锁的主要目的是避免忙等待带来的 CPU 资源浪费。 死锁 死锁的发生条件 当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成 两个线程都在等待对方释放锁 ，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了死锁 。\n死锁的发生条件如下\n互斥条件 ：多个线程不能同时使用同一个资源，如果另一进程申请该资源，那么必须等待直到该资源被释放为止。 等待占有条件 ：一个进程已经持有了至少一个资源，同时还在等待获取其他被占用的资源。在此期间，该进程不会释放已经持有的资源。 不可剥夺条件 ：当线程已经持有了资源 ，在自己使用完之前不能被其他线程获取 环路等待条件 ：在死锁发生的时候，两个线程获取资源的顺序构成了环形链 避免死锁的方法 忽略死锁 ：使用鸵鸟算法，假装死锁不会发生\n保证系统不进入死锁状态\n银行家算法：资源分配时使用银行家算法检测死锁，在分配给进程资源前，首先判断这个进程的安全性 ，也就是预执行，判断分配后是否产生死锁现象。如果系统当前资源能满足其执行，则尝试分配，如果不满足则让该进程等待。通过不断检查剩余可用资源是否满足某个进程的最大需求，如果可以则加入安全序列，并把该进程当前持有的资源回收；不断重复这个过程，看最后能否实现让所有进程都加入安全序列\n破坏死锁条件\n破坏占用等待条件 ：所有进程在开始执行前请求所需的全部资源，若全部资源可用才分配\n破坏环路等待条件 ：可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后就不存在环路了。\n破坏不可剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。\n允许系统进入死锁后再处理\n利用抢占恢复\n某些情况下可能临时将某个资源从当前所有者这里转移到另一个进程\n可行性：取决于资源的特性\n利用回滚恢复\n周期性进行检查点检查：将进程的状态写入一个文件以备以后重启\n一旦检查到死锁回滚到上一个检查点\n杀死进程恢复\n杀死环中一个进程，直到打破死循环\n杀死环外的一个进程以释放该进程所占用的资源\n","date":"2025-02-13T15:10:49+08:00","permalink":"https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/","title":"操作系统的进程管理和线程管理"},{"content":"栈和队列的相互转换 用栈实现队列 思路解析 使用栈来模拟队列的行为，所以需要两个栈 一个输入栈，一个输出栈 。\noffer 操作时直接将数据 push 到输入栈中\npoll 操作时若输出栈不为空则先将输入栈中数据依次出栈并放入输出栈中（这会让输入栈中的数据倒序存储在输出栈中）然后直接出栈\nleetcode 232 用栈实现队列 题目描述\n力扣题目链接(opens new window)\n使用栈实现队列的下列操作：\npush(x) \u0026ndash; 将一个元素放入队列的尾部。 pop() \u0026ndash; 从队列首部移除元素。 peek() \u0026ndash; 返回队列首部的元素。 empty() \u0026ndash; 返回队列是否为空。\n示例:\n1 2 3 4 5 6 MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // 返回 1 queue.pop(); // 返回 1 queue.empty(); // 返回 false 说明:\n你只能使用标准的栈操作 \u0026ndash; 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class MyQueue { Stack\u0026lt;Integer\u0026gt;stackIn; Stack\u0026lt;Integer\u0026gt;stackOut; public MyQueue() { stackIn=new Stack\u0026lt;\u0026gt;(); stackOut=new Stack\u0026lt;\u0026gt;(); } // push 操作直接放入输入栈 public void push(int x) { stackIn.push(x); } // pop 操作先转移元素到输出栈再弹出元素 public int pop() { transfer(); return stackOut.pop(); } public int peek() { transfer(); return stackOut.peek(); } public boolean empty() { return stackIn.isEmpty()\u0026amp;\u0026amp; stackOut.empty(); } // 将输入栈的元素转移到输出栈中 public void transfer(){ if (!stackOut.isEmpty()) return; while(!stackIn.isEmpty()) { stackOut.push(stackIn.pop()); } } } 用队列实现栈 思路解析 用队列实现栈可以使用一个队列或者两个队列实现\n两个队列的思路\n设置两个队列，一个队列为主队列，另一个队列为辅助队列。\npush 操作时先将元素添加到辅助队列中，然后将主队列的元素依次出队加入辅助队列，最后辅助队列和主队列互相交换 pop 操作直接让主队列出队即可 一个队列的思路\npush 操作时保证元素每次都添加到队首 先进行 offer 操作 将除新元素以外的元素依次出队再入队 poll 操作时直接出队即可 leetcode 225 用队列实现栈 题目描述\n力扣题目链接(opens new window)\n使用队列实现栈的下列操作：\npush(x) \u0026ndash; 元素 x 入栈 pop() \u0026ndash; 移除栈顶元素 top() \u0026ndash; 获取栈顶元素 empty() \u0026ndash; 返回栈是否为空 注意:\n你只能使用队列的基本操作\u0026ndash; 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。 你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。 参考代码\n两个队列实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class MyStack { Queue\u0026lt;Integer\u0026gt;que1; Queue\u0026lt;Integer\u0026gt;que2; public MyStack() { que1=new ArrayDeque\u0026lt;\u0026gt;(); que2=new ArrayDeque\u0026lt;\u0026gt;(); } public void push(int x) { que2.offer(x); while(!que1.isEmpty()) { que2.offer(que1.poll()); } Queue\u0026lt;Integer\u0026gt; queueTemp; queueTemp = que1; que1 = que2; que2 = queueTemp; } public int pop() { return que1.poll(); } public int top() { return que1.peek(); } public boolean empty() { return que1.isEmpty()\u0026amp;\u0026amp;que2.isEmpty(); } } 单个队列实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class MyStack { Queue\u0026lt;Integer\u0026gt;que; public MyStack() { que=new ArrayDeque\u0026lt;\u0026gt;(); } public void push(int x) { que.offer(x); int size=que.size(); while(size\u0026gt;1) { que.offer(que.poll()); size--; } } public int pop() { return que.poll(); } public int top() { return que.peek(); } public boolean empty() { return que.isEmpty(); } } 括号匹配问题 思路解析 在编译原理中的括号匹配就是使用栈来解决的，因此可以在读取左括号时将对应的右括号入栈\n分析不匹配的情况\n左括号多余 左右括号不匹配 右括号多余 在栈中的情况如下\n已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配 遍历字符串匹配的过程中，发现栈里没有可以匹配的字符 遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符 leetcode 20 有效的括号 题目描述 力扣题目链接(opens new window)\n给定一个只包括 \u0026lsquo;(\u0026rsquo;，\u0026rsquo;)\u0026rsquo;，\u0026rsquo;{\u0026rsquo;，\u0026rsquo;}\u0026rsquo;，\u0026rsquo;[\u0026rsquo;，\u0026rsquo;]\u0026rsquo; 的字符串，判断字符串是否有效。\n有效字符串需满足：\n左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1:\n输入: \u0026ldquo;()\u0026rdquo; 输出: true 示例 2:\n输入: \u0026ldquo;()[]{}\u0026rdquo; 输出: true 示例 3:\n输入: \u0026ldquo;(]\u0026rdquo; 输出: false 示例 4:\n输入: \u0026ldquo;([)]\u0026rdquo; 输出: false 示例 5:\n输入: \u0026ldquo;{[]}\u0026rdquo; 输出: true 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public boolean isValid(String s) { Stack\u0026lt;Character\u0026gt;stack=new Stack\u0026lt;\u0026gt;(); for(char ch:s.toCharArray()) { // 检索到左括号将对应的右括号入栈 if(ch==\u0026#39;(\u0026#39;) { stack.push(\u0026#39;)\u0026#39;); } else if(ch==\u0026#39;{\u0026#39;){ stack.push(\u0026#39;}\u0026#39;); } else if(ch==\u0026#39;[\u0026#39;){ stack.push(\u0026#39;]\u0026#39;); } // 1.栈在遍历过程中为空说明右括号多余 // 2.栈在遍历过程中不对应说明左右括号不匹配 else if(stack.isEmpty()||ch!=stack.peek()) return false; else stack.pop(); } // 3.栈在遍历后不为空说明左括号多余 return stack.isEmpty(); } } leetcode 1021 删除最外层的括号 题目描述 题目链接\n有效括号字符串为空 \u0026quot;\u0026quot;、\u0026quot;(\u0026quot; + A + \u0026quot;)\u0026quot; 或 A + B ，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。\n例如，\u0026quot;\u0026quot;，\u0026quot;()\u0026quot;，\u0026quot;(())()\u0026quot; 和 \u0026quot;(()(()))\u0026quot; 都是有效的括号字符串。 如果有效字符串 s 非空，且不存在将其拆分为 s = A + B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。\n给出一个非空有效字符串 s，考虑将其进行原语化分解，使得：s = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。\n对 s 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 s 。\n示例 1：\n1 2 3 4 5 输入：s = \u0026#34;(()())(())\u0026#34; 输出：\u0026#34;()()()\u0026#34; 解释： 输入字符串为 \u0026#34;(()())(())\u0026#34;，原语化分解得到 \u0026#34;(()())\u0026#34; + \u0026#34;(())\u0026#34;， 删除每个部分中的最外层括号后得到 \u0026#34;()()\u0026#34; + \u0026#34;()\u0026#34; = \u0026#34;()()()\u0026#34;。 示例 2：\n1 2 3 4 5 输入：s = \u0026#34;(()())(())(()(()))\u0026#34; 输出：\u0026#34;()()()()(())\u0026#34; 解释： 输入字符串为 \u0026#34;(()())(())(()(()))\u0026#34;，原语化分解得到 \u0026#34;(()())\u0026#34; + \u0026#34;(())\u0026#34; + \u0026#34;(()(()))\u0026#34;， 删除每个部分中的最外层括号后得到 \u0026#34;()()\u0026#34; + \u0026#34;()\u0026#34; + \u0026#34;()(())\u0026#34; = \u0026#34;()()()()(())\u0026#34;。 示例 3：\n1 2 3 4 5 输入：s = \u0026#34;()()\u0026#34; 输出：\u0026#34;\u0026#34; 解释： 输入字符串为 \u0026#34;()()\u0026#34;，原语化分解得到 \u0026#34;()\u0026#34; + \u0026#34;()\u0026#34;， 删除每个部分中的最外层括号后得到 \u0026#34;\u0026#34; + \u0026#34;\u0026#34; = \u0026#34;\u0026#34;。 思路解析 用一个栈来表示括号的深度。遇到 ‘(’ 则将字符入栈，遇到 ‘)’ 则将栈顶字符出栈。栈从空到下一次空的过程，则是扫描了一个原语的过程。\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public String removeOuterParentheses(String s) { Deque\u0026lt;Character\u0026gt;stack=new LinkedList\u0026lt;\u0026gt;(); StringBuffer sb=new StringBuffer(); for(int i=0;i\u0026lt;s.length();i++) { char ch=s.charAt(i); if(ch==\u0026#39;)\u0026#39;) stack.pop(); if(!stack.isEmpty()) { sb.append(ch); } if(ch==\u0026#39;(\u0026#39;) { stack.push(ch); } System.out.println(sb); System.out.println(\u0026#34;stack:\u0026#34;+stack.toString()); } return sb.toString(); } } 字符串相邻重复项问题 思路解析 在删除相邻重复项的时候，其实就是要知道当前遍历的这个元素，我们在前一位是不是遍历过一样数值的元素。因为栈具有先进先出的特性可以快速得到前一位的元素，因此可以用栈来存放元素。当遍历当前的这个元素的时候，去栈里看一下我们是不是遍历过相同数值的相邻元素。然后再去做对应的消除操作\nleetcode 1047 删除字符串中所有相邻重复项 题目描述 力扣题目链接(opens new window)\n给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。\n在 S 上反复执行重复项删除操作，直到无法继续删除。\n在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。\n示例：\n输入：\u0026ldquo;abbaca\u0026rdquo; 输出：\u0026ldquo;ca\u0026rdquo; 解释：例如，在 \u0026ldquo;abbaca\u0026rdquo; 中，我们可以删除 \u0026ldquo;bb\u0026rdquo; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 \u0026ldquo;aaca\u0026rdquo;，其中又只有 \u0026ldquo;aa\u0026rdquo; 可以执行重复项删除操作，所以最后的字符串为 \u0026ldquo;ca\u0026rdquo;。 提示：\n1 \u0026lt;= S.length \u0026lt;= 20000 S 仅由小写英文字母组成。 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public String removeDuplicates(String s) { Stack\u0026lt;Character\u0026gt;stack=new Stack\u0026lt;\u0026gt;(); for(Character ch:s.toCharArray()) { if(!stack.isEmpty()\u0026amp;\u0026amp;ch==stack.peek()) stack.pop(); else stack.push(ch); } StringBuffer str=new StringBuffer(); while(!stack.isEmpty()) { str.append(stack.pop()); } return str.reverse().toString(); } } 逆波兰表达式求值 思路解析 在离散数学中，对逆波兰表达式的求解就是使用栈进行存储。遍历字符串，将数字直接存入栈中，如果遇到运算符则连续出栈两次作为运算符的运算数。注意除法和减法是后出栈的运算先出栈的\nleetcode 150 逆波兰式求值 题目描述 力扣题目链接(opens new window)\n根据 逆波兰表示法，求表达式的值。\n有效的运算符包括 + , - , * , / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。\n说明：\n整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。\n示例 1：\n输入: [\u0026ldquo;2\u0026rdquo;, \u0026ldquo;1\u0026rdquo;, \u0026ldquo;+\u0026rdquo;, \u0026ldquo;3\u0026rdquo;, \u0026quot; * \u0026ldquo;] 输出: 9 解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 示例 2：\n输入: [\u0026ldquo;4\u0026rdquo;, \u0026ldquo;13\u0026rdquo;, \u0026ldquo;5\u0026rdquo;, \u0026ldquo;/\u0026rdquo;, \u0026ldquo;+\u0026rdquo;] 输出: 6 解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 示例 3：\n输入: [\u0026ldquo;10\u0026rdquo;, \u0026ldquo;6\u0026rdquo;, \u0026ldquo;9\u0026rdquo;, \u0026ldquo;3\u0026rdquo;, \u0026ldquo;+\u0026rdquo;, \u0026ldquo;-11\u0026rdquo;, \u0026quot; * \u0026ldquo;, \u0026ldquo;/\u0026rdquo;, \u0026quot; * \u0026ldquo;, \u0026ldquo;17\u0026rdquo;, \u0026ldquo;+\u0026rdquo;, \u0026ldquo;5\u0026rdquo;, \u0026ldquo;+\u0026rdquo;]\n输出: 22\n解释:该算式转化为常见的中缀算术表达式为：\n1 2 3 4 5 6 7 ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public int evalRPN(String[] tokens) { Stack\u0026lt;Integer\u0026gt;stack=new Stack\u0026lt;\u0026gt;(); for(String str:tokens) { if(str.equals(\u0026#34;+\u0026#34;)) { int x=stack.pop(); int y=stack.pop(); stack.push(x+y); } else if(str.equals(\u0026#34;*\u0026#34;)) { int x=stack.pop(); int y=stack.pop(); stack.push(x*y); } else if(str.equals(\u0026#34;/\u0026#34;)) { int x=stack.pop(); int y=stack.pop(); stack.push(y/x); } else if(str.equals(\u0026#34;-\u0026#34;)) { int x=stack.pop(); int y=stack.pop(); stack.push(y-x); } else { stack.push(Integer.valueOf(str)); } } return stack.pop(); } } 单调队列问题 单调队列通常用于解决 区间最值问题 。\n单调队列具有以下特点\n队列中的元素 从前到后单调 ，保证队头的元素是最值 单调队列要根据具体的场景自行设计\npop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作 push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止 leetcode 239 滑动窗口最大值 题目描述 力扣题目链接(opens new window)\n给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n返回滑动窗口中的最大值。\n进阶：\n你能在线性时间复杂度内解决此题吗？\n提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 -10^4 \u0026lt;= nums[i] \u0026lt;= 10^4 1 \u0026lt;= k \u0026lt;= nums.length 思路解析 本题是区间最值问题，可以维护一个单调队列，队列内单调递减，队头为队列的最大值。窗口移动时队头的最大值出队，队尾入队，入队前先将队列中所有比入队元素小的元素出队。\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public int[] maxSlidingWindow(int[] nums, int k) { if (nums.length == 1) { return nums; } int num=0; int len = nums.length - k + 1; //存放结果元素的数组 int[] res = new int[len]; MyQueue que=new MyQueue(); for(int i=0;i\u0026lt;k;i++) { que.push(nums[i]); } res[num++] = que.peek(); for(int i=k;i\u0026lt;nums.length;i++) { que.poll(nums[i-k]); que.push(nums[i]); res[num++]= que.peek(); } return res; } } class MyQueue{ Deque\u0026lt;Integer\u0026gt;deq=new LinkedList\u0026lt;\u0026gt;(); void poll(int val){ if(!deq.isEmpty()\u0026amp;\u0026amp;val==deq.peek()) deq.poll(); } void push(int val) { while (!deq.isEmpty() \u0026amp;\u0026amp; val \u0026gt; deq.getLast()) { deq.removeLast(); } deq.add(val); } int peek() { return deq.peek(); } } 前K个的最值问题 题目描述 通常在数据结构中堆（优先队列）适合处理前k个的最值问题。维护一个优先队列，将元素依次入队，元素在队列中进行堆排序，再依次出队\nleetcode 347 前k个高频元素 题目描述 力扣题目链接(opens new window)\n给定一个非空的整数数组，返回其中出现频率前 k 高的元素。\n示例 1:\n输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2:\n输入: nums = [1], k = 1 输出: [1] 提示：\n你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 $O(n \\log n)$ , n 是数组的大小。 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。 你可以按任意顺序返回答案。 思路解析 本题是经典的前k个最值问题，故想到使用优先队列实现。题目要求统计元素的出现频率，故需要使用map建立元素和出现次数之间的映射关系\n为了在队列中体现键值对可以将队列中的元素设置为长度为2的数字，第一个元素代表键，第二个元素代表值\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public int[] topKFrequent(int[] nums, int k) { // 统计元素出现次数 HashMap\u0026lt;Integer,Integer\u0026gt;map=new HashMap\u0026lt;\u0026gt;(); for(Integer i:nums) { map.put(i,map.getOrDefault(i,0)+1); } int[]res=new int[k]; // 优先队列中按照出现频率降序排列 PriorityQueue\u0026lt;int[]\u0026gt;que=new PriorityQueue\u0026lt;\u0026gt;((int[] o1, int[] o2)-\u0026gt; { return o2[1]-o1[1]; } ); // 元素依次入队 for(Integer i:map.keySet()) { que.add(new int[]{i,map.get(i)}); } for(int i=0;i\u0026lt;k;i++) { res[i]=que.poll()[0]; } return res; } } BM48 数据流中的中位数 题目描述 题目链接\n如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。\n数据范围：数据流中数个数满足 1≤n≤1000 1≤n≤1000 ，大小满足 1≤val≤1000 1≤val≤1000\n进阶： 空间复杂度 O(n) O(n) ， 时间复杂度 O(nlogn) O(nlogn)\n示例1\n输入：\n1 [5,2,3,4,1,6,7,0,8] 返回值：\n1 \u0026#34;5.00 3.50 3.00 3.50 3.00 3.50 4.00 3.50 4.00 \u0026#34; 说明：\n1 数据流里面不断吐出的是5,2,3...,则得到的平均数分别为5,(5+2)/2,3... 示例2\n输入：\n1 [1,1,1] 返回值：\n1 \u0026#34;1.00 1.00 1.00 \u0026#34; 思路解析 中位数的特征，它是数组中间个数字或者两个数字的均值，它是数组较小的一半元素中最大的一个，同时也是数组较大的一半元素中最小的一个。那我们只要每次维护最小的一半元素和最大的一半元素，并能快速得到它们的最大值和最小值，那不就可以了嘛。这时候就可以想到了堆排序的优先队列。\nstep 1：我们可以维护两个堆，分别是大顶堆min，用于存储较小的值，其中顶部最大；小顶堆max，用于存储较大的值，其中顶部最小，则中位数只会在两个堆的堆顶出现。 step 2：我们可以约定奇数个元素时取大顶堆的顶部值，偶数个元素时取两堆顶的平均值，则可以发现两个堆的数据长度要么是相等的，要么奇数时大顶堆会多一个。 step 3：每次输入的数据流先进入大顶堆排序，然后将小顶堆的最大值弹入大顶堆中，完成整个的排序。 step 4：但是因为大顶堆的数据不可能会比小顶堆少一个，因此需要再比较二者的长度，若是小顶堆长度小于大顶堆，需要从大顶堆中弹出最小值到大顶堆中进行平衡。 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Solution { // 小顶堆 PriorityQueue\u0026lt;Integer\u0026gt;max_que = new PriorityQueue\u0026lt;\u0026gt;(); // 大顶堆 PriorityQueue\u0026lt;Integer\u0026gt;min_que = new PriorityQueue\u0026lt;\u0026gt;(new Comparator\u0026lt;Integer\u0026gt;() { @Override public int compare(Integer o1, Integer o2) { return o2 - o1; } }); public void Insert(Integer num) { min_que.offer(num); max_que.offer(min_que.poll()); if (min_que.size() \u0026lt; max_que.size()) { min_que.offer(max_que.poll()); } } public Double GetMedian() { // 奇数个 if (min_que.size() \u0026gt; max_que.size()) return (double)min_que.peek(); else { return (double)(min_que.peek() + max_que.peek()) / 2; } } } ","date":"2025-02-13T10:41:58+08:00","permalink":"https://Tyritic.github.io/p/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","title":"栈和队列"},{"content":"操作系统的主要功能 负责创建和终止进程。进程是正在运行的程序实例，每个进程都有自己的地址空间和资源。 负责为进程分配资源，比如说内存，并在进程终止时回收内存。 提供创建、删除、读写文件的功能，并组织文件的存储结构，比如说目录。 通过设备驱动程序控制和管理计算机的硬件设备，如键盘、鼠标、打印机等。 操作系统内核 计算机是由各种外部硬件设备组成的，比如内存、cpu、硬盘等，内核作为应用连接硬件设备的桥梁 ，应用程序只需关心与内核交互，不用关心硬件的细节。\n操作系统内核具有很高的权限\n进程调度 ：管理进程、线程，决定哪个进程、线程使用 CPU 内存管理 ：管理内存，决定内存的分配和回收 硬件通信 ：管理硬件设备，为进程与硬件设备之间提供通信能力 系统调用 ：提供系统调用，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。 提示\n微内核和宏内核\n微内核 ：尽量将大部分操作系统功能移至用户态，仅保留最基础的功能（如进程间通信、内存管理）在内核态中。优点是系统更稳定、模块化，但切换频繁，性能不如宏内核。 宏内核 ：大部分操作系统服务在内核态中运行，包括文件系统、驱动程序等。优点是性能高，因为减少了用户态与内核态之间的切换，但可能增加系统的复杂性和维护难度。 混合内核 ：是宏内核和微内核的结合体，内核中抽象出了微内核的概念，也就是内核中会有一个小型的内核，其他模块就在这个基础上搭建，整个内核是个完整的程序； 内核态和用户态 内核具有很高的权限，可以控制CPU、内存、硬盘等硬件，而应用程序具有的权限很小，因此大多数操作系统，把内存分成了两个区域\n定义 内核态：在内核态下，CPU可以执行所有的指令和访问所有的硬件资源。这种模式下的操作具有更高的权限，主要用于操作系统内核的运行。 用户态：在用户态下，CPU只能执行部分指令集，无法直接访问硬件资源。这种模式下的操作权限较低。应用程序需要通过系统调用与内核进行通信，由内核代为执行敏感操作。即使程序出现问题也不会影响操作系统的稳定性，主要用于运行用户程序。 切换机制 大部分的状态切换出现在用户程序调用系统调用的时候，当应用程序执行系统调用时，CPU 将从用户态切换到内核态，进入内核空间执行相应的内核代码，然后再切换回用户态。\n内核程序执行在内核态，用户程序执行在用户态。当应用程序使用系统调用时，会产生一个中断。发生中断后， CPU 会中断当前在执行的用户程序，转而跳转到中断处理程序，也就是开始执行内核程序。内核处理完后，主动触发中断，把 CPU 执行权限交回给用户程序，回到用户态继续工作。\n什么时候会出现上下文切换\n系统调用：用户态进程主动要求切换到内核态的一种方式，主要是为了使用内核态才能做的事情比如读取磁盘资源。系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现。 中断：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。 异常：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。 在用户态和内核态之间切换时，操作系统会执行上下文切换 ，包括保存当前进程的寄存器、状态和堆栈等信息，并加载内核态的状态以处理系统调用。上下文切换的成本较高，所以优化系统性能时，需要减少不必要的系统调用和态切换。\n内核态和用户态的切换过程\n保存用户态的上下文信息 ：CPU 会将当前用户态进程使用的通用寄存器、程序计数器（PC）、栈指针（SP）、标志寄存器等内容保存起来。这些寄存器中存储着用户态程序当前的执行状态和相关数据，以便内核态处理完任务后能恢复到正确的用户态执行位置。 进行模式与权限的切换 ：通过修改 CPU 的特定标志位或寄存器，将处理器的运行模式从用户态切换到内核态，使 CPU 能够执行特权指令，访问所有的内存空间和硬件资源。内核会检查此次切换的合法性和权限，比如检查系统调用的参数是否正确、进程是否具有相应的权限来执行此操作等，以确保系统的安全性和稳定性。 加载内核态上下文并执行内核态代码 ：根据进程的描述符或任务控制块（TCB）中保存的内核栈信息，将栈指针设置为指向内核栈的地址，开始使用内核栈来进行内核代码的执行。 内核态和用户态的存在原因 安全性：用户态和内核态的划分确保了普通应用程序无法直接访问硬件资源或执行敏感操作，避免了程序或用户恶意操作对系统核心的破坏。 稳定性：通过在内核态中运行关键系统服务（如内存管理、文件系统、设备驱动等），操作系统可以对资源进行集中管理和保护。某个应用程序崩溃，只会影响用户态中的进程，不会影响到整个系统。 隔离性：通过设置不同的权限级别，操作系统能够更好地控制对资源的访问。只有在内核态下，操作系统才有权对硬件资源进行操作，而用户态程序必须通过系统调用请求内核服务，这种设计确保了对系统资源的统一管理。内核态和用户态的划分使得操作系统内核与用户程序之间有了明确的边界，有利于系统的模块化和维护。 系统调用 系统调用提供了调用操作系统提供的内核态级别的子功能。凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。\n系统调用过程\n用户态的程序发起系统调用，因为系统调用中涉及一些特权指令（只能由操作系统内核态执行的指令），用户态程序权限不足，因此会中断执行，也就是 Trap（Trap 是一种中断）。 发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序。内核程序开始执行，也就是开始处理系统调用。 内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作。 ","date":"2025-02-12T20:36:54+08:00","permalink":"https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD/","title":"操作系统的结构和主要功能"},{"content":"冯诺依曼体系 现代计算机模型是基于冯诺依曼计算机模型\n计算机在运行时，先从内存中取出第一条指令，通过控制器的译码，按指令的要求，从存储器中取出数据进行指定的运算和逻辑操作等加工，然后再按地址把结果送到内存中去，接下来，再取出第二条指令，在控制器的指挥下完成规定操作，依此进行下去。直至遇到停止指令\n程序与数据一样存贮，按程序编排的顺序，一步一步地取出指令，自动地完成指令规定的操作是计算机最基本的工作模型\n计算机基本结构为 5 个部分\n运算器 ：对数据进行各种算术运算和逻辑运算，即对数据进行加工处理 控制器 ：是整个计算机的中枢神经，其功能是对程序规定的控制信息进行解释，根据其要求进行控制，调度程序、数据、地址，协调计算机各部分工作及内存与外设的访问等。 存储器 ：存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息 输入设备 ：将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机 输出设备 ：它把计算机的中间结果或最后结果、机内的各种数据符号及文字或各种控制信号等信息输出出来 内存 在冯诺依曼模型中，程序和数据被存储在一个被称作内存的线性排列存储区域。\n存储的数据单位是一个二进制位，最小的存储单位叫作字节，也就是 8 位，英文是 byte，每一个字节都对应一个内存地址。\n内存地址由 0 开始编号，比如第 1 个地址是 0，第 2 个地址是 1， 然后自增排列，最后一个地址是内存中的字节数减 1。\n我们通常说的内存都是随机存取器（RAM），也就是读取任何一个地址数据的速度是一样的，写入任何一个地址数据的速度也是一样的。\n中央处理器CPU 冯诺依曼模型中 CPU 负责控制和计算，为了方便计算较大的数值，CPU 每次可以计算多个字节的数据。\n提示\nCPU位宽：代表的是 CPU 一次可以计算（运算）的数据量\n32 位和 64 位 CPU 最主要区别在于一次能计算多少字节数据：\n32 位 CPU 一次可以计算 4 个字节 64 位 CPU 一次可以计算 8 个字节 CPU 的位宽最好不要小于线路位宽\nCPU 内部还有一些组件，常见的有 寄存器、控制单元和逻辑运算单元 等。\n控制单元：负责控制 CPU 工作 逻辑运算单元：负责逻辑运算 寄存器：存放计算的中间结果，离控制单元和逻辑运算单元非常近，因此速度很快 通用寄存器：用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。 程序计数器：用来存储 CPU 要执行下一条指令「所在的内存地址」，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令「的地址」。 指令寄存器：用来存放当前正在执行的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。 局部性原理 在CPU访问存储设备时，无论是存取数据抑或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理\n时间局部性\n如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。 空间局部性（Spatial Locality）：\n如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。 总线 总线是用于 CPU 和内存以及其他设备之间的通信，总线可分为 3 种：\n地址总线：用于指定 CPU 将要操作的内存地址 数据总线：用于读写内存的数据 控制总线：用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线 当 CPU 要读写内存数据的时候，一般需要通过以下三条总线\n首先要通过地址总线来指定内存的地址 然后通过控制总线控制是读或写命令 最后通过数据总线来传输数据 程序执行的基本过程 程序实际上是一条一条指令，所以程序的运行过程就是把每一条指令一步一步的执行起来，负责执行指令的就是 CPU 了。\n取得指令 ：CPU 读取程序计数器的值，这个值是指令的内存地址，然后 CPU 的控制单元操作地址总线指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过数据总线将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到指令寄存器。程序计数器的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定 指令译码 ：CPU 的控制器分析指令寄存器中的指令，确定指令的类型和参数。 执行指令 ：把指令交给逻辑运算单元运算；如果是存储类型的指令，则交由控制单元执行 数据回写 ：CPU 将计算结果存回寄存器或者将寄存器的值存入内存 存储器的层次结构 寄存器 寄存器是最靠近 CPU 的控制单元和逻辑计算单元的存储器。寄存器的访问速度非常快，一般要求在半个 CPU 时钟周期内完成读写\nCPU多级缓存 CPU缓存 是高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器\n由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用，减少CPU的等待时间，提高了系统的效率，具体包括以下几种：\nL1-Cache ：L1- 缓存在 CPU 中，相比寄存器，虽然它的位置距离 CPU 核心更远，但造价更低，读写速度在 2~4 个 CPU 时钟周期。 每个 CPU 核心都有一块属于自己的 L1 高速缓存，指令和数据在 L1 是分开存放的，所以 L1 高速缓存通常分成 指令缓存 和 数据缓存 。 L2-Cache ：L2- 缓存也在 CPU 中，位置比 L1- 缓存距离 CPU 核心更远，它的大小比 L1-Cache 更大，速度在 10~20 个 CPU 周期。 L2 高速缓存同样每个 CPU 核心都有 L3-Cache ：L3- 缓存同样在 CPU 中，位置比 L2- 缓存距离 CPU 核心更远，大小通常比 L2-Cache 更大，读写速度在 20~60 个 CPU 周期。 L3 高速缓存通常是多个 CPU 核心共用的 当 CPU 需要内存中某个数据的时候，如果寄存器中有这个数据，我们可以直接使用；如果寄存器中没有这个数据，我们就要先查询 L1 缓存；L1 中没有，再查询 L2 缓存；L2 中没有再查询 L3 缓存；L3 中没有，再去内存中拿。\n存储器存储空间大小：内存\u0026gt;L3\u0026gt;L2\u0026gt;L1\u0026gt;寄存器 存储器速度快慢排序：寄存器\u0026gt;L1\u0026gt;L2\u0026gt;L3\u0026gt;内存 CPU缓存一致性 CPU 缓存 是由很多个 Cache Line 组成的，CPU Line 是 CPU 从内存读取数据的基本单位，而 CPU Line 是由各种标志（Tag）+ 数据块（Data Block）组成\nCPU写入数据通常有以下两种策略\n写穿： 把数据同时写入内存和 Cache 中 写入前会先判断数据是否已经在 CPU 缓存里面了： 如果数据已经在 Cache 里面，先将数据更新到 Cache 里面，再写入到内存里面 如果数据没有在 Cache 里面，就直接把数据更新到内存里面。 写回：当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block 被替换时才需要写到内存中 如果当发生写操作时，数据命中缓存，则把数据更新到 CPU 缓存 里，同时标记 CPU 缓存里的这个 Cache Block 为脏（Dirty）的，这个脏的标记代表这个时候，CPU Cache 里面的这个 Cache Block 的数据和内存是不一致的 如果当发生写操作时，数据未命中缓存，就要检查这个 Cache Block 里的数据有没有被标记为脏的 如果是脏的话，就要把这个 Cache Block 里的数据写回到内存，然后再把当前要写入的数据，先从内存读入到 Cache Block 里，然后再把当前要写入的数据写入到 Cache Block，最后也把它标记为脏的 如果不是脏的话，把当前要写入的数据先从内存读入到 Cache Block 里，接着将数据写入到这个 Cache Block 里，然后再把这个 Cache Block 标记为脏的 缓存一致性问题\n不同核心的缓存，在同一行时候是不一致，从而会导致执行结果的错误。\n解决思路\n写传播 ：某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache； 事务的串行化 ：某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的。 内存 内存通常使用 DRAM （Dynamic Random Access Memory，动态随机存取存储器） 。DRAM的数据会被存储在电容里，电容会不断漏电，所以需要「定时刷新」电容，才能保证数据不会被丢失，这就是 DRAM 之所以被称为「动态」存储器的原因，只有不断刷新，数据才能被存储起来。因此断电后内存中的数据全部丢失\n磁盘 SSD 就是固体硬盘，结构和内存类似，但是它相比内存的优点是断电后数据还是存在的，而内存、寄存器、高速缓存断电后数据都会丢失。\n存储器的层次关系 存储空间越大的存储器设备，其访问速度越慢，所需成本也相对越少。\nCPU 并不会直接和每一种存储器设备直接打交道，而是每一种存储器设备只和它相邻的存储器设备打交道。\n当 CPU 需要访问内存中某个数据的时候，如果寄存器有这个数据，CPU 就直接从寄存器取数据即可，如果寄存器没有这个数据，CPU 就会查询 L1 高速缓存，如果 L1 没有，则查询 L2 高速缓存，L2 还是没有的话就查询 L3 高速缓存，L3 依然没有的话，才去内存中取数据\n中断 在计算机中，中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求\n操作系统收到了中断请求，会打断其他进程的运行，所以 中断请求的响应程序，也就是中断处理程序，要尽可能快的执行完，这样可以减少对正常进程运行调度地影响。\n硬中断和软中断 Linux 系统为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段\n上半部用来快速处理中断（硬中断） ：由 硬件设备（如键盘、网络卡、定时器等）触发的中断信号，当硬件设备需要与 CPU 交互（如数据传输完成、定时中断等），会通过硬中断通知 CPU。硬中断具有较高的优先级，一般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。 当硬中断发生时，CPU会保存当前执行的上下文，并跳转到中断处理程序。 中断处理程序处理完成后，会恢复被中断的程序的上下文，并继续执行。 下半部用来延迟处理上半部未完成的工作（软中断）：由内核触发，一般以内核线程的方式运行。通常是通过执行特定指令（如int指令）或系统调用产生的。在程序运行中请求操作系统的服务，软中断的优先级一般低于硬中断。 ","date":"2025-02-12T18:42:06+08:00","permalink":"https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/","title":"操作系统的硬件结构"},{"content":"字符串反转操作 在算法题中，反转字符串通常作为题目的子操作进行。\n反转操作通常使用左右指针进行处理，因为字符串和数组类似都是基于连续分布内存而设计。故可以设计两个指针，一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。\n代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void reverseString(vector\u0026lt;char\u0026gt;\u0026amp; s) { int l = 0; int r = s.length - 1; while(l \u0026lt; r){ char temp = s[l]; s[l] = s[r]; s[r] = temp; l++; r--; } } // 字符串长度为奇数时，left将会等于right，并位于数组下标为n/2的位置上 // 字符串长度为偶数时，left将会大于right，其中left位于数组下标为n/2，right位于数组下标为n/2-1 经典例题 leetcode 304 反转字符串 题目描述\n力扣题目链接(opens new window)\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。\n不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。\n示例 1： 输入：[\u0026ldquo;h\u0026rdquo;,\u0026ldquo;e\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;o\u0026rdquo;] 输出：[\u0026ldquo;o\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;l\u0026rdquo;,\u0026ldquo;e\u0026rdquo;,\u0026ldquo;h\u0026rdquo;]\n示例 2： 输入：[\u0026ldquo;H\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;h\u0026rdquo;] 输出：[\u0026ldquo;h\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;n\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;H\u0026rdquo;]\n思路解析\n代码模板题，直接套用模板即可\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public void reverseString(char[] s) { int left=0; int right=s.length-1; while(left\u0026lt;right) { char temp=s[right]; s[right]=s[left]; s[left]=temp; left++; right--; } } } leetcode 541 反转字符串II 题目描述\n力扣题目链接(opens new window)\n给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。\n如果剩余字符少于 k 个，则将剩余字符全部反转。\n如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\n示例:\n输入: s = \u0026ldquo;abcdefg\u0026rdquo;, k = 2 输出: \u0026ldquo;bacdfeg\u0026rdquo;\n思路解析\n可以在for循环中将 2k 作为步长，判断是否需要有反转的区间。\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public String reverseStr(String s, int k) { char[]str=s.toCharArray(); for(int i=0;i\u0026lt;s.length();i+=2*k) { // 定位起始位置和终止位置 int start=i; int end=Math.min(start+k-1,str.length-1); // 反转操作 while(start\u0026lt;end) { char temp=str[start]; str[start]=str[end]; str[end]=temp; start++; end--; } } return new String(str); } } leetcode 151 反转字符串中的单词 题目描述\n力扣题目链接(opens new window)\n给定一个字符串，逐个翻转字符串中的每个单词。\n示例 1： 输入: \u0026ldquo;the sky is blue\u0026rdquo; 输出: \u0026ldquo;blue is sky the\u0026rdquo;\n示例 2： 输入: \u0026quot; hello world! \u0026quot; 输出: \u0026ldquo;world! hello\u0026rdquo; 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n示例 3： 输入: \u0026ldquo;a good example\u0026rdquo; 输出: \u0026ldquo;example good a\u0026rdquo; 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n思路解析\n从示例的单词位置可以看出字符串应当进行了一次整体反转。于是考虑先对字符串做一次整体反转\n源字符串为：\u0026ldquo;the sky is blue \u0026quot;\n整体反转后为：\u0026rdquo; eulb si yks eht\u0026quot;\n对比示例可知，再将每个单词进行反转即可\n反转每个单词后为：\u0026quot; blue is sky the\u0026quot;\n发现有多余空格则还要考虑去除多余空格\n故总体思路总结如下\n源字符串：\u0026ldquo;the sky is blue \u0026quot; 先去除多余的空格：\u0026ldquo;the sky is blue\u0026rdquo; 字符串反转：\u0026ldquo;eulb si yks eht\u0026rdquo; 单词反转：\u0026ldquo;blue is sky the\u0026rdquo; 去除空格的思路可以参考 leetcode 27 移除元素\n使用快慢指针法\n当快指针遍历到非空格时 若慢指针不指向第一个位置则将慢指针位置置为空格，并右移慢指针 进行单个单词的遍历 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Solution { public String reverseWords(String s) { char[]str= removeSpace(s); reverse(str,0,str.length-1); reverseEachWord(str); return new String(str); } // 去除多余空格,利用快慢指针的思路 public static char[] removeSpace(String s) { int slow=0; char[]str=s.toCharArray(); for(int fast=0;fast\u0026lt;str.length;fast++) { if(str[fast]!=\u0026#39; \u0026#39;) { // 去除在第一个单词前加入空格，同时在每个单词前加入空格 if(slow\u0026gt;0) { str[slow++]=\u0026#39; \u0026#39;; } // 获取每个单词，每个单词遍历结束后slow位于一个空格中 while(fast\u0026lt;str.length\u0026amp;\u0026amp;str[fast]!=\u0026#39; \u0026#39;) { str[slow++]=str[fast++]; } } } return Arrays.copyOf(str,slow); } public static void reverse(char[] chars, int left, int right) { while(left\u0026lt;right) { char temp=chars[left]; chars[left]=chars[right]; chars[right]=temp; left++; right--; } } public void reverseEachWord(char[] chars) { int start=0; for(int end=0;end\u0026lt;=chars.length;end++) { if(end==chars.length||chars[end]==\u0026#39; \u0026#39;) { reverse(chars,start,end-1); start=end+1; } } } } 右旋字符串 卡码网题目链接(opens new window)\n字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。\n例如，对于输入字符串 \u0026ldquo;abcdefg\u0026rdquo; 和整数 2，函数应该将其转换为 \u0026ldquo;fgabcde\u0026rdquo;。\n输入：输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。\n输出：输出共一行，为进行了右旋转操作后的字符串。\n样例输入：\n1 2 2 abcdefg 1 2\n样例输出：\n1 fgabcde 1\n数据范围：1 \u0026lt;= k \u0026lt; 10000, 1 \u0026lt;= s.length \u0026lt; 10000;\n思路解析\n根据样例输出，可以发现整个字符串进行一次反转，然后将前k个字符反转，剩下的字符反转\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner=new Scanner(System.in); int k = Integer.parseInt(scanner.nextLine()); String s=scanner.nextLine(); int start=0; char[]str=s.toCharArray(); int end=s.length()-1; // 将整个字符串反转 reverse(str,start,end); // 将前k个字符反转，下标范围为[start,start+k-1] reverse(str,start,start+k-1); // 将剩下的部分反转，下标范围为[start+k,end] reverse(str,start+k,end); System.out.println(str); } public static void reverse(char[] chars,int left,int right) { while (left \u0026lt; right) { char temp = chars[left]; chars[left] = chars[right]; chars[right] = temp; left++; right--; } } } 字符串替换操作 思路解析 字符串可以被视为字符数组。做法都是先预先给数组扩容带填充后的大小，然后在从后向前进行操作\n经典例题 替换数字 卡码网题目链接(opens new window)\n给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。\n例如，对于输入字符串 \u0026ldquo;a1b2c3\u0026rdquo;，函数应该将其转换为 \u0026ldquo;anumberbnumbercnumber\u0026rdquo;。\n对于输入字符串 \u0026ldquo;a5b\u0026rdquo;，函数应该将其转换为 \u0026ldquo;anumberb\u0026rdquo;\n输入：一个字符串 s,s 仅包含小写字母和数字字符。\n输出：打印一个新的字符串，其中每个数字字符都被替换为了number\n样例输入：a1b2c3\n样例输出：anumberbnumbercnumber\n数据范围：1 \u0026lt;= s.length \u0026lt; 10000。\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public class Main { public static String replaceNumber(String s) { // 提取计算出数字的个数 int count=0; int oldLength=s.length(); for (int i = 0; i \u0026lt; s.length(); i++) { if(Character.isDigit(s.charAt(i))){ count++; } } // 预先设置扩容后的大小 char[]newS=new char[s.length()+5*count]; int newLength=s.length()+5*count; System.arraycopy(s.toCharArray(), 0, newS, 0, oldLength); // 从后向前操作 for(int i=newLength-1,j=oldLength-1;j\u0026lt;i;i--,j--) { // 判断是否为数字，不是数字则不做操作 if(!Character.isDigit(newS[j])){ newS[i]=newS[j]; } // 填充操作 else{ newS[i] = \u0026#39;r\u0026#39;; newS[i - 1] = \u0026#39;e\u0026#39;; newS[i - 2] = \u0026#39;b\u0026#39;; newS[i - 3] = \u0026#39;m\u0026#39;; newS[i - 4] = \u0026#39;u\u0026#39;; newS[i - 5] = \u0026#39;n\u0026#39;; i -= 5; } } return new String(newS); } public static void main(String[]args){ Scanner scanner = new Scanner(System.in); String s = scanner.next(); System.out.println(replaceNumber(s)); scanner.close(); } } 字符串匹配（KMP算法） KMP的主要思想是 当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。\n前缀表的作用 前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。 找到了最长相等的前后缀，匹配失败的位置是后缀子串的后面，那么找到与其相同的前缀的后面重新匹配就可以。记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。\n最长公共前后缀 前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。 后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。 计算方法\n例如：模式串为”aabaaf\u0026rdquo;\n字符串：a，最长公共前后缀长度为0 字符串：aa，最长公共前后缀长度为1 前缀：a 后缀：a 字符串：aab，最长公共前后缀长度为0 前缀：a，aa 后缀：b，ab 字符串：aaba，最长公共前后缀长度为1 前缀：a，aa，aab 后缀：a，ab，aba 字符串：aabaa，最长公共前后缀长度为2 前缀：a，aa，aab，aaba 后缀：a，aa，baa，abaa 字符串：aabaaf，最长公共前后缀长度为0 前缀：a，aa，aab，aabaa 后缀：f，af，aaf，baaf，abaaf 匹配过程 计算出模式串的前缀表 设置两个指针 一个指针 i 指向文本串的起始位置，且永不回退 一个指针 j 指向模式串的起始位置 文本串和模式串逐一匹配，遍历文本串 对于匹配的字符，模式串指针 j 向右移动 对于不匹配的字符，模式串指针回退前缀表的前一个位置 （next[j-1]） next数组的构造方法 prefix数组通常指代前缀表本身\nnext数组通常将前缀表prefix数组统一减一后使用，next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）\n构造方法\n初始化 定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。 对next数组进行初始化赋值 j=0 next[0]=0 遍历模式串 处理前后缀不相同的情况 j 不断回退到next数组的前一个位置 处理前后缀相同的情况 j 不断向右移动 更新next数组 代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public int strStr(String haystack, String needle) { if (needle.length() == 0) return 0; int[]next=new int[needle.length()]; getNext(next,needle); //kmp匹配过程 int j=0;//模式串的指针 for(int i=0;i\u0026lt;haystack.length();i++)//文本串的指针 { //遇到不匹配的 while(j\u0026gt;0\u0026amp;\u0026amp;haystack.charAt(i)!=needle.charAt(j)) { j=next[j-1];//j回退 } if(needle.charAt(j)==haystack.charAt(i)) { j++; } if(j==needle.length())//找到匹配子串 { return i-needle.length()+1; } } return -1; } // next数组的获取 public static void getNext(int[]next,String needle){ //初始化 int j=0;//前缀的末尾，最长相等前后缀的长度 next[0]=0; //i为后缀的末尾 for(int i=1;i\u0026lt;needle.length();i++) { //前后缀不匹配 while(j\u0026gt;0\u0026amp;\u0026amp;needle.charAt(i)!=needle.charAt(j)) { j=next[j-1]; } //前后缀匹配 if(needle.charAt(i)==needle.charAt(j)) { j++; } next[i]=j;//更新next数组 } } } 经典例题 leetcode 28 找出字符串中第一个匹配项的下标 题目描述\n力扣题目链接(opens new window)\n实现 strStr() 函数。\n给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。\n示例 1: 输入: haystack = \u0026ldquo;hello\u0026rdquo;, needle = \u0026ldquo;ll\u0026rdquo; 输出: 2\n示例 2: 输入: haystack = \u0026ldquo;aaaaa\u0026rdquo;, needle = \u0026ldquo;bba\u0026rdquo; 输出: -1\n说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。\n思路解析\n套用kmp算法模板即可\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public int strStr(String haystack, String needle) { if (needle.length() == 0) return 0; int[]next=new int[needle.length()]; getNext(next,needle); //kmp匹配过程 int j=0;//模式串的指针 for(int i=0;i\u0026lt;haystack.length();i++)//文本串的指针 { //遇到不匹配的 while(j\u0026gt;0\u0026amp;\u0026amp;haystack.charAt(i)!=needle.charAt(j)) { j=next[j-1];//j回退 } if(needle.charAt(j)==haystack.charAt(i)) { j++; } if(j==needle.length())//找到匹配子串 { return i-needle.length()+1; } } return -1; } // next数组的获取 public static void getNext(int[]next,String needle){ //初始化 int j=0;//前缀的末尾，最长相等前后缀的长度 next[0]=0; //i为后缀的末尾 for(int i=1;i\u0026lt;needle.length();i++) { //前后缀不匹配 while(j\u0026gt;0\u0026amp;\u0026amp;needle.charAt(i)!=needle.charAt(j)) { j=next[j-1]; } //前后缀匹配 if(needle.charAt(i)==needle.charAt(j)) { j++; } next[i]=j;//更新next数组 } } } leetcode 459 重复的子字符串 题目描述\n力扣题目链接(opens new window)\n给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。\n示例 1:\n输入: \u0026ldquo;abab\u0026rdquo; 输出: True 解释: 可由子字符串 \u0026ldquo;ab\u0026rdquo; 重复两次构成。 示例 2:\n输入: \u0026ldquo;aba\u0026rdquo; 输出: False 示例 3:\n输入: \u0026ldquo;abcabcabcabc\u0026rdquo; 输出: True 解释: 可由子字符串 \u0026ldquo;abc\u0026rdquo; 重复四次构成。 (或者子字符串 \u0026ldquo;abcabc\u0026rdquo; 重复两次构成。) 思路解析\n重要结论：若 s 可以被其一个子串重复多次构成则 s+s去掉头尾字符的字符串 后出现子串 s 。于是可以使用kmp算法\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public boolean repeatedSubstringPattern(String s) { if(s.length()==1)return false; String str=(s+s).substring(1,(s+s).length()-1); return kmp(str,s); } // 求解next数组 public static int[] getNext(String str) { int[]next=new int[str.length()]; int j=0; //前缀的末尾（同时是前缀的长度） next[0]=0; // 后缀末尾 for(int i=1;i\u0026lt;next.length;i++) { // 前后缀不相同 while(j\u0026gt;0\u0026amp;\u0026amp;str.charAt(i)!=str.charAt(j)) j=next[j-1]; // 回退 // 前后缀相同 if(str.charAt(i)==str.charAt(j)) j++; // 更新next数组 next[i]=j; } return next; } public static boolean kmp(String str1,String str2) { int[]next=getNext(str2); int j=0; //模式串指针 for(int i=0;i\u0026lt;str1.length();i++) { // 前后缀不匹配 while(j\u0026gt;0\u0026amp;\u0026amp;str1.charAt(i)!=str2.charAt(j)) j=next[j-1]; // 前后缀匹配 if(str1.charAt(i)==str2.charAt(j)) j++; if(j==str2.length()) { return true; } } return false; } } 字符串去除多余空格 问题描述 当字符串中需要去掉多余空格，同时保持正常英文语法中的单词空格\n思路解析 这里的思路是去除掉字符串头和字符串尾部以及字符串中的多余空格。可以参考 leetcode 27 移除元素的思路 使用快慢指针，快指针用于遍历原始字符串，慢指针用于确定真正需要的字符。\n代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public static char[] removeSpace(String s) { int slow=0; char[]str=s.toCharArray(); for(int fast=0;fast\u0026lt;str.length;fast++) { if(str[fast]!=\u0026#39; \u0026#39;) { // 去除在第一个单词前加入空格，同时在每个单词前加入空格 if(slow\u0026gt;0) { str[slow++]=\u0026#39; \u0026#39;; } // 获取每个单词，每个单词遍历结束后slow位于一个空格中 while(fast\u0026lt;str.length\u0026amp;\u0026amp;str[fast]!=\u0026#39; \u0026#39;) { str[slow++]=str[fast++]; } } } return Arrays.copyOf(str,slow); } 回文串问题 思路解析 通常回文串问题可以通过两个思路解决\n左右指针法 设置一个左指针指向字符串开头，一个右指针指向字符串结尾，两个指针相向而行，直到相遇 反转字符串 可以利用回文字符串反转后相等的属性 经典例题 leetcode 125 验证回文串 题目描述\n如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。\n字母和数字都属于字母数字字符。\n给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。\n示例 1：\n1 2 3 输入: s = \u0026#34;A man, a plan, a canal: Panama\u0026#34; 输出：true 解释：\u0026#34;amanaplanacanalpanama\u0026#34; 是回文串。 示例 2：\n1 2 3 输入：s = \u0026#34;race a car\u0026#34; 输出：false 解释：\u0026#34;raceacar\u0026#34; 不是回文串。 示例 3：\n1 2 3 4 输入：s = \u0026#34; \u0026#34; 输出：true 解释：在移除非字母数字字符之后，s 是一个空字符串 \u0026#34;\u0026#34; 。 由于空字符串正着反着读都一样，所以是回文串。 思路解析\n本题可以使用左右指针法，指针遇到非数字字母字符直接跳过。当左右指针所指的位置都是数字字母字符时进行比较，同时移动指针\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public boolean isPalindrome(String s) { int left=0; int right=s.length()-1; while(left\u0026lt;right) { while((left\u0026lt;right)\u0026amp;\u0026amp;!check(s.charAt(left))) left++; while((left\u0026lt;right)\u0026amp;\u0026amp;!check(s.charAt(right))) right--; if(check(s.charAt(left))\u0026amp;\u0026amp;check(s.charAt(right))) { if(Character.toLowerCase(s.charAt(left))!=Character.toLowerCase(s.charAt(right))) { return false; } left++; right--; } } return true; } // 验证数字字母字符 public boolean check(char s) { if((\u0026#39;a\u0026#39;\u0026lt;=s\u0026amp;\u0026amp;s\u0026lt;=\u0026#39;z\u0026#39;)||(\u0026#39;A\u0026#39;\u0026lt;=s\u0026amp;\u0026amp;s\u0026lt;=\u0026#39;Z\u0026#39;)||(\u0026#39;0\u0026#39;\u0026lt;=s\u0026amp;\u0026amp;s\u0026lt;=\u0026#39;9\u0026#39;)) return true; return false; } } 字符串同构问题 问题描述 给定两个字符串 s 和 t ，判断它们是否是同构的。\n如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。\n每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。\n思路解析 维护两张哈希表，一张哈希表以第一个字符串中字符为键，映射至第二个字符串的字符为值，第二张哈希表以第二个字符串中的字符为键，映射至第一个字符串的字符为值。从左至右遍历两个字符串的字符，不断更新两张哈希表，如果出现冲突时说明两个字符串无法构成同构，返回 false。\n经典例题 leetcode 205 同构字符串 题目描述\n给定两个字符串 s 和 t ，判断它们是否是同构的。\n如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。\n每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。\n示例 1:\n1 2 输入：s = \u0026#34;egg\u0026#34;, t = \u0026#34;add\u0026#34; 输出：true 示例 2：\n1 2 输入：s = \u0026#34;foo\u0026#34;, t = \u0026#34;bar\u0026#34; 输出：false 示例 3：\n1 2 输入：s = \u0026#34;paper\u0026#34;, t = \u0026#34;title\u0026#34; 输出：true 提示：\n1 \u0026lt;= s.length \u0026lt;= 5 * 104 t.length == s.length s 和 t 由任意有效的 ASCII 字符组成 思路解析\n维护两张哈希表，第一张哈希表以 s 中字符为键，映射至 t 的字符为值，第二张哈希表以 t 中字符为键，映射至 s 的字符为值。从左至右遍历两个字符串的字符，不断更新两张哈希表，如果出现冲突时说明两个字符串无法构成同构，返回 false。\n如果遍历结束没有出现冲突，则表明两个字符串是同构的，返回 true 即可。\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public boolean isIsomorphic(String s, String t) { HashMap\u0026lt;Character,Character\u0026gt;st=new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;Character,Character\u0026gt;ts=new HashMap\u0026lt;\u0026gt;(); for(int i=0;i\u0026lt;s.length();i++) { char s_ch=s.charAt(i); char t_ch=t.charAt(i); if((st.containsKey(s_ch)\u0026amp;\u0026amp;st.get(s_ch)!=t_ch)||(ts.containsKey(t_ch)\u0026amp;\u0026amp;ts.get(t_ch)!=s_ch)) { return false; } st.put(s_ch,t_ch); ts.put(t_ch,s_ch); } return true; } } leetcode 290 单词规律 题目描述\n给定一种规律 pattern 和一个字符串 s ，判断 s 是否遵循相同的规律。\n这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 s 中的每个非空单词之间存在着双向连接的对应规律。\n示例1:\n1 2 输入: pattern = \u0026#34;abba\u0026#34;, s = \u0026#34;dog cat cat dog\u0026#34; 输出: true 示例 2:\n1 2 输入:pattern = \u0026#34;abba\u0026#34;, s = \u0026#34;dog cat cat fish\u0026#34; 输出: false 示例 3:\n1 2 输入: pattern = \u0026#34;aaaa\u0026#34;, s = \u0026#34;dog cat cat dog\u0026#34; 输出: false 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public boolean wordPattern(String pattern, String s) { HashMap\u0026lt;Character,String\u0026gt;ps=new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;String,Character\u0026gt;sp=new HashMap\u0026lt;\u0026gt;(); // 记录每个单词的起始位置 int index=0; for(int i=0;i\u0026lt;pattern.length();i++) { char p_ch=pattern.charAt(i); // 针对单个单词 if (index \u0026gt;= s.length()) { return false; } int j=index; while(j\u0026lt;s.length()\u0026amp;\u0026amp;s.charAt(j)!=\u0026#39; \u0026#39;) { j++; } // 截取单词 String s_string=s.substring(index,j); if((ps.containsKey(p_ch)\u0026amp;\u0026amp;!ps.get(p_ch).equals(s_string))||(sp.containsKey(s_string)\u0026amp;\u0026amp;sp.get(s_string)!=p_ch)) { return false; } ps.put(p_ch,s_string); sp.put(s_string,p_ch); index=j+1; } return index\u0026gt;=s.length(); } } ","date":"2025-02-12T09:41:35+08:00","permalink":"https://Tyritic.github.io/p/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/","title":"字符串操作"},{"content":"数组作哈希表 数组就是简单的哈希表，但是数组的大小是受限的。通常用于在字母计数问题中\n经典例题 leetcode 242 有效的字母异位词 题目描述\n力扣题目链接(opens new window)\n给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n示例 1: 输入: s = \u0026ldquo;anagram\u0026rdquo;, t = \u0026ldquo;nagaram\u0026rdquo; 输出: true\n示例 2: 输入: s = \u0026ldquo;rat\u0026rdquo;, t = \u0026ldquo;car\u0026rdquo; 输出: false\n说明: 你可以假设字符串只包含小写字母。\n思路解析\n小写字母的数量只有26个，故考虑使用数组作为哈希表。因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。\n使用一个数组 record 作为哈希表对字符串 s 进行字母计数，记录字符串中每个字符的出现次数 遍历另一个字符串 t ，每遇到一个字符将 record 中对应的计数减一 遍历 record ，如果出现不为零的元素代表多了或者少了字母，不是字母异位词 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public boolean isAnagram(String s, String t) { int[] record = new int[26]; for(int i=0;i\u0026lt;s.length();i++) { record[s.charAt(i)-\u0026#39;a\u0026#39;]++; } for(int i=0;i\u0026lt;t.length();i++) { record[t.charAt(i)-\u0026#39;a\u0026#39;]--; } for(int count:record) { if(count!=0) return false; } return true; } } leetcode 383 赎金信 题目描述\n力扣题目链接(opens new window)\n给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。\n(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)\n注意：\n你可以假设两个字符串均只含有小写字母。\ncanConstruct(\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;) -\u0026gt; false canConstruct(\u0026ldquo;aa\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;) -\u0026gt; false canConstruct(\u0026ldquo;aa\u0026rdquo;, \u0026ldquo;aab\u0026rdquo;) -\u0026gt; true\n思路解析\n与 有效的字母异位词 类似，将 magazines 中的字母出现次数进行记录，再遍历 ransom 修改哈希表中的字母出现次数，检验是否存在负数即可\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public boolean canConstruct(String ransomNote, String magazine) { int ch[]=new int[26]; for(int i=0;i\u0026lt;magazine.length();i++) { ch[magazine.charAt(i)-\u0026#39;a\u0026#39;]++; } for(int i=0;i\u0026lt;ransomNote.length();i++) { ch[ransomNote.charAt(i)-\u0026#39;a\u0026#39;]--; } for(int i:ch) { if(i\u0026lt;0)return false; } return true; } } Set做哈希表 经典例题 leetcode 349 两个数组的交集 力扣题目链接(opens new window)\n题意：给定两个数组，编写一个函数来计算它们的交集。\n说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。\n思路解析\n对于集合的运算可以直接考虑使用set集合，使用两个set，一个set用于记录 nums1 中出现的不重复数字，一个set用于在遍历**nums2** 时记录前一个set和 nums2 的相同数字，转换为数组后作为答案返回\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int[] intersection(int[] nums1, int[] nums2) { HashSet\u0026lt;Integer\u0026gt; set=new HashSet\u0026lt;Integer\u0026gt;(); HashSet\u0026lt;Integer\u0026gt; ans=new HashSet\u0026lt;Integer\u0026gt;(); // 记录nums1的不重复数字 for(Integer num1:nums1) set.add(num1); // 遍历nums2 for(Integer num2:nums2) { //若是和set具有相同的数字 if(set.contains(num2)) ans.add(num2); } // 将set转换为数组返回 int arr[]=new int[ans.size()]; int index=0; for(Integer i:ans) { arr[index]=i; index++; } return arr; } } leetcode 202 快乐数 力扣题目链接(opens new window)\n编写一个算法来判断一个数 n 是不是快乐数。\n「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。\n如果 n 是快乐数就返回 True ；不是，则返回 False 。\n示例：\n输入：19 输出：true 解释： 1^2 + 9^2 = 82 8^2 + 2^2 = 68 6^2 + 8^2 = 100 1^2 + 0^2 + 0^2 = 1\n思路解析\n题目中说了会 无限循环，那么也就是说 求和的过程中，sum会重复出现 ，由此可以转换成sum是否重复在一个集合中的问题\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public boolean isHappy(int n) { // 保存sum的出现情况 HashSet\u0026lt;Integer\u0026gt;set=new HashSet\u0026lt;\u0026gt;(); // 循环直到n=1或者出现重复的sum while(n!=1\u0026amp;\u0026amp;!set.contains(n)) { set.add(n); n=getNext(n); } return n==1; } // 获取下一个数 public static int getNext(int n) { int ans=0; while(n!=0) { int temp=n%10; ans+=temp*temp; n/=10; } return ans; } } Map做哈希表 经典例题 leetcode 49 字母异位词分组 力扣题目链接(opens new window)\n给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n字母异位词 是由重新排列源单词的所有字母得到的一个新单词。\n示例 1:\n1 2 输入: strs = [\u0026#34;eat\u0026#34;, \u0026#34;tea\u0026#34;, \u0026#34;tan\u0026#34;, \u0026#34;ate\u0026#34;, \u0026#34;nat\u0026#34;, \u0026#34;bat\u0026#34;] 输出: [[\u0026#34;bat\u0026#34;],[\u0026#34;nat\u0026#34;,\u0026#34;tan\u0026#34;],[\u0026#34;ate\u0026#34;,\u0026#34;eat\u0026#34;,\u0026#34;tea\u0026#34;]] 示例 2:\n1 2 输入: strs = [\u0026#34;\u0026#34;] 输出: [[\u0026#34;\u0026#34;]] 示例 3:\n1 2 输入: strs = [\u0026#34;a\u0026#34;] 输出: [[\u0026#34;a\u0026#34;]] 提示：\n1 \u0026lt;= strs.length \u0026lt;= 104 0 \u0026lt;= strs[i].length \u0026lt;= 100 strs[i] 仅包含小写字母 思路解析\n对于此类分组问题，首先要明确分组的标准。题目显式指出分组标准：使用相同的字母。明确了分组标准，只要以分组标准为键，\n以分组内容为值，放入map中。\n分组标准可以从以下角度表示\n将每个字符串进行排序，字母异位词的排序结果相同 利用数组收集每个字母出现次数并拼接成字符串，字母异位词的字符串相同 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groupAnagrams(String[] strs) { HashMap\u0026lt;String,List\u0026lt;String\u0026gt;\u0026gt;map=new HashMap\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt;(); for(String str:strs) { // 将每个字符串排序 char[] arr=str.toCharArray(); Arrays.sort(arr); // 将排序后的结果作为键 String key=new String(arr); // 将键值对放入map中 List\u0026lt;String\u0026gt; val=map.getOrDefault(key,new ArrayList\u0026lt;String\u0026gt;()); val.add(str); map.put(key,val); } // 分组结果为map的值集合 return new ArrayList\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;(map.values()); } } leetcode 350 两个数组的交集II 题目描述\n题目链接\n给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。\n示例 1：\n1 2 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2] 示例 2:\n1 2 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9] 提示：\n1 \u0026lt;= nums1.length, nums2.length \u0026lt;= 1000 0 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 1000 思路解析\n题目中出现了“出现次数”，故考虑使用map集合做哈希表。设计算法如下\n使用一个map集合记录 **nums1**中数字的出现频率 遍历 nums2 获取 nums2 中的数字在map中的出现次数、 如果出现次数大于0 放入答案集中 将map中的出现次数减一，当出现次数为0时移除该键值对 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public int[] intersect(int[] nums1, int[] nums2) { HashMap\u0026lt;Integer,Integer\u0026gt;map=new HashMap\u0026lt;\u0026gt;(); int[]ans=new int[nums1.length]; // 记录nums1中的数字出现频率 for(Integer num1:nums1) { map.put(num1, map.getOrDefault(num1,0)+1); } // 记录交集的长度 int index=0; // 遍历nums2 for(Integer num2:nums2) { // 获取nums2中的数字在nums1中的出现次数 int count=map.getOrDefault(num2,0); if(count\u0026gt;0) { // 将nums2中的数字加入答案集 ans[index++]=num2; // nums2中的数字在nums1中的出现次数减一 count--; // 更新map if(count\u0026gt;0) { map.put(num2,count); } else { map.remove(num2); } } } return Arrays.copyOf(ans,index); } } leetcode 1 两数之和 力扣题目链接(opens new window)\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n示例:\n给定 nums = [2, 7, 11, 15], target = 9\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n思路解析\n本题需要遍历 nums 数组 ，然后判断 target-nums[i] 是否在哈希表中。由于本题需要记录数组下标，所以需要使用map集合记录元素下标\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int[] twoSum(int[] nums, int target) { // 使用map集合记录前面的数组元素 HashMap\u0026lt;Integer,Integer\u0026gt;map=new HashMap\u0026lt;\u0026gt;(); int[]res=new int[2]; if(nums == null || nums.length == 0){ return res; } for(int i=0;i\u0026lt;nums.length;i++) { // 寻找temp是否在哈希表中 int temp=target-nums[i]; if(map.containsKey(temp)) { res[0]=map.get(temp); res[1]=i; break; } map.put(nums[i],i); } return res; } } leetcode 454 四数相加 题目描述\n力扣题目链接(opens new window)\n给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。\n为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。\n例如:\n输入:\nA = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2] 输出:\n2\n解释:\n两个元组如下:\n(0, 0, 0, 1) -\u0026gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0 (1, 1, 0, 0) -\u0026gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 思路解析\n本题不需要列举出具体的四元组，只需要列举了组合数。这里需要建立sum和出现次数的映射关系，于是需要map集合\n遍历 nums1 和 nums2 记录两个数组的元素之和与出现次数的映射关系 遍历 nums3 和 nums4 ，查询map集合是否存在键为 0-nums3-nums4 的键值对 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) { int res=0; HashMap\u0026lt;Integer,Integer\u0026gt;map=new HashMap\u0026lt;\u0026gt;(); // 统计nums1和nums2的元素之和以及出现次数 for(Integer i:nums1) { for(Integer j:nums2) { int sum=i+j; map.put(sum,map.getOrDefault(sum,0)+1); } } // 统计nums3和nums4的元素之和的相反数是否在map中出现 for(Integer i:nums3) { for(Integer j:nums4) { res+=map.getOrDefault(0-i-j,0); } } return res; } } ","date":"2025-02-11T16:24:13+08:00","permalink":"https://Tyritic.github.io/p/%E5%93%88%E5%B8%8C%E8%A1%A8/","title":"哈希表"},{"content":"为什么要异步调用？ 实际项目中，一个接口可能需要同时获取多种不同的数据，然后再汇总返回\n如果是串行（按顺序依次执行每个任务）执行的话，接口的响应速度会非常慢。考虑到这些任务之间有大部分都是 无前后顺序关联 的，可以 并行执行 。通过并行执行多个任务的方式，接口的响应速度会得到大幅优化。\nFuture接口 核心思想 ：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用等待耗时任务执行完成。等我们的事情干完后，我们再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // V 代表了Future执行的任务返回值的类型 public interface Future\u0026lt;V\u0026gt; { // 取消任务执行 // 成功取消返回 true，否则返回 false boolean cancel(boolean mayInterruptIfRunning); // 判断任务是否被取消 boolean isCancelled(); // 判断任务是否已经执行完成 boolean isDone(); // 获取任务执行结果 V get() throws InterruptedException, ExecutionException; // 指定时间内没有返回计算结果就抛出 TimeOutException 异常 V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutExceptio } FutureTask 提供了 Future 接口的基本实现，常用来封装 Callable 和 Runnable，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。\nFutureTask 有两个构造函数，可传入 Callable 或者 Runnable 对象。实际上，传入 Runnable 对象也会在方法内部转换为**Callable** 对象。\nFutureTask 相当于对 Callable 进行了封装，管理着任务执行的情况，存储了 Callable 的 call 方法的任务执行结果。\nCompletableFuture 类 CompletableFuture 是 Java 8 引入的一个强大的异步编程工具。允许非阻塞地处理异步任务，并且可以通过链式调用组合多个异步操作。\n核心特性\n异步执行：使用 runAsync() 或 supplyAsync() 方法，可以非阻塞地执行任务。 任务的组合：可以使用 thenApply() 、thenAccept() 等方法在任务完成后进行后续操作，支持链式调用。 异常处理：提供 exceptionally()、handle() 等方法来处理异步任务中的异常。 并行任务：支持多个异步任务的组合，如 thenCombine()、allOf() 等方法，可以在多个任务完成后进行操作。 非阻塞获取结果：相比 Future，CompletableFuture 支持通过回调函数获取结果，而不需要显式的阻塞等待。 创建操作 使用构造方法 CompletableFuture\u0026lt;T\u0026gt; future = new CompletableFuture\u0026lt;\u0026gt;(); 使用静态工厂方法 创建异步任务并返回结果 static \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; supplyAsync(Supplier\u0026lt;U\u0026gt; supplier) ：// 使用自定义线程池(推荐) static \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; supplyAsync(Supplier\u0026lt;U\u0026gt; supplier, Executor executor) 创建异步任务，不返回结果 static CompletableFuture\u0026lt;Void\u0026gt; runAsync(Runnable runnable) ：// 使用自定义线程池(推荐) static CompletableFuture\u0026lt;Void\u0026gt; runAsync(Runnable runnable, Executor executor) 获取异步调用的结果 V get() throws InterruptedException, ExecutionException ：阻塞 调用，等待异步任务完成并返回结果。\nget() 会抛出 InterruptedException 或 ExecutionException V getNow(V valueIfAbsent) ：非阻塞 调用。如果任务已完成，返回计算结果；否则，返回默认值 valueIfAbsent 。\npublic T join() ：获取 CompletableFuture 计算的结果，如果任务 尚未完成，它会 阻塞 直到结果可用。\n如果 CompletableFuture 执行失败，join() 不会抛出 CheckedException，而是抛出 CompletionException（运行时异常）。 处理异步调用的结果 \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; thenApply(Function\u0026lt;? super T,? extends U\u0026gt; fn) ：接受一个 Function 实例，用它来修改任务返回值，并返回新的 CompletableFuture\u0026lt;U\u0026gt; ，支持 链式调用\n适合需要 基于前一个任务的结果进行计算或转换 的场景。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; import java.util.function.Function; public class ThenApplyAnonymousClassExample { public static void main(String[] args) throws ExecutionException, InterruptedException { // 创建 CompletableFuture CompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(new java.util.concurrent.Callable\u0026lt;Integer\u0026gt;() { @Override public Integer call() { return 10; } }).thenApply(new Function\u0026lt;Integer, String\u0026gt;() { @Override public String apply(Integer number) { return \u0026#34;Result: \u0026#34; + (number * 2); } }); // 获取结果 System.out.println(future.get()); // 输出: Result: 20 } } CompletableFuture\u0026lt;Void\u0026gt; thenAccept(Consumer\u0026lt;? super T\u0026gt; action) ：接受一个 Comsumer 实例（该任务访问之前异步任务的结果），并基于结果做无返回值的操作，返回新的 CompletableFuture\u0026lt;Void\u0026gt; ，支持 链式调用 ，但不返回新结果\n适用于 消费 上一个异步操作的结果，但 不需要修改结果，例如打印日志、存储数据等。 1 2 3 4 5 6 7 8 9 10 11 import java.util.concurrent.CompletableFuture; public class ThenAcceptExample { public static void main(String[] args) throws Exception { CompletableFuture\u0026lt;Void\u0026gt; future = CompletableFuture .supplyAsync(() -\u0026gt; \u0026#34;Hello, World\u0026#34;) .thenAccept(result -\u0026gt; System.out.println(\u0026#34;Received: \u0026#34; + result)); future.get(); // 等待执行完成 } } CompletableFuture\u0026lt;Void\u0026gt; thenRun(Runnable action) ：接受一个 不接收参数 且 无返回值 的 Runnable 任务（该任务不访问之前异步任务的结果），并返回新的 CompletableFuture\u0026lt;Void\u0026gt; ，支持 链式调用 ，不返回新结果\n适用于在异步任务完成后执行 不依赖于结果的 动作时。 1 2 3 4 5 6 7 8 9 10 11 import java.util.concurrent.CompletableFuture; public class ThenRunExample { public static void main(String[] args) throws Exception { CompletableFuture\u0026lt;Void\u0026gt; future = CompletableFuture .supplyAsync(() -\u0026gt; \u0026#34;Task Completed\u0026#34;) .thenRun(() -\u0026gt; System.out.println(\u0026#34;Logging: Task finished!\u0026#34;)); future.get(); // 等待任务完成 } } CompletableFuture\u0026lt;T\u0026gt; whenComplete(BiConsumer\u0026lt;? super T, ? super Throwable\u0026gt; action) ：不改变异步任务的结果，但是保存下异步任务的结果\nBiConsumer\u0026lt;? super T, ? super Throwable\u0026gt; action ： T：前一个 CompletableFuture 成功 计算的结果（可能为 null）。 Throwable ：异常信息（若任务成功则为 null） 用于 无论任务成功或失败时 都要执行某些操作，且 不修改原始结果 的场景。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; public class WhenCompleteExample { public static void main(String[] args) throws ExecutionException, InterruptedException { CompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(() -\u0026gt; { if (Math.random() \u0026gt; 0.5) { throw new RuntimeException(\u0026#34;Computation failed!\u0026#34;); } return \u0026#34;Success!\u0026#34;; }).whenComplete((result, error) -\u0026gt; { if (error != null) { System.out.println(\u0026#34;Error: \u0026#34; + error.getMessage()); } else { System.out.println(\u0026#34;Result: \u0026#34; + result); } }); // 获取最终结果（可能抛出异常） System.out.println(\u0026#34;Final result: \u0026#34; + future.get()); } } 异常处理 CompletableFuture\u0026lt;U\u0026gt; handle(BiFunction\u0026lt;? super T, Throwable, ? extends U\u0026gt; fn) ：\n如果 任务成功，则 fn 会接收到前一个任务的结果和 null 作为异常，返回一个新的结果。 如果 任务失败，则 fn 会接收到前一个任务的异常和 null 作为结果，返回一个新的结果（默认值）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import java.util.concurrent.CompletableFuture; public class HandleExample { public static void main(String[] args) { CompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(() -\u0026gt; { // 随机决定是否抛出异常 if (Math.random() \u0026gt; 0.5) { throw new RuntimeException(\u0026#34;Task failed!\u0026#34;); } return \u0026#34;Task completed successfully!\u0026#34;; }).handle((result, error) -\u0026gt; { if (error != null) { // 任务失败时，返回一个默认值 return \u0026#34;Recovered from error: \u0026#34; + error.getMessage(); } else { // 任务成功时，返回结果的修改 return \u0026#34;Handled result: \u0026#34; + result; } }); // 输出结果 System.out.println(future.join()); } } 组合处理 public \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; thenCompose(Function\u0026lt;? super T, ? extends CompletionStage\u0026lt;U\u0026gt;\u0026gt; fn)\n适用场景\n适用于 前后依赖的异步任务（即一个任务的结果作为下一个任务的输入）。 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 CompletableFuture\u0026lt;String\u0026gt; future1 = CompletableFuture.supplyAsync(new Supplier\u0026lt;String\u0026gt;() { @Override public String get() { return \u0026#34;Hello\u0026#34;; } }).thenCompose((String s)-\u0026gt; { return CompletableFuture.supplyAsync(new Supplier\u0026lt;String\u0026gt;() { @Override public String get() { return s + \u0026#34; World\u0026#34;; } }); }); public \u0026lt;U, V\u0026gt; CompletableFuture\u0026lt;V\u0026gt; thenCombine( CompletionStage\u0026lt;? extends U\u0026gt; other, BiFunction\u0026lt;? super T, ? super U, ? extends V\u0026gt; fn)\n适用场景\nthenCombine() 会在 两个任务都完成 后，使用提供的函数 合并它们的结果。两个任务之间没有前后依赖 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 CompletableFuture\u0026lt;Integer\u0026gt; future2=CompletableFuture.supplyAsync(new Supplier\u0026lt;Integer\u0026gt;() { @Override public Integer get() { return 100; } }); CompletableFuture\u0026lt;Integer\u0026gt; future3=CompletableFuture.supplyAsync(new Supplier\u0026lt;Integer\u0026gt;() { @Override public Integer get() { return 200; } }); CompletableFuture\u0026lt;Integer\u0026gt; future4=future2.thenCombine(future3, new BiFunction\u0026lt;Integer, Integer, Integer\u0026gt;() { @Override public Integer apply(Integer integer, Integer integer2) { return integer+integer2; } }); 并行处理 static CompletableFuture\u0026lt;Void\u0026gt; allOf(CompletableFuture\u0026lt;?\u0026gt;... cfs)\n适用场景\n适用于 多个异步任务并行执行，并在 所有任务完成后继续执行 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.util.concurrent.CompletableFuture; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class AllOfExample { public static void main(String[] args) { CompletableFuture\u0026lt;String\u0026gt; future1 = CompletableFuture.supplyAsync(() -\u0026gt; \u0026#34;Task 1\u0026#34;); CompletableFuture\u0026lt;String\u0026gt; future2 = CompletableFuture.supplyAsync(() -\u0026gt; \u0026#34;Task 2\u0026#34;); CompletableFuture\u0026lt;String\u0026gt; future3 = CompletableFuture.supplyAsync(() -\u0026gt; \u0026#34;Task 3\u0026#34;); CompletableFuture\u0026lt;Void\u0026gt; allOf = CompletableFuture.allOf(future1, future2, future3); // 等待所有任务完成后，获取每个任务的结果 List\u0026lt;String\u0026gt; results = Arrays.asList(future1, future2, future3) .stream() .map(CompletableFuture::join) .collect(Collectors.toList()); System.out.println(results); // 输出: [Task 1, Task 2, Task 3] } } static CompletableFuture\u0026lt;Object\u0026gt; anyOf(CompletableFuture\u0026lt;?\u0026gt;... cfs)\n适用场景\n适用于 多个任务竞争，只关心 最先完成 的任务结果。 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import java.util.concurrent.CompletableFuture; public class AnyOfExample { public static void main(String[] args) { CompletableFuture\u0026lt;String\u0026gt; future1 = CompletableFuture.supplyAsync(() -\u0026gt; { try { Thread.sleep(1000); } catch (InterruptedException e) {} return \u0026#34;Task 1\u0026#34;; }); CompletableFuture\u0026lt;String\u0026gt; future2 = CompletableFuture.supplyAsync(() -\u0026gt; { try { Thread.sleep(500); } catch (InterruptedException e) {} return \u0026#34;Task 2\u0026#34;; }); CompletableFuture\u0026lt;Object\u0026gt; anyOf = CompletableFuture.anyOf(future1, future2); System.out.println(anyOf.join()); // 输出: Task 2 （因为 Task 2 更快） } } ","date":"2025-02-08T10:24:08+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/","title":"Java中的异步调用"},{"content":"什么是阻塞队列 阻塞队列代表的是线程安全的队列，不仅可以由多个线程并发访问，还添加了等待/通知机制，以便在队列为空时阻塞获取元素的线程，直到队列变得可用，或者在队列满时阻塞插入元素的线程，直到队列变得可用。\n常见操作 由于 BlockingQueue 继承了 Queue 接口，因此，BlockingQueue 也具有 Queue 接口的基本操作，如下所示：\n插入元素 boolean add(E e) ：将元素添加到队列尾部，如果队列满了，则抛出异常 IllegalStateException 。 boolean offer(E e) ：将元素添加到队列尾部，如果队列满了，则返回 false。 删除元素 boolean remove(Object o) ：从队列中删除元素，成功返回 true，失败返回 false E poll() ：检索并删除此队列的头部，如果此队列为空，则返回 null。 查找元素 E element() ：检索但不删除此队列的头部，如果队列为空时则抛出 NoSuchElementException 异常； peek() ：检索但不删除此队列的头部，如果此队列为空，则返回 null . 特定方法 void put(E e) ：将元素添加到队列尾部，如果队列满了，则线程将阻塞直到有空间。 offer(E e, long timeout, TimeUnit unit) ：将指定的元素插入此队列中，如果队列满了，则等待指定的时间，直到队列可用。 take() ：检索并删除此队列的头部，如有必要，则等待直到队列可用； poll(long timeout, TimeUnit unit) ：检索并删除此队列的头部，如果需要元素变得可用，则等待指定的等待时间。 ArrayBlockingQueue ArrayBlockingQueue 它是一个基于数组的有界阻塞队列\n特点 有界：ArrayBlockingQueue 的大小是在构造时就确定了，并且在之后不能更改。这个界限提供了流量控制，有助于资源的合理使用。 FIFO：队列操作符合先进先出的原则。 当队列容量满时，尝试将元素放入队列将导致阻塞；尝试从一个空的队列取出元素也会阻塞 实现原理 ArrayBlockingQueue 一旦创建，容量不能改变。其并发控制采用可重入锁 ReentrantLock ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻，尝试从一个空队列中取一个元素也会同样阻塞。\nArrayBlockingQueue 默认情况下不能保证线程访问队列的公平性但是可以在构造方法中将第二个 Boolean 类型参数设置为 true\nLinkedBlockingQueue LinkedBlockingQueue 是一个底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性。\n特点 可以在队列头部和尾部进行高效的插入和删除操作。 当队列为空时，取操作会被阻塞，直到队列中有新的元素可用。当队列已满时，插入操作会被阻塞，直到队列有可用空间。 可以在构造时指定最大容量。如果不指定，默认为 Integer.MAX_VALUE，这意味着队列的大小受限于可用内存。 实现原理 LinkedBlockingQueue 使用两个锁（putLock 和 takeLock），一个用于放入操作，另一个用于取出操作。锁分离\nPriorityBlockingQueue PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。\nPriorityBlockingQueue 并发控制采用的是可重入锁 ReentrantLock，队列为无界队列（ ArrayBlockingQueue 是有界队列，LinkedBlockingQueue 也可以通过在构造函数中传入 capacity 指定队列最大的容量，但是 PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容）。\n其他阻塞队列 SynchronousQ ueue：每个插入操作必须等待另一个线程的移除操作，同样，任何一个移除操作都必须等待另一个线程的插入操作。 DelayQueue ：类似于 PriorityBlockingQueue，由二叉堆实现的无界优先级阻塞队列。 ","date":"2025-02-07T21:27:50+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/","title":"Java的阻塞队列"},{"content":"什么是线程池 线程池其实是一种池化的技术实现，池化技术的核心思想就是实现资源的复用，避免资源的重复创建和销毁带来的性能开销。线程池可以管理一堆线程，让线程执行完任务之后不进行销毁，而是继续去处理其它线程已经提交的任务。\n线程池的优点\n降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 Executor 框架 Executor 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor 框架让并发编程变得更加简单。\n框架的组成部分 任务(Runnable /Callable)：执行任务需要实现的 Runnable 接口 或 Callable接口。Runnable 接口或 Callable 接口 实现类都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。 任务的执行器(Executor)：任务执行机制的核心接口 Executor ，以及继承自 Executor 接口的 ExecutorService 接口。ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 这两个关键类实现了 ExecutorService 接口。 异步计算的结果(Future)：Future 接口以及 Future 接口的实现类 FutureTask 类都可以代表异步计算的结果。 使用流程 主线程首先要创建实现 Runnable 或者 Callable 接口的任务对象。\n提交任务\n把创建完成的实现 Runnable/Callable 接口的对象直接交给 ExecutorService 执行: 对于 Runnable 这种无返回值的任务，把 Runnable 对象提交给 ExecutorService 执行 ExecutorService.submit(Runnable task) ExecutorService.execute（Runnable command） 对于 Callable 这种有返回值的任务，把 Callable 对象提交给 ExecutorService 执行 ExecutorService 将返回一个实现 Future 接口的对象\nExecutorService.submit(Callable \u0026lt;T\u0026gt; task)\n主线程可以执行 FutureTask.get() 方法来获得任务执行完成的结果。\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // 提交Runnable任务 class Task implements Runnable { @Override public void run() { // 线程执行的代码 } } public static void main(String[] args) { ExecutorService executor = Executors.newFixedThreadPool(10); // 创建固定大小的线程池 for (int i = 0; i \u0026lt; 10; i++) { executor.submit(new Task()); // 提交任务到线程池执行 } executor.shutdown(); // 关闭线程池 } //提交Callable任务 import java.util.concurrent.*; class Task implements Callable\u0026lt;String\u0026gt; { @Override public String call() { return \u0026#34;Task executed by \u0026#34; + Thread.currentThread().getName(); } } public class CallableExample { public static void main(String[] args) { ExecutorService executor = Executors.newFixedThreadPool(10); // 创建固定大小的线程池 Future\u0026lt;String\u0026gt;[] results = new Future[10]; // 存储任务的返回结果 for (int i = 0; i \u0026lt; 10; i++) { results[i] = executor.submit(new Task()); // 提交 Callable 任务 } // 获取任务的返回结果 for (Future\u0026lt;String\u0026gt; result : results) { try { System.out.println(result.get()); // get() 方法会阻塞直到结果可用 } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } } executor.shutdown(); // 关闭线程池 } } 创建线程池的方法 使用 ThreadPoolExecutor 直接创建线程池 常见构造函数\n1 2 3 4 5 6 7 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize ：核心线程数，线程池会始终保持这个数量的线程，即使它们处于空闲状态。\nmaximumPoolSize ：最大线程数，当任务队列已满且核心线程已满时，线程池会创建新线程，最多创建到 maximumPoolSize 。\nkeepAliveTime ：当线程池中的线程数量超过 corePoolSize 时，空闲线程的存活时间，超过该时间的空闲线程会被回收。\nunit ：keepAliveTime 的时间单位，例如 TimeUnit.SECONDS 。\nworkQueue ：任务队列，用于存放待执行的任务，常见的选择包括：\nArrayBlockingQueue\u0026lt;Runnable\u0026gt;(capacity) ：有界队列，适用于任务数可预测的情况。\nLinkedBlockingQueue\u0026lt;Runnable\u0026gt;() ：无界队列，适用于任务数量不确定但不希望拒绝任务的情况（可能导致线程数不会超过 corePoolSize）。\nSynchronousQueue\u0026lt;Runnable\u0026gt;() ：不存储任务的队列，每个任务必须有可用线程立即执行，否则会创建新线程（可能导致线程数迅速增长）。\nthreadFactory ：用于创建线程的工厂，可以自定义线程名称、优先级等，常用 Executors.defaultThreadFactory() 作为默认实现。\nhandler ：拒绝策略，当任务队列满且线程数量已达到 maximumPoolSize 时，会触发拒绝策略，常见的策略包括：\nAbortPolicy（默认）：直接抛出 RejectedExecutionException，拒绝任务。 CallerRunsPolicy ：让提交任务的线程自己执行任务，避免任务丢失。 DiscardPolicy ：丢弃任务，不做任何处理。 DiscardOldestPolicy ：丢弃队列中最老的任务，并尝试再次提交新任务。 使用 Executors 工厂类 通过 Executor 框架的工具类 Executors 来创建内置线程池。\n1 2 3 4 5 ExecutorService fixedThreadPool = Executors.newFixedThreadPool(4); // 固定大小线程池 ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); // 可伸缩线程池 ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); // 单线程池 ExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(2); // 定时任务线程池 ExecutorService pool = Executors.newWorkStealingPool(); //任务窃取线程池 FixedThreadPool ：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。适合负载稳定的场景，任务数量确定且不需要动态调整线程数。 SingleThreadExecutor ： 只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。适用于需要保证任务按顺序执行的场景，或者不需要并发处理任务的情况。 CachedThreadPool ： 可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。适合短期大量并发任务的场景，任务执行时间短且线程数需求变化较大。 ScheduledThreadPool ：给定的延迟后运行任务或者定期执行任务的线程池。适用于需要周期性任务执行的场景，如定时任务调度器。 WorkStealingPool ：基于任务窃取算法的线程池。线程池中的每个线程维护一个双端队列（deque），线程可以从自己的队列中取任务执行。如果线程的任务队列为空，它可以从其他线程的队列中“窃取”任务来执行，达到负载均衡的效果。适合大量小任务并行执行，特别是递归算法或大任务分解成小任务的场景。 线程池的核心参数 corePoolSize ：线程池中用来工作的核心线程数量。 maximumPoolSize ：最大线程数，线程池允许创建的最大线程数。 keepAliveTime ：超出 corePoolSize 后创建的线程存活时间或者是所有线程最大存活时间，取决于配置。 unit ：keepAliveTime 的时间单位。 workQueue ：任务队列，是一个阻塞队列，当线程数达到核心线程数后，会将任务存储在阻塞队列中。 threadFactory ：线程池内部创建线程所用的工厂。 handler ：拒绝策略；当队列已满并且线程数量达到最大线程数量时，会调用该方法处理任务。 线程池的工作流程 提交任务 检查线程池是否运行 若线程池不再运行则放弃任务 检测当前线程池的线程数是否小于核心线程数 若小于核心线程数则创建一个工作线程并执行任务 若大于核心线程数检测阻塞队列是否已经满 若阻塞队列未满了，就会添加任务到阻塞队列中，等待工作线程获取执行 若阻塞队列已经满了就会检测当前线程池的线程数 若线程数小于最大线程数则会创建非核心线程 若线程数大于最大线程数则会拒绝任务 线程池的拒绝策略 Java中提供了四种拒绝策略用于任务被拒绝时执行该策略同时支持自定义拒绝策略\nThreadPoolExecutor.AbortPolicy ：抛出 RejectedExecutionException 来拒绝新任务的处理。 ThreadPoolExecutor.CallerRunsPolicy ：调用执行者自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。 ThreadPoolExecutor.DiscardPolicy ：不处理新任务，直接丢弃掉。 ThreadPoolExecutor.DiscardOldestPolicy ：此策略将丢弃最早的未处理的任务请求。 自定义拒绝策略\n可以自己实现 RejectedExecutionHandler 接口\n1 2 3 4 5 6 7 public class CustomRejectedExecutionHandler implements RejectedExecutionHandler { @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) { System.out.println(r.toString() + \u0026#34; rejected\u0026#34;); // 可以在这里实现日志记录或其他逻辑 } } 警告\nThreadPoolExecutor.CallerRunsPolicy 策略具有一定风险\n如果被 CallerRunsPolicy 的拒绝的任务是个非常耗时的任务，且处理提交任务的线程是主线程，可能会导致主线程阻塞，影响程序的正常运行。\n解决策略\n在内存允许的情况下，我们可以增加阻塞队列 BlockingQueue 的大小并调整堆内存以容纳更多的任务，确保任务能够被准确执行。 为了充分利用 CPU，我们还可以调整线程池的 maximumPoolSize （最大线程数）参数，这样可以提高任务处理速度，避免累计在 BlockingQueue 的任务过多导致内存用完。 线程池常用的阻塞队列 ArrayBlockingQueue：一个有界队列，底层基于数组实现。需要在初始化时指定队列的大小，队列满时，生产者会被阻塞，队列空时，消费者会被阻塞。 LinkedBlockingQueue：基于链表的阻塞队列，允许可选的界限（有界或无界）。无界模式下可以不断添加元素，直到耗尽系统资源。有界模式则类似于 ArrayBlockingQueue，但吞吐量通常较高。 PriorityBlockingQueue：一个无界的优先级队列，元素按照自然顺序或者指定的比较器顺序进行排序。与其他阻塞队列不同的是，PriorityBlockingQueue 不保证元素的 FIFO 顺序。 DelayQueue：一个无界队列，队列中的元素必须实现 Delayed 接口，只有当元素的延迟时间到期时，才能被取出。常用于延迟任务调度。 SynchronousQueue：一个没有内部容量的队列，每个插入操作必须等待对应的移除操作，反之亦然。常用于在线程之间的直接传递任务，而不是存储任务。 参见往期博客\n核心线程的执行策略 核心线程数量可以为0 当核心线程数为0的时候，会创建一个非核心线程进行执行。\n核心线程回收问题 ThreadPoolExecutor 默认不会回收核心线程，即使它们已经空闲了。这是为了减少创建线程的开销，因为核心线程通常是要长期保持活跃的。\n但是，如果线程池是被用于周期性使用的场景，且频率不高（周期之间有明显的空闲时间）可以考虑回收核心线程。在负载高峰时临时增加核心线程数，低负载时通过回收空闲线程释放资源\nallowCoreThreadTimeOut(true) 可以允许核心线程在空闲时被回收，从而释放系统资源。\n核心线程数在运行过程可以动态修改 使用 ThreadPoolExecutor.setCorePoolSize(int corePoolSize) 方法可以动态修改核心线程数。\ncorePoolSize 参数代表线程池中的核心线程数。\n当池中线程数量少于核心线程数时，会创建新的线程来处理任务。这个修改可以在线程池运行的过程中进行，立即生效。\n注意事项\n核心线程数的修改不会中断现有任务，新的核心线程数会在新任务到来时生效。 setCorePoolSize() 方法可以减少核心线程数，但如果当前线程池中的线程数量超过了新的核心线程数，多余的线程不会立即被销毁，直到这些线程空闲后被回收。 提示\n线程池中的核心参数支持动态调整\nsetCorePoolSize(int corePoolSize) ：修改 核心线程数 setMaximumPoolSize(int maximumPoolSize) ：修改 最大线程数 setKeepAliveTime(long time, TimeUnit unit) ：修改 线程存活时间 setRejectedExecutionHandler(RejectedExecutionHandler handler) ：修改 拒绝策略 线程池的状态 RUNNING ：线程池创建时就是这个状态，能够接收新任务，以及对已添加的任务进行处理。 SHUTDOWN ：调用 shutdown 方法，线程池就会转换成 SHUTDOWN 状态，此时线程池不再接收新任务，但能继续处理已添加的任务到队列中。 STOP ：调用 shutdownNow 方法，线程池就会转换成 STOP 状态，不接收新任务，也不能继续处理已添加的任务到队列中任务，并且会尝试中断正在处理的任务的线程。 TIDYING：所有的任务已经运行终止，记录的任务数量为 0。 SHUTDOWN 状态下，任务数为 0， 其他所有任务已终止，线程池会变为 TIDYING 状态 线程池在 SHUTDOWN 状态，任务队列为空且执行中任务为空，线程池会变为 TIDYING 状态 线程池在 STOP 状态，线程池中执行中任务为空时，线程池会变为 TIDYING 状态。 TERMINATED ：线程池彻底终止。线程池在 TIDYING 状态执行完 terminated() 方法就会转变为 TERMINATED 状态。 线程池的任务提交 提交不需要返回值的任务 execute() 用于提交不需要返回值的任务\n方法签名 void execute(Runnable command)\n代码示例 1 2 3 4 threadsPool.execute(new Runnable() { @Override public void run() { // TODO Auto-generated method stub } }); 异常处理 当任务通过 execute() 提交到线程池并在执行过程中抛出异常时，如果这个异常没有在任务内被捕获，那么该异常会导致当前线程终止，并且异常会被打印到控制台或日志文件中。线程池会检测到这种线程终止，并创建一个新线程来替换它，从而保持配置的线程数不变。\n提交需要返回值的任务 submit() 方法用于提交需要返回值的任务。线程池会返回一个 future 类型的对象，通过这个 future 对象可以判断任务是否执行成功，并且可以通过 future 的 get() 方法来获取返回值\n方法签名 \u0026lt;T\u0026gt; Future\u0026lt;T\u0026gt; submit(Runnable task, T result) ：无返回值的任务（可以传默认值） \u0026lt;T\u0026gt; Future\u0026lt;T\u0026gt; submit(Callable\u0026lt;T\u0026gt; task) ：有返回值的任务 代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.util.concurrent.*; public class SubmitRunnableExample { public static void main(String[] args) throws ExecutionException, InterruptedException { ExecutorService executor = Executors.newFixedThreadPool(2); Runnable task = () -\u0026gt; { System.out.println(Thread.currentThread().getName() + \u0026#34; 执行任务\u0026#34;); }; Future\u0026lt;?\u0026gt; future = executor.submit(task); // `Runnable` 没有返回值，future.get() 只能拿到 `null` System.out.println(\u0026#34;任务执行结果: \u0026#34; + future.get()); executor.shutdown(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.util.concurrent.*; public class SubmitCallableExample { public static void main(String[] args) throws ExecutionException, InterruptedException { ExecutorService executor = Executors.newFixedThreadPool(2); Callable\u0026lt;Integer\u0026gt; task = () -\u0026gt; { System.out.println(Thread.currentThread().getName() + \u0026#34; 执行任务\u0026#34;); return 42; }; Future\u0026lt;Integer\u0026gt; future = executor.submit(task); System.out.println(\u0026#34;任务执行结果: \u0026#34; + future.get()); executor.shutdown(); } } 异常处理 对于通过 submit() 提交的任务，如果在任务执行中发生异常，这个异常不会直接打印出来。相反，异常会被封装在由 submit() 返回的 Future 对象中。当调用 Future.get() 方法时，可以捕获到一个 ExecutionException 。在这种情况下，线程不会因为异常而终止，它会继续存在于线程池中，准备执行后续的任务。\n线程池的关闭 shutdown() ：关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。 shutdownNow() ：关闭线程池，线程池的状态变为 STOP。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。 shutdown() 方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * 启动一次顺序关闭，在这次关闭中，执行器不再接受新任务，但会继续处理队列中的已存在任务。 * 当所有任务都完成后，线程池中的线程会逐渐退出。 */ public void shutdown() { final ReentrantLock mainLock = this.mainLock; // ThreadPoolExecutor的主锁 mainLock.lock(); // 加锁以确保独占访问 try { checkShutdownAccess(); // 检查是否有关闭的权限 advanceRunState(SHUTDOWN); // 将执行器的状态更新为SHUTDOWN interruptIdleWorkers(); // 中断所有闲置的工作线程 onShutdown(); // ScheduledThreadPoolExecutor中的挂钩方法，可供子类重写以进行额外操作 } finally { mainLock.unlock(); // 无论try块如何退出都要释放锁 } tryTerminate(); // 如果条件允许，尝试终止执行器 } 启动线程池的平滑关闭。它不再接受新的任务，但会继续执行已经提交的任务（包括在队列中的任务）。\n线程池会进入 SHUTDOWN 状态，所有已执行和正在执行的任务都会继续完成，只有所有任务完成后，线程池才会完全终止。\nshutdownNow() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * 尝试停止所有正在执行的任务，停止处理等待的任务， * 并返回等待处理的任务列表。 * * @return 从未开始执行的任务列表 */ public List\u0026lt;Runnable\u0026gt; shutdownNow() { List\u0026lt;Runnable\u0026gt; tasks; // 用于存储未执行的任务的列表 final ReentrantLock mainLock = this.mainLock; // ThreadPoolExecutor的主锁 mainLock.lock(); // 加锁以确保独占访问 try { checkShutdownAccess(); // 检查是否有关闭的权限 advanceRunState(STOP); // 将执行器的状态更新为STOP interruptWorkers(); // 中断所有工作线程 tasks = drainQueue(); // 清空队列并将结果放入任务列表中 } finally { mainLock.unlock(); // 无论try块如何退出都要释放锁 } tryTerminate(); // 如果条件允许，尝试终止执行器 return tasks; // 返回队列中未被执行的任务列表 } 启动线程池的强制关闭。它会尝试停止所有正在执行的任务，并返回等待执行的任务列表。它会尽力中断正在执行的任务，但不能保证所有任务都能被立即停止。\n线程池进入 STOP 状态，除了尝试中断正在执行的任务外，还会清空任务队列，返回未执行的任务列表。\n线程池的最佳实践和调优 线程池声明时 必须 使用 ThreadPoolExecutor 构造函数的方式，不允许使用 Executors 去创建 FixedThreadPool 和 SingleThreadExecutor 使用的是有界阻塞队列是 LinkedBlockingQueue ，其任务队列的最大长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。 CachedThreadPool 使用的是同步队列 SynchronousQueue , 允许创建的线程数量为 Integer.MAX_VALUE ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。 ScheduledThreadPool 和 SingleThreadScheduledExecutor 使用的无界的延迟阻塞队列 DelayedWorkQueue ，任务队列最大长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。 选择合适的线程池大小 过小的线程池可能会导致任务一直在排队 过大的线程池可能会导致大家都在竞争 CPU 资源，增加上下文切换的开销 设置策略 CPU 密集型任务 (N/N+1)： 这种任务消耗的主要是 CPU 资源，线程数应设置为 N或N+1（CPU 核心数）。由于任务主要瓶颈在于 CPU 计算能力，与核心数相等的线程数能够最大化 CPU 利用率，过多线程反而会导致竞争和上下文切换开销。 I/O 密集型任务(M * N)： 这类任务大部分时间处理 I/O 交互，线程在等待 I/O 时不占用 CPU。 为了充分利用 CPU 资源，线程数可以设置为 M * N，其中 N 是 CPU 核心数，M 是一个大于 1 的倍数，建议默认设置为 2 ，具体取值取决于 I/O 等待时间和任务特点，需要通过测试和监控找到最佳平衡点。 自定义 ThreadFactory 实现给线程命名 线程池尽量不放入耗时操作 ","date":"2025-02-07T13:17:52+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF/","title":"Java的线程池技术"},{"content":"原子操作类是什么 原子类就是具有原子性操作特征的类。\njava.util.concurrent.atomic 包中的 Atomic 原子类提供了一种线程安全的方式来操作单个变量。\n原子类的基本特性 非阻塞（无锁）：基于 CAS（Compare-And-Swap） 实现，不使用 synchronized。 高效并发：比 synchronized 或 Lock 更快，适合高并发环境。 保证原子性：不会发生竞态条件（Race Condition）。 原子操作基本数据类型 AtomicBoolean：以原子更新的方式更新 boolean AtomicInteger ：以原子更新的方式更新 Integer AtomicLong：以原子更新的方式更新 Long 常用方法（以 AtomicInteger 为例）\n1 2 3 4 5 6 7 public final int get() //获取当前的值 public final int getAndSet(int newValue)//获取当前的值，并设置新的值 public final int getAndIncrement()//获取当前的值，并自增 public final int getAndDecrement() //获取当前的值，并自减 public final int getAndAdd(int delta) //获取当前的值，并加上预期的值 boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update） public final void lazySet(int newValue)//最终设置为newValue, lazySet 提供了一种比 set 方法更弱的语义，可能导致其他线程在之后的一小段时间内还是可以读到旧的值，但可能更高效。 原子操作数组类型 AtomicIntegerArray：原子更新 int 整数数组的方法。 AtomicLongArray ：原子更新 long 型证书数组的方法。 AtomicReferenceArray ：原子更新引用类型数组的方法。 常用方法（以 AtomicIntegerArray 为例）\n1 2 3 4 5 6 7 public final int get(int i) //获取 index=i 位置元素的值 public final int getAndSet(int i, int newValue)//返回 index=i 位置的当前的值，并将其设置为新值：newValue public final int getAndIncrement(int i)//获取 index=i 位置元素的值，并让该位置的元素自增 public final int getAndDecrement(int i) //获取 index=i 位置元素的值，并让该位置的元素自减 public final int getAndAdd(int i, int delta) //获取 index=i 位置元素的值，并加上预期的值 boolean compareAndSet(int i, int expect, int update) //如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update） public final void lazySet(int i, int newValue)//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 原子操作引用类型 AtomicReference ：原子更新引用类型； AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。 AtomicMarkableReference ：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class AtomicDemo { private static AtomicReference\u0026lt;User\u0026gt; reference = new AtomicReference\u0026lt;\u0026gt;(); public static void main(String[] args) { User user1 = new User(\u0026#34;a\u0026#34;, 1); reference.set(user1); User user2 = new User(\u0026#34;b\u0026#34;,2); User user = reference.getAndSet(user2); System.out.println(user); System.out.println(reference.get()); } static class User { private String userName; private int age; public User(String userName, int age) { this.userName = userName; this.age = age; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;userName=\u0026#39;\u0026#34; + userName + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } } // 输出结果 // User{userName=\u0026#39;a\u0026#39;, age=1} // User{userName=\u0026#39;b\u0026#39;, age=2} 原子更新字段 AtomicIntegerFieldUpdater :原子更新整形字段的更新器 AtomicLongFieldUpdater ：原子更新长整形字段的更新器 AtomicReferenceFieldUpdater ：原子更新引用类型里的字段的更新器 使用步骤\n通过静态方法 newUpdater 创建一个更新器，并且设置想要更新的类和字段； 字段必须使用 public volatile 进行修饰； 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class AtomicDemo { private static AtomicIntegerFieldUpdater updater = AtomicIntegerFieldUpdater.newUpdater(User.class,\u0026#34;age\u0026#34;); public static void main(String[] args) { User user = new User(\u0026#34;a\u0026#34;, 1); int oldValue = updater.getAndAdd(user, 5); System.out.println(oldValue); System.out.println(updater.get(user)); } static class User { private String userName; public volatile int age; public User(String userName, int age) { this.userName = userName; this.age = age; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;userName=\u0026#39;\u0026#34; + userName + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } } 原子操作的实现原理 Java 中的原子类是通过使用硬件提供的原子操作指令（ CAS ，Compare-And-Swap）来确保操作的原子性，从而避免线程竞争问题。\n具体细节参见 往期博客\n","date":"2025-02-06T14:56:39+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/","title":"Java中的原子操作类"},{"content":"为什么需要 ThreadLocal ThreadLocal 是 Java 中提供的一种用于实现线程局部变量的工具类。它允许每个线程都拥有自己的独立副本，从而实现线程隔离，用于解决多线程中共享对象的线程安全问题。\n通常，使用 synchronzed 关键字 或者 lock 来控制线程对临界区资源的同步顺序，但这种加锁的方式会让未获取到锁的线程进行阻塞，很显然，这种方式的时间效率不会特别高。\n线程安全问题的核心在于多个线程会对同一个临界区的共享资源进行访问，那如果每个线程都拥有自己的“共享资源”，各用各的，互不影响，这样就不会出现线程安全的问题\nThreadLocal 就是线程的“本地变量”，即每个线程都拥有该变量的一个副本，达到人手一份的目的，这样就可以避免共享资源的竞争。\nThreadLocal 的主要特性 每个线程都维护一份独立的变量副本：不同线程之间的值互不影响。 变量的生命周期与线程一致：线程结束后，ThreadLocal 变量会自动回收，避免内存泄漏。 适用于线程安全的场景，尤其是在无锁并发编程中使用，如 数据库连接、用户 Session、事务管理 等。 ThreadLocal 的主要方法 set(T value) 设置当前线程的变量值\nget() 获取当前线程的变量值\nremove() 删除当前线程的变量值，避免内存泄漏\nwithInitial(Supplier\u0026lt;T\u0026gt; supplier) 设置初始值\nThreadLocal 的实现原理 ThreadLocal 提供了一种线程内独享的变量机制，使每个线程都能有自己独立的变量副本。每个线程内部维护一个 ThreadLocalMap，这个 ThreadLocalMap 用于存储线程独立的变量副本。ThreadLocalMap 以 ThreadLocal 实例作为键，以线程独立的变量副本作为值。不同线程通过 ThreadLocal 获取各自的变量副本，而不会影响其他线程的数据。\nThreadLocal 可以理解为 ThreadLocalMap的封装，传递了变量值。\n每个Thread中都具备一个ThreadLocalMap，而 ThreadLocalMap 可以存储以ThreadLocal为 key ，Object 对象为 value 的键值对。\n提示\nThreadLocalMap 的引用情况\nkey ：ThreadLocal 对 key 是弱引用 value ：ThreadLocalMap.Entry 对 value 强引用 ThreadLocal 对 key 的引用为弱引用的原因\n防止内存泄漏 ：若 ThreadLocal 实例被不再需要的线程（尤其是在线程池中）持有为强引用，那么当该线程结束时，相关的 ThreadLocal 实例及其对应的数据可能无法被回收，导致内存持续占用。而弱引用允许垃圾回收器在内存不足时回收对象。这样，当没有其他强引用指向某个 ThreadLocal 实例时，它可以被及时回收，避免长时间占用内存。 ThreadLocal 的使用场景 用于保存用户登录信息，这样在同一个线程中的任何地方都可以获取到登录信息。 用于保存数据库连接、Session 对象等，这样在同一个线程中的任何地方都可以获取到数据库连接、Session 对象等。 用于保存事务上下文，这样在同一个线程中的任何地方都可以获取到事务上下文。 用于保存线程中的变量，这样在同一个线程中的任何地方都可以获取到线程中的变量。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class UserAuthenticationService { // 创建一个ThreadLocal实例，用于保存用户登录信息 private static ThreadLocal\u0026lt;User\u0026gt; currentUser = ThreadLocal.withInitial(() -\u0026gt; null); public static void main(String[] args) { // 模拟用户登录 loginUser(new User(\u0026#34;Alice\u0026#34;, \u0026#34;password123\u0026#34;)); System.out.println(\u0026#34;User logged in: \u0026#34; + getCurrentUser().getUsername()); // 模拟另一个线程处理另一个用户 Runnable task = () -\u0026gt; { loginUser(new User(\u0026#34;Bob\u0026#34;, \u0026#34;password456\u0026#34;)); System.out.println(\u0026#34;User logged in: \u0026#34; + getCurrentUser().getUsername()); }; Thread thread = new Thread(task); thread.start(); } // 模拟用户登录方法 public static void loginUser(User user) { // 这里通常会有一些身份验证逻辑 currentUser.set(user); } // 获取当前线程关联的用户信息 public static User getCurrentUser() { return currentUser.get(); } // 用户类 public static class User { private final String username; private final String password; public User(String username, String password) { this.username = username; this.password = password; } public String getUsername() { return username; } // 其他getter和setter... } } ThreadLocal 的缺点 内存泄漏问题 当 ThreadLocal 实例失去强引用后，由于 ThreadLocalMap 中的 key 是弱引用会被GC，而因为 Entry 对象强引用了其对应的 value 导致 value 仍然存在于 ThreadLocalMap 中。如果线程持续存活（例如线程池中的线程），ThreadLocalMap 也会一直存在，导致 key 为 null 的 entry 无法被垃圾回收，即会造成内存泄漏。\n底层原因 key 是弱引用：ThreadLocalMap 中的 key 是 ThreadLocal 的弱引用 。 这意味着，如果 ThreadLocal 实例不再被任何强引用指向，垃圾回收器会在下次 GC 时回收该实例，导致 ThreadLocalMap 中对应的 key 变为 null value 是强引用： ThreadLocalMap 中的 value 是强引用。 即使 key 被回收（变为 null），value 仍然存在于 ThreadLocalMap 中，被强引用，不会被回收。 内存泄漏的条件 ThreadLocal 实例不再被强引用，导致 ThreadLocalMap 中对应的 key 变为 null 线程持续存活，导致 ThreadLocalMap 长期存在。 解决方法 显式调用 remove() 方法 解决哈希冲突的策略可以优化 HashMap 是通过链表(红黑树)法来解决冲突，而 ThreadLocalMap 是通过开放寻址法来解决冲突。在哈希冲突多了，需要遍历的次数就多了\n使用建议 避免内存泄漏： ThreadLocal 中的 key 是弱引用，但 value 是强引用，因此需要在适当的时机调用 remove() 方法来清除 ThreadLocal 的值，避免内存泄漏。尤其是在使用线程池时，线程对象会被重用，若不手动清理，容易导致内存泄漏。 使用静态变量存放 ThreadLocal： 将 ThreadLocal 作为类的静态变量保存，这样可以确保同一个线程的局部变量在线程的生命周期内都可以被访问，避免对象频繁创建。 ","date":"2025-02-06T13:16:53+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84threadlocal/","title":"Java中的ThreadLocal"},{"content":"ReentrantLock类 ReentrantLock 是 Java 并发包（java.util.concurrent.locks） 提供的一个可重入锁，比 synchronized 更灵活，支持公平锁、非公平锁、可中断锁、超时获取锁等特性。\nReentrantLock类的常用方法 构造方法 public ReentrantLock() ：// 创建一个非公平锁（默认） public ReentrantLock(boolean fair) ：// 创建一个公平锁或非公平锁 获取锁 public void lock() ：阻塞式地获取锁（如果锁被占用，会一直等待）。 public boolean tryLock() ：尝试获取锁（不会阻塞，获取失败返回 false）。 public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException ：在指定时间内尝试获取锁，超时返回 false。 使用 ReentrantLock 时，锁必须在 try 代码块开始之前获取，并且加锁之前不能有异常抛出，否则在 finally 块中就无法释放锁（ReentrantLock 的锁必须在 finally 中手动释放）。\n判断锁的归属 public boolean isLocked() ：判断锁是否被任何线程持有。 public boolean isHeldByCurrentThread() ：判断锁是否被当前线程持有。 释放锁 public void unlock() ：释放锁 ReentrantLock 的实现原理 ReentrantLock 是基于 AQS 实现的可重入锁，内部实现依靠一个 state 变量和两个队列：同步队列 和 等待队列。\n等待队列：条件 condition 不满足时候则入等待队列等待，是个单向链表。 同步队列：等待争抢锁的线程 线程利用 CAS 修改 state 来争抢锁。争抢不到则入同步队列等待，同步队列是一个双向链表。\n是否是公平锁的区别在于：线程获取锁时是加入到同步队列尾部还是直接利用 CAS 争抢锁。\n非公平锁的实现 获取非公平锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 final boolean nonfairTryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); //1. 如果该锁未被任何线程占有，该锁能被当前线程获取 if (c == 0) { if (compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } //2. 若被占有，检查占有线程是否是当前线程 else if (current == getExclusiveOwnerThread()) { //3. 再次获取，计数加一 int nextc = c + acquires; if (nextc \u0026lt; 0) // overflow throw new Error(\u0026#34;Maximum lock count exceeded\u0026#34;); setState(nextc); return true; } return false; } 如果该锁未被任何线程占有，该锁能被当前线程获取 如果该锁已经被线程占有了，会继续检查占有线程是否为当前线程 如果是的话，同步状态加 1 返回 true，表示可以再次获取成功。每次重新获取都会对同步状态进行加一的操作 释放非公平锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 protected final boolean tryRelease(int releases) { //1. 同步状态减1 int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) { //2. 只有当同步状态为0时，锁成功被释放，返回true free = true; setExclusiveOwnerThread(null); } // 3. 锁未被完全释放，返回false setState(c); return free; } 由于锁会被获取 n 次，那么只有锁在被释放同样的 n 次之后，该锁才算是完全释放成功。\n总体逻辑 CAS 方式尝试将 state 从 0 变为 1，如果成功，锁被当前线程获取。 如果失败（锁已被占用），则进入 AQS 同步队列，等待唤醒。 公平锁的实现 获取公平锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 protected final boolean tryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { if (!hasQueuedPredecessors() \u0026amp;\u0026amp; compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc \u0026lt; 0) throw new Error(\u0026#34;Maximum lock count exceeded\u0026#34;); setState(nextc); return true; } return false; } 增加了 hasQueuedPredecessors 的逻辑判断，用来判断当前节点在同步队列中是否有前驱节点的\n如果有前驱节点，说明有线程比当前线程更早的请求资源，根据公平性，当前线程请求资源失败。\n如果当前节点没有前驱节点，才有做后面逻辑判断的必要性。\n总体逻辑 如果该锁未被任何线程占有，该锁能被当前线程获取 再检查 hasQueuedPredecessors() ，判断当前线程前面是否有排队的线程 如果队列为空，才允许当前线程尝试获取锁（严格遵循先来先得）。 如果队列中已有等待的线程，即使 state == 0 也不能直接获取锁。 如果该锁已经被线程占有了，会继续检查占有线程是否为当前线程 如果是的话，同步状态加 1 返回 true，表示可以再次获取成功。每次重新获取都会对同步状态进行加一的操作 底层实现 ReentrantLock 是基于 AQS 实现的可重入锁，内部实现依靠一个 state 变量和两个队列：同步队列 和 等待队列。\n内部通过一个计数器 state 来跟踪锁的状态和持有次数。 当线程调用 lock() 方法获取锁时，ReentrantLock 会检查 state 的值如果为 0 通过 CAS 修改为 1，表示成功加锁。 否则根据当前线程的公平性策略，加入到等待队列中。 线程首次获取锁时，state 值设为 1；如果同一个线程再次获取锁时，state 加 1；每释放一次锁，state 减 1。 如果 state = 0 ，则释放锁，并唤醒等待队列中的线程来竞争锁。 ReentrantLock 和 synchronized 的区别 用法不同：synchronized 可用来修饰普通方法、静态方法和代码块，而 ReentrantLock 只能用在代码块上。 获取锁和释放锁方式不同：synchronized 会自动加锁和释放锁，当进入 synchronized 修饰的代码块之后会自动加锁，当离开 synchronized 的代码段之后会自动释放锁。而 ReentrantLock 需要手动加锁和释放锁 锁类型不同：synchronized 属于非公平锁，而 ReentrantLock 既可以是公平锁也可以是非公平锁。 响应中断不同：ReentrantLock 可以响应中断，解决死锁的问题，而 synchronized 不能响应中断。 底层实现不同：synchronized 是 JVM 层面通过监视器实现的，而 ReentrantLock 是基于 AQS 实现的。 实现多路选择通知 ：ReentrantLock 可以实现多路选择通知（可以绑定多个 Condition），而 synchronized 只能通过 wait 和 notify/notifyAll 方法唤醒一个线程或者唤醒全部线程（单路通知） ","date":"2025-02-04T20:59:16+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84reentrantlock%E7%B1%BB/","title":"Java中的ReentrantLock类"},{"content":"什么是AQS AQS 全称 Abstract Queued Synchronizer 即 抽象队列同步器\n可以从以下角度理解\n抽象：抽象类，只实现一些主要逻辑，有些方法由子类实现； 队列：使用先进先出（FIFO）的队列存储数据； 同步：实现了同步的功能。 AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的同步器\nAQS 常见的实现类有 ReentrantLock 、 CountDownLatch 、 Semaphore 等等\nAQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，AQS 是用 CLH 队列锁 实现这个机制，即将暂时获取不到锁的线程加入到队列中。\nAQS的底层数据结构 状态 AQS 通过一个 volatile 类型的整数 state 来表示同步状态。\n1 2 3 4 /** * The synchronization state. */ private volatile int state; CLH双端队列 AQS 内部使用了一个先进先出（FIFO）的双端队列。用于管理等待获取同步状态的线程。CLH变体队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。每个节点（Node）代表一个等待的线程，节点之间通过 next 和 prev 指针链接。\n1 2 3 4 5 6 7 8 9 10 static final class Node { static final Node SHARED = new Node(); static final Node EXCLUSIVE = null; volatile int waitStatus; volatile Node prev; volatile Node next; volatile Thread thread; // 保存等待的线程 Node nextWaiter; ..... } 在 CLH 变体队列中，会对等待的线程进行阻塞操作，当队列前边的线程释放锁之后，需要对后边的线程进行唤醒\n提示\nCLH 锁 对自旋锁进行了改进，是基于单链表的自旋锁。在多线程场景下，会将请求获取锁的线程组织成一个单向队列，每个等待的线程会通过自旋访问前一个线程节点的状态，前一个节点释放锁之后，当前节点才可以获取锁。\n资源共享模式 AQS 支持两种同步方式：\n独占模式：只有一个线程能获取同步状态，例如 ReentrantLock 。 共享模式：多个线程可以同时获取同步状态，例如 Semaphore 和 ReadWriteLock。 如果共享资源被占用，需要一种特定的阻塞等待唤醒机制来保证锁的分配，AQS 会将竞争共享资源失败的线程添加到一个 CLH 队列中。\n在 CLH 锁中，当一个线程尝试获取锁并失败时，它会将自己添加到队列的尾部并自旋，等待前一个节点的线程释放锁。\n","date":"2025-02-04T16:24:44+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84aqs/","title":"Java中的AQS"},{"content":"线程同步问题 线程同步是指在多线程环境下，为了避免多个线程对共享资源进行同时访问，从而引发数据不一致或其他问题的一种机制。它通过对关键代码段加锁，使得同一时刻只有一个线程能够访问共享资源。\n当多个线程共享同一资源（如变量、对象或文件）时，若没有同步机制，可能会导致竞态条件，即线程对共享资源的操作是非原子性的，多个线程之间可能会同时修改数据，导致结果不符合预期。\n死锁问题 线程死锁的定义：多个线程在争夺资源时发生的同时阻塞。每个线程都 持有某些资源 ，并 等待其他进程释放它需要的资源 ，但这些资源 又被其他线程占用 ，导致所有进程 都无法继续执行 。（ 死锁不是锁 ）\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class A { synchronized void method1(B b) { System.out.println(\u0026#34;Thread 1: Holding lock 1...\u0026#34;); try { Thread.sleep(1000); } catch (InterruptedException e) {} System.out.println(\u0026#34;Thread 1: Waiting for lock 2...\u0026#34;); b.last(); } synchronized void last() { System.out.println(\u0026#34;Thread 1: Inside method last\u0026#34;); } } class B { synchronized void method2(A a) { System.out.println(\u0026#34;Thread 2: Holding lock 2...\u0026#34;); try { Thread.sleep(1000); } catch (InterruptedException e) {} System.out.println(\u0026#34;Thread 2: Waiting for lock 1...\u0026#34;); a.last(); } synchronized void last() { System.out.println(\u0026#34;Thread 2: Inside method last\u0026#34;); } } public class DeadlockExample { public static void main(String[] args) { final A a = new A(); final B b = new B(); // Thread 1 new Thread() { public void run() { a.method1(b); } }.start(); // Thread 2 new Thread() { public void run() { b.method2(a); } }.start(); } } 死锁的必要条件 互斥条件 ：该资源任意一个时刻只由一个线程占用。 等待占用条件 ：一个进程已经持有了至少一个资源，同时还在等待获取其他被占用的资源。在此期间，该进程不会释放已经持有的资源。 不可剥夺条件 ：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。 环路等待条件 ：若干线程之间形成一种头尾相接的循环等待资源关系。 预防和防止死锁的方法 防止死锁的方法\n破坏死锁的必要条件\n破坏等待占用条件：一次性申请所有的资源。\n破坏不可剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。\n破坏环路等待条件\n靠按序申请资源来预防 ：按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。 设置超时等待时间：为锁操作设置超时，防止线程无限期地等待锁。 预防死锁的方法\n银行家算法：在分配给进程资源前，首先判断这个进程的安全性 ，也就是预执行，判断分配后是否产生死锁现象。如果系统当前资源能满足其执行，则尝试分配，如果不满足则让该进程等待。通过不断检查剩余可用资源是否满足某个进程的最大需求，如果可以则加入安全序列，并把该进程当前持有的资源回收；不断重复这个过程，看最后能否实现让所有进程都加入安全序列 锁机制的定义 锁（Lock）是一种用于控制对共享资源的访问的机制，确保多个线程在并发执行时，能够安全地访问资源，防止数据冲突和不一致的情况。锁通常用于实现线程同步，确保同一时刻只有一个线程可以访问临界区（critical section）中的共享资源。\nJava 多线程的锁都是基于对象的，Java 中的每一个对象都可以作为一个锁。\n锁存放的位置 对象头 每个 Java 对象都有一个对象头。如果是非数组类型，则用 2 个字宽来存储对象头，如果是数组，则会用 3 个字宽来存储对象头。其中锁的相关信息保存在 Mark Word 中\n对象头的内容\n长度 内容 说明 32/64bit Mark Word 存储对象的 hashCode 或锁信息等 32/64bit Class Metadata Address 存储到对象类型数据的指针 32/64bit Array length 数组的长度（如果是数组） Mark Word 锁状态 29 bit 或 61 bit 1 bit 是否是偏向锁？ 2 bit 锁标志位 无锁 0 01 偏向锁 线程 ID 1 01 轻量级锁 指向栈中锁记录的指针 此时这一位不用于标识偏向锁 00 重量级锁 指向互斥量（重量级锁）的指针 此时这一位不用于标识偏向锁 10 GC 标记 此时这一位不用于标识偏向锁 11 锁的级别 在 JDK 1.6 以前，所有的锁都是”重量级“锁，因为使用的是操作系统的互斥锁，当一个线程持有锁时，其他试图进入 synchronized 块的线程将被阻塞，直到锁被释放。涉及到了线程上下文切换和用户态与内核态的切换，因此效率较低。\n那为了减少获得锁和释放锁带来的性能消耗，JDK 1.6 引入了 “ 偏向锁 ”和“ 轻量级锁 ” 的概念\n一个对象其实有四种锁级别，它们级别由低到高依次是\n无锁状态 偏向锁状态 轻量级锁状态 重量级锁状态 无锁状态 在这个状态下，没有线程试图获取锁。没有对资源进行锁定，任何线程都可以尝试去修改它\n偏向锁 出现原因：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此可以消除同一线程的后续锁获取和释放的开销。如果同一线程再次请求锁，就无需再次同步。\n偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。也就是说，偏向锁在资源无竞争情况下消除了同步语句。\n工作原理 一个线程在第一次进入同步块时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID。 当下次该线程进入这个同步块时，会去检查锁的 Mark Word 里面是不是放的自己的线程 ID。 如果是，表明该线程已经获得了锁，以后该线程在进入和退出同步块时不需要花费 CAS 操作来加锁和解锁 如果不是，就代表有另一个新线程来竞争这个偏向锁。新线程会尝试使用 CAS 来替换 Mark Word 里面的线程 ID 为新线程的 ID 成功，表示之前的线程不存在了， Mark Word 里面的线程 ID 为新线程的 ID，锁不会升级，仍然为偏向锁； 失败，表示之前的线程仍然存在，那么暂停之前的线程，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。 轻量级锁 多个线程在不同时段获取同一把锁 ，即不存在锁竞争的情况，也就没有线程阻塞。针对这种情况，JVM 采用轻量级锁来避免线程的阻塞与唤醒。\n当一个线程尝试获取轻量级锁时，它会在自己的栈帧中创建一个锁记录（Lock Record），然后尝试使用 CAS 操作将对象头的 Mark Word 替换为指向锁记录的指针。\n工作原理 当线程想要获取一个轻量级锁时，它会在自己的栈帧中创建一个锁记录（Lock Record）然后尝试用 CAS 将锁的 Mark Word 替换为指向锁记录的指针 如果 CAS 操作成功，即锁当前没有被任何线程持有。JVM会将锁的标志位设置为“轻量级锁”状态，并将当前线程的ID保存在对象头中。该线程会继续执行它的代码，并且无需阻塞。 如果 CAS 操作失败，即另一个线程试图获取锁。当前线程会进入自旋 状态（它会在短时间内不断地尝试访问锁的对象，而不立即挂起自己）自旋的过程会消耗一些CPU资源，但如果锁竞争不激烈，线程很可能在自旋过程中成功获取锁，而不会造成线程的阻塞。 如果自旋到一定程度（和 JVM、操作系统相关），依然没有获取到锁，那么这个线程会阻塞。同时这个锁就会升级成重量级锁。 重量级锁 重量级锁依赖于操作系统的互斥锁（mutex，用于保证任何给定时间内，只有一个线程可以执行某一段特定的代码段） 实现，而操作系统中线程间状态的转换需要相对较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗 CPU。\n锁的升级过程 无锁\u0026ndash;\u0026gt;偏向锁\u0026mdash;\u0026gt; 轻量级锁\u0026mdash;-\u0026gt;重量级锁。\n当线程A首次访问同步块时，如果此对象无锁状态且偏向锁未被禁用，JVM 会将该对象头的锁标记改为偏向锁状态，并记录下线程A的 ID。此时，对象头中的 Mark Word 中存储了持有偏向锁的线程 ID。\n当线程A再次进入这个同步块时，会去检查锁的 Mark Word 里面是不是放的自己的线程 ID。\n如果是，表明线程A已经获得了锁，以后该线程在进入和退出同步块时不需要花费 CAS 操作来加锁和解锁 如果不是，就代表有另一个线程B来竞争这个偏向锁，这个时候线程B会尝试使用 CAS 来替换 Mark Word 里面的线程 ID 为自己的 ID 成功，表示线程A已经退出同步块了， Mark Word 里面的线程 ID 为线程B的 ID，锁不会升级，仍然为偏向锁； 失败，表示线程A仍然持有偏向锁，那么JVM会 暂停线程A 撤销偏向锁 升级为轻量级锁， 线程A和线程B按照轻量级锁的方式进行竞争锁。 当线程B想要获取一个轻量级锁时，它会在自己的栈帧中创建一个锁记录（Lock Record）然后尝试用 CAS 将锁的 Mark Word 替换为指向锁记录的指针\n如果 CAS 操作成功，即锁当前没有被任何线程持有。JVM会将锁的标志位设置为“轻量级锁”状态，并将线程B的ID保存在对象头中。该线程会继续执行它的代码，并且无需阻塞。 如果 CAS 操作失败，即另一个线程（线程A）试图获取锁。线程B会进入自旋 状态（它会在短时间内不断地尝试访问锁的对象，而不立即挂起自己）自旋的过程会消耗一些CPU资源，但如果锁竞争不激烈，线程B很可能在自旋过程中成功获取锁，而不会造成线程的阻塞。 如果线程B自旋到一定程度（和 JVM、操作系统相关），依然没有获取到锁，那么这个线程会阻塞。同时这个锁就会升级成重量级锁。\nsynchronized 的优化 锁膨胀：synchronized 从无锁升级到偏向锁，再到轻量级锁，最后到重量级锁的过程。JDK 1.6 之前，synchronized 是重量级锁，也就是说 synchronized 在释放和获取锁时都会从用户态转换成内核态，而转换的效率是比较低的。但有了锁膨胀机制之后，synchronized 的状态就多了无锁、偏向锁以及轻量级锁了，这时候在进行并发操作时，大部分的场景都不需要用户态到内核态的转换了，这样就大幅的提升了 synchronized 的性能 锁消除：在某些情况下，JVM 虚拟机如果检测不到某段代码被共享和竞争的可能性，就会将这段代码所属的同步锁消除掉，从而到底提高程序性能的目的 自旋锁：当线程尝试获取轻量级锁失败时，它会进行自旋，即循环检查锁是否可用，以避免立即进入阻塞状态。自旋的次数不是固定的，而是根据之前在同一个锁上的自旋时间和锁的状态动态调整的。 锁粗化：如果 JVM 检测到一系列连续的锁操作实际上是在单一线程中完成的，则会将多个锁操作合并为一个更大范围的锁操作，这可以减少锁请求的次数。锁粗化主要针对循环内连续加锁解锁的情况进行优化。 提示\n自旋 和 锁自适应自旋\n自旋 ：在多线程环境下，当一个线程尝试获取锁时，如果锁已经被其他线程持有，线程并不会立即被阻塞，而是不断地访问锁对象。检查锁是否已经释放，线程在自旋过程中不会被挂起，也不会进行上下文切换，而是占用CPU继续执行循环检查。 锁自适应自旋 ：自适应自旋锁通过动态调整自旋的次数来提高性能。自适应的策略基于之前的自旋结果，假如上一次自旋很快获得了锁，下次可能会增加自旋次数；如果自旋失败，则减少自旋时间甚至直接放弃自旋。 乐观锁和悲观锁 乐观锁（Optimistic Lock） 和 悲观锁（Pessimistic Lock） 是两种不同的并发控制策略，常用于处理多线程环境下对共享资源的访问冲突。它们的核心区别在于对数据冲突的预判和处理方式不同。\n悲观锁 定义 悲观锁是一种假设会发生冲突的策略，认为在并发环境下线程之间会发生数据竞争，因此采用锁机制来确保线程之间的互斥执行，避免数据冲突。悲观锁会在操作数据之前加锁，保证同一时刻只有一个线程可以访问共享资源。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。\n特点 假设线程之间会有冲突，因此总是会对共享资源加锁。 锁的粒度较大，通常在整个操作过程中都持有锁。 当一个线程持有锁时，其他线程必须等待该锁释放才能继续执行。 缺点 性能开销大 ：高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。 线程阻塞 ：悲观锁还可能会存在死锁问题（线程获得锁的顺序不当时），影响代码的正常运行。 使用场景 悲观锁通常多用于写比较多的情况（读少写多场景，竞争激烈），这样可以避免频繁失败和重试影响性能。 需要严格保证数据一致性和完整性的场合 数据库中的行级锁防止多个事务同时修改同一行数据。 在电商平台等支付系统中，多个用户可能会同时购买同一商品，或者多个支付请求同时处理。使用悲观锁可以确保同一时间只有一个线程能够处理某个商品的支付请求，从而避免出现库存不足或重复支付的情况。 具体实现 synchronized 是最常见的悲观锁实现方式，会在方法或代码块上加锁，确保同一时刻只有一个线程能够执行该代码块或方法。 ReentrantLock 是 Java 提供的一种显式锁，比 synchronized 提供了更多的控制功能，例如尝试获取锁、定时获取锁等。 乐观锁 定义 乐观锁则是一种假设不会发生冲突的策略，认为在并发环境下线程之间发生冲突的概率较低，因此不通过加锁来进行数据保护，而是通过其他手段，如版本号、时间戳等，来验证数据在提交时是否发生变化。如果数据发生了变化，乐观锁会进行重试或者抛出异常。\n特点 假设冲突发生的概率较低，因此不会加锁。 在操作数据时，乐观锁会先执行任务并在提交时检查数据是否已经发生变化。 如果数据没有变化，则提交成功；如果数据发生了变化，则需要重新尝试或处理冲突。 缺点 实现复杂度较高，尤其是在多表或复杂事务的场景下。 冲突频繁时性能下降。 使用场景 “读多写少“的环境，避免频繁加锁影响性能 在数据库系统中，乐观锁用于保证数据在并发环境下的正确性。典型的做法是给每行数据加上一个 version 字段（或 timestamp）。在更新数据时，首先读取该行数据的版本号，然后在提交时比较版本号，如果版本号没有变化，则表示没有其他事务修改过该数据，可以进行更新；如果版本号发生变化，则回滚操作。 乐观锁发现有线程修改数据，可以重新读取数据，然后再尝试更新，直到成功为止或达到最大重试次数。 具体实现 版本号机制 在版本号机制中，每个数据对象（或数据库表中的记录）都会有一个与之关联的版本号或时间戳。每次读取数据时，都会获取当前的版本号。在数据修改时，首先检查版本号是否和读时一致。如果版本号没有变化，则说明在读取和写入期间没有其他事务对该数据进行修改，操作可以继续进行；否则，如果版本号发生了变化，表示数据在此期间已被其他事务修改，当前事务需要回滚或者重试。\n初始化版本号：每个数据项或记录初始化时会有一个版本号 version 读取数据时：每次读取数据时，除了获取数据内容外，还会获取该数据的版本号 version。 修改数据时： 在修改数据前，程序会检查当前数据的版本号 version。 提交更新时，检查该数据在操作期间是否有其他事务修改过。如果版本号 version 没有变化，说明没有发生冲突，可以提交更新；如果版本号 version 已发生变化，说明数据已被其他事务修改，此时需要回滚或重试。 提交操作时：如果数据没有被其他事务修改（即版本号 version 一致），则可以成功提交更新，并将版本号 version 自增。 冲突处理：如果在提交时发现版本号 version 不一致，说明发生了冲突，当前操作需要处理冲突（比如重试、提示用户、选择保留某个版本等）。 CAS操作 CAS(Compare And Swap) 是一种硬件级别的原子操作，它比较内存中的某个值是否为预期值，如果是，则更新为新值，否则不做修改。\n算法原理\n涉及的变量如下\nV：要更新的变量(var) E：预期值(expected) N：新值(new) 算法步骤如下\n比较（Compare） ：CAS 会检查内存中的某个值 V 是否与预期值 E 相等。 交换（Swap） ：如果相等，则 CAS 通过 原子 方式用新值 N 来更新 V 的值 失败重试 ：如果不相等，说明有其他线程已经修改了该值，CAS 操作失败。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。 Java中的实现和应用\n在 Java 中，实现 CAS 操作的一个关键类是 Unsafe 。Unsafe 类中的 CAS 方法是 native方法。native 关键字表明这些方法是用本地代码（通常是 C 或 C++）实现的，而不是用 Java 实现的。这些方法直接调用底层的硬件指令来实现原子操作。也就是说，Java 语言并没有直接用 Java 实现 CAS 。\nJava中的原子类都是基于 CAS 操作实现原子操作的\n原子性的保证机制\nCPU层面采取以下策略\n总线锁定：通过锁定 CPU 的总线，禁止其他 CPU 或设备访问内存。在进行操作时，CPU 发出一个 LOCK 信号，这会阻止其他处理器对内存地址进行操作，直到当前指令执行完成。 缓存锁定：当多个 CPU 操作同一块内存地址时，如果该内存地址已经被缓存到某个 CPU 的缓存中，缓存锁定机制会锁定该缓存行，防止其他 CPU 对这块内存进行修改。 存在的问题\nABA 问题：在多线程环境下，某个变量的值在一段时间内经历了从 A 到 B 再到 A 的变化，这种变化可能被线程误认为值没有变化，从而导致错误的判断和操作。 解决思路 版本号/时间戳：在每次更新一个变量时，不仅更新变量的值，还更新一个版本号。CAS 操作在比较时，除了比较值是否一致，还比较版本号是否匹配。这样，即使值回到了初始值，版本号的变化也能检测到修改。 引用标记 ：另一种类似的机制，通过在引用上标记一个布尔值，帮助区分是否发生了特定变化。 长时间自旋的CPU消耗 ：CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。 解决方案：让 JVM 支持处理器提供的pause 指令。 只能对单个变量执行操作的原子性 ：如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。 解决方案 可以考虑改用锁来保证操作的原子性 可以考虑合并多个变量，将多个变量封装成一个对象，通过 AtomicReference 来保证原子性。 可重入锁 定义 可重入锁 是指同一个线程在获取了锁之后，可以再次重复获取该锁而不会造成死锁或其他问题。当一个线程持有锁时，如果再次尝试获取该锁，就会成功获取而不会被阻塞。\n具体实现 synchronized 关键字 ReentrantLock 类 示例 同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提：锁的是同一个对象或者 class），不会因为之前已经获取过还没释放而阻塞\n1 2 3 4 5 6 7 8 9 10 public class Widget { public synchronized void doSomething() { System.out.println(\u0026#34;方法1执行...\u0026#34;); doOthers(); } public synchronized void doOthers() { System.out.println(\u0026#34;方法2执行...\u0026#34;); } } doSomething() 方法中调用了 doOthers() 方法。因为内置锁是可重入的，所以同一个线程在调用 doOthers() 时可以直接获得当前对象的锁，进入 doOthers() 进行操作。\n如果是一个不可重入锁，那么当前线程在调用doOthers()之前，需要将执行 doSomething() 时获取当前对象的锁释放掉，实际上该对象锁已经被当前线程所持有，且无法释放。所以此时会出现死锁。\n公平锁和非公平锁 公平锁 : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。\n非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。\n一般情况下，非公平锁能提升一定的效率。但是非公平锁可能会发生线程饥饿（有一些线程长时间得不到锁）的情况。\n读写锁和排他锁 排他锁 定义 ：在同一时刻只能有一个线程获取该锁，其他线程必须等待锁释放后才能继续执行。\n如果线程 T 对数据 A 加上排它锁后，则其他线程不能再对 A 加任何类型的锁。获得排它锁的线程既能读数据又能修改数据。\n特点 ：\n写操作必须独占锁，防止数据竞争。 多个线程不能同时持有排它锁，即便是读操作也会被阻塞。 具体实现\nsynchronized 关键字 ReentrantLock 类 读写锁 定义 ：允许多个线程同时读取共享资源，而在写操作时确保只有一个线程能够进行写操作（读读不互斥，读写互斥、写写互斥）。\n读操作 写操作 读操作 √ × 写操作 × × 提供两种模式\n读锁（共享锁） ：只要没有任何线程持有写锁，允许多个线程同时获取读锁。适合读操作频繁而写操作较少的场景。 写锁（独占锁） ：写锁是独占的，当有线程持有写锁时，其他线程既不能获取写锁，也不能获取读锁。写锁用于保证写操作的独占性，防止数据不一致。 ","date":"2025-02-03T12:54:49+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E9%94%81/","title":"Java中的锁"},{"content":"Java内存模型的定义 Java 内存模型（Java Memory Model, JMM） 是 Java 虚拟机 (JVM) 定义的一种规范，用于描述多线程程序中变量（包括实例字段、静态字段和数组元素）如何在内存中存储和传递的规则。规范了线程何时会从主内存中读取数据、何时会把数据写回主内存。\n操作系统有一套内存模型，而 Java 是跨平台实现的，因此它需要自己定义一套内存模型屏蔽各操作系统之间的差异。\nJMM 定义了 Java 源码到 CPU 指令执行一套规范，我们仅需直接使用 Java 提供的并发类（synchronized、volatile 等），知晓它定义的 happens-before 原则，即可写出并发安全的代码，无需关心底层的 CPU 指令重排、多级缓存等各种底层原理。\n常见并发模型\nJava 使用的是共享内存并发模型\n三大特性 JMM 的核心目标是确保多线程环境下的可见性、有序性和原子性，从而避免由于硬件和编译器优化带来的不一致问题。\n原子性 原子性 指的是一个操作或一系列操作要么全部执行成功，要么全部不执行，期间不会被其他线程干扰。\n原子类与锁：Java 提供了 java.util.concurrent.atomic 包中的原子类，如 AtomicInteger , AtomicLong，来保证基本类型的操作具有原子性。此外，synchronized 关键字和 Lock 接口也可以用来确保操作的原子性。 CAS（Compare-And-Swap）：Java 的原子类底层依赖于 CAS 操作来实现原子性。CAS 是一种硬件级的指令，它比较内存位置的当前值与给定的旧值，如果相等则将内存位置更新为新值，这一过程是原子的。CAS 可以避免传统锁机制带来的上下文切换开销。 可见性 可见性 指的是一个线程对共享变量的修改，能够被其他线程及时看见。\nvolatile：volatile 关键字是 Java 中用来保证可见性的轻量级同步机制。当一个变量被声明为 volatile 时，所有对该变量的读写操作都会直接从主内存中进行，从而确保变量对所有线程的可见性。 synchronized：synchronized 关键字不仅可以保证代码块的原子性，还可以保证进入和退出 synchronized 块的线程能够看到块内变量的最新值。每次线程退出 synchronized 块时，都会将修改后的变量值刷新到主内存中，进入该块的线程则会从主内存中读取最新的值。 Java Memory Model（JMM）：JMM 规定了共享变量在不同线程间的可见性和有序性规则。它定义了内存屏障的插入规则，确保在多线程环境下的代码执行顺序和内存可见性。 有序性 有序性 指的是程序执行的顺序和代码的先后顺序一致。但在多线程环境下，为了优化性能，编译器和处理器可能会对指令进行重排序。\n指令重排序：为了提高性能，处理器和编译器可能会对指令进行重排序。尽管重排序不会影响单线程中的执行结果，但在多线程环境下可能会导致严重的问题。例如，单例模式 中的 双重检查锁定（DCL） 模式在没有正确同步的情况下，由于指令重排序可能导致对象尚未完全初始化就被另一个线程访问。 happens-before 原则：JMM 定义了 happens-before 规则，用于约束操作之间的有序性。如果一个操作 A happens-before 操作 B，那么 A 的结果对于 B 是可见的，且 A 的执行顺序在 B 之前。这为开发者提供了在多线程环境中控制操作顺序的手段。 内存屏障：volatile 变量的读写操作会在指令流中插入内存屏障，阻止特定的指令重排序。 线程不安全问题 内存可见性问题 共享变量 对于每一个线程来说，栈都是私有的，而堆是共有的。\n在栈中的变量（局部变量、方法定义的参数、异常处理的参数）不会在线程之间共享，也就不会有内存可见性的问题，也不受内存模型的影响。\n而在堆中的变量是共享的，一般称之为共享变量。\nCPU缓存模型 CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。\n可以把 内存看作外存的高速缓存，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。\n工作方式：先复制一份数据到 CPU 缓存 中，当 CPU 需要用到的时候就可以直接从 CPU 缓存 中读取数据，当运算完成后，再将运算得到的数据写回 主存 中。\nCPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议（比如 MESI 协议）或者其他手段来解决。\n问题定义 问题定义如下：\nCPU 缓存一致性 ：每个 CPU 核心都可能对共享变量在本地缓存中进行修改，而不立即将修改的值写回到主存（RAM）。这意味着，一个线程对变量的修改可能只有它自己能看到，其他线程可能会看到旧的值，因为它们依然访问的是自己缓存中的旧值。 写回延迟 ：当线程修改变量时，它通常会先将修改结果写入自己的 CPU 缓存，而不立即更新到主存。这种写回延迟可能导致其他线程不能及时看到变量的更新，因为其他线程从主存读取数据时并没有得到最新的值。 缓存刷新与同步 ：由于缓存的写入并不是同步的，多个线程之间的修改没有立即同步到主存。线程 A 可能在自己的缓存中修改了变量 x，但线程 B 可能依然读取的是线程 A 修改前的值，直到缓存被刷新或被同步。 指令重排问题 问题定义 在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序\n编译器优化的重排序 ：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令级并行的重排序 ：现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。 内存系统的重排序 ：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 单线程情况下不会影响程序执行结果。多线程情况下，指令重排可能导致线程之间的数据不一致问题，影响并发的正确性。\n指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致。所以在多线程下，指令重排序可能会导致一些问题。\n示例：单例模式中的“双重检查锁定”就是为了避免指令重排的问题。在初始化单例对象时，由于编译器或 CPU 的指令重排，可能会导致另一个线程读取到未初始化完成的对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Singleton { private static volatile Singleton instance; private Singleton() {} public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); // 可能会发生指令重排 } } } return instance; } } instance = new Singleton(); 的执行步骤\n分配内存空间。 初始化对象。 将对象指向内存地址。 如果没有 volatile 关键字，编译器或处理器可能会重排步骤 2 和步骤 3，这就会导致另一个线程可能读取到一个尚未初始化完成的对象\nJava内存模型的结构 抽象的来看 JMM 会把内存分为 本地内存 和 主存 ，每个线程都有自己的私有化的 本地内存，然后还有个存储共享数据的 主存 。\n主存：所有共享变量（实例变量、静态变量）存储在 主存（也就是所有线程共享的内存区域）。\n本地内存：每个线程都有一个私有的本地内存，本地内存存储了该线程以读 / 写共享变量的 副本 。每个线程只能操作自己本地内存中的变量，无法直接访问其他线程的本地内存。 如果线程间需要通信，必须通过 主存 来进行。\n由图可知\n所有的 共享变量 都存在 主存 中。 每个线程都保存了一份该线程使用到的 共享变量 的副本。 如果线程间需要通信，必须通过 主存 来进行 当一个线程更改了本地内存中共享变量的副本后，它需要将这些更改刷新到主内存中，以确保其他线程可以看到这些更改。 当一个线程需要读取共享变量时，它可能首先从本地内存中读取。如果本地内存中的副本是过时的，线程将从主内存中重新加载共享变量的最新值到本地内存中。 提示\n为什么线程需要拥有自己的内存\n在多线程环境中，如果所有线程都直接操作主内存中的共享变量，会引发更多的内存访问竞争，这不仅影响性能，还增加了线程安全问题的复杂度。通过让每个线程使用本地内存，可以减少对主内存的直接访问和竞争，从而提高程序的并发性能。\n现代 CPU 为了优化执行效率，可能会对指令进行乱序执行（指令重排序）。使用本地内存（CPU 缓存和寄存器）可以在不影响最终执行结果的前提下，使得 CPU 有更大的自由度来乱序执行指令，从而提高执行效率。\n内存可见性的保证 volatile 关键字 写入 volatile 变量时，JMM 强制把值 刷新到主存。 读取 volatile 变量时，JMM 强制从主存 获取最新值，而不是从缓存读取。 禁止指令重排序（确保 volatile 变量的读写顺序不会被 JVM 或 CPU 乱序执行）。 synchronized 关键字 进入 synchronized 方法或代码块时，线程必须从主存读取最新变量。 退出 synchronized 方法或代码块时，线程必须把修改的变量刷新回主存。 由于同一时间只有一个线程能进入 synchronized 代码块，它可以确保变量修改对所有线程可见。 顺序一致性的保证和happens-before规则 指令重排的限制条件 在单线程环境下不能改变程序运行的结果 存在数据依赖关系的不允许重排序。 happens-before规则的定义 如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。 主要规则 程序次序规则：在一个线程中，代码的执行顺序是按照程序中的书写顺序执行的，即一个线程内，前面的操作 happens-before 后面的操作。 监视器锁规则：一个锁的解锁（ unlock ）操作 happens-before 后续对这个锁的加锁（ lock ）操作。也就是说，在释放锁之前的所有修改在加锁后对其他线程可见。 volatile 变量规则：对一个 volatile 变量的写操作 happens-before 后续对这个 volatile 变量的读操作。它保证 volatile 变量的可见性，确保一个线程修改 volatile 变量后，其他线程能立即看到最新值。 线程启动规则：线程 A 执行 Thread.start() 操作后，线程 B 中的所有操作 happens-before 线程 A 的 Thread.start() 调用。 线程终止规则：线程 A 执行 Thread.join() 操作后，线程 B 中的所有操作 happens-before 线程 A 从 Thread.join() 返回。 线程中断规则：对线程的 interrupt() 调用 happens-before 线程检测到中断事件（通过 Thread.interrupted() 或 Thread.isInterrupted()）。 对象的构造规则：对象的构造完成（即构造函数执行完毕） happens-before 该对象的 finalize() 方法调用。 ","date":"2025-02-02T20:48:21+08:00","permalink":"https://Tyritic.github.io/p/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bjmm/","title":"Java内存模型（JMM）"},{"content":"传统的BIO模式（同步阻塞模式） 在计算机网络中，BIO (Blocking I/O) 是一种同步的 I/O 模型。它的工作原理是：在 BIO 模式下，调用方在发起I/O操作时会被阻塞，直到操作完成后才继续执行\n它通常用于基于传统 TCP/IP 协议的客户端和服务器通信。\nBIO模式的特点 阻塞模式：在进行读取或写入操作时，线程会被阻塞，直到数据准备好或操作完成。对于每个客户端请求，都会分配一个线程来处理，直到请求完成后，线程才会释放。 简单易用：因为阻塞 I/O 模型非常直观，它不需要复杂的线程管理或事件驱动机制，对于小型应用或简单的服务器来说，BIO 是一个相对简洁的选择。 性能瓶颈：由于每个连接都需要单独的线程进行处理，BIO 会消耗更多的系统资源，并且当连接数增加时，会导致性能下降。特别是在并发量很大的情况下，BIO 的效率就变得较低。 适用于低并发的应用场景：BIO 最适合用在连接数较少且并发请求量不大的应用中，比如传统的客户端-服务器模型，或者早期的网络服务。 BIO 的缺点 线程资源浪费：每个连接都需要一个单独的线程，线程管理和上下文切换会导致系统资源浪费，尤其在连接数较多时，会对系统性能产生负面影响。 不适合高并发应用：对于高并发的场景，BIO 模型的性能会大幅下降，因为线程数过多时会导致线程切换和内存消耗过大，甚至可能导致服务器崩溃。 改进后的模式——NIO模式（同步非阻塞模式） NIO (New Input/Output) 是 Java 1.4 引入的一种非阻塞式 I/O 模型，它相较于传统的 BIO (Blocking I/O) 模型，提供了更高效的 I/O 操作，特别是在处理大量并发连接时。NIO 通过支持非阻塞 I/O 操作、缓冲区、选择器等机制，N基于I/O多路复用实现的，它可以只用一个线程处理多个客户端I/O，线程不会在执行读取或写入操作时被阻塞。线程可以在等待数据时继续做其他事情，当数据准备好时，NIO 会通过回调机制告知应用程序，显著提高了系统的性能，尤其适用于高并发的网络编程。\nNIO的特点 非阻塞 I/O：NIO 中的 I/O 操作是非阻塞的。也就是说，在进行读写操作时，线程不会被阻塞，线程可以继续处理其他任务，直到数据准备好。 双向读写：channel作为I/O 操作的数据流通道，可以用于读写数据。 线程的多路复用：选择器（Selector） 使得一个线程可以同时监控多个通道，检测哪些通道可以进行 I/O 操作。允许一个线程在多个通道之间进行多路复用。 缓冲机制：NIO 中的所有数据读写操作都通过 缓冲区（Buffer） 来完成。缓冲区是一个在内存中临时存储数据的区域 NIO 的主要组成部分 选择器（Selector）： 选择器是 NIO 的核心组件之一，它允许单个线程同时监控多个 I/O 通道，检测哪些通道准备好进行读写操作。 通过选择器，NIO 可以避免为每个连接创建一个线程，而是利用单个线程同时处理多个连接，提高了并发处理能力。 缓冲区（Buffer）： 在 NIO 中，数据读写通过 缓冲区（Buffer）进行操作。缓冲区是一个内存区域，它用于在数据与通道（Channel）之间传递数据。 数据总是从通道读到缓冲区，或者从缓冲区写到通道。缓冲区是 NIO 中的一个重要概念，类似于传统 I/O 的字节流和字符流。 通道（Channel）： 通道是 NIO 中与数据源或数据目的地之间的连接通道，用于读取或写入数据。Channel 与传统的流不同，它是双向的，即既可以读，也可以写。 NIO 提供了多个具体的通道类，如 FileChannel（文件通道）、SocketChannel（套接字通道）和 ServerSocketChannel（服务器套接字通道）。 内存映射文件（Memory-mapped Files）： NIO 支持内存映射文件，可以通过 MappedByteBuffer 来将文件的部分或整个内容映射到内存中，允许程序像访问数组一样操作文件内容，提升了文件操作的效率。 SelectionKey： SelectionKey 是选择器与通道之间的桥梁，它表示通道在选择器上的注册状态，并且它指示通道准备好进行的操作（如读、写、连接等）。 NIO的工作流程 创建通道并设置为非阻塞模式：在 NIO 中，所有的数据读取和写入操作都是通过 通道（Channel） 完成的。通道是一个连接 I/O 设备（如文件、网络套接字等）的双向数据传输通道。 将通道注册到选择器（Selector）：通道需要注册到 选择器（Selector） 上。选择器是一个核心组件，它允许单个线程监控多个通道的 I/O 状态。 轮询选择器（Selector）：在应用程序中，调用选择器的 select() 方法来阻塞并等待事件的发生。当至少一个通道准备好进行指定的 I/O 操作时，选择器会返回并且唤醒线程。 处理就绪的通道：一旦选择器检测到某些通道已经准备好进行 I/O 操作，就会返回这些通道的集合。 处理IO操作：在通道准备好后，应用程序通过 ByteBuffer 来读取或写入数据。 继续轮询并处理其他通道的 I/O 事件 关闭通道与选择器 核心组件 Channel接口 是双向的，可以同时支持读取和写入（读/写），与传统的I/O流相比更灵活。传统的流只能单向，要么是输入流要么是输出流。 常用于非阻塞I/O操作，可以结合Selector来实现多路复用，从而处理多个并发连接。 种类\nSocketChannel：用于基于TCP的网络通信，可以与服务器或客户端进行连接。 ServerSocketChannel：用于监听TCP连接，类似于传统I/O中的ServerSocket。 DatagramChannel：用于基于UDP的网络通信。 FileChannel：用于从文件中读取或向文件中写入数据。 常用方法\nSelectionKey register(Selector sel, int ops) throws ClosedChannelException sel：选择器对象，通道将会注册到该选择器上。 ops：感兴趣的操作，可以是 SelectionKey.OP_READ、SelectionKey.OP_WRITE、SelectionKey.OP_CONNECT 等。 返回值：返回一个 SelectionKey，表示通道在选择器中的状态。 创建对象 public static FileChannel open(Path path, OpenOption... options) throws IOException; path: 要操作的文件路径，类型为 Path。 options: 文件打开选项，例如 StandardOpenOption.READ、StandardOpenOption.WRITE 等，可以传入多个选项。 public static SocketChannel open() throws IOException; public static ServerSocketChannel open() throws IOException; public static DatagramChannel open() throws IOException; 读取数据 int read(ByteBuffer dst) throws IOException; Selector类 Selector 是Java NIO（New I/O）中用于实现I/O多路复用的组件，它可以通过一个单独的线程同时监视多个通道（Channel）的事件。\nSelector的作用：\n管理多个Channel：通过一个Selector实例，程序可以同时监听多个通道的I/O事件（如可读、可写、连接就绪等），从而使一个线程管理多个连接变得高效。 非阻塞I/O：Selector通常与非阻塞通道（如SocketChannel）配合使用，实现高效的非阻塞I/O操作。它使得程序无需为每个连接创建一个线程，减少了线程的开销。 Selector的事件类型：\nOP_READ：表示通道中有数据可读。 OP_WRITE：表示通道可以向其中写入数据。 OP_CONNECT：表示通道完成连接操作。 OP_ACCEPT：表示通道可以接受新的连接 Selector的常见方法\nint selectNow()：不论是否有无事件发生，立即返回 int select(long timeout)：至多阻塞 timeout 时间（或被唤醒），如果提早有事件发生，提早返回 int select()：一直阻塞着，直到有事件发生（或被唤醒） 返回值就是就绪的通道数，一般判断大于 0 即可进行后续的操作。\n","date":"2025-01-20T15:22:04+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84bionioaio/","title":"Java的BIO,NIO,AIO"},{"content":"什么是注解 注解（Annotation） 是一种元数据，它为代码提供了附加的信息，注解本身不直接影响代码的逻辑执行，但可以通过工具、编译器或运行时反射等机制对代码进行处理。\n注解的定义方式 1 2 3 4 public @interface MyAnnotation { String value() default \u0026#34;default value\u0026#34;; // 带有默认值的元素 int number(); // 没有默认值的元素 } 注解的目标对象 ElementType.TYPE：类、接口（包括注解类型）或枚举。 ElementType.FIELD：字段（包括枚举常量）。 ElementType.METHOD：方法。 ElementType.PARAMETER：方法参数。 ElementType.CONSTRUCTOR：构造方法。 ElementType.LOCAL_VARIABLE：局部变量。 ElementType.ANNOTATION_TYPE：注解类型。 ElementType.PACKAGE：包。 定义在 ElementType 枚举中，使用元注解@Target指定目标对象\n注解的生命周期 RetentionPolicy.SOURCE：注解仅在源码中存在，编译时被丢弃。 RetentionPolicy.CLASS：注解存在于编译后的 .class 文件中，但运行时不可用。 RetentionPolicy.RUNTIME：注解在运行时可用，可以通过反射机制访问。 定义在 RetentionPolicy 枚举中，使用元注解@Retention指定生命周期\n示例 1 2 3 4 5 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface JsonField { public String value() default \u0026#34;\u0026#34;; } JsonField 注解的生命周期是 RUNTIME，也就是运行时有效。 JsonField 注解装饰的目标是 FIELD，也就是针对字段的。 创建注解需要用到 @interface 关键字。 JsonField 注解有一个参数，名字为 value，类型为 String，默认值为一个空字符串。 ","date":"2025-01-20T09:40:41+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86/","title":"Java的注解原理"},{"content":"动态代理的定义 动态代理（Dynamic Proxy） 是 Java 提供的运行时动态创建代理对象的机制，主要用于在不修改原始类的情况下对方法调用进行拦截和增强。\n动态代理主要用途 简化代码：通过代理模式，可以减少重复代码，尤其是在横切关注点（如日志记录、事务管理、权限控制等）方面。 增强灵活性：动态代理使得代码更具灵活性和可扩展性，因为代理对象是在运行时生成的，可以动态地改变行为。 实现 AOP：动态代理是实现面向切面编程（AOP, Aspect-Oriented Programming）的基础，可以在方法调用前后插入额外的逻辑 动态代理的种类 基于接口的动态代理：Java自带的JDK动态代理 基于继承的动态代理：CGLIB动态代理 JDK动态代理 工作原理 基于接口：JDK 动态代理要求目标对象必须实现一个或多个接口。代理对象不是直接继承自目标对象，而是实现了与目标对象相同的接口。 基于 InvocationHandler ：当调用代理对象的任何方法时，调用会被转发到 InvocationHandler 的 invoke 方法。可以在这个 invoke 方法中定义拦截逻辑，比如前置处理、后置处理等。然后根据反射调用目标类的方法 基于 Proxy ：Proxy 利用 InvocationHandler 动态创建一个符合目标类实现的接口实例，生成目标类的代理对象。 实现步骤 定义接口： 被代理对象必须实现一个接口。 处理器类实现 InvocationHandler 接口： 通过 InvocationHandler 接口来定义代理类的逻辑，重写invoke方法实现对方法的拦截。 Object proxy：代理对象 Method method：调用的方法 Object[] args：传递的实参 主类使用 Proxy.newProxyInstance() 创建代理对象： 通过 Proxy 类的 newProxyInstance() 方法创建代理对象。 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // 定义接口 public interface UserService { void addUser(String name); void deleteUser(String name); } // 实现接口 public class UserServiceImpl implements UserService { @Override public void addUser(String name) { System.out.println(\u0026#34;Adding user: \u0026#34; + name); } @Override public void deleteUser(String name) { System.out.println(\u0026#34;Deleting user: \u0026#34; + name); } } // 处理器实现InvocationHandler接口 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class LoggingHandler implements InvocationHandler { private final Object target; public LoggingHandler(Object target) { this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 在方法执行前添加日志 System.out.println(\u0026#34;Method \u0026#34; + method.getName() + \u0026#34; is called with arguments: \u0026#34; + args[0]); // 调用真实对象的方法 Object result = method.invoke(target, args); // 在方法执行后添加日志 System.out.println(\u0026#34;Method \u0026#34; + method.getName() + \u0026#34; execution completed.\u0026#34;); return result; } } // 创建代理对象 import java.lang.reflect.Proxy; public class ProxyExample { public static void main(String[] args) { UserService userService = new UserServiceImpl(); // 创建动态代理对象 UserService proxy = (UserService) Proxy.newProxyInstance( userService.getClass().getClassLoader(), userService.getClass().getInterfaces(), new LoggingHandler(userService) ); // 使用代理对象 proxy.addUser(\u0026#34;Alice\u0026#34;); proxy.deleteUser(\u0026#34;Bob\u0026#34;); } } CGLIB动态代理 CGLIB（Code Generation Library）是一个强大的高性能的代码生成库，它可以在运行时动态生成一个目标类的子类。CGLIB代理不需要目标类实现接口，而是通过继承的方式创建代理类。因此，如果目标对象没有实现任何接口，可以使用CGLIB来创建动态代理。\n工作原理 基于继承 ：CGLIB 通过在运行时生成目标对象的子类来创建代理对象，并在子类中覆盖非 final 的方法。因此，它不要求目标对象必须实现接口。 基于 ASM ：ASM 是一个 Java 字节码操作和分析框架，CGLIB 可以通过 ASM 读取目标类的字节码，然后修改字节码生成新的类。它在运行时动态生成一个被代理类的子类作为代理类，并在子类中覆盖父类的方法，通过方法拦截技术插入增强代码。 实现步骤 创建一个需要被代理的类。 创建一个继承 MethodInterceptor 的代理类，在 intercept 方法中定义代理逻辑。 使用 Enhancer 类创建被代理类的子类，并设置回调。 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 //定义一个普通类 public class HelloService { public void sayHello(String name) { System.out.println(\u0026#34;Hello, \u0026#34; + name); } } //创建一个继承 MethodInterceptor 的代理类 实现 intercept 方法 public class HelloServiceCglib implements MethodInterceptor { private Object target; public Object getInstance(Object target) { this.target = target; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(this.target.getClass()); // 设置回调 enhancer.setCallback(this); // 创建代理对象 return enhancer.create(); } @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { System.out.println(\u0026#34;Before sayHello\u0026#34;); // 执行目标类的方法 Object result = proxy.invokeSuper(obj, args); System.out.println(\u0026#34;After sayHello\u0026#34;); return result; } } //实现 public static void main(String[] args) { HelloService target = new HelloService(); HelloServiceCglib cglib = new HelloServiceCglib(); HelloService proxy = (HelloService) cglib.getInstance(target); proxy.sayHello(\u0026#34;World\u0026#34;); } ","date":"2025-01-19T20:10:12+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","title":"Java的动态代理"},{"content":"反射机制的定义 Java的反射机制是一种强大的特性，它允许在运行时动态地查询和操作类、方法、构造器、字段等信息，甚至可以在运行时创建对象、修改字段和调用方法。反射机制使得 Java 程序具备了更高的灵活性，可以编写更加通用和扩展性强的代码。\n反射机制的特性 运行时类信息访问：反射机制允许程序在运行时获取类的完整结构信息，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。 动态对象创建：可以使用反射API动态地创建对象实例，即使在编译时不知道具体的类名。这是通过Class类的newInstance()方法或Constructor对象的newInstance()方法实现的。 动态方法调用：可以在运行时动态地调用对象的方法，包括私有方法。这通过Method类的invoke()方法实现，允许你传入对象实例和参数值来执行方法。 访问和修改字段值：反射还允许程序在运行时访问和修改对象的字段值，即使是私有的。这是通过Field类的get()和set()方法完成的。 反射的核心类 Class 类：Class 类是反射的核心，它表示一个类或接口的元数据。通过 Class 类，可以获取类的构造器、方法、字段等信息。 Constructor 类：表示类的构造器，可以通过反射动态创建对象。 Method 类：表示类的方法，可以调用指定的实例方法。 Field 类：表示类的字段（成员变量），可以访问和修改字段的值。 Modifier 类：用于解析和获取类、方法、字段等的访问修饰符。 反射的常见操作 类对象（class） 获取类的class的对象 Class.forName(\u0026quot;全类名\u0026quot;)：对应于Java的源代码阶段 类名.class：对应于加载阶段（将字节码文件加入到内存中） 对象.getClass()：对应于运行阶段 上述三个方法获取的class的对象是同一个对象\n获取类的构造器（Constructor） getConstructor(Class\u0026lt;?\u0026gt;... parameterTypes)：获取类的公共构造器，构造器的参数类型必须与传入的类型匹配。\n如果构造器不存在，会抛出 NoSuchMethodException。\n1 2 3 Class\u0026lt;?\u0026gt; clazz = Person.class; Constructor\u0026lt;?\u0026gt; constructor = clazz.getConstructor(String.class, int.class); // 传入构造器参数类型 Person person = (Person) constructor.newInstance(\u0026#34;John\u0026#34;, 25); getDeclaredConstructor(Class\u0026lt;?\u0026gt;... parameterTypes)：获取类的所有构造器（包括私有构造器、受保护的构造器等），与 getConstructor 方法不同，getDeclaredConstructor 会返回类的所有构造器，而不仅限于公共构造器。\n1 2 3 Constructor\u0026lt;?\u0026gt; constructor = clazz.getDeclaredConstructor(String.class, int.class); // 获取指定参数类型的构造器 constructor.setAccessible(true); // 如果是私有构造器，需要解除访问权限 Person person = (Person) constructor.newInstance(\u0026#34;Alice\u0026#34;, 30); getConstructors()：获取类的所有公共构造器，返回一个 Constructor 数组，包含该类及其父类的所有公共构造器。\n1 2 3 4 Constructor\u0026lt;?\u0026gt;[] constructors = clazz.getConstructors(); for (Constructor\u0026lt;?\u0026gt; constructor : constructors) { System.out.println(constructor.getName()); } getDeclaredConstructors()：获取类的所有构造器（包括私有构造器、受保护的构造器等），返回一个 Constructor 数组，包含该类的所有构造器（不包括父类的构造器）。\n1 2 3 4 Constructor\u0026lt;?\u0026gt;[] declaredConstructors = clazz.getDeclaredConstructors(); for (Constructor\u0026lt;?\u0026gt; constructor : declaredConstructors) { System.out.println(constructor.getName()); } 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 import java.lang.reflect.*; class Person { private String name; private int age; // 公共构造器 public Person(String name, int age) { this.name = name; this.age = age; } // 默认构造器 public Person() {} // 私有构造器 private Person(String name) { this.name = name; } public void display() { System.out.println(\u0026#34;Name: \u0026#34; + name + \u0026#34;, Age: \u0026#34; + age); } } public class ConstructorDemo { public static void main(String[] args) throws Exception { Class\u0026lt;?\u0026gt; clazz = Person.class; // 1. 获取公共构造器 (带有参数) Constructor\u0026lt;?\u0026gt; constructor1 = clazz.getConstructor(String.class, int.class); Person person1 = (Person) constructor1.newInstance(\u0026#34;John\u0026#34;, 25); person1.display(); // 2. 获取默认构造器 Constructor\u0026lt;?\u0026gt; constructor2 = clazz.getConstructor(); Person person2 = (Person) constructor2.newInstance(); person2.display(); // 3. 获取私有构造器 Constructor\u0026lt;?\u0026gt; constructor3 = clazz.getDeclaredConstructor(String.class); constructor3.setAccessible(true); // 解除访问限制 Person person3 = (Person) constructor3.newInstance(\u0026#34;Alice\u0026#34;); person3.display(); // 4. 获取所有公共构造器 Constructor\u0026lt;?\u0026gt;[] constructors = clazz.getConstructors(); System.out.println(\u0026#34;Public constructors:\u0026#34;); for (Constructor\u0026lt;?\u0026gt; constructor : constructors) { System.out.println(constructor.getName()); } // 5. 获取所有构造器（包括私有的） Constructor\u0026lt;?\u0026gt;[] declaredConstructors = clazz.getDeclaredConstructors(); System.out.println(\u0026#34;Declared constructors:\u0026#34;); for (Constructor\u0026lt;?\u0026gt; constructor : declaredConstructors) { System.out.println(constructor.getName()); } } } // 输出 // Name: John, Age: 25 // Name: null, Age: 0 // Name: Alice, Age: 0 // Public constructors: // Person // Person // Declared constructors: // Person // Person // Person 获取类的方法（Method） getMethod(String name, Class\u0026lt;?\u0026gt;... parameterTypes) 获取类的公共方法，包括继承自父类的公共方法。 如果指定的方法不存在，会抛出 NoSuchMethodException。 该方法的第一个参数是方法名，后续参数是方法的参数类型（可以是空参数）。 getDeclaredMethod(String name, Class\u0026lt;?\u0026gt;... parameterTypes) 获取类的所有方法（包括私有方法和受保护的方法）。 如果指定的方法不存在，会抛出 NoSuchMethodException。 getMethods() 返回类的所有公共方法（包括继承自父类的公共方法）。 返回的是一个 Method 数组，包含该类的所有公共方法。 getDeclaredMethods() 返回类的所有方法（包括私有方法、受保护的方法和公共方法），但不包括从父类继承的方法。 返回的是一个 Method 数组，包含该类的所有方法。 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import java.lang.reflect.*; class Person { private String name; private int age; // 公共构造器 public Person(String name, int age) { this.name = name; this.age = age; } // 公共方法 public void display() { System.out.println(\u0026#34;Name: \u0026#34; + name + \u0026#34;, Age: \u0026#34; + age); } // 私有方法 private void privateMethod() { System.out.println(\u0026#34;This is a private method.\u0026#34;); } // 受保护的方法 protected void protectedMethod() { System.out.println(\u0026#34;This is a protected method.\u0026#34;); } } public class MethodDemo { public static void main(String[] args) throws Exception { // 创建对象实例 Person person = new Person(\u0026#34;John\u0026#34;, 25); // 1. 获取公共方法 Class\u0026lt;?\u0026gt; clazz = person.getClass(); Method method1 = clazz.getMethod(\u0026#34;display\u0026#34;); // 获取公共方法 method1.invoke(person); // 调用方法 // 2. 获取私有方法 Method method2 = clazz.getDeclaredMethod(\u0026#34;privateMethod\u0026#34;); // 获取私有方法 method2.setAccessible(true); // 解除访问限制 method2.invoke(person); // 调用私有方法 // 3. 获取受保护的方法 Method method3 = clazz.getDeclaredMethod(\u0026#34;protectedMethod\u0026#34;); // 获取受保护的方法 method3.setAccessible(true); // 解除访问限制 method3.invoke(person); // 调用受保护的方法 // 4. 获取所有方法（包括私有、受保护方法） Method[] declaredMethods = clazz.getDeclaredMethods(); // 获取所有方法 System.out.println(\u0026#34;Declared methods:\u0026#34;); for (Method method : declaredMethods) { System.out.println(method.getName()); } } } // 输出结果： // Name: John, Age: 25 // This is a private method. // This is a protected method. // Declared methods: // display // privateMethod // protectedMethod 获取类的字段（Field） getField(String name) 获取类的公共字段，包括继承自父类的公共字段。 如果指定的字段不存在，会抛出 NoSuchFieldException。 只能获取公共字段。 getDeclaredField(String name) 获取类的所有字段（包括私有字段、受保护字段和公共字段）。 如果指定的字段不存在，会抛出 NoSuchFieldException。 getFields() 获取类的所有公共字段（包括继承自父类的公共字段）。 返回一个 Field 数组，包含该类的所有公共字段。 getDeclaredFields() 获取类的所有字段（包括私有、受保护和公共字段），但不包括从父类继承的字段。 返回一个 Field 数组，包含该类的所有字段。 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 import java.lang.reflect.*; class Person { public String name; private int age; protected String gender; // 公共构造器 public Person(String name, int age, String gender) { this.name = name; this.age = age; this.gender = gender; } } public class FieldDemo { public static void main(String[] args) throws Exception { // 创建对象实例 Person person = new Person(\u0026#34;John\u0026#34;, 25, \u0026#34;Male\u0026#34;); // 1. 获取公共字段 Class\u0026lt;?\u0026gt; clazz = person.getClass(); Field field1 = clazz.getField(\u0026#34;name\u0026#34;); // 获取公共字段 System.out.println(\u0026#34;Public field \u0026#39;name\u0026#39;: \u0026#34; + field1.get(person)); // 获取字段值 // 2. 获取私有字段 Field field2 = clazz.getDeclaredField(\u0026#34;age\u0026#34;); // 获取私有字段 field2.setAccessible(true); // 解除访问限制 System.out.println(\u0026#34;Private field \u0026#39;age\u0026#39;: \u0026#34; + field2.get(person)); // 获取字段值 // 3. 获取受保护的字段 Field field3 = clazz.getDeclaredField(\u0026#34;gender\u0026#34;); // 获取受保护字段 field3.setAccessible(true); // 解除访问限制 System.out.println(\u0026#34;Protected field \u0026#39;gender\u0026#39;: \u0026#34; + field3.get(person)); // 获取字段值 // 4. 获取所有公共字段（包括从父类继承的公共字段） Field[] fields = clazz.getFields(); // 获取所有公共字段 System.out.println(\u0026#34;Public fields:\u0026#34;); for (Field field : fields) { System.out.println(field.getName()); } // 5. 获取所有字段（包括私有、受保护和公共字段） Field[] declaredFields = clazz.getDeclaredFields(); // 获取所有字段 System.out.println(\u0026#34;Declared fields:\u0026#34;); for (Field field : declaredFields) { System.out.println(field.getName()); } } } // 输出： // Public field \u0026#39;name\u0026#39;: John // Private field \u0026#39;age\u0026#39;: 25 // Protected field \u0026#39;gender\u0026#39;: Male // Public fields: // name // Declared fields: // name // age // gender 字段（Field） 访问对象字段属性 获取对象的 Field 对象。 通过 Field 对象访问或修改字段的值。 对于 private、protected 或默认访问级别的字段，使用 setAccessible(true) 解除访问限制。 获取字段：public Object get(Object obj) throws IllegalAccessException 获取对象中某个字段的值。\n获取字段名：public String getName()\n获取字段的数据类型：public Class\u0026lt;?\u0026gt; getType()\n获取访问修饰符：public int getModifiers() 如果多个修饰符一起使用，它们的整数值是通过位 OR 运算得出的\npublic：1 private：2 protected：4 static：8 final：16 获取访问修饰符的字符串表示：Modifier.toString(int modifiers)\n修改访问性：setAccessible(Boolean T)\n示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import java.lang.reflect.Field; import java.lang.reflect.Modifier; class Person { public String name; // 公共字段 private int age; // 私有字段 protected String gender; // 受保护字段 static String country; // 静态字段 // 公共构造器 public Person(String name, int age, String gender) { this.name = name; this.age = age; this.gender = gender; } } public class FieldInfoDemo { public static void main(String[] args) throws Exception { // 创建一个 Person 对象 Person person = new Person(\u0026#34;John Doe\u0026#34;, 30, \u0026#34;Male\u0026#34;); // 获取 Person 类的 Class 对象 Class\u0026lt;?\u0026gt; clazz = person.getClass(); // 获取所有字段，包括私有、受保护和公共字段 Field[] fields = clazz.getDeclaredFields(); // 遍历所有字段 for (Field field : fields) { // 获取字段名 String fieldName = field.getName(); // 获取字段的修饰符 int modifiers = field.getModifiers(); // 获取修饰符的字符串表示 String modifierString = Modifier.toString(modifiers); // 获取字段的值 // 使用 setAccessible(true) 来允许访问私有字段 field.setAccessible(true); Object fieldValue = field.get(person); // 输出字段信息 System.out.println(\u0026#34;Field: \u0026#34; + fieldName + \u0026#34;, Modifier: \u0026#34; + modifierString + \u0026#34;, Value: \u0026#34; + fieldValue); } } } // 输出： // Field: name, Modifier: public, Value: John Doe // Field: age, Modifier: private, Value: 30 // Field: gender, Modifier: protected, Value: Male // Field: country, Modifier: static, Value: null 修改对象字段 修改字段：public void set(Object obj, Object value) throws IllegalAccessException, IllegalArgumentException 修改对象中某个字段的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import java.lang.reflect.Field; class Person { public String name; // 公共字段 private int age; // 私有字段 protected String gender; // 受保护字段 static String country; // 静态字段 // 公共构造器 public Person(String name, int age, String gender) { this.name = name; this.age = age; this.gender = gender; } } public class ModifyFieldDemo { public static void main(String[] args) throws Exception { // 创建一个 Person 对象 Person person = new Person(\u0026#34;John Doe\u0026#34;, 30, \u0026#34;Male\u0026#34;); // 获取 Person 类的 Class 对象 Class\u0026lt;?\u0026gt; clazz = person.getClass(); // 获取所有字段，包括私有、受保护和公共字段 Field[] fields = clazz.getDeclaredFields(); // 遍历所有字段 for (Field field : fields) { // 获取字段名 String fieldName = field.getName(); // 获取字段的修饰符 int modifiers = field.getModifiers(); String modifierString = java.lang.reflect.Modifier.toString(modifiers); // 输出字段信息 System.out.println(\u0026#34;Field: \u0026#34; + fieldName + \u0026#34;, Modifier: \u0026#34; + modifierString + \u0026#34;, Original Value: \u0026#34; + field.get(person)); // 修改字段的值 field.setAccessible(true); // 设置字段为可访问 if (field.getType() == String.class) { // 如果是 String 类型，修改字段值 field.set(person, \u0026#34;Jane Doe\u0026#34;); } else if (field.getType() == int.class) { // 如果是 int 类型，修改字段值 field.set(person, 35); } // 输出修改后的字段值 System.out.println(\u0026#34;Modified Field: \u0026#34; + fieldName + \u0026#34;, New Value: \u0026#34; + field.get(person)); } } } 方法（Method） 访问对象方法属性 获取方法名：public String getName()\n获取方法的返回值类型：public Class\u0026lt;?\u0026gt; getReturnType()\n获取访问修饰符：public int getModifiers() 如果多个修饰符一起使用，它们的整数值是通过位 OR 运算得出的\npublic：1 private：2 protected：4 static：8 final：16 获取访问修饰符的字符串表示：Modifier.toString(int modifiers)\n获取方法的形参类型： Class\u0026lt;?\u0026gt;[] getParameterTypes()\n获取方法的形参数组：public Parameter[] getParameters()\ngetName()：获取参数名称。 getType()：获取参数的类型。 修改访问性：setAccessible(Boolean T)\n示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import java.lang.reflect.Method; import java.lang.reflect.Parameter; class Person { public String greet(String name, int age) { return \u0026#34;Hello, \u0026#34; + name + \u0026#34;. You are \u0026#34; + age + \u0026#34; years old.\u0026#34;; } public void display() { System.out.println(\u0026#34;This is a display method.\u0026#34;); } } public class ReflectDemo { public static void main(String[] args) throws Exception { // 获取 Person 类的 Class 对象 Class\u0026lt;?\u0026gt; clazz = Person.class; // 获取 greet 方法 Method greetMethod = clazz.getMethod(\u0026#34;greet\u0026#34;, String.class, int.class); // 获取方法的参数信息 Parameter[] parameters = greetMethod.getParameters(); // 输出参数的详细信息 System.out.println(\u0026#34;Method: \u0026#34; + greetMethod.getName()); for (Parameter param : parameters) { System.out.println(\u0026#34;Parameter name: \u0026#34; + param.getName()); System.out.println(\u0026#34;Parameter type: \u0026#34; + param.getType().getName()); } } } // 输出： // Method: greet // Parameter name: name // Parameter type: java.lang.String // Parameter name: age // Parameter type: int 调用对象方法 public Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException\nobj:\n类型：Object 说明：调用方法的目标对象。对于实例方法，它是目标对象实例；对于静态方法，这个参数可以是 null（尽管最好传递 null）。 args:\n类型：Object... 说明：方法的实际参数（如果有）。这个参数是一个可变参数，表示调用方法时传入的参数值。如果方法没有参数，args 可以是空数组或者不传递任何值。 Object: 返回调用方法的结果。如果方法是 void，则返回 null。\n示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class Person { private String name; public Person(String name) { this.name = name; } // 有返回值的方法 public String greet(String greeting) { return greeting + \u0026#34;, \u0026#34; + name; } // 无返回值的方法 public void display() { System.out.println(\u0026#34;Hello, \u0026#34; + name); } } import java.lang.reflect.Method; public class ReflectDemo { public static void main(String[] args) throws Exception { // 创建 Person 对象 Person person = new Person(\u0026#34;Alice\u0026#34;); // 获取 Person 类的 Class 对象 Class\u0026lt;?\u0026gt; clazz = person.getClass(); // 获取 greet 方法（具有一个 String 参数） Method greetMethod = clazz.getMethod(\u0026#34;greet\u0026#34;, String.class); // 调用 greet 方法，传递参数 \u0026#34;Hello\u0026#34; String result = (String) greetMethod.invoke(person, \u0026#34;Hello\u0026#34;); System.out.println(\u0026#34;Result from greet method: \u0026#34; + result); // 获取 display 方法（没有参数） Method displayMethod = clazz.getMethod(\u0026#34;display\u0026#34;); // 调用 display 方法 displayMethod.invoke(person); } } // 输出： // Result from greet method: Hello, Alice // Hello, Alice 对象 创建对象 通过反射得到的构造器创建对象（ Constructor）\n1 2 Constructor\u0026lt;MyClass\u0026gt; constructor = MyClass.class.getConstructor(); MyClass obj = constructor.newInstance(); 通过类的字节码（Class）来创建对象\n1 MyClass obj = (MyClass) Class.forName(\u0026#34;com.example.MyClass\u0026#34;).newInstance(); 反射的使用场景 Spring 框架的 IOC（动态加载管理 Bean），Spring通过配置文件配置各种各样的bean，你需要用到哪些bean就配哪些，spring容器就会根据你的需求去动态加载，你的程序就能健壮地运行。\nSpring通过XML配置模式装载Bean的过程：\n将程序中所有XML或properties配置文件加载入内存 Java类里面解析xml或者properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息 使用反射机制，根据这个字符串获得某个类的Class实例 动态配置实例的属性 ","date":"2025-01-17T09:15:30+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/","title":"Java的反射机制"},{"content":"Optional类的定义 Optional 类是 Java 8 引入的一个容器类，用来解决可能出现的 NullPointerException 问题。它表示一个值可能存在也可能不存在，提供了一种优雅的方式来避免显式的 null 检查。\n核心思想 避免显式使用 null： 使用 Optional 代替直接返回 null，从而避免潜在的空指针异常。 增强代码可读性： 提供清晰的 API，表示值的存在或缺失，并能安全处理缺失的值。 函数式编程支持： 支持链式调用和流式操作，更适合在函数式编程中使用 创建对象方法 Optional.empty()：创建一个空的 Optional 对象。 1 Optional\u0026lt;String\u0026gt; emptyOpt = Optional.empty(); Optional.of(value)：根据非空值创建一个 Optional 对象。 1 Optional\u0026lt;String\u0026gt; nameOpt = Optional.of(\u0026#34;John\u0026#34;); 注意：传入 null 值会抛出 NullPointerException。\nOptional.ofNullable(value)：根据值创建 Optional，值可以是 null。 1 Optional\u0026lt;String\u0026gt; nullableOpt = Optional.ofNullable(null); 判断值是否存在 isPresent()：值存在返回 true，否则返回 false。 isEmpty()：值不存在返回 true（Java 11 引入）。 获取值 get()：返回值，如果值不存在会抛出 NoSuchElementException。\n1 String name = nameOpt.get(); orElse(defaultValue)：值存在则返回值，否则返回默认值。\n1 String name = nullableOpt.orElse(\u0026#34;Default Name\u0026#34;); 操作值 ifPresent(Consumer\u0026lt;? super T\u0026gt;)：值存在时执行给定的动作。\nmap(Function\u0026lt;? super T, ? extends U\u0026gt;)：值存在时对值进行映射操作。\n","date":"2025-01-16T20:56:03+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84optional%E7%B1%BB/","title":"Java中的Optional类"},{"content":"内容模块库表设计 单一文章 文章表 字段名 数据类型 默认值 描述 id int(10) unsigned AUTO_INCREMENT 主键ID user_id int(10) unsigned 0 用户ID article_type tinyint(4) 1 文章类型（1-博文，2-问答） title varchar(120) '' 文章标题 short_title varchar(120) '' 短标题 picture varchar(128) '' 文章头图 summary varchar(300) '' 文章摘要 category_id int(10) unsigned 0 类目ID source tinyint(4) 1 来源（1-原创，2-AI，3-翻译） source_url varchar(128) '1' 原文链接 offical_stat int(10) unsigned 0 官方状态（0-非官方，1-官方） topping_stat int(10) unsigned 0 置顶状态（0-不置顶，1-置顶） cream_stat int(10) unsigned 0 加精状态（0-不加精，1-加精） status tinyint(4) 0 状态（0-未发布，1-已发布） deleted tinyint(4) 0 是否删除 create_time timestamp CURRENT_TIMESTAMP 创建时间 update_time timestamp CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP 最后更新时间 文章详情表 字段名 数据类型 默认值 描述 id int(10) unsigned AUTO_INCREMENT 主键ID article_id int(10) unsigned 0 文章ID version int(10) unsigned 0 版本号 content longtext NULL 文章内容 deleted tinyint(4) 0 是否删除 create_time timestamp CURRENT_TIMESTAMP 创建时间 update_time timestamp CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP 最后更新时间 分类表 文章对应的分类，要求一个文章只能挂在一个分类下。分类表和文章表之间通过\n字段名 数据类型 默认值 描述 id int(10) unsigned AUTO_INCREMENT 主键ID category_name varchar(64) '' 类目名称 status tinyint(4) 0 状态（0-未发布，1-已发布） rank tinyint(4) 0 排序 deleted tinyint(4) 0 是否删除 create_time timestamp CURRENT_TIMESTAMP 创建时间 update_time timestamp CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP 最后更新时间 专栏文章 专栏主要是一系列文章的合集，通过专栏-文章表建立专栏和文字之间的映射关系\n专栏表 字段名 数据类型 默认值 描述 id int(10) unsigned AUTO_INCREMENT 专栏ID column_name varchar(64) '' 专栏名称 user_id int(10) unsigned 0 作者ID introduction varchar(256) '' 专栏简述 cover varchar(128) '' 专栏封面 state tinyint(3) unsigned 0 状态（0-审核中，1-连载，2-完结） publish_time timestamp '1970-01-02 00:00:00' 上线时间 create_time timestamp CURRENT_TIMESTAMP 创建时间 update_time timestamp CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP 最后更新时间 section int(10) unsigned 0 排序 nums int(10) unsigned 0 专栏预计的更新的文章数 type int(10) unsigned 0 专栏类型（0-免费，1-登录阅读，2-限时免费） free_start_time timestamp '1970-01-02 00:00:00' 限时免费开始时间 free_end_time timestamp '1970-01-02 00:00:00' 限时免费结束时间 专栏-文章表 字段名 数据类型 默认值 描述 id int(10) unsigned AUTO_INCREMENT 主键ID column_id int(10) unsigned 0 专栏ID article_id int(10) unsigned 0 文章ID section int(10) unsigned 0 章节顺序（越小越靠前） create_time timestamp CURRENT_TIMESTAMP 创建时间 update_time timestamp CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP 最后更新时间 文章的发布流程 用户登录，进入发布页面 输入标题、文章内容 选择分类，封面、简介 提交文章，进入待审核状态，仅用户可看详情 管理员审核通过，所有人可看详情 点赞功能和点赞排行榜的实现过程 在本项目中规定每位用户只能对一篇文章点赞一次，再次点击则取消点赞。同时后续还要实现点赞排行榜的功能\n具体实现应用到了Redis的zset数据结构，该数据结构具有排序的功能\n给 Article 类中添加一个 isLike 字段，标示是否被当前用户点赞 利用Redis的Zset集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1 通过查询Zset集合的TOP5来进行点赞排行榜的实现 1 2 Key: article:liked:\u0026lt;文章ID\u0026gt; Value (ZSet): 用户ID -\u0026gt; Score（点赞时间） 点赞的相关逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @Override public Result likeArticle(Long id) { // 1.获取登录用户 Long userId = UserHolder.getUser().getId(); // 2.判断当前登录用户是否已经点赞 String key = article_LIKED_KEY + id; Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString()); if (score == null) { // 3.如果未点赞，可以点赞 // 3.1.数据库点赞数 + 1 boolean isSuccess = update().setSql(\u0026#34;liked = liked + 1\u0026#34;).eq(\u0026#34;id\u0026#34;, id).update(); // 3.2.保存用户到Redis的set集合 zadd key value score if (isSuccess) { stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis()); } } else { // 4.如果已点赞，取消点赞 // 4.1.数据库点赞数 -1 boolean isSuccess = update().setSql(\u0026#34;liked = liked - 1\u0026#34;).eq(\u0026#34;id\u0026#34;, id).update(); // 4.2.把用户从Redis的set集合移除 if (isSuccess) { stringRedisTemplate.opsForZSet().remove(key, userId.toString()); } } return Result.ok(); } private void isArticleLiked(Article article) { // 1.获取登录用户 UserDTO user = UserHolder.getUser(); if (user == null) { // 用户未登录，无需查询是否点赞 return; } Long userId = user.getId(); // 2.判断当前登录用户是否已经点赞 String key = \u0026#34;article:liked:\u0026#34; + article.getId(); Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString()); article.setIsLike(score != null); } 缓存设计 本项目在内存管理模块中将热点数据进行缓存到Redis中，以减轻数据库的压力\n热点数据如下\n展馆方发布的文章：此类文章属于热点文章，用户访问频率较高优先缓存 文章列表：用户的文章列表需要频繁显示但是改动频率较低 文章分类：文章的分类列表也是需要频繁显示但是改动频率比较低 缓存问题 缓存击穿问题 问题描述 当本项目中热点数据例如展馆方发布的文章，文章分类突然因为过期失效导致大量请求会访问数据库，造成数据库压力过大\n解决方案 可以使用互斥锁的思路来解决这个问题。当大量用户同时访问同一篇文章时，只允许一个用户去MySQL中获取数据。当该用户从数据库中获得相关信息后重新构建缓存，再返回给用户。\n本项目中采用Redis实现互斥锁\n核心思路就是利用redis的setnx方法来表示获取锁\n查询缓存：首先检查 Redis 是否已缓存该文章，若缓存命中则直接返回。 空值缓存：如果缓存中存在空值（表示该文章数据不存在），则返回 null。 加锁防止并发：使用分布式锁保证同一时间只有一个请求去查询数据库并重建缓存。 缓存写入：数据库查询成功后，将文章数据缓存到 Redis 中；如果文章不存在，缓存一个空值以避免重复查询。 1 2 3 4 5 6 7 8 9 // 加锁和解锁 private boolean tryLock(String key) { Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, \u0026#34;1\u0026#34;, 10, TimeUnit.SECONDS); return BooleanUtil.isTrue(flag); } private void unlock(String key) { stringRedisTemplate.delete(key); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 public Article queryWithMutex(Long id) { String key = CACHE_ARTICLE_KEY + id; // 从redis中查询文章缓存 String articleJson = stringRedisTemplate.opsForValue().get(key); // 判断是否存在 if (StrUtil.isNotBlank(articleJson)) { // 存在,直接返回 return JSONUtil.toBean(articleJson, Article.class); } // 判断命中的值是否是空值 if (articleJson != null) { // 返回一个错误信息 return null; } // 实现缓存重构 String lockKey = \u0026#34;lock:article:\u0026#34; + id; Article article = null; try { boolean isLock = tryLock(lockKey); // 判断是否获取成功 if (!isLock) { // 失败，则休眠重试 Thread.sleep(50); return queryWithMutex(id); } // 成功，根据id查询数据库 article = getById(id); // 不存在，返回错误 if (article == null) { // 将空值写入redis stringRedisTemplate.opsForValue().set(key, \u0026#34;\u0026#34;, CACHE_NULL_TTL, TimeUnit.MINUTES); // 返回错误信息 return null; } // 写入redis stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(article), CACHE_NULL_TTL, TimeUnit.MINUTES); } catch (Exception e) { throw new RuntimeException(e); } finally { // 释放互斥锁 unlock(lockKey); } return article; } 缓存穿透问题 问题描述 当用户访问到已经被删除的文章（文章已经不存在于数据库和Redis中）这样缓存永远不会生效，这些请求都会打到数据库\n解决方案 可以使用布隆过滤器加缓存空值来解决这个问题。布隆过滤器是一种高效的数据结构，能够快速判断某个元素是否存在于一个集合中。但是具有误判率。被判定为存在的对象不一定存在但是被判定为不存在的对象一定不存在。因此可以有缓存空值的策略来解决误判的问题\n具体流程如下\n初始化布隆过滤器 ：将数据库内所有的文字ID都加入布隆过滤器中 查询布隆过滤器 ：当用户查询文章时先查询布隆过滤器，若被布隆过滤器判定为不存在则直接返回为空（文章一定不存在数据库中） 查询Redis ：被判定为存在的文章不一定存在于数据库。先查询缓存，若缓存命中则直接返回 查询数据库 ：若缓存未命中则查询数据库，若数据库命中则重构缓存，反之则在redis缓存中缓存空值（这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到数据库了） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 public class ArticleService { private static final String CACHE_ARTICLE_KEY = \u0026#34;article:\u0026#34;; private static final long CACHE_NULL_TTL = 10; // 缓存空值的有效时间，单位：分钟 private static final long CACHE_TTL = 60; // 缓存文章的有效时间，单位：分钟 private StringRedisTemplate stringRedisTemplate; private BloomFilterService bloomFilterService; public ArticleService(StringRedisTemplate stringRedisTemplate, BloomFilterService bloomFilterService) { this.stringRedisTemplate = stringRedisTemplate; this.bloomFilterService = bloomFilterService; } // 从布隆过滤器获取文章ID的有效性 private BitMapBloomFilter getBloomFilter() { return bloomFilterService.createBloomFilter(); } public Article queryWithBloomFilter(Long id) { String key = CACHE_ARTICLE_KEY + id; // 查询布隆过滤器判断文章ID是否存在 BitMapBloomFilter bloomFilter = getBloomFilter(); // 如果布隆过滤器判断文章ID不存在，直接返回null if (!bloomFilter.contains(id.toString())) { return null; } // 查询缓存 String articleJson = stringRedisTemplate.opsForValue().get(key); // 如果缓存命中，直接返回文章数据 if (StrUtil.isNotBlank(articleJson)) { return JSONUtil.toBean(articleJson, Article.class); } // 如果缓存中没有，继续查询数据库 Article article = articleMapper.getById(id); // 如果数据库中没有该文章，缓存空值 if (article == null) { stringRedisTemplate.opsForValue().set(key, \u0026#34;\u0026#34;, CACHE_NULL_TTL, TimeUnit.MINUTES); return null; } // 如果数据库中存在，将文章缓存 stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(article), CACHE_TTL, TimeUnit.MINUTES); return article; } 缓存一致性问题 问题描述 使用 Redis 作为缓存系统时，数据在缓存（Redis）和数据库（MySQL）之间可能会出现不同步或不一致的情况。这种不一致性会导致系统在读取数据时获取到过时的数据，或者在更新数据时没有及时更新缓存，从而影响系统的准确性和稳定性。\n解决方案 本项目采用以下策略\n写操作：先更新数据库，再删除缓存，后续等查询把数据库的数据回种到缓存中 读操作：先查询缓存，若缓存不命中则查询数据库，然后将数据回种到缓存中 采用理由 本项目对一致性要求不高，可以容忍短时间的不一致性\nKafka实现异步处理 异步处理的必要性 在本项目中使用Kafka消息队列，能够使我们项目异步加速（只负责投递）。同时避免传统的同步处理带来的高延迟和同步调用链条过长的问题。\n具体实现方案 Kafka生产者 由于本项目的内容模块的消息类型只有以下几种\n点赞 取消点赞 评论 取消评论 因此可以通过AOP来整合消息实现环绕通知，将消息投入Kafka队列中\nKafka消费者 kafka消费者则监听队列中指定主题的消息，进行业务逻辑的消费。\n遇到的问题 众所周知，Kafka作为消息队列具有消息重复消费的问题。而解决该问题的方法就是实现消费的幂等性。消费的幂等性是指 无论一条消息被消费多少次，最终的业务结果都应该与消费一次时的结果相同。 而消费的幂等性通常可以通过 去重 来实现。策略如下\n每次消费时，先检查 Redis 是否已处理 该 ID。 如果已存在，则跳过处理，避免数据重复写入。 本项目使用先前的雪花算法生成全局唯一的消息ID\n","date":"2025-01-13T18:13:37+08:00","permalink":"https://Tyritic.github.io/p/%E8%AF%86%E7%89%A9%E6%8E%A2%E8%B6%A3%E5%9B%9B%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97/","title":"识物探趣（四）内容管理模块"},{"content":"Serverless架构的定义与特点 Serverless 的英文直译是无服务器的。但是并不代表真正的没有服务器，而是将底层服务器的管理和维护细节透明化，使得开发者可以专注于业务逻辑的实现，而无需考虑服务器的配置、扩展和维护等问题。\n2019年UBC发表的论文《Cloud Programming Simplified: A Berkeley View on Serverless Computing》 指出了 Serverful 架构和Serverless 架构的一些区别\n在云的上下文中，Serverful 的计算就像使用低级的汇编语言编程，而 Serverless 的计算就像使用 Python 这样的高级语言进行编程。例如 c=a+b 这样简单的表达式，如果用汇编描述，就必须先选择几个寄存器，把值加载到寄存器，进行数学计算，再存储结果。\n这就好比今天在云环境下 Serverful 的计算，开发首先需要分配或找到可用的资源，然后加载代码和数据，再执行计算，将计算的结果存储起来，最后还需要管理资源的释放。\n在我看来Serverless架构和Serverful架构最根本的区别在于 开发者的责任划分的问题 。在Serverful架构中开发者需要关心的非业务问题非常多。而在 Serverless 架构下，开发者只专注于开发业务逻辑，所有的这些与业务无关的基础设施，全部交给云平台负责，由云平台统一调度、运维。\n同样该论文提出了以下观点：Serverless computing=FaaS(函数即服务)+BaaS(后端即服务)\n下面表达以下我对 FaaS 和 BaaS 的理解\nBaaS意味着云服务商把后端架构的工作全部包揽下来。例如硬件的维护，集群的管理，运行环境的搭建，全部由云平台完成，除此之外，像缓存、数据库、文件存储、消息中间件等，也全部有云平台帮我们做好，封装起来，以接口的形式提供服务。对于开发者，BaaS 就是一个黑盒，你不用知道我怎么做，更不需要关心我如何做，你需要什么过来拿就行了。 FaaS意味着一个函数运行平台，用于执行业务逻辑代码。 Serverless架构具有以下特点\n服务器透明化 ：虽然实际还是在服务器上运行，但开发者无需管理或配置这些服务器，所有的资源调度、伸缩和维护均由云服务平台自动处理。 事件驱动 ：函数或组件只有在特定事件触发时才会被调用。这种模式使得资源利用更加高效，按需执行并只为实际使用的计算资源付费。 高扩展性 ：云平台会根据实际请求量自动扩展或缩减计算资源，确保应用在流量高峰时能够稳定运行，而在流量低谷时减少资源浪费。 按需计费：由于只在函数执行期间计费，用户可以大幅降低成本，避免因长期运行空闲服务器而产生的浪费。 架构设计思路 组件即函数 在Serverless架构中，开发者将代码作为函数上传到云平台，并在事件触发时执行。而项目中的组件与函数具有很多相似之处\n事件驱动 ：组件是基于事件驱动的，当存在数据处理事件时，组件才会被触发并开始运行，并在处理完数据后立即终止。 服务器透明 ：组件不需要事先配置或管理任何服务器，组件开发人员可以专注于编写组件代码，而无需关心服务器的管理。 状态无关 ：组件是无状态的，其算法功能单一且稳定，对固定类型的输入数据进行数据处理后得到对应的处理结果，不同组件之间不存在调用关系且不共享任何状态信息。 移动数据不如移动计算 数据处理平台中有一条重要理念：移动数据不如移动计算 。与其将大量数据从存储地点传输到计算资源处进行处理，不如把计算任务迁移到数据所在的位置。这样可以避免大量数据在网络中传输所带来的延迟、带宽占用和I/O开销，从而提高数据处理效率。因此通过在边缘计算节点上直接执行任务，可以利用本地数据进行计算，而无需将数据传输到云端进行处理\n架构核心设计 核心概念 批处理算法组件 ：由组件开发人员开发得到的算法组件。 组件库 ：由组件开发人员上传并成功构建的多个可被调用的组件组成组件库 批处理任务 ：指定数据处理操作需要调用的批处理算法组件，在配置中每个任务都与批处理算法组件有唯一的映射关系，每个批处理任务的执行实际上是通过启动容器执行组件从而实现数据处理。 作业工作流 ：由多个批处理任务组成，每个作业工作流代表着一个数据处理作业的执行流程，对应于组件编排模型，通过DAG图描述批处理任务之间的依赖关系。 作业 ：数据处理作业是引擎核心业务单位，每个数据处理作业包含作业基本信息及工作流。 核心架构 架构中包含三大核心模块，分别是中心控制器（Server）以边缘执行器（Agent）以及Kafka消息中心。\n中心控制器（Server） Server部署在云端，负责管理集群的计算节点、组件及作业等资源。\nServer提供 计算节点管理服务 ：Server会维护一个计算节点列表，该列表用于记录平台中的所有计算节点。在用户进行组件编排时，可通过在Json文件中指定组件运行的计算节点，将组件迁移至数据所在处的计算节点运行。若计算节点长期未上报心跳事件，中心控制器会将该计算节点从列表中删除，以保持列表的准确性和及时性。 Server提供 组件管理服务 ：开发人员将算法程序封装为组件后，将组件代码和镜像构建文件打包成压缩包，并将压缩包和组件描述文档一起上传至Server。Server解压缩得到组件代码和镜像构建文件后，开始构建组件镜像。镜像构建完成后，将该镜像推送到私有的镜像仓库中，并将组件信息和镜像地址存储到数据库中，完成组件上传与镜像构建的流程。 Server提供 作业管理服务 ：业务人员在组件库中选取需要执行的组件，编写作业描述文档构建并上传新的数据处理作业，Server接收到业务人员上传的作业描述文档后，解析文档并将作业信息和作业工作流中各个任务的信息存储至数据库中。执行作业时，Server首先通过采用拓扑排序的方法来确定工作流中待执行的任务，并将这些任务派发至数据所在地的计算节点进行执行。一旦任务执行完成，组件会上报组件运行生命周期事件，Server通过订阅消息队列的指定主题，获取该消息后，获取作业工作流中的下一个待执行任务，并重复上述操作，直至所有的任务都运行完毕，从而完成整个作业的运行过程。 边缘控制器（Agent） Agent部署在各个计算节点上，启动时会向中心控制器发起节点注册请求，注册成功后，边缘执行器所在的Agent成为集群中的计算节点。\nAgent提供 计算节点硬件资源使用情况查询 ：Server通过调用该接口，获取计算节点当前的硬件资源信息。同时，边缘执行器以固定的频率向中心控制器发送心跳事件，告知Server当前计算节点处于健康（在线）状态，可以向该计算节点分配任务。\nAgent提供 组件容器的封装 ：与计算节点上的Docker服务进行交互，任务运行时，Agent解析获取任务使用的组件镜像地址，从云端的组件库中拉取组件镜像到计算节点本地后，根据任务参数中的组件运行配置信息创建并组件运行容器，实现移动计算，将代码迁移至数据所在地运行。\nAgent提供 请求转发 ：Server向Agent发起任务运行生命周期管理请求，请求中携带组件容器绑定的端口和动作类型，Agent接收到该请求后根据请求中的端口号，将该请求转发至监听该端口的组件容器，获得请求响应后再将结果返回给中心控制器。 图\n整体架构设计图 工作流程设计 编写组件逻辑代码 ：开发人员根据提供的SDK编写好组件的业务逻辑代码和生命周期事件代码\n构建组件 ：编写Dockerfile然后将组件构建成镜像推送到私有镜像仓库中\n编写作业描述文档 ：开发人员编写作业描述文档，指定容器的编排顺序，指定计算节点等\n执行作业\nServer解析文档并将作业信息和作业工作流中各个任务的信息存储至数据库中 Server采用拓扑排序的方法来确定工作流中待执行的任务，并将这些任务派发至数据所在地的计算节点进行执行 任务执行完成，组件会上报组件运行生命周期事件 ","date":"2025-01-08T20:56:25+08:00","permalink":"https://Tyritic.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E6%89%B9%E5%A4%84%E7%90%86%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E4%B8%89%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","title":"分布式批处理计算平台（三）引擎架构设计"},{"content":"批处理算法组件的设计动机 异常处理 ：大多数算法开发人员在程序开发过程中通常只关注程序的正常逻辑，而忽视了程序在运行过程中可能遇到的异常情况以及如何处理这些异常故障。 缺乏生命周期管理 ：缺乏提供生命周期管理接口，用户无法方便地查询程序的运行状态，也无法进行必要的生命周期管理操作，例如暂停、恢复或停止程序的执行。若在程序执行过程中发现逻辑错误或需要优先执行其他任务，用户只能通过终止进程的方式停止程序的执行。 批处理算法组件的模型结构 批处理算法组件是 面向海量数据批处理场景 的 具有生命周期管理 和 检查点恢复机制 的功能软件单元\n属性 属性是组件内部维护的数据成员，包含以下类型\n组件启动配置属性 组件运行过程属性 数据处理属性。 组件启动配置属性 在组件启动时，外部环境将参数传递给组件，随后组件进入初始化阶段，利用这些参数为组件的启动配置属性进行赋值\nmode：组件运行模式 算法执行模式 （algorithm）：正常执行算法过程 数据清理模式（clean）：若组件的算法逻辑有误导致错误的数据输出或中间输出结果没有业务价值，则需要清理这些数据，减轻集群节点机器的磁盘资源压力。 restore：检查点标志位 1：组件在运行之前，会尝试读取本地的检查点文件，并从检查点处恢复执行 0：组件此次运行会重新开始处理所有数据 properties_url：数据处理参数的配置文件地址 组件运行过程属性 组件运行过程属性是用于记录组件的运行状态、运行进度等相关信息的属性集合\n数据处理属性 数据处理属性是组件进行数据处理时需要使用的属性\n输入数据地址 输出结果地址 可选的算法模型动态参数 接口 接口定义了组件的各项行为\n生命周期管理 组件运行时会启动一个HTTP服务，并提供生命周期管理接口给外界控制和获取组件运行状态\ninfo ：获取组件运行状态，包括组件运行进度、运行状态等信息 pause：暂停组件运行 restart：恢复运行处于暂停状态的组件 stop：停止组件运行 数据处理 数据处理接口是组件读取、处理以及写入数据的接口集合\ngetConfig：获取数据处理属性。 getGenerator：返回一个获取批处理任务所需数据的生成器。组件进行数据处理时，数据被分成块进行处理。开发人员实现该接口时，可以根据需要指定块的粒度。 readItem：从生成器中遍历得到数据的存放地址，并将数据读取至内存中。 beforeProcess：输入数据的预处理环节。 process：主要的数据分析处理环节，开发人员要在该接口内实现批处理算法逻辑。 afterProcess：收尾工作，例如可将处理完毕的图片从内存中移除，避免过多的图片将内存占满 clean：清理组件执行过程中生成的所有数据 handleFinish：当数据的批处理任务后，将要退出前调用此接口进行收尾工作 算法运行模式 通过getGenerator接口获取数据生成器，并遍历该生成器 在每次遍历时，按照以下步骤进行数据处理操作。 通过readItem接口将数据块读入内存。 将读入的数据传入beforeProcress接口进行预处理操作。 预处理完毕后，将处理结果传入process接口进行数据分析处理，执行具体的数据处理算法或操作。 处理完毕的数据会进入到afterProcess接口进行收尾工作，如释放内存等。 进入下一次循环之前，组件程序会判断当前的运行状态。 如果状态为暂停，线程将被阻塞，直到状态重新变为运行中。 如果状态为停止或生成器已遍历完成，则进入使用handleFinish接口进行程序的收尾工作。 数据清理模式 通过getGenerator接口获取待清理数据生成器，并遍历该生成器。 在每次遍历时 将数据块地址传入clean接口进行数据清理工作。 数据清理完毕后，在进入下一次循环之前，需要判断组件运行状态 如果状态为暂停，线程将被阻塞，直到状态重新变为运行中。 如果状态为停止或生成器已遍历完成，则进入使用handleFinish接口进行程序的收尾工作。 检查点管理 检查点接口是负责组件运行过程中检查点设置和读取的接口集合\nsetCheckpoint：设置检查点内容，保存组件当前的运行状态。 getCheckpoint：读取检查点内容，组件重新启动时，调用该接口恢复组件运行状态。 事件发布 lifeCycleEventPublish：发布组件运行生命周期事件。 runPorgressEventPublish：发布组件运行进度事件。 事件 事件是批处理算法组件具备的主动向外界传递信息的能力，采用发布/订阅机制。\n消息队列接受组件模型发布的事件\n订阅者通过订阅获取事件\n组件运行入口 组件的运行入口是一个main函数，外界通过调用组件的main函数启动组件运行。\n首先接收外界传递的参数，以进行组件的初始化阶段。 启动一个HTTP服务线程，以便外界可以与组件进行通信。 通过判断mode属性值来确定组件进入哪种运行模式 如果mode为algorithm，进入算法执行模式； 如果mode为clean，进入数据清理模式。 批处理算法组件的模型机制 生命周期管理机制 初始化 （init） ：处于该状态的组件进行必要的初始化操作。 运行中 （running） ：处于该状态的组件按照既定的算法逻辑处理数据。 运行暂停 （paused） ：一旦组件进入暂停状态，线程将会持续阻塞，无法继续执行下一步操作。 运行停止 （stopped） ：组件主动终止当前的执行进入停止状态，组件进程将会退出 运行完成 （finished） ：当组件处理完所有的数据后，进入运行完成状态，进行收尾工作并退出进程。 运行失败 （failed） ：运行失败状态表示组件在执行过程中遇到了错误、异常或不可恢复的问题，导致无法继续正常运行 检查点恢复机制 检查点恢复机制确保组件运行时，即使组件运行停止或突然遇到故障导致组件崩溃退出，也能够在下一次重新启动时恢复到最近一个检查点的状态继续执行\n设置检查点 在每次数据处理循环结束之前，调用设置检查点接口 setCheckpoint 将当前组件处理输入数据的进度作为检查点文件保存在本地文件系统中。组件模型内部维护一个检查点对象，在保存检查点时，会将该对象进行序列化并以 Json 文件格式持久到本地的文件系统\n后续开发人员可以增加检查点中的数据成员用于保存数据处理的中间处理结果，并在 setCheckpoint 和 getCheckpoint 接口实现相应代码逻辑\n读取检查点 当组件恢复运行时，若属性restore的值为1，则判断本地是否存在该组件运行的检查点文件，存在则读取检查点文件并进行反序列化得到检查点对象\n批处理算法组件的编排模型 由算法程序封装得到的批处理算法组件只能提供单一的算法功能，无法单独完成完整的数据处理任务。\n因此在完成各个组件的独立开发后，还需要允许用户根据具体需求选择组件，并对多个组件进行编排，通过复用已有组件，处理复杂的数据处理任务。\n组件编排模型的结构设计 在组件编排模型中，多个组件之间以有向无环图（DAG）的方式进行编排\n有向箭头表示组件之间的依赖关系，例如，组件A指向组件B的有向箭头表示组件B需要在组件A的运行结果的基础上进行数据处理和分析，即组件A的运行输出结果作为组件B的运行输入数据。\n组件编排模型的结构实现 组件编排信息通过规范化的 Json 语言进行描述\nconnections：组件执行顺序 fromIndex：起始组件序号 toIndex：结束组件序号 components：组件列表 componentId：组件唯一标识 index：组件序号 mode：组件运行模式 machine：执行组件的计算节点名称 args：组件数据处理参数 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 { \u0026#34;connections\u0026#34;: [ { \u0026#34;fromIndex\u0026#34;: 0, \u0026#34;toIndex\u0026#34;: 1 }, { \u0026#34;fromIndex\u0026#34;: 1, \u0026#34;toIndex\u0026#34;: 2 } ], \u0026#34;components\u0026#34;: [ { // 道路水平面切片生成组件 \u0026#34;componentId\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;index\u0026#34;: 0, \u0026#34;mode\u0026#34;: \u0026#34;algorithm\u0026#34;, \u0026#34;machine\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;input\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;secatt\u0026#34;: 1, \u0026#34;canvasrl\u0026#34;: 30, \u0026#34;canvasrw\u0026#34;: 30, \u0026#34;begins\u0026#34;: [ 30, 61, 90, 120 ], \u0026#34;ends\u0026#34;: [ 40, 71, 100, 130 ], \u0026#34;canvasstep\u0026#34;: 1, \u0026#34;interratiol\u0026#34;: 4, \u0026#34;interratiow\u0026#34;: 6, \u0026#34;centralFilepath\u0026#34;: \u0026#34;#\u0026#34;, } }, { // 道路裂缝识别组件 \u0026#34;componentId\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;index\u0026#34;: 1, \u0026#34;mode\u0026#34;: \u0026#34;algorithm\u0026#34;, \u0026#34;machine\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;input\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;alpha\u0026#34;:\u0026#34;0.3\u0026#34; } }, { // 裂缝线状形态拟合组件 \u0026#34;componentId\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;index\u0026#34;: 2, \u0026#34;mode\u0026#34;: \u0026#34;algorithm\u0026#34;, \u0026#34;machine\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;input\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;rho\u0026#34;: 0.8, \u0026#34;theta\u0026#34;: 180, \u0026#34;threshold\u0026#34;: 40, \u0026#34;minLineLength\u0026#34;: 40, \u0026#34;maxLineGap\u0026#34;: 10, \u0026#34;delta1\u0026#34;: 0.1, \u0026#34;delta2\u0026#34;: 40 } } ] } ","date":"2025-01-07T15:43:24+08:00","permalink":"https://Tyritic.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E6%89%B9%E5%A4%84%E7%90%86%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E4%BA%8C%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9E%8B/","title":"分布式批处理计算平台（二）组件模型"},{"content":"项目背景 在数字经济时代，数据已经成为企业最重要的资产之一，如何有效地处理和分析这些数据以获取其潜在 价值，已经成为企业面临的重要任务。在进行数据处理和分析时，采用智能算法对数据进行批处理操作。处理过程 中，数据可被划分为适当大小的块，并通过循环逐块进行处理。\n业务场景分析 数据规模大：数字经济时代的数据规模可能以 TB 为单位 数据边缘存储 ：数据是企业的核心资产，通常情况下数据保存在企业内部服务器，即边缘端。在进行数据处理时，应避免将数据上传至云端，否则将占用大量的网络带宽，降低数据处理的效率，并且可能导致数据泄露的风险。 算法选择多样：在数据分析过程中，涉及的算法程序并没有一个统一的最优解，业务人员需要综合考虑业务需求、算法性能和特点等因素，从众多可行算法中选择最合适的算法来解决问题 项目目标 搭建分布式的批处理计算平台，将现有的批处理算法程序封装为可重用的批处理算法组件，通过平台实现组件的 构建与管理、任务编排与运行等功能。\n","date":"2025-01-07T15:05:51+08:00","permalink":"https://Tyritic.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E6%89%B9%E5%A4%84%E7%90%86%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E4%B8%80%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/","title":"分布式批处理计算平台（一）项目起步"},{"content":"表结构设计 用户登录表 字段名 类型 约束条件 备注 id int(10) unsigned NOT NULL AUTO_INCREMENT PRIMARY KEY 主键 ID third_account_id varchar(128) NOT NULL DEFAULT '' 第三方用户 ID（主要是微信openid user_name varchar(64) NOT NULL DEFAULT '' 用户名 password varchar(128) NOT NULL DEFAULT '' 密码 login_type tinyint(4) NOT NULL DEFAULT '0' 登录方式: 0-微信登录，1-账号密码登录 deleted tinyint(4) NOT NULL DEFAULT '0' 是否删除 create_time timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP 创建时间 update_time timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP 最后更新时间 增删改查的技巧 增加对象：mapper层直接对Entity对象操作，server层对DTO操作 查询对象：使用分页查询可以同时支持一次查询多个对象和一次查询一个对象 更新对象：在mapper中直接对Entity对象操作，使用动态SQL实现根据条件更新 删除对象：直接接受主键作为形参进行删除 登录流程设计 相对于 Cookie 和 Session 不适用于分布式集群，本项目选择 JWT 令牌方案作为登录的鉴权机制。\n具体鉴权机制的方案对比参考往期博客\n微信用户登录 作为服务端只需要完成以下任务\n服务端，通过HttpClient向微信接口服务发送请求，并携带appId+appsecret+code三个参数。 服务端，接收微信接口服务返回的数据，session_key+opendId等。opendId是微信用户的唯一标识。 服务端，自定义登录态，生成令牌(token)和openid等数据返回给小程序端，方便后绪请求身份校验。 开发遇到的问题 JWT无法主动失效的安全问题 JWT 令牌的无状态特性导致服务端不会主动跟踪JWT令牌的状态，无法管控令牌。在某些场景中会导致潜在的安全问题，比如当用户登出之后，使用相同的JWT令牌依然成功访问服务。\n解决方案 通过引入redis缓存中间件来形成黑名单机制，将已经失效的JWT令牌放入redis缓存中并根据该令牌的过期时间为redis键值对设置过期时间，当已经登出的用户带着被纳入黑名单的令牌访问服务时将被拒绝提供服务\n具体实现 黑名单基于jwt标识来实现对令牌的处理\nJWT 令牌通常包含一个 jti（JWT ID），它是一个唯一标识，可以用来跟踪和管理 JWT。\nJWT 生成时，包含唯一的 jti 字段。 当用户登出或 Token 需要失效时，将 jti 存入 Redis 黑名单。 每次请求时，解析 Token，检查其 jti 是否在黑名单中，如果存在，则拒绝访问。 未来改进方向 黑名单功能可以使用基于Redis的布隆过滤器，布隆过滤器详情可见往期博客\n将已经失效的JWT令牌放入Redis和布隆过滤器中 先通过布隆过滤器做第一次判断，判断JWT令牌是否位于黑名单中，若判断不在黑名单中则直接返回 如果布隆过滤器认为 Token 可能失效，则查询 Redis 进行最终确认 无法在线程中获取用户的id信息 服务端只会在拦截器中拦截到JWT令牌，虽然JWT令牌中可以解析出用户id，但是用户id无法持久化被其他组件访问到。\n解决方案\n每次请求在Tomcat服务器中都会开辟一个新的线程，可以选择将JWT令牌中的id信息放入ThreadLocal中以便其他位置可以通过线程上下文获取该id\n数据库自增主键的问题 在项目是单表的时候，数据库自增主键暂时不会出现问题。但是当数据增多之后，一张表无法满足需求后则会出现问题\n单点性能瓶颈\n数据库的 AUTO_INCREMENT 依赖单台数据库的锁管理，每次插入数据时都需要更新主键值。 在 高并发场景 下，这种方式很容易成为 性能瓶颈，影响整个数据库的写入速度。 分库分表\n在 分布式架构 下，不同的数据库实例需要共享 全局唯一 ID，但 AUTO_INCREMENT 只能保证单个数据库实例内的唯一性，导致 ID 可能冲突。 分库分表后，不同数据库的自增 ID 可能重复，需要额外处理，增加复杂性。 解决方案\n本项目采用雪花算法（hutool包实现）来生成用户唯一性ID。同时雪花算法还保证了ID的递增性\n雪花算法生成的 64 位 ID（一个 long 类型数字），结构如下：\n符号位（1 bit） 时间戳（41 bit） 机器 ID（10 bit） 序列号（12 bit） 0（正数） 约 69 年 1024 台机器 每毫秒 4096 个 ID 1 bit（符号位）：始终为 0，保证生成的是正数。 41 bit（时间戳）：存储 当前时间（毫秒），可用 约 69 年（2⁴¹ 毫秒）。 10 bit（机器 ID）：支持 1024 台机器，确保分布式部署不冲突。通常由5位数据中心ID和5位机器ID构成 12 bit（序列号）：同一毫秒内，支持 4096 个 ID（2¹² = 4096）。 生成算法过程\n获取当前时间戳（毫秒级），并 计算时间戳偏移量 检查当前毫秒内序列号： 若当前毫秒内 序列号未满 4096，则递增。 若达到上限，则 等待下一毫秒（时间回拨问题）。 拼接各部分生成唯一 ID： 时间戳偏移量 左移22位到符号位的右侧 机器ID 左移动12位 数据中心ID 左移动12+5=17位 自增序列 拼接到最右侧 警告\n雪花算法的潜在问题\n时钟回拨问题：雪花算法依赖系统时间戳，如果服务器的时钟 回拨（倒退），可能会导致： 生成重复 ID（如果新的时间比之前的时间还小）。 ID 生成失败（因为 ID 递增的逻辑依赖时间）。 ","date":"2025-01-07T13:28:40+08:00","permalink":"https://Tyritic.github.io/p/%E8%AF%86%E7%89%A9%E6%8E%A2%E8%B6%A3%E4%B8%89%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97/","title":"识物探趣（三）用户管理模块"},{"content":"项目总体架构 表现层（前端） Web 前端 移动端 业务逻辑层 用户管理模块 ：管理用户的登录注册，用户身份识别，以及关注和被关注 展品管理模块 ：展馆方对展馆内部的展品信息进行管理，同时提供展品的访问情况 展品识别模块 ：模块直接调用外部封装的Yolo模型接口，将识别结果传递给后续业务逻辑。 内容生成模块 ：根据建筑识别结果和用户行为数据，利用RAG实现大模型的精准回答。 内容管理模块 管理端：为展馆的管理方提供对发布内容的管理，以及对展品信息的管理 用户端：提供对自己发布内容的管理，以及对其他用户文章的点赞，收藏，计数统计 评论管理模块 用户端：提供对内容的评论功能，以及修改撤回评论的能力 管理端：提供对用户评论的管理权限 数据访问层 关系型数据库 存储用户信息、文章、评论等结构化数据。 缓存系统 缓存热点数据、用户会话和部分生成结果，提升系统响应速度。 消息队列 异步更新数据，保证主业务操作的速度 向量数据库 服务于RAG的向量化 技术选型 总体框架：SpringBoot\n数据持久层：MyBatis\n建筑识别模块\nyolo模型 外部Flask模块 生成系统模块\nLangchain4j框架进行对话管理和RAG Ollama部署私有LLM 向量数据库：Qdrant 关系型数据库：MySQL\n缓存系统：Redis作为缓存中间件\n消息队列：Kafka\n","date":"2025-01-05T16:02:40+08:00","permalink":"https://Tyritic.github.io/p/%E8%AF%86%E7%89%A9%E6%8E%A2%E8%B6%A3%E4%BA%8C%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E5%92%8C%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/","title":"识物探趣（二）项目架构和技术选型"},{"content":"体系结构 连接层：最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 服务层：第二层架构主要完成大多数的核心服务功能。 负责建立连接、分析和执行 SQL ，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。 引擎层：存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。 存储层：主要是将数据存储在文件系统之上，并完成与存储引擎的交互 语句执行过程 连接器 连接过程 先连接 MySQL 服务，然后才能执行 SQL 语句 连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的 如果 MySQL 服务正常运行，完成 TCP 连接的建立后，连接器就要开始验证你的用户名和密码 如果用户密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。 所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。 连接类型 MySQL 的连接也跟 HTTP 一样，有短连接和长连接的概念\n使用长连接的好处就是可以减少建立连接和断开连接的过程，所以一般使用长连接。\n但是，使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象。\n查询缓存 连接器得工作完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段获得语句类型。\n如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。\n如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。\n注意 ：MYSQL8.0后不使用查询缓存\n解析SQL语句 在正式执行 SQL 查询语句之前， MySQL 会先对 SQL 语句做解析。解析器只负责检查语法和构建语法树，但是不会去查表或者字段存不存在。\n执行SQL语句 预处理 检查 SQL 查询语句中的表或者字段是否存在； 将 select * 中的 * 符号，扩展为表上的所有列 优化器 优化器主要负责将 SQL 查询语句的执行方案确定下来，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。\n执行器 在执行的过程中，执行器就会和存储引擎交互了\n主键索引查询 执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 交给存储引擎，让存储引擎定位符合条件的第一条记录。 存储引擎通过主键索引的 B+ 树结构定位到符合条件的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器； 执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。 执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。 全表扫描 执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，让存储引擎读取表中的第一条记录 执行器会判断读到的这条记录的是不是符合条件，如果不是则跳过；如果是则将记录发给客户的（Server 层每从存储引擎读到一条记录就会发送给客户端，）。 执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端； 一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息； 执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。 索引下推（对联合索引的优化） Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age \u0026gt; 20 的第一条记录； 存储引擎定位到二级索引后，先不执行回表 操作，而是先判断一下该索引中包含的列的条件是否成立。如果 条件不成立 ，则直接 跳过该二级索引 。如果 成立 ，则 执行回表 操作，将完成记录返回给 Server 层。 Server 层在判断其他的查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。 如此往复，直到存储引擎把表中的所有记录读完。 总结 通过连接器校验权限 利用分析器进行 SQL 语句的词法分析和语法分析，构建解析树 使用优化器选择合适的索引和表连接顺序，最终选择一个最佳的执行计划 利用执行器，调用引擎层查询数据，返回结果集给客户端 存储引擎简介 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以不同表可以使用不同的存储引擎\n默认的存储引擎为 innoDB、\n查询当前数据库支持的存储引擎\n1 show engines 指定存储引擎\n1 2 create table table_name( )engine = 引擎名 存储引擎的特点 innoDB InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL5.5之后，InnoDB是默认的 MySOL存储引擎。\n特点 DML操作遵循ACID模型，支持 事务 行级锁 ，提高并发访问性能 支持外键 约束，保证数据的完整性和正确性 数据以 聚集索引 的方式存储，提高检索效率。 对应的磁盘文件 innoDB引擎的每张表都会对应这样一个表空间文件：xxx.ibd（xxx代表的是表名）\n存储该表的表结构（frm、sdi）、数据和索引\n参数：innodb_file_per_table\n表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段。 段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。 区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。 页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。 行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段 MyISAM MyISAM是MySQL早期的默认存储引擎。\n特点 不支持事务，不支持外键 支持表锁，不支持行锁 访问速度快 MyISAM 写入性能差。因为不支持行锁，只有表锁，所以写入的时候会对整张表加锁 MyISAM 为非聚簇索引，索引和数据分开存储，索引保存的是数据文件的指针。 对应的磁盘文件 xxx.sdi：存储表结构信息 xxx.MYD: 存储数据 xxx.MYI: 存储索引 Memory 特点 数据存储在内存中，速度快，但数据在服务器重启后丢失。 适用于临时数据存储或快速缓存。 存储引擎的选择 大多数情况下，使用默认的 InnoDB ，InnoDB 可以提供事务、行级锁、外键、B+ 树索引等能力。 MyISAM 适合读更多的场景。 MEMORY 适合临时表，数据量不大的情况。由于数据都存放在内存，所以速度非常快。 ","date":"2025-01-04T15:59:42+08:00","permalink":"https://Tyritic.github.io/p/mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/","title":"MySQL存储引擎"},{"content":"项目背景 数字文旅的兴起 随着数字化技术的不断成熟和普及，文化旅游产业正迎来全新的转型契机。传统的文旅体验往往受限于物理空间和时间，而数字文旅平台可以打破这些限制，提供沉浸式、互动性强的体验 人工智能技术的发展 人工智能在图像识别、自然语言处理、大数据分析等领域的突破，为数字文旅平台提供了强大的技术支撑。AI 可以帮助平台实现个性化内容推荐、智能导览、用户行为分析等功能，提升用户体验和平台运营效率。 业务场景 实时建筑识别与信息推送 游客在展馆现场，通过手机拍照或视频扫描，平台利用 YOLO 模型快速识别出建筑或艺术品。识别结果将触发后续信息推送，展示该建筑的历史背景、设计理念及相关文创产品介绍等信息。这一过程能够为游客提供沉浸式、互动式的现场体验，使文化旅游更具趣味性和互动性。 智能推荐与深度内容消费 基于 Agent 技术，平台能根据游客的兴趣、历史行为及现场识别结果，智能推荐与之相关的深度内容。比如，当识别到某个著名建筑后，平台不仅提供该建筑的基本信息，还可能推荐详细的专题文章、历史故事、专家讲解视频等，满足用户多层次的知识需求。 用户行为数据采集与分析 在识别、推荐和社交互动过程中，平台会持续采集用户的行为数据（如点击、浏览、互动频次、停留时间等）。这些数据不仅有助于改进 YOLO 模型的识别精度和 Agent 推荐策略。 ","date":"2025-01-02T15:14:51+08:00","permalink":"https://Tyritic.github.io/p/%E8%AF%86%E7%89%A9%E6%8E%A2%E8%B6%A3%E4%B8%80%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/","title":"识物探趣（一）项目起步"},{"content":"作用 Object类是Java所有类的父类，所有的Java类默认继承Object类，Object类中的所有方法都可以被Java类使用\n常见方法 以下是 Object 类中的主要方法及其作用：\n对象比较 public boolean equals(Object obj)\n作用：用于比较两个对象是否相等。默认实现比较对象的内存地址，即判断两个引用是否指向同一个对象。 使用：通常会重写此方法来比较对象的内容或特定属性，以定义对象的相等性。 public int hashCode()\n作用：返回对象的哈希码，是对象的整数表示。哈希码用于支持基于哈希的集合（如 HashMap 和 HashSet）。 使用：如果重写了 equals 方法，则通常也需要重写 hashCode 方法，以保证相等的对象具有相同的哈希码。 hashCode()和equals()的关系 equals决定了对象的逻辑相等性\nhashCode决定了对象的哈希存储方式。\nequals() 方法：\n用于判断两个对象是否相等。默认实现是使用 == 比较对象的内存地址，但可以在类中重写 equals() 来定义自己的相等逻辑。 hashCode() 方法：\n返回对象的哈希值，主要用于基于哈希的集合（如 HashMap、HashSet）。同一个对象每次调用 hashCode() 必须返回相同的值，且相等的对象必须有相同的哈希码。 equals() 和 hashCode() 的约定 相等对象的哈希值必须相等 ： 如果两个对象通过 equals 方法比较相等（a.equals(b) == true），那么它们的哈希值必须相同（a.hashCode() == b.hashCode()）\n不相等的对象可以有相同的哈希值 ： 如果两个对象通过 equals 方法比较不相等（a.equals(b) == false），它们的哈希值不必不同，但为了提升性能，应尽量让不相等的对象有不同的哈希值。\n哈希值不相同的对象一定不相同\n编码建议 重写 equals 方法的时候，也要重写 hashCode 方法，这样才能保持条件判断的同步。\n解释\n如果仅重写 equals 方法而不重写 hashCode，会违反 hashCode 与 equals 的约定，从而导致集合类行为异常。例如：HashSet 基于哈希值来判断对象是否相同，哈希值不同导致它们被视为不同的对象。导致 HashSet 中存储两个相同的对象\n对象转字符串 public String toString()\n作用：返回对象的字符串表示。默认实现返回对象的类名加上其哈希码的十六进制表示。 使用：通常会重写此方法以提供对象的更有意义的描述。 反射 public final Class\u0026lt;?\u0026gt; getClass()\n作用：返回对象的运行时类（Class 对象）。此方法是 Object 类中的一个 final 方法，不能被重写。 使用：可以用来获取对象的类信息，常用于反射操作。 多线程调度 public void notify()\n作用：唤醒在对象的监视器上等待的一个线程。该方法需要在同步块或同步方法中调用。 使用：用于在多线程环境中进行线程间的通信和协调。 public void notifyAll()\n作用：唤醒在对象的监视器上等待的所有线程。该方法需要在同步块或同步方法中调用。 使用：与 notify() 相似，但唤醒所有等待线程，用于处理多个线程之间的协作。 public void wait()\n作用：使当前线程等待，直到其他线程调用 notify() 或 notifyAll() 方法。此方法需要在同步块或同步方法中调用。 使用：用于线程间的通信，线程会等待直到被唤醒或超时。 public void wait(long timeout)\n作用：使当前线程等待，直到指定的时间到期或被唤醒。超时后线程会自动被唤醒。 使用：用于实现带有超时的等待机制。 public void wait(long timeout, int nanos)\n作用：使当前线程等待，直到指定的时间和纳秒数到期或被唤醒。 使用：用于实现更精细的等待控制，允许指定等待时间的精确到纳秒。 对象拷贝 protected Object clone()\n作用：创建并返回当前对象的一个副本。默认实现是进行浅拷贝。 使用：通常会重写此方法来实现深拷贝，以确保克隆对象的完整性。 垃圾回收 protected void finalize()\n作用：在垃圾回收器确定不存在对该对象的更多引用时调用，用于进行资源释放等清理工作。 使用：不建议使用，因为它依赖于垃圾回收器的实现，可能会导致不确定的性能问题。推荐使用 try-with-resources 和 AutoCloseable 接口进行资源管理 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } // 重写equals方法 @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null || getClass() != obj.getClass()) return false; Person person = (Person) obj; return age == person.age \u0026amp;\u0026amp; name.equals(person.name); } // 重写hashCode方法 @Override public int hashCode() { return Objects.hash(name, age); } // 重写toString方法 @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, age=\u0026#34; + age + \u0026#34;}\u0026#34;; } public static void main(String[] args) { Person p1 = new Person(\u0026#34;Alice\u0026#34;, 30); Person p2 = new Person(\u0026#34;Alice\u0026#34;, 30); System.out.println(p1.equals(p2)); // true System.out.println(p1.hashCode() == p2.hashCode()); // true System.out.println(p1); // Person{name=\u0026#39;Alice\u0026#39;, age=30} } } ","date":"2025-01-02T14:24:41+08:00","permalink":"https://Tyritic.github.io/p/object%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95/","title":"Object类的作用和相关方法"},{"content":"回答重点 主要工具 javac：Java 编译器，负责将 Java 源代码编译成字节码（.class 文件）。 java：运行 Java 应用程序的命令，使用 JVM 来解释并执行编译后的字节码文件。 javadoc：生成 API 文档的工具，能够根据源代码中的注释生成 HTML 格式的文档。 jar：用于创建和管理 JAR 文件的工具，可以将多个 .class 文件打包为单一文件，便于分发和管理。 jdb：Java 调试工具，用于在命令行中调试 Java 应用程序，支持断点设置、变量查看等功能。 性能监控和分析工具 jps：Java 进程工具，显示所有正在运行的 Java 进程，便于监控和诊断。 jstack：生成线程堆栈信息的工具，常用于分析死锁和线程问题。 jmap：内存映射工具，可以生成堆转储（heap dump）文件，便于内存泄漏分析和垃圾回收优化。 jhat：堆分析工具，配合 jmap 使用，分析生成的堆转储文件，帮助开发者了解内存使用情况。 jstat：JVM 统计监控工具，实时监控垃圾回收、内存、类加载等信息，帮助开发者调优 JVM 性能。 jconsole：图形化的 JVM 监控工具，可以监控应用程序的内存、线程和类加载情况，常用于监控和调试。 jvisualvm：功能强大的性能分析工具，支持堆、线程、GC 的详细监控，还提供内存分析和 CPU 性能分析。 诊断工具 jinfo：用于查看和修改正在运行的 JVM 参数，便于动态调优和调整 JVM 行为。 jstatd：远程 JVM 监控工具，可以通过网络远程监控 JVM 的状态，适合分布式系统中的性能监控。 拓展知识 高级调试和性能优化工具 Java Mission Control (JMC)：一个功能强大的工具，用于分析和优化 Java 应用程序的性能，提供了基于飞行记录器（Java Flight Recorder，JFR）的性能分析功能，可以详细查看垃圾回收、线程活动、CPU 使用率等指标，是进行深度性能分析的利器。 Java Flight Recorder (JFR)：低开销的监控工具，能够记录 JVM 的运行时数据，适合生产环境中的性能分析，尤其是在高并发系统中使用频率较高。 GC 调优和内存分析 jmap 和 jhat 常用于排查内存泄漏或内存占用过高的问题。通过 jmap 生成堆转储文件后，开发者可以使用 jhat 或其他工具（如 Eclipse MAT）分析对象的引用链，从而发现潜在的内存问题。\n线程和死锁分析 jstack 是用于调试线程状态的利器，尤其是在分析线程死锁时。当应用卡死或响应时间异常时，通过 jstack 可以捕获应用的线程状态，并分析是否存在死锁情况。\n","date":"2025-01-02T14:03:21+08:00","permalink":"https://Tyritic.github.io/p/jdk%E5%B7%A5%E5%85%B7%E5%8C%85/","title":"JDK工具包"},{"content":"Pojo类 pojo类在项目开发中用于标识实体类，该类在项目对应一个实际的业务对象，例如：user,student等\nPO/DO PO/DO类在项目中对应数据库中的一张表，数据库PO/DO是持久化对象，用于表示数据库中的一条记录映射成的Java对象，类中应该都是基本数据类型和String\nPO仅仅用于表示数据，不对数据进行操作，拥有get和set方法。对象类中的属性对应数据库表中的字段，有多少个字段就有多少个属性，完全匹配。\n命名规范：数据库表名+PO/DO\nDTO 全称（Data Transfer Object）用于后端接受前端的请求，将前端请求参数封装成对象\n通常用于将前端请求传递到控制层和控制层传递到业务逻辑层\nVO 全称（View Object）用于后端响应前端的过程中，作为视图对象\nBO 全称（Business Object）用于后端业务逻辑的处理\nBO是实际的业务对象，会参与业务逻辑的处理操作，里面可能会包含多个类，用于表示一个业务对象。遵循JavaBean规范，拥有get和set方法。\n","date":"2025-01-01T14:51:32+08:00","permalink":"https://Tyritic.github.io/p/bovopododto%E7%9A%84%E7%90%86%E8%A7%A3/","title":"BO、VO、PO、DO、DTO的理解"},{"content":"一维前缀和 题目描述 用于计算一维数组的区间和，将时间复杂度从$O(n * m) ,m 是查询的次数$简化到$O(n)$\n算法思想 前缀和的思想是重复利用计算过的子数组之和，从而降低区间查询需要累加计算的次数。\n例如，统计 vec[i] 这个数组上的区间和。\n先做累加，即 p[i] 表示 下标 0 到 i 的 vec[i] 累加 之和。 统计vec数组上 下标 i 到下标 j 之间的累加和时使用 p[j]-p[i-1] 即可 1 2 3 p[i] = vec[0] + vec[1] + ... vec[i]; p[j] = vec[0] + vec[1] + vec[2] + vec[3] + vec[4] + vec[5] + ..vec[j]; p[j] - p[i] = vec[i+1] + vec[i+2] + vec[i+3] + ... +vec[j]; 代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 // 求解前缀和数组 int presum = 0; for (int i = 0; i \u0026lt; n; i++) { presum += vec[i]; p[i] = presum; } // 求解子区间和 int sum; if (a == 0) { sum = p[b]; } else { sum = p[b] - p[a - 1]; } 经典例题 板子题 题目描述\n题目链接(opens new window)\n给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。\n输入描述\n第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间，直至文件结束。\n输出描述\n输出每个指定区间内元素的总和。\n输入示例\n1 2 3 4 5 6 7 8 5 1 2 3 4 5 0 1 1 3 输出示例\n1 2 3 9 数据范围：\n0 \u0026lt; n \u0026lt;= 100000\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int[] vec = new int[n]; int[] p = new int[n]; int presum = 0; for (int i = 0; i \u0026lt; n; i++) { vec[i] = scanner.nextInt(); presum += vec[i]; p[i] = presum; } while (scanner.hasNextInt()) { int a = scanner.nextInt(); int b = scanner.nextInt(); int sum; if (a == 0) { sum = p[b]; } else { sum = p[b] - p[a - 1]; } System.out.println(sum); } scanner.close(); } } leetcode 560 和为K的子数组 题目描述\n题目链接\n给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。\n子数组是数组中元素的连续非空序列。\n示例 1：\n1 2 输入：nums = [1,1,1], k = 2 输出：2 示例 2：\n1 2 输入：nums = [1,2,3], k = 3 输出：2 思路解析\n先构造出nums的前缀和数组 根据公式，从区间[i,j]的区间和为p[j]-p[i-1]=k 因此可以遍历前缀和数组，相当于求解p[j]-k在map中出现多少次 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int subarraySum(int[] nums, int k) { int n=nums.length; int[]preSum=new int[n+1]; int pre=0; for(int i=1;i\u0026lt;=n;i++){ pre+=nums[i-1]; preSum[i]=pre; } HashMap\u0026lt;Integer,Integer\u0026gt;map=new HashMap\u0026lt;\u0026gt;(); int count=0; // k=preSum[j]-preSum[i-1] for(int j=0;j\u0026lt;nums.length+1;j++){ int temp=preSum[j]-k; if(map.containsKey(temp)){ count+=map.get(temp); } map.put(preSum[j],map.getOrDefault(preSum[j],0)+1); } return count; } } ","date":"2024-12-31T20:35:31+08:00","permalink":"https://Tyritic.github.io/p/%E5%89%8D%E7%BC%80%E5%92%8C/","title":"前缀和"},{"content":"题目描述 通常用于在数组，链表中求解窗口的最值问题\n算法模板 最小滑动窗口 题目前提 给定数组 nums，定义滑窗的左右边界 i, j，求满足某个条件的滑窗的最小长度。\n思路解析 先固定左指针不动 一开始滑窗不满足条件，向右移动右指针直到窗口满足题目条件 迭代右移左指针同时更新结果（更新结果和移动左边界处于同一个while循环中） 代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class solution{ public result\u0026lt;T\u0026gt; search(int[]nums) { int left=0; for(int right=0;right\u0026lt;nums.length;right++) { calculate();// 计算约束条件 // 判断[i, j]是否满足条件 while 满足条件 { update(result); // 不断更新结果(注意在while内更新！) left++; //最大程度的压缩左边界，使得滑窗尽可能的小 } } return result; } } 最大滑动窗口 题目前提 给定数组 nums，定义滑窗的左右边界 i, j，求满足某个条件的滑窗的最大长度。\n思路解析 先固定左指针不动 一开始滑窗满足条件，向右移动右指针直到不满足条件 迭代右移右边界的过程中更新结果（更新结果和移动左边界不在一个while循环内） 最保守的压缩左边界，一旦满足条件了就退出压缩左边界的过程，使得滑窗尽可能的大 代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class solution{ public result\u0026lt;T\u0026gt; search(int[]nums) { int left=0; for(int right=0;right\u0026lt;nums.length;right++) { calculate();// 计算约束条件 // 判断[i, j]是否满足条件 while 不满足条件 { left++; //（最保守的压缩左边界，一旦满足条件了就退出压缩左边界的过程，使得滑窗尽可能的大） } update(result); } return result; } } 固定滑动窗口 题目前提 题目中出现显式的窗口长度或字符串长度可以考虑使用\n代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public List\u0026lt;Integer\u0026gt; findAnagrams(String s, String p) { int left=0; for(int right=0;right\u0026lt;s.length();right++){ // 将右侧元素加入窗口 if(right\u0026lt;pLen-1){ //窗口大小不足 continue; } // 更新答案 // 窗口左侧元素离开队列 left++; } return ans; } } 经典例题 leetcode 209. 长度最小的子数组 题目描述 力扣题目链接(opens new window)\n给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。\n示例：\n输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 提示：\n1 \u0026lt;= target \u0026lt;= 10^9 1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^5 思路解析 题目前提条件为\n给定数组 nums 求满足某个条件的滑窗的最小长度。 窗口一开始不满足条件 故采用最小滑动窗口策略\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int minSubArrayLen(int target, int[] nums) { int left=0; int sum=0; int result=Integer.MAX_VALUE; for(int right=0;right\u0026lt;nums.length;right++) {\t// 1.计算约束条件 sum+=nums[right]; // 2.当窗口满足条件 while(sum\u0026gt;=target) { // 3. 更新结果 result=Math.min(result,right-left+1); // 4. 右移右边界 sum-=nums[left]; left++; } } return result; } } leetcode 904. 水果成篮 题目描述 力扣题目链接\n你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。\n你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：\n你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。\n示例 1：\n1 2 3 输入：fruits = [1,2,1] 输出：3 解释：可以采摘全部 3 棵树。 示例 2：\n1 2 3 4 输入：fruits = [0,1,2,2] 输出：3 解释：可以采摘 [1,2,2] 这三棵树。 如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。 示例 3：\n1 2 3 4 输入：fruits = [1,2,3,2,2] 输出：4 解释：可以采摘 [2,3,2,2] 这四棵树。 如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。 示例 4：\n1 2 3 输入：fruits = [3,3,3,1,2,1,1,2,3,3,4] 输出：5 解释：可以采摘 [1,2,1,1,2] 这五棵树。 提示：\n1 \u0026lt;= fruits.length \u0026lt;= 105 0 \u0026lt;= fruits[i] \u0026lt; fruits.length 思路解析 本题可以抽象为求解一个滑动窗口，滑动窗口内只有两种数字，求解滑动窗口长度的最大值\n题目前提条件\n给定数组 nums 求满足某个条件的滑窗的最大长度。 窗口一开始满足条件 故采用最大滑动窗口策略\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int totalFruit(int[] fruits) { int n=fruits.length; if(n==1)return 1; if(n==2)return 2; int left=0; int ans=0; int result=1; HashMap\u0026lt;Integer,Integer\u0026gt;map=new HashMap\u0026lt;\u0026gt;(); for(int right=0;right\u0026lt;fruits.length;right++) { // 1.计算约束条件（水果的种类数） map.put(fruits[right],map.getOrDefault(fruits[right],0)+1); // 2.若不满足条件 while(map.size()\u0026gt;2) { // 3.右移左边界 map.put(fruits[left],map.get(fruits[left])-1); if(map.get(fruits[left])==0) map.remove(fruits[left]); left++; } // 4.更新结果 result=Math.max(result,right-left+1); } return result; } } leetcode 76 最小覆盖子串 题目描述 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \u0026quot;\u0026quot; 。\n注意：\n对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。 如果 s 中存在这样的子串，我们保证它是唯一的答案。 示例 1：\n1 2 3 输入：s = \u0026#34;ADOBECODEBANC\u0026#34;, t = \u0026#34;ABC\u0026#34; 输出：\u0026#34;BANC\u0026#34; 解释：最小覆盖子串 \u0026#34;BANC\u0026#34; 包含来自字符串 t 的 \u0026#39;A\u0026#39;、\u0026#39;B\u0026#39; 和 \u0026#39;C\u0026#39;。 示例 2：\n1 2 3 输入：s = \u0026#34;a\u0026#34;, t = \u0026#34;a\u0026#34; 输出：\u0026#34;a\u0026#34; 解释：整个字符串 s 是最小覆盖子串。 示例 3:\n1 2 3 4 输入: s = \u0026#34;a\u0026#34;, t = \u0026#34;aa\u0026#34; 输出: \u0026#34;\u0026#34; 解释: t 中两个字符 \u0026#39;a\u0026#39; 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。 提示：\nm == s.length n == t.length 1 \u0026lt;= m, n \u0026lt;= 105 s 和 t 由英文字母组成 思路解析 本题可以将覆盖子串抽象为一个滑动窗口，求解该滑动窗口的最小值\n故采用最小滑动窗口策略\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Solution { public String minWindow(String s, String t) { int[]cnS=new int[128]; int[]cnT=new int[128]; char[]S=s.toCharArray(); char[]T=t.toCharArray(); for(char e:T) { cnT[e]++; } int left=0; int ansLeft=-1; int ansRight=s.length-1; for(int right=0;right\u0026lt;s.length;right++) { // 1.计算约束条件 cnS[S[right]]++; // 2.若满足条件 while(isCover(cnS,cnT)) { // 3.更新结果 if(right-left+1\u0026lt;ansRight-ansLeft+1) { ansLeft=left; ansRight=right; } // 4.右移左边界 cnT[S[left]]--; left++; } } return ansLeft\u0026lt;0?\u0026#34;\u0026#34;:s.substring(ansLeft,ansRight+1); } //通过统计子串中字符的出现次数来判断是否覆盖 public static boolean isCover(int[]cnS,int[]cnT) { for(int i=\u0026#39;a\u0026#39;;i\u0026lt;=\u0026#39;z\u0026#39;;i++) { if(cnS[i]\u0026lt;cnT[i]) { return false; } } for(int i=\u0026#39;A\u0026#39;;i\u0026lt;=\u0026#39;Z\u0026#39;;i++) { if(cnS[i]\u0026lt;cnT[i]) { return false; } } return true; } } leetcode 438 找到字符串中所有的字母异位词 题目描述 题目链接\n给定两个字符串 s 和 p，找到 s 中所有 p 的\n异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n示例 1:\n1 2 3 4 5 输入: s = \u0026#34;cbaebabacd\u0026#34;, p = \u0026#34;abc\u0026#34; 输出: [0,6] 解释: 起始索引等于 0 的子串是 \u0026#34;cba\u0026#34;, 它是 \u0026#34;abc\u0026#34; 的异位词。 起始索引等于 6 的子串是 \u0026#34;bac\u0026#34;, 它是 \u0026#34;abc\u0026#34; 的异位词。 示例 2:\n1 2 3 4 5 6 输入: s = \u0026#34;abab\u0026#34;, p = \u0026#34;ab\u0026#34; 输出: [0,1,2] 解释: 起始索引等于 0 的子串是 \u0026#34;ab\u0026#34;, 它是 \u0026#34;ab\u0026#34; 的异位词。 起始索引等于 1 的子串是 \u0026#34;ba\u0026#34;, 它是 \u0026#34;ab\u0026#34; 的异位词。 起始索引等于 2 的子串是 \u0026#34;ab\u0026#34;, 它是 \u0026#34;ab\u0026#34; 的异位词。 提示:\n1 \u0026lt;= s.length, p.length \u0026lt;= 3 * 104 s 和 p 仅包含小写字母 思路解析 可以考虑设置一个长度为字符串p的长度的滑动窗口，移动滑动窗口比较窗口内的子串是否是p的字母异位词\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public List\u0026lt;Integer\u0026gt; findAnagrams(String s, String p) { List\u0026lt;Integer\u0026gt;ans=new ArrayList\u0026lt;\u0026gt;(); int sLen=s.length(); int pLen=p.length(); if(sLen\u0026lt;pLen)return ans; // 设置两个哈希表，分别记录s和p的字母出现次数 int[]sCount=new int[26]; int[]pCount=new int[26]; // 比较起始位置是否是字母异位词 for(int i=0;i\u0026lt;pLen;i++) { pCount[p.charAt(i)-\u0026#39;a\u0026#39;]++; } int left=0; for(int right=0;right\u0026lt;s.length();right++){ sCount[s.charAt(right)-\u0026#39;a\u0026#39;]++; if(right\u0026lt;pLen-1){ continue; } if(Arrays.equals(sCount,pCount)){ ans.add(left); } sCount[s.charAt(left)-\u0026#39;a\u0026#39;]--; left++; } return ans; } } leetcode 3 无重复字符的最长子串 题目描述 题目链接\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。\n示例 1:\n1 2 3 输入: s = \u0026#34;abcabcbb\u0026#34; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026#34;abc\u0026#34;，所以其长度为 3。 示例 2:\n1 2 3 输入: s = \u0026#34;bbbbb\u0026#34; 输出: 1 解释: 因为无重复字符的最长子串是 \u0026#34;b\u0026#34;，所以其长度为 1。 示例 3:\n1 2 3 4 输入: s = \u0026#34;pwwkew\u0026#34; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026#34;wke\u0026#34;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\u0026#34;pwke\u0026#34; 是一个子序列，不是子串。 思路解析 题目前提条件\n给定数组 nums 求满足某个条件的滑窗的最大长度。 窗口一开始满足条件 故采用最大滑动窗口策略\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int lengthOfLongestSubstring(String s) { if(s.isEmpty())return 0; HashMap\u0026lt;Character,Integer\u0026gt;map=new HashMap\u0026lt;\u0026gt;(); int left=0; int res=Integer.MIN_VALUE; for(int right=0;right\u0026lt;s.length();right++){ // 计算约束条件 char ch=s.charAt(right); map.put(ch,map.getOrDefault(ch,0)+1); // 不满足条件 while(map.get(ch)\u0026gt;1){ // 压缩左边界 map.put(s.charAt(left),map.get(s.charAt(left))-1); left++; } res=Math.max(res,right-left+1); } return res; } } ","date":"2024-12-30T15:29:22+08:00","permalink":"https://Tyritic.github.io/p/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B3%95/","title":"双指针法-滑动窗口法"},{"content":"题目描述 通常当使用蛮力法需要两个for循环时，将两个for循环削减成一个for循环的优化方法。时间复杂度$O(n^2)$可以优化为$O(n)$\n同时数组排序为两端大，中间小\n算法模板 方法步骤 双指针法（左右指针法）： 通过一个左指针和右指针在一个for循环下完成两个for循环的工作。\n定义左右指针\n左指针：定义在数组左侧的指针 右指针：定义在数组尾部的指针 代码模板 1 2 3 4 5 6 7 8 9 10 11 class solution{ public int solution(int[]nums,int val) { int leftIndex=0; int rightIndex=nums.length-1; while(left\u0026lt;=right) { } } } 经典例题 leetcode 977. 有序数组的平方 题目描述 力扣题目链接(opens new window)\n给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n示例 1：\n输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100] 示例 2：\n输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] 思路解析 数组其实是有序的， 只不过负数平方之后可能成为最大数了。\n那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。\n此时可以考虑双指针法了，i指向起始位置，j指向终止位置。\n定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。比较左指针和右指针的平方大小\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int[] sortedSquares(int[] nums) { int leftIndex=0; int rightIndex=nums.length-1; int numsIndex=nums.length-1; int[]result=new int[nums.length]; while(leftIndex\u0026lt;=rightIndex) { if(nums[leftIndex]*nums[leftIndex]\u0026gt;=nums[rightIndex]*nums[rightIndex]) { result[numsIndex]=nums[leftIndex]*nums[leftIndex]; leftIndex++; } else{ result[numsIndex]=nums[rightIndex]*nums[rightIndex]; rightIndex--; } numsIndex--; } return result; } } leetcode 15. 三数之和 题目描述 力扣题目链接(opens new window)\n给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。\n注意： 答案中不可以包含重复的三元组。\n示例：\n给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]\n思路解析 一开始的思路为，固定 a+b ，然后通过哈希法求出 0-(a+b) 是否在数组中出现过。但是题目中出现限制条件：答案中不可以包含重复的三元组。而使用哈希法进行去重比较困难。于是考虑先固定 a ,然后使用指针移动 b 和 c ,通过计算他们的和与0的大小关系来移动指针。同时题目不涉及数组下标，然后考虑使用排序+左右指针进行求解。\n代码思路如下\n将数组进行预排序 遍历数组，固定 a ，（注意去重操作） 设置左右指针 左指针指向 a 的后一个位置，代表 b 右指针指向数组末尾，代表 c 计算三数之和 sum 与零的大小关系 sum\u0026gt;0 ：说明 c 大了，右指针左移动 sum\u0026lt;0 ：说明 b 小了，左指针右移动 sum=0 ：说明符合要求，加入答案集中，但是要注意对 b 和 c 进行去重 左指针右移动 右指针左移动 去重的思路如下\n对 a 的去重：若 a 的值出现重复直接跳过\n判断 nums[i] 与 nums[i + 1] 是否相同会导致三元组内不能出现重复的元素，导致损失了含有重复元素的三元组（[-1,-1,2]） 判断 i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] 可以正常打成去重效果 对 b 和 **c ** 的去重，直接移动指针即可\nwhile (right \u0026gt; left \u0026amp;\u0026amp; nums[right] == nums[right - 1]) right--;\nwhile (right \u0026gt; left \u0026amp;\u0026amp; nums[left] == nums[left + 1]) left++;\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 import java.util.ArrayList; import java.util.Arrays; import java.util.HashSet; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;res=new ArrayList\u0026lt;\u0026gt;(); //答案集 Arrays.sort(nums); //数组预排序 for(int i=0;i\u0026lt;nums.length;i++) { // 小剪枝操作，预先判断最小的数与0的关系，若最小的数比0大则不用进行下面的比较 if(nums[i]\u0026gt;0) return res; // 对a去重的逻辑 if(i\u0026gt;0\u0026amp;\u0026amp;nums[i]==nums[i-1]){ continue; } // 设置左右指针 int left=i+1; int right=nums.length-1; while(left\u0026lt;right) { int sum=nums[i]+nums[left]+nums[right]; // sum太大，表示c太大，左移动右指针缩小c if(sum\u0026gt;0) { right--; } // sum太小，表示b太小，右移动左指针扩大b else if(sum\u0026lt;0) { left++; } else{ // 将结果加入答案集 List\u0026lt;Integer\u0026gt;ans=new ArrayList\u0026lt;\u0026gt;(); ans.add(nums[i]); ans.add(nums[left]); ans.add(nums[right]); res.add(ans); // 对b和c去重的逻辑 while(right\u0026gt;left\u0026amp;\u0026amp;nums[right]==nums[right-1]) { right--; } while(right\u0026gt;left\u0026amp;\u0026amp;nums[left]==nums[left+1]) { left++; } left++; right--; } } } return res; } } leetcode 18 四数之和 题目描述 力扣题目链接(opens new window)\n题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。\n注意：\n答案中不可以包含重复的四元组。\n示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]\n思路解析 基本思路与三数之和类似，但是在剪枝操作中存在注意点\n在三数之和中判断 nums[i]\u0026gt;0 可以直接跳过接下来的比较但是在本题只通过 nums[i]\u0026gt;target 就跳过是错误的 因为数组经过排序且target的值与零的大小关系不确定，假设 nums[i]\u0026lt;0，且 target\u0026lt;0 但是 nums[i]\u0026gt;target ，那么要是四元组中存在一个负数也能满足条件，例如数组是 [-4, -3, -2, -1] ，target 是 -10 但是只要保证 nums[i]\u0026gt;=0\u0026amp;\u0026amp;nums[i]\u0026gt;target ，这个条件就能成功跳过不必要的比较 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; fourSum(int[] nums, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;res=new ArrayList\u0026lt;\u0026gt;(); if(nums.length\u0026lt;4)return res; Arrays.sort(nums); for(int i=0;i\u0026lt;nums.length;i++) { // 第一层剪枝 if(nums[i]\u0026gt;target\u0026amp;\u0026amp;nums[i]\u0026gt;0) break; // 对a去重 if(i\u0026gt;0\u0026amp;\u0026amp;nums[i]==nums[i-1]) continue; for(int j=i+1;j\u0026lt;nums.length;j++) { // 第二层剪枝 if(nums[i]+nums[j]\u0026gt;target\u0026amp;\u0026amp;nums[i]+nums[j]\u0026gt;0) break; // 对b去重 if(j\u0026gt;i+1\u0026amp;\u0026amp;nums[j]==nums[j-1]) continue; // 设置左指针对应c，右指针对应d int k=j+1; int l=nums.length-1; while(k\u0026lt;l) { int sum=nums[i]+nums[j]+nums[k]+nums[l]; if(sum\u0026gt;target)l--; else if(sum\u0026lt;target)k++; else{ List\u0026lt;Integer\u0026gt;ans=new ArrayList\u0026lt;\u0026gt;(); ans.add(nums[i]); ans.add(nums[j]); ans.add(nums[k]); ans.add(nums[l]); res.add(ans); // 对c和d进行去重 while(k\u0026lt;l\u0026amp;\u0026amp;nums[k]==nums[k+1])k++; while(k\u0026lt;l\u0026amp;\u0026amp;nums[l]==nums[l-1])l--; k++; l--; } } } } return res; } } leetcode 941 有效的山脉数组 题目描述 力扣题目链接(opens new window)\n给定一个整数数组 arr，如果它是有效的山脉数组就返回 true，否则返回 false。\n让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：\narr.length \u0026gt;= 3 在 0 \u0026lt; i \u0026lt; arr.length - 1 条件下，存在 i 使得： arr[0] \u0026lt; arr[1] \u0026lt; \u0026hellip; arr[i-1] \u0026lt; arr[i] arr[i] \u0026gt; arr[i+1] \u0026gt; \u0026hellip; \u0026gt; arr[arr.length - 1] 示例 1：\n输入：arr = [2,1] 输出：false 示例 2：\n输入：arr = [3,5,5] 输出：false 示例 3：\n输入：arr = [0,3,2,1] 输出：true 思路解析 山脉数组保证从左边到山顶是单调递增，从右边到山顶时单调递增\n故可以通过设置左指针和右指针，让两个指针相向移动。只要两个指针相遇则是山脉数组\n如果left或者right没有移动，说明是一个单调递增或者递减的数组，依然不是山峰\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public boolean validMountainArray(int[] arr) { int left=0; int right=arr.length-1; // 保证从左到右单调递增 while(left\u0026lt;arr.length-1\u0026amp;\u0026amp;arr[left]\u0026lt;arr[left+1]) left++; // 保证从右到左单调递增 while(right\u0026gt;0\u0026amp;\u0026amp;arr[right]\u0026lt;arr[right-1]) right--; if(left==right\u0026amp;\u0026amp;left!=0\u0026amp;\u0026amp;right!=arr.length-1) return true; return false; } } ","date":"2024-12-30T11:44:58+08:00","permalink":"https://Tyritic.github.io/p/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95%E5%B7%A6%E5%8F%B3%E6%8C%87%E9%92%88%E6%B3%95/","title":"双指针法—左右指针法"},{"content":"虚拟头节点 方法描述 设置一个虚拟头结点，这样原链表的所有节点就都可以按照统一的方式进行操作了。\n经典例题 leetcode 203. 移除链表元素 力扣题目链接(opens new window)\n题意：删除链表中等于给定值 val 的所有节点。\n示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]\n示例 2： 输入：head = [], val = 1 输出：[]\n示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * 时间复杂度 O(n) * 空间复杂度 O(1) * @param head * @param val * @return */ public ListNode removeElements(ListNode head, int val) { // 设置一个虚拟的头结点 ListNode dummy = new ListNode(); dummy.next = head; ListNode cur = dummy; while (cur.next != null) { if (cur.next.val == val) { cur.next = cur.next.next; } else { cur = cur.next; } } return dummy.next; } leetcode 24. 两两交换的节点 题目描述\n力扣题目链接(opens new window)\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n思路解析\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(-1); // 设置一个虚拟头结点 dummy.next = head; // 将虚拟头结点指向head，这样方便后面做删除操作 ListNode curr=dummy; ListNode temp; //保存两个节点后的节点 ListNode firstNode; //保存curr后的第一个节点 ListNode secondNode; //保存curr后的第二个节点 while(curr.next!=null\u0026amp;\u0026amp;curr.next.next!=null) { firstNode=curr.next; secondNode=firstNode.next; temp=secondNode.next; curr.next=secondNode; // 步骤一 secondNode.next=firstNode; //步骤二 firstNode.next=temp; // 步骤三 curr=firstNode; //重新设置为原先在secondNode位置上的节点 } return dummy.next; } } leetcode 19. 删除链表的倒数第N个节点 题目描述\n力扣题目链接(opens new window)\n给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n进阶：你能尝试使用一趟扫描实现吗？\n示例 1：\n输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5]\n示例 2：\n输入：head = [1], n = 1 输出：[]\n示例 3：\n输入：head = [1,2], n = 1 输出：[1]\n思路解析\n使用快慢指针和虚拟头节点，让快节点从虚拟头节点开始，提前移动n+1步。\n然后再让快节点和慢节点同时移动直到快节点移动到最后一个节点的后一个位置（null)\n此时快节点和慢节点之间间隔n个节点，慢节点位于要删除的节点的前一个节点位置\n直接删除即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { //新建一个虚拟头节点指向head ListNode dummyNode = new ListNode(0); dummyNode.next = head; //快慢指针指向虚拟头节点 ListNode fastIndex = dummyNode; ListNode slowIndex = dummyNode; // 快指针移动n+1步，使得快慢指针相差 n 个结点即可 for (int i = 0; i \u0026lt;= n; i++) { fastIndex = fastIndex.next; } // 两个指针同时移动，直到快指针移动到最后一个节点的后一个位置（null) while (fastIndex != null) { fastIndex = fastIndex.next; slowIndex = slowIndex.next; } // 检查 slowIndex.next 是否为 null，以避免空指针异常 if (slowIndex.next != null) { slowIndex.next = slowIndex.next.next; // 直接删除节点 } return dummyNode.next; } } leetcode 2 两数相加 题目描述\n给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n示例 1：\n1 2 3 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807. 示例 2：\n1 2 输入：l1 = [0], l2 = [0] 输出：[0] 示例 3：\n1 2 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出：[8,9,9,9,0,0,0,1] 提示：\n每个链表中的节点数在范围 [1, 100] 内 0 \u0026lt;= Node.val \u0026lt;= 9 题目数据保证列表表示的数字不含前导零 思路解析\n本题应当模拟加法的竖式操作。首先建立虚拟头节点pre，然后从 l1 和 l2 的第一个节点开始进行加法运算。第一个节点的加法运算的进位可以视为0，然后将 l1 和 l2 的节点和与10相除的结果作为进位，l1 和 l2 的节点和与10的余数作为新节点的值。注意**l1** 和**l2** 的长度不一致，因此需要判断是否节点为空，为空的节点视为0即可。\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy=new ListNode(0); ListNode curr=pre; int carry=0; while(l1!=null||l2!=null) { // 判断节点是否为空，空节点视为0 int x=l1==null?0:l1.val; int y=l2==null?0:l2.val; int sum=x+y+carry; // 计算进位 carry=sum/10; // 计算新节点的值 curr.next=new ListNode(sum%10); curr=curr.next; // 防止越界，只有节点不为空的时候再向下遍历 if(l1!=null)l1=l1.next; if(l2!=null)l2=l2.next; } // 注意最后一位的进位可能导致结果多出一位比如：99+10=109 if(carry==1) { curr.next=new ListNode(1); } return dummy.next; } } 反转操作 思路解析 只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表\n定义节点\ncurr：当前节点 prev：当前节点的上一个节点 temp：当前节点的下一个节点 操作\n记录curr的下一个指针temp 将指针反转，让curr指向prev 将prev节点设置为curr 将curr设置为temp 经典例题 leetcode 206. 翻转链表 力扣题目链接(opens new window)\n题意：反转一个单链表。\n示例: 输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL 输出: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public ListNode reverseList(ListNode head) { ListNode prev=null; ListNode curr=head; ListNode temp=null; while(curr!=null) { temp=curr.next; curr.next=prev; prev=curr; curr=temp; } } } BM2 链表内指定区间反转 题目描述\n将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)，空间复杂度 O(1)。 例如： 给出的链表为 1→2→3→4→5→NULL m=2,n=4 返回 1→4→3→2→5→NULL\n数据范围： 链表长度 0\u0026lt;size≤10000\u0026lt;size≤1000，链表中每个节点的值满足 ∣val∣≤1000\n要求：时间复杂度 O(n) ，空间复杂度 O(n)\n进阶：时间复杂度 O(n)，空间复杂度 O(1)\n示例1\n输入：\n1 {1,2,3,4,5},2,4 返回值：\n1 {1,4,3,2,5} 示例2\n输入：\n1 {5},1,1 返回值：\n1 {5} 思路解析\n固定子区间外的节点。 在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。 变量解释 pre：待反转的区间之前的一个节点 curr：待反转区间的第一个节点 temp：curr的后驱节点，将temp节点反转到起始位置 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public ListNode reverseBetween (ListNode head, int m, int n) { // write code here // 虚拟头节点 ListNode dummy=new ListNode(0); dummy.next=head; ListNode pre=dummy; ListNode curr=head; // 求出pre和curr for(int i=1;i\u0026lt;m;i++) { pre=curr; curr=curr.next; } for(int i=m;i\u0026lt;n;i++) { ListNode temp=curr.next; // 跳过一个节点 curr.next=temp.next; // temp指向待反转区间的第一个节点 temp.next=pre.next; pre.next=temp; } return dummy.next; } 判断链表是否相交 思路解析 求出A链表和B链表的长度 让currB到currA对齐的位置 此时比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。 经典例题 leetcode 160. 链表相交 力扣题目链接(opens new window)\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n图示两个链表在节点 c1 开始相交：\n题目数据 保证 整个链式结构中不存在环。\n注意，函数返回结果后，链表必须 保持其原始结构 。\n示例 1：\n示例 2：\n示例 3：\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode currA = headA; ListNode currB = headB; int lenA = 0, lenB = 0; while (currA != null) { // 求链表A的长度 lenA++; currA = currA.next; } while (currB != null) { // 求链表B的长度 lenB++; currB = currB.next; } // 将当前指针回到头节点 currA = headA; currB = headB; // 让currA为最长链表的头，lenA为其长度 if (lenB \u0026gt; lenA) { //1. swap (lenA, lenB); 交换长度 int tmpLen = lenA; lenA = lenB; lenB = tmpLen; //2. swap (currA, currB); 交换节点 ListNode tmpNode = currA; currA = currB; currB = tmpNode; } // 求长度差 int gap = lenA - lenB; // 让currA和currB在同一起点上（末尾位置对齐） for(int i=0;i\u0026lt;gap;i++) { currA=currA.next; } // 遍历currA 和 currB，遇到相同则直接返回 while (currA != null) { if (currA == currB) { return currA; } currA = currA.next; currB = currB.next; } return null; } } 环形链表 思路解析 判断是否是环形链表 使用快慢指针法，设置一个快指针和慢指针，让快指针一次移动两步，慢指针一次移动一步，若两个指针能相遇则该链表是环形链表\n证明过程\nfast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇\n其实相对于slow来说，fast是一个节点一个节点的靠近slow的\n如何找到环的入口 从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。\n经典例题 leetcode 142. 环形链表II 题目描述\n力扣题目链接(opens new window)\n题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。\n说明：不允许修改给定的链表。\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head; ListNode fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) {// 有环 ListNode index1 = fast; ListNode index2 = head; // 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口 while (index1 != index2) { index1 = index1.next; index2 = index2.next; } return index1; } } return null; } } ","date":"2024-12-29T17:25:11+08:00","permalink":"https://Tyritic.github.io/p/%E9%93%BE%E8%A1%A8/","title":"链表"},{"content":"题目描述 通常当使用蛮力法需要两个for循环时，将两个for循环削减成一个for循环的优化方法。时间复杂度$O(n^2)$可以优化为$O(n)$\n算法模板 方法步骤 双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。\n新数组指在旧数组的基础上修改后的数组\n定义快慢指针\n快指针：通过遍历旧数组来寻找新数组的元素 ，新数组就是不含有目标元素的数组 慢指针：指向更新后新数组下标的位置 代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 class solution{ public int solution(int[]nums,int val) { int slowIndex=0; for(int fastIndex=0;fastIndex\u0026lt;nums.length;fastIndex++) { //题目要求的操作,用于构建新数组，if条件内是符合新数组要求的谓词 //fastIndex用于遍历原数组 //slowIndex用于插入新数组 } return slowIndex; } } 结果分析 slowIndex是新数组的元素个数。\n经典例题 leetcode 27. 移除元素 题目描述 力扣题目链接(opens new window)\n给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。\n示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n你不需要考虑数组中超出新长度后面的元素。\n思路解析 题目条件中原地一词提示使用快慢指针法，将$O(n^2)$的操作转变为$O(n)$的操作\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int removeElement(int[] nums, int val) { int slowIndex=0; for(int fastIndex=0;fastIndex\u0026lt;nums.length;fastIndex++) { if(nums[fastIndex]!=val) { nums[slowIndex++]=nums[fastIndex]; } } return slowIndex; } } leetcode 26. 删除有序数组的重复项 题目描述 力扣题目链接\n给你一个 非严格递增排列 的数组 nums ，请你** 原地** 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。\n考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：\n更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。 返回 k 。 判题标准:\n系统会用下面的代码来测试你的题解:\n1 2 3 4 5 6 7 8 9 int[] nums = [...]; // 输入数组 int[] expectedNums = [...]; // 长度正确的期望答案 int k = removeDuplicates(nums); // 调用 assert k == expectedNums.length; for (int i = 0; i \u0026lt; k; i++) { assert nums[i] == expectedNums[i]; } 如果所有断言都通过，那么您的题解将被 通过。\n示例 1：\n1 2 3 输入：nums = [1,1,2] 输出：2, nums = [1,2,_] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2：\n1 2 3 输入：nums = [0,0,1,1,1,2,2,3,3,4] 输出：5, nums = [0,1,2,3,4] 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums 已按 非严格递增 排列 思路解析 题目条件中原地一词提示使用快慢指针法，将$O(n^2)$的操作转变为$O(n)$的操作\nslow 指针指向新数组中被更新元素下一个位置\nfast 指针遍历原数组\n根据题意，第一个元素 nums[0] 一定会被保留故 slow 从 1 开始，于是 fast 从 1 开始，当遇到与新数组的最后一个有效元素不重复的元素就更新数组\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int removeDuplicates(int[] nums) { int slow=1; for(int fast=1;fast\u0026lt;nums.length;fast++) { if(nums[fast]!=nums[slow-1]) { nums[slow++]=nums[fast]; } } return slow; } } leetcode 283. 移动零 题目描述 力扣题目链接\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n示例 1:\n1 2 输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0] 示例 2:\n1 2 输入: nums = [0] 输出: [0] 提示:\n1 \u0026lt;= nums.length \u0026lt;= 104 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 思路解析 将所有不等于0的元素放入原先的数组中 在新数组的尾部全部置为零 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public void moveZeroes(int[] nums) { int slowIndex=0; for(int fastIndex=0;fastIndex\u0026lt;nums.length;fastIndex++) { if(nums[fastIndex]!=0) { nums[slowIndex++]=nums[fastIndex]; } } for(int i=slowIndex;i\u0026lt;nums.length;i++) { nums[i]=0; } } } leetcode 844. 比较含退格的字符串 题目描述 力扣题目链接\n给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。\n**注意：**如果对空文本输入退格字符，文本继续为空。\n示例 1：\n1 2 3 输入：s = \u0026#34;ab#c\u0026#34;, t = \u0026#34;ad#c\u0026#34; 输出：true 解释：s 和 t 都会变成 \u0026#34;ac\u0026#34;。 示例 2：\n1 2 3 输入：s = \u0026#34;ab##\u0026#34;, t = \u0026#34;c#d#\u0026#34; 输出：true 解释：s 和 t 都会变成 \u0026#34;\u0026#34;。 示例 3：\n1 2 3 输入：s = \u0026#34;a#c\u0026#34;, t = \u0026#34;b\u0026#34; 输出：false 解释：s 会变成 \u0026#34;c\u0026#34;，但 t 仍然是 \u0026#34;b\u0026#34;。 提示：\n1 \u0026lt;= s.length, t.length \u0026lt;= 200 s 和 t 只含有小写字母以及字符 '#' 思路解析 基本思路\n将s和t经过退格操作后的字符串求解出（封装成一个函数） 对比求解后的字符串来判断（主函数中进行） 退格操作的求解思路\n定义快慢指针fastIndex和slowIndex fastIndex从左往右遍历 当遇到非退格符号时slowIndex正常记录数组元素 当遇到退格符号时slowIndex向后退一位 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public boolean backspaceCompare(String s, String t) { String s1=checked(s); String s2=checked(t); if(s1.equals(s2)) { return true; } return false; } //求解退格处理后的字符串 public static String checked(String s) { char[]chars=s.toCharArray(s); int slowIndex=0; for(int fastIndex=0;fastIndex\u0026lt;chars.length;fastIndex++) { //遍历旧数组，不为退格符#的字符保留 if(chars[fastIndex]!=\u0026#39;#\u0026#39;) chars[slowIndex++]=chars[fastIndex]; //遍历旧数组，为退格符#的字符进行退格处理 else if(chars[fastIndex]==\u0026#39;#\u0026#39;) { //slowIndex是新数组的长度 if(slowIndex\u0026gt;0) slowIndex--; } } return new String(chars).substring(0,slow); } } ","date":"2024-12-29T16:21:01+08:00","permalink":"https://Tyritic.github.io/p/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E6%B3%95/","title":"双指针法—快慢指针法"},{"content":"题目特征 前提条件\n数组为有序数组 强调数组中无重复元素 题目的前提是数组为有序数组，同时题目还强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。\n算法模板 左闭右闭（推荐使用） 定义 target 是在一个在左闭右闭的区间里，也就是[left, right] 。\n临界条件的变化 while (left \u0026lt;= right) 要使用 \u0026lt;= ，因为left == right是有意义的，所以使用 \u0026lt;= if (nums[middle] \u0026gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class solution{ public int search(int[]nums,int target) { //定义target处于区间[left,right]中 int left=0; //左边界 int right=nums.length-1; //右边界 while(left\u0026lt;=right) { int mid=left+(right-left)/2; //防止溢出 等同于(left + right)/2 if(nums[mid]\u0026gt;target) right=mid-1; //查找区间为[left,mid-1] else if(nums[mid]\u0026lt;target) left=mid+1; //查找区间为[mid+1.right] else //nums[mid]==target return mid; } return -1; //若未找到返回-1，表示数组中不存在该元素 } } 结果分析 若数组中找不到元素此时满足条件\nleft=right+1 同时nums[left]是大于target的元素中最小的，nums[right]是小于target元素中最大的 左闭右开 定义 target 是在一个在左闭右开的区间里，也就是[left, right） 。\n临界条件的变化 while (left \u0026lt; right) 要使用 \u0026lt; ，因为left == right是没有意义的 if (nums[middle] \u0026gt; target) right 要赋值为 middle ，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle，下一个查询区间不会去比较nums[middle] 代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class solution{ public int search(int[]nums,int target) { //定义target处于区间[left,right)中 int left=0; //左边界 int right=nums.length; //右边界 while(left\u0026lt;right) { int mid=left+(right-left)/2; //防止溢出 等同于(left + right)/2 if(nums[mid]\u0026gt;target) right=mid; //查找区间为[left,mid-1] else if(nums[mid]\u0026lt;target) left=mid+1; //查找区间为[mid+1.right] else //nums[mid]==target return mid; } return -1; //若未找到返回-1，表示数组中不存在该元素 } } 结果分析 若数组中找不到元素此时满足条件\nleft=right 同时nums[left]=nums[right]是大于target的元素中最小的 经典例题 leetcode 704. 二分查找 题目描述 力扣题目链接(opens new window)\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n示例 1:\n1 2 3 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2:\n1 2 3 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示：\n你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 思路分析 直接嵌套算法模板即可\n参考代码 左闭右闭版本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int search(int[] nums, int target) { int left=0,right=nums.length-1; while(left\u0026lt;=right) { int mid=left+(right-left)/2; if(nums[mid]\u0026lt;target) left=mid+1; else if(nums[mid]\u0026gt;target) right=mid-1; else return mid; } return -1; } } 左闭右开版本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int search(int[] nums, int target) { int left=0,right=nums.length; while(left\u0026lt;right) { int mid=left+(right-left)/2; if(nums[mid]\u0026lt;target) left=mid+1; else if(nums[mid]\u0026gt;target) right=mid; else return mid; } return -1; } } leetcode 35. 搜索插入位置 题目描述 力扣题目链接(opens new window)\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n你可以假设数组中无重复元素。\n示例 1:\n输入: [1,3,5,6], 5 输出: 2 示例 2:\n输入: [1,3,5,6], 2 输出: 1 示例 3:\n输入: [1,3,5,6], 7 输出: 4 示例 4:\n输入: [1,3,5,6], 0 输出: 0 思路分析 注意这道题目的前提是数组是有序数组\n同时题目还强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的。\n分别处理四种可能情况\n目标值在数组所有元素之前 [0, -1] 目标值等于数组中某一个元素 return middle 目标值插入数组中的位置 [left, right]，return right + 1 目标值在数组所有元素之后的情况 [left, right]， 因为是右闭区间，所以 return right + 1 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int searchInsert(int[] nums, int target) { int left=0; int right=nums.length-1; while(left\u0026lt;=right) { int mid=left+(right-left)/2; if(nums[mid]\u0026lt;target) { left=mid+1; } else if(nums[mid]\u0026gt;target) { right=mid-1; } else{ return mid; } } // 2.目标值在数组所有元素之前 // 3.目标值插入数组中 // 4.目标值在数组所有元素之后 return right+1; } } leetcode 34. 在排序数组中查找元素的第一个和最后一个位置 题目描述 力扣链接(opens new window)\n给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n如果数组中不存在目标值 target，返回 [-1, -1]。\n进阶：你可以设计并实现时间复杂度为 $O(\\log n)$ 的算法解决此问题吗？\n示例 1：\n输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2：\n输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3：\n输入：nums = [], target = 0 输出：[-1,-1] 思路分析 题目条件\n给定一个按照升序排列的整数数组 nums 一个目标值 target。 符合二分查找的前提条件考虑使用二分查找\n具体思路如下\n首先，在 nums 数组中二分查找 target； 如果二分查找失败，则 binarySearch 返回 -1，表明 nums 中没有 target。此时，searchRange 直接返回 {-1, -1}； 如果二分查找成功，则 binarySearch 返回 nums 中值为 target 的一个下标。然后，通过左右滑动指针，来找到等于target的区间 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public int[] searchRange(int[] nums, int target) { int index=BinarySearch(nums,target); // 1.先进行二分查找 if(index==-1) return new int[]{-1,-1}; int left=index; //左边界 int right=index; //右边界 // 2.移动左边界 while(left\u0026gt;0\u0026amp;\u0026amp;nums[left-1]==nums[index]) left--; // 3.移动右边界 while(right\u0026lt;nums.length-1\u0026amp;\u0026amp;nums[right+1]==nums[index]) right++; return new int[]{left,right}; } public static int BinarySearch(int[] nums, int target) { int left=0; int right=nums.length-1; while(left\u0026lt;=right) { int mid=left+(right-left)/2; if(nums[mid]\u0026lt;target) { left=mid+1; } else if(nums[mid]\u0026gt;target) { right=mid-1; } else{ return mid; } } return -1; } } leetcode 69. x的平方根 题目描述 力扣题目链接\n给你一个非负整数 x ，计算并返回 x 的 算术平方根 。\n由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。\n**注意：**不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\n示例 1：\n1 2 输入：x = 4 输出：2 示例 2：\n1 2 3 输入：x = 8 输出：2 解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 提示：\n0 \u0026lt;= x \u0026lt;= 231 - 1 思路分析 题目中隐含条件，平方根在[1,x]中且该区域为有序递增数组，考虑使用二分查找\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int mySqrt(int x) { if(x==0)return 0; if(x==1)return 1; int left=0,right=x/2; while(left\u0026lt;=right) { int mid=left+(right-left)/2; if(nums[mid]\u0026lt;target) left=mid+1; else if(nums[mid]\u0026gt;target) right=mid-1; else return mid; } return right; //结果为比x小的最大整数 } } leetcode 367. 有效的完全平方数 题目描述 力扣题目链接\n给你一个正整数 num 。如果 num 是一个完全平方数，则返回 true ，否则返回 false 。\n完全平方数 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。\n不能使用任何内置的库函数，如 sqrt 。\n示例 1：\n1 2 3 输入：num = 16 输出：true 解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。 示例 2：\n1 2 3 输入：num = 14 输出：false 解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。 提示：\n1 \u0026lt;= num \u0026lt;= 231 - 1 思路分析 同上一题，注意细节：mid*mid非常容易溢出，所以采取的策略是用除法代替乘法\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public boolean isPerfectSquare(int num) { int left=0; int right=num; if(num==0||num==1)return true;// 1.特殊值判断 while(left\u0026lt;=right) { int mid=left+(right-left)/2; if(mid==num/(mid*1.0)) return true; else if (mid\u0026gt;num/(mid*1.0)) right=mid-1; else left=mid+1; } return false; } } ","date":"2024-12-29T10:52:54+08:00","permalink":"https://Tyritic.github.io/p/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","title":"二分查找"},{"content":"synchronized 关键字 synchronized 是 Java 提供的一种内置同步机制，用于解决多线程环境下的并发安全问题。它能够确保同一时刻只有一个线程执行同步代码块，从而防止线程间的数据不一致和竞态条件。\nsynchronized 的作用 保证原子性：同步代码块在执行时不会被其他线程打断，保证操作的完整性。 保证可见性：线程进入 synchronized 代码块前，必须先从主内存中读取变量最新的值，退出时必须将变量的修改刷新到主内存。 保证有序性：由于 synchronized 具有内存屏障（Memory Barrier），可以保证重排序不会影响同步代码块的正确性。 synchronized 使用方式 同步实例方法 ：为 当前对象 加锁，进入同步代码前要获得当前对象的锁； 同步静态方法 ：为 当前类（Class对象） 加锁，进入同步代码前要获得当前类的锁； 同步代码块 ：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 提示\n构造方法不能使用 synchronized 关键字修饰。但是可以在构造方法内部使用 synchronized 代码块。\n构造方法本身是 线程安全 的，但如果在构造方法中涉及到共享资源的操作，就需要采取适当的同步措施来保证整个构造过程的线程安全。\nsynchronized 修饰实例方法 在实例方法声明中加入 synchronized 关键字，可以保证在任意时刻，只有一个线程能执行该方法。也就是说，线程在执行这个方法的时候，其他线程不能同时执行，需要等待锁释放。\n1 2 3 synchronized void method() { //业务代码 } 注意事项\n修饰实例方法是给当前对象上锁 不同实例的 synchronized 方法不会相互影响（每个对象都有一个对象锁，不同的对象，他们的锁不会互相影响） synchronized 修饰静态方法 给 当前类 加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁。\n静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。\n1 2 3 synchronized static void method() { //业务代码 } 注意事项\n锁的是 当前类的 Class 对象，不属于某个对象。 当前类的 Class 对象锁被获取，不影响实例对象锁的获取，两者互不影响 静态 synchronized 方法和非静态 synchronized 方法之间的调用不互斥（因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。），比如说如果线程 A 调用了一个对象的非静态 synchronized 方法，线程 B 需要调用这个对象所属类的静态 synchronized 方法，是不会发生互斥的 synchronized 修饰代码块 对括号里指定的对象/类加锁：\nsynchronized(object) ：进入同步代码库前要获得 给定对象的锁。 synchronized(类.class) ：进入同步代码前要获得 给定 Class 的锁 1 2 3 synchronized(this) { //业务代码 } synchronized 属于可重入锁 可重入锁 是指同一个线程在获取了锁之后，可以再次重复获取该锁而不会造成死锁或其他问题。当一个线程持有锁时，如果再次尝试获取该锁，就会成功获取而不会被阻塞。\n因此一个线程调用 synchronized 方法的同时，在其方法体内部调用该对象另一个 synchronized 方法是允许的\n示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class AccountingSync implements Runnable{ static AccountingSync instance=new AccountingSync(); static int i=0; static int j=0; @Override public void run() { for(int j=0;j\u0026lt;1000000;j++){ //this,当前实例对象锁 synchronized(this){ i++; increase();//synchronized的可重入性 } } } public synchronized void increase(){ j++; } public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(instance); Thread t2=new Thread(instance); t1.start();t2.start(); t1.join();t2.join(); System.out.println(i); } } AccountingSync 类中定义了一个静态的 AccountingSync 实例 instance 和两个静态的整数 i 和 j，静态变量被所有的对象所共享。 在 run() 方法中，使用了 synchronized(this) 来加锁。这里的锁对象是 this（当前的 AccountingSync 实例）。在锁定的代码块中，对静态变量 i 进行增加，并调用了 increase() 方法。 increase() 方法是一个同步方法，它会对 j 进行增加。由于 increase() 方法也是同步的，所以它能在已经获取到锁的情况下被 run() 方法调用，体现 synchronized 关键字的可重入性。 在 main 方法中，创建了两个线程 t1 和 t2，它们共享同一个 Runnable 对象 synchronized(this) 和 synchronized 方法都使用了同一个锁对象（当前的 AccountingSync 实例），并且对静态变量 i 和 j 进行了增加操作，因此，在多线程环境下，也能保证 i 和 j 的操作是线程安全的。 synchronized 底层实现原理 synchronized 实现原理依赖于 JVM 的 Monitor（监视器锁） 和 对象头（Object Header）。\n当 synchronized 修饰在方法或代码块上时，会对特定的对象或类加锁，从而确保同一时刻只有一个线程能执行加锁的代码块。\nsynchronized 修饰方法：会在方法的访问标志中增加一个 ACC_SYNCHRONIZED 标志。每当一个线程访问该方法时，JVM 会检查方法的访问标志。如果包含 ACC_SYNCHRONIZED 标志，线程必须先获得该方法对应的对象的监视器锁（即对象锁），然后才能执行该方法，从而保证方法的同步性。 synchronized 修饰代码块：会在代码块的前后插入 monitorenter 和 monitorexit 字节码指令。 执行 monitorenter 指令时会尝试获取对象锁，如果对象没有被锁定或者已经获得了锁，锁的计数器+1。此时其他竞争锁的线程则会进入等待队列中。 执行 monitorexit 指令时则会把计数器-1，当计数器值为0时，则锁释放，处于等待队列中的线程再继续竞争锁。 从源码的角度上\n当多个线程进入同步代码块时，首先进入entryList 有一个线程获取到monitor锁后，就赋值给当前线程，并且计数器+1 如果线程调用wait方法，将释放锁，当前线程置为null，计数器-1，同时进入waitSet等待被唤醒，调用notify或者notifyAll之后又会进入entryList竞争锁 如果线程执行完毕，同样释放锁，计数器-1，当前线程置为null 原子性的保证 线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。 线程加锁后，其它线程无法获取主内存中的共享变量。 线程解锁前，必须把共享变量的最新值刷新到主内存中。 有序性的保证 synchronized 同步的代码块，具有排他性，一次只能被一个线程拥有，所以 synchronized 保证同一时刻，代码是单线程执行的。\nsynchronized 通过 JVM 指令 monitorenter 和 monitorexit 来确保加锁代码块内的指令不会被重排。\nmonitorenter ：获取锁，进入同步代码块 monitorexit ：释放锁，退出同步代码块 可重入锁的实现 可重入意味着同一个线程可以多次获得同一个锁，而不会被阻塞。\nsynchronized 支持可重入的原理\nJava 的对象头包含了一个 Mark Word ，用于存储对象的状态，包括锁信息。\n当一个线程获取对象锁时，JVM 会将该线程的 ID 写入 Mark Word，并将锁计数器设为 1。\n如果一个线程尝试再次获取已经持有的锁，JVM 会检查 Mark Word 中的线程 ID。如果 ID 匹配，表示的是同一个线程，锁计数器递增。\n当线程退出同步块时，锁计数器递减。如果计数器值为零，JVM 将锁标记为未持有状态，并清除线程 ID 信息。\n源码中是通过 Monitor 对象的 owner 和 count 字段实现的，owner 记录持有锁的线程，count 记录线程获取锁的次数。\nsynchronized 的锁升级过程 参见下期博客\n","date":"2024-12-04T13:16:44+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84synchronized%E5%85%B3%E9%94%AE%E5%AD%97/","title":"Java中的synchronized关键字"},{"content":"volatile 关键字 volatile 是一个修饰符，用来修饰共享变量。它的作用是确保对该变量的读写操作直接在主存中进行，而不使用线程的本地缓存。这意味着所有线程访问 volatile 变量时都会看到该变量的最新值，避免了多线程环境下的内存可见性问题。\nvolatile 关键字的作用 可见性：\n当一个线程修改了 volatile 变量的值，新值会立即被刷新到主存中。 当其他线程读取这个 volatile 变量时，必须从主存读取新值，而不是从本地缓存中读取。 禁止指令重排序：volatile 还通过内存屏障来禁止特定情况下的指令重排序，从而保证程序的执行顺序符合预期。\nvolatile 可以保证 可见性 ，但不保证 原子性\nvolatile 保证数据可见性 volatile 关键字可以保证变量的可见性，如果将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。\n当线程对 volatile 变量进行写操作时，JVM 会在这个变量写入之后插入一个写屏障指令，这个指令会强制将本地内存中的变量值刷新到主内存中。 当线程对 volatile 变量进行读操作时，JVM 会插入一个读屏障指令，这个指令会强制让本地内存中的变量值失效，从而重新从主内存中读取最新的值。 volatile 保证指令有序性 在程序执行期间，为了提高性能，编译器和处理器会对指令进行重排序。但涉及到 volatile 变量时，它们必须遵循一定的规则：\n写 volatile 变量的操作之前的操作不会被编译器重排序到写操作之后。 读 volatile 变量的操作之后的操作不会被编译器重排序到读操作之前。 这意味着 volatile 变量的写操作总是发生在任何后续读操作之前。\n写操作 写 volatile 变量时，强制刷新到主内存： 对于写操作会加入以下的内存屏障\n每个 volatile 写操作的前面插入一个 StoreStore 屏障 每个 volatile 写操作的后面插入一个 StoreLoad 屏障 这意味着，当线程 A 更新一个 volatile 变量时，其他线程（如线程 B）在读取该 volatile 变量时，可以看到线程 A 写入的最新值。\n写屏障保证\nStoreStore 屏障： 屏障内的 volatile 写操作 不会和屏障外的可能的写操作重排序，确保了在 volatile 写操作 之前的所有写操作都已完成，防止了这些写操作被重排序到 volatile写操作 之后。使得 volatile 写操作 之前的所有写操作的结果对 volatile 写操作 可见 StoreLoad 屏障：屏障外 volatile 写操作 不会和屏障内可能的读操作重排序，确保了在 volatile 写操作 之后的所有读操作都不会被重排序到 volatile写操作 之前。使得 volatile 写操作 对后面的读操作可见 读屏障 当线程对 volatile 变量进行读操作时，JMM 会插入一个读屏障指令，这个指令会强制让本地内存中的变量值失效，从而重新从主内存中读取最新的值。\n每个 volatile 读操作的后面插入一个 LoadLoad 屏障 每个 volatile 读操作的后面插入一个 LoadStore 屏障 保证\nLoadLoad 屏障：屏障外的 volatile 读操作 不会和屏障内可能的读操作重排序，确保 volatile 读操作 之后的所有读操作必须在 volatile 读操作 之后执行，防止了这些读操作被重排序到 volatile读操作 之前。 LoadStore 屏障：屏障外 volatile 读操作 不会和屏障内可能的写操作重排序，确保了 volatile读操作 之后的所有写操作必须在 volatile 读操作 之后执行，防止这个写操作被重排序到 volatile读操作 之前。 四种内存屏障的作用 StoreStore 屏障 （指令Store1; StoreStore; Store2）：在Store2及后续写入操作执行前， 保证Store1的写入操作对其它处理器可见。 LoadLoad 屏障 （指令Load1; LoadLoad; Load2） ：在Load2及后续读取操作要读取的数 据被访问前，保证Load1要读取的数据被读取完毕。 StoreLoad 屏障（指令Store1; StoreLoad; Load2） ：在Load2及后续所有读取操作执行 前，保证Store1的写入对所有处理器可见。 LoadStore 屏障（指令Load1; LoadStore; Store2） ：在Store2及后续写入操作被刷出前， 保证Load1要读取的数据被读取完毕。 通用作用\n它会强制将对缓存的修改操作立即写入主存； 如果是写操作，它会导致其他 CPU 中对应的缓存行无效。 对于 volatile 的写，发生于任何一个对于 volatile 的读之前 volatile 不保证原子性 虽然 volatile 保证了可见性和有序性，但它不能保证操作的原子性。原子性意味着一个操作不可分割，不能被中断。典型的例子是 i++ 操作，这实际上分为读取 i 的值、递增、写回三个步骤。如果多个线程同时执行 i++，最终结果可能不正确，因为每个线程都可能读取到相同的初始值。\n总而言之：volatile 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的\n因此 volatile 不能保证线程安全\n解决方式\n使用 AtomicInteger 使用 synchronized 块 volatile 修饰基本数据类型和引用数据类型的区别 当 volatile 用于基本数据类型时，能确保该变量的读写操作是直接从主内存中读取或写入的。 当 volatile 用于引用类型时，能确保引用本身的可见性，即确保引用指向的对象地址是最新的。但是，volatile 并不能保证引用对象内部状态的线程安全。 volatile 与 synchronized 的对比 性能 volatile 是一种轻量级的同步机制，开销较小，但它只能用于变量的可见性和禁止重排序，无法实现复杂的同步逻辑 synchronized 则是重量级的同步机制，可以保证代码块的原子性和可见性，但开销较大。 使用场景： volatile 适用于简单的状态标志、标记等场景 synchronized 更适合复杂的临界区保护，需要确保多个操作的原子性时。 volatile 关键字在单例模式中的应用 使用双重检查锁定实现的单例模式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Penguin { private static volatile Penguin m_penguin = null; //类的静态变量，用来存储 Penguin 类的唯一实例。 // 一个成员变量 money private int money = 10000; // 避免通过 new 初始化对象，构造方法应为 private private Penguin() {} public void beating() { System.out.println(\u0026#34;打豆豆\u0026#34; + money); } // 对类的 Class 对象加锁，确保在多线程环境下，同时只能有一个线程进入同步代码块。 public static Penguin getInstance() { if (m_penguin == null) { synchronized (Penguin.class) { if (m_penguin == null) { m_penguin = new Penguin(); } } } return m_penguin; } } volatile 关键字用于防止 m_penguin = new Penguin() 这一步被指令重排序。因为实际上，new Penguin() 这一行代码分为三个子步骤：\n步骤 1：为 Penguin 对象分配足够的内存空间 步骤 2：调用 Penguin 的构造方法，初始化对象的成员变量 步骤 3：将内存地址赋值给 m_penguin 变量，使其指向新创建的对象 如果不使用 volatile 关键字，JVM 可能会对这三个子步骤进行指令重排\n为 Penguin 对象分配内存 将对象赋值给引用 m_penguin 调用构造方法初始化成员变量 这种重排序会导致 m_penguin 引用在对象完全初始化之前就被其他线程访问到。\n","date":"2024-12-03T09:32:05+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84volatile%E5%85%B3%E9%94%AE%E5%AD%97/","title":"Java中的volatile关键字"},{"content":"并发和并行 并行：多核 CPU 上的多任务处理，多个任务在同一时间真正地同时执行。 并发：单核 CPU 上的多任务处理，多个任务在同一时间段内交替执行，通过时间片轮转实现交替执行。 同步和异步 同步：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。 异步：调用在发出之后，不用等待返回结果，该调用直接返回。 进程和线程 进程：是对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现了操作系统的并发。 线程：是进程的子任务，是 CPU 调度和分派的基本单位，实现了进程内部的并发。 进程和线程之间的关系 线程在进程下进行 进程之间不会相互影响，主线程结束将会导致整个进程结束 不同的进程数据很难共享 同进程下的不同线程之间数据很容易共享 进程使用内存地址可以限定使用量 Java中的线程和操作系统的线程的关系 在 JDK 1.2 及以后，Java 线程改为基于原生线程（Native Threads）实现，也就是说 JVM 直接使用操作系统原生的内核级线程（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。\n所以本质上 java 程序创建的线程，就是和操作系统线程是一样的，是 1 对 1 的线程模型。\n线程的上下文切换 并发其实是一个 CPU 来应付多个线程。CPU 资源的分配采用了时间片轮转也就是给每个线程分配一个时间片，线程在时间片内占用 CPU 执行任务。当线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占用。\n线程在执行过程中会有自己的运行条件和状态（也称上下文）。线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。\n同时线程可以被多核调度。操作系统的调度器负责将线程分配给可用的 CPU 核心，从而实现并行处理。多核处理器提供了并行执行多个线程的能力。\n线程安全 线程安全的定义 线程安全是指多个线程访问某一共享资源时，能够保证一致性和正确性，即无论线程如何交替执行，程序都能够产生预期的结果，且不会出现数据竞争或内存冲突\n原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作.一个操作或一系列操作要么全部执行成功，要么全部不执行，期间不会被其他线程干扰。在Java中使用了atomic包（这个包提供了一些支持原子操作的类，这些类可以在多线程环境下保证操作的原子性）和 synchronized 关键字来确保原子性\n原子类与锁：Java 提供了 java.util.concurrent.atomic 包中的原子类，如 AtomicInteger ， AtomicLong ，来保证基本类型的操作具有原子性。此外，synchronized 关键字和 Lock 接口也可以用来确保操作的原子性。 CAS（Compare-And-Swap）：Java 的原子类底层依赖于 CAS 操作来实现原子性。CAS 是一种硬件级的指令，它比较内存位置的当前值与给定的旧值，如果相等则将内存位置更新为新值，这一过程是原子的。CAS 可以避免传统锁机制带来的上下文切换开销。 可见性：一个线程对主内存的修改可以及时地被其他线程看到\nvolatile：volatile 关键字是 Java 中用来保证可见性的轻量级同步机制。当一个变量被声明为 volatile 时，所有对该变量的读写操作都会直接从主内存中进行，从而确保变量对所有线程的可见性。 synchronized：synchronized 关键字不仅可以保证代码块的原子性，还可以保证进入和退出 synchronized 块的线程能够看到块内变量的最新值。每次线程退出 synchronized 块时，都会将修改后的变量值刷新到主内存中，进入该块的线程则会从主内存中读取最新的值。 Java Memory Model（JMM）：JMM 规定了共享变量在不同线程间的可见性和有序性规则。它定义了内存屏障的插入规则，确保在多线程环境下的代码执行顺序和内存可见性。 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，在Java中使用了happens-before原则来确保有序性。\n指令重排序：为了提高性能，处理器和编译器可能会对指令进行重排序。尽管重排序不会影响单线程中的执行结果，但在多线程环境下可能会导致严重的问题。例如，经典的双重检查锁定（DCL）模式在没有正确同步的情况下，由于指令重排序可能导致对象尚未完全初始化就被另一个线程访问。 happens-before 原则：JMM 定义了 happens-before 规则，用于约束操作之间的有序性。如果一个操作 A happens-before 操作 B，那么 A 的结果对于 B 是可见的，且 A 的执行顺序在 B 之前。这为开发者提供了在多线程环境中控制操作顺序的手段。 内存屏障：volatile 变量的读写操作会在指令流中插入内存屏障，阻止特定的指令重排序。对于 volatile 变量的写操作，会在写操作前插入一个 StoreStore 屏障，防止写操作与之前的写操作重排序；在读操作之后插入一个 LoadLoad 屏障，防止读操作与之后的读操作重排序。 活跃性：\n死锁是指多个线程因为环形等待锁的关系而永远地阻塞下去。 活锁：线程没有阻塞。当多个线程都在运行并且都在修改各自的状态，而其他线程又依赖这个状态，就导致任何一个线程都无法继续执行，只能重复着自身的动作，于是就发生了活锁。 饥饿：如果一个线程无其他异常却迟迟不能继续运行。 高优先级的线程一直在运行消耗 CPU，所有的低优先级线程一直处于等待； 一些线程被永久堵塞在一个等待进入同步块的状态，而其他线程总是能在它之前持续地对该同步块进行访问； 常见线程安全措施 同步锁：通过 synchronized 关键字或 ReentrantLock 实现对共享资源的同步控制。 原子操作类：Java 提供的 AtomicInteger、AtomicReference 等类确保多线程环境下的原子性操作。 线程安全容器：如 ConcurrentHashMap、CopyOnWriteArrayList 等，避免手动加锁。 局部变量：线程内独立的局部变量天然是线程安全的，因为每个线程都有自己的栈空间（线程隔离）。 ThreadLocal：类似于局部变量，属于线程本地资源，通过线程隔离保证了线程安全。 线程的创建方式 继承 Thread 类 创建一个类继承 Thread 类，并重写 run() 方法\nrun() 方法中定义了线程执行的具体任务。创建该类的实例后，通过调用 start() 方法启动线程\n1 2 3 4 5 6 7 8 9 10 11 class MyThread extends Thread { @Override public void run() { // 线程执行的代码 } } public static void main(String[] args) { MyThread t = new MyThread(); t.start(); } 优缺点\n优点: 编写简单，如果需要访问当前线程，无需使用 Thread.currentThread () 方法，直接使用 this ，即可获得当前线程 缺点：因为线程类已经继承了Thread类，所以不能再继承其他的父类 实现 Runnable 接口 创建一个类实现 Runnable 接口，并重写 run() 方法,使用 Thread 类的构造函数传入 Runnable 对象，调用 start() 方法启动线程\n1 2 3 4 5 6 7 8 9 10 11 class MyRunnable implements Runnable { @Override public void run() { // 线程执行的代码 } } public static void main(String[] args) { Thread t = new Thread(new MyRunnable()); t.start(); } 优缺点\n优点：线程类只是实现了 Runnable 接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。\n缺点：编程稍微复杂，如果需要访问当前线程，必须使用 Thread.currentThread() 方法。\n实现 Callable 接口与 FutureTask 实现 Callable 接口的 call() 方法\n使用 FutureTask 包装 Callable 对象\n再通过 Thread 包裹 FutureTask 对象。\n方法的返回值通过 FutureTask 的 get() 方法获取\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class MyCallable implements Callable\u0026lt;Integer\u0026gt; { @Override public Integer call() throws Exception { // 线程执行的代码，这里返回一个整型结果 return 1; } } public static void main(String[] args) { MyCallable task = new MyCallable(); FutureTask\u0026lt;Integer\u0026gt; futureTask = new FutureTask\u0026lt;\u0026gt;(task); Thread t = new Thread(futureTask); t.start(); try { Integer result = futureTask.get(); // 获取线程执行结果 System.out.println(\u0026#34;Result: \u0026#34; + result); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } } 缺点：编程稍微复杂，如果需要访问当前线程，必须调用 Thread.currentThread() 方法。 优点：线程只是实现Runnable或实现Callable接口，还可以继承其他类。这种方式下，多个线程可以共享一个target对象，非常适合多线程处理同一份资源的情形。 使用线程池（ ExecutorService ） 通过 ExecutorService 提交 Runnable 或 Callable 任务，不直接创建和管理线程，适合管理大量并发任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // 提交Runnable任务 class Task implements Runnable { @Override public void run() { // 线程执行的代码 } } public static void main(String[] args) { ExecutorService executor = Executors.newFixedThreadPool(10); // 创建固定大小的线程池 for (int i = 0; i \u0026lt; 10; i++) { executor.submit(new Task()); // 提交任务到线程池执行 } executor.shutdown(); // 关闭线程池 } //提交Callable任务 import java.util.concurrent.*; class Task implements Callable\u0026lt;String\u0026gt; { @Override public String call() { return \u0026#34;Task executed by \u0026#34; + Thread.currentThread().getName(); } } public class CallableExample { public static void main(String[] args) { ExecutorService executor = Executors.newFixedThreadPool(10); // 创建固定大小的线程池 Future\u0026lt;String\u0026gt;[] results = new Future[10]; // 存储任务的返回结果 for (int i = 0; i \u0026lt; 10; i++) { results[i] = executor.submit(new Task()); // 提交 Callable 任务 } // 获取任务的返回结果 for (Future\u0026lt;String\u0026gt; result : results) { try { System.out.println(result.get()); // get() 方法会阻塞直到结果可用 } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } } executor.shutdown(); // 关闭线程池 } } 优缺点\n缺点：线程池增加了程序的复杂度，特别是当涉及线程池参数调整和故障排查时。错误的配置可能导致死锁、资源耗尽等问题，这些问题的诊断和修复可能较为复杂。 优点：线程池可以重用预先创建的线程，避免了线程创建和销毁的开销，显著提高了程序的性能。对于需要快速响应的并发请求，线程池可以迅速提供线程来处理任务，减少等待时间。并且，线程池能够有效控制运行的线程数量，防止因创建过多线程导致的系统资源耗尽（如内存溢出）。通过合理配置线程池大小，可以最大化CPU利用率和系统吞吐量。 提示\nRunnable 和Callable：\nRunnable 的 run() 方法不返回结果，不能抛出检查异常 Callable 的 call() 方法可以返回结果，并允许抛出检查异常。使用 Callable 更适合需要返回结果或处理异常的并发任务。 Runnable 接口 和 Callable 接口 无返回值的 Runnable 1 2 3 public interface Runnable { public abstract void run(); } 执行完任务之后无法返回任何结果\n有返回值的 Callable 1 2 3 public interface Callable\u0026lt;V\u0026gt; { V call() throws Exception; } call() 方法返回的类型是一个 V 类型的泛型\nFuture 接口和 FutureTask 实现类 1 2 3 4 5 6 7 8 public interface Future\u0026lt;V\u0026gt; { boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; } Future 位于 java.util.concurrent 包下，是一个接口\ncancel() ：取消任务，如果取消任务成功则返回 true，如果取消任务失败则返回 false。 参数 mayInterruptIfRunning 表示是否允许取消正在执行却没有执行完毕的任务，如果设置 true，则表示可以取消正在执行过程中的任务。 isCancelled() ：表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。 isDone() ：表示任务是否已经完成，若任务完成，则返回 true； get()：获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回； get(long timeout, TimeUnit unit)：获取执行结果，如果在指定时间内，还没获取到结果，就直接返回 null。 1 public class FutureTask\u0026lt;V\u0026gt; implements RunnableFuture\u0026lt;V\u0026gt; FutureTask 是唯一的实现类\n构造器\n1 2 3 4 public FutureTask(Callable\u0026lt;V\u0026gt; callable) { } public FutureTask(Runnable runnable, V result) { } 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 创建一个固定大小的线程池 ExecutorService executorService = Executors.newFixedThreadPool(3); // 创建一系列 Callable Callable\u0026lt;Integer\u0026gt;[] tasks = new Callable[5]; for (int i = 0; i \u0026lt; tasks.length; i++) { final int index = i; tasks[i] = new Callable\u0026lt;Integer\u0026gt;() { @Override public Integer call() throws Exception { TimeUnit.SECONDS.sleep(index + 1); return (index + 1) * 100; } }; } // 将 Callable 包装为 FutureTask，并提交到线程池 FutureTask\u0026lt;Integer\u0026gt;[] futureTasks = new FutureTask[tasks.length]; for (int i = 0; i \u0026lt; tasks.length; i++) { futureTasks[i] = new FutureTask\u0026lt;\u0026gt;(tasks[i]); executorService.submit(futureTasks[i]); } // 获取任务结果 for (int i = 0; i \u0026lt; futureTasks.length; i++) { System.out.println(\u0026#34;Result of task\u0026#34; + (i + 1) + \u0026#34;: \u0026#34; + futureTasks[i].get()); } // 关闭线程池 executorService.shutdown(); 控制线程的常用方法 启动线程 public void start() 在 Java 中，启动一个新的线程应该调用其 start() 方法，而不是直接调用 run() 方法。\n当调用 start() 方法时，会启动一个新的线程，并让这个新线程调用 run() 方法。这样，run() 方法就在新的线程中运行，从而实现多线程并发。\n如果直接调用 run() 方法，那么 run() 方法就在当前线程中以同步的方式运行，没有新的线程被创建，也就没有实现多线程的效果。\n线程命名 public void setName(String) ：给当前线程取名字name) public void getName()：获取当前线程的名字。线程存在默认名称 子线程是Thread-索引 主线程是main public static ThreadcurrentThread()：获取当前线程对象，代码在哪个线程中执行 线程休眠 public static void sleep(long millis) throws InterruptedException：使当前正在执行的线程暂停指定的毫秒数，也就是进入休眠的状态，休眠期间线程不会占用 CPU 时间片。休眠结束后，线程会尝试重新获取 CPU 时间片，进入可运行状态，但是不会让出锁。 线程优先执行 public void join() throws InterruptedException public synchronized void join(long millis) throws InterruptedException public synchronized void join(long millis, int nanos) throws InterruptedException 等待这个线程执行完才会轮到后续线程得到 cpu 的执行权\n线程间通信 wait() 让当前线程释放锁并进入等待状态\npublic final void wait() throws InterruptedException public final void wait(long millis) throws InterruptedException public final void wait(long millis, int nanos) throws InterruptedException notify() 唤醒一个等待的线程，具体唤醒哪个等待的线程是随机的，notifyAll() 唤醒所有等待的线程。\npublic final void notify() public final void notifyAll() 中断线程 public void interrupt()：设置线程的中断标志为 true 并立即返回。仅仅是设置标志而不会实际中断 boolean isInterrupted()：检测当前线程是否被中断 boolean interrupted() ： 检测当前线程是否被中断，与 isInterrupted() 不同的是，该方法如果发现当前线程被中断，则会清除中断标志。 public void stop() ：强制线程停止执行，目前已经处于废弃状态，因为 stop 方法会导致线程立即停止，可能会在不一致的状态下释放锁，破坏对象的一致性，导致难以发现的错误和资源泄漏。 响应中断示例\n1 2 3 4 5 6 7 8 9 10 11 public void run() { try { while (!Thread.currentThread().isInterrupted()) { // 执行任务 } } catch (InterruptedException e) { // 线程被中断时的清理代码 } finally { // 线程结束前的清理代码 } } 让出时间片 yield() 方法用于暗示当前线程愿意放弃其当前的时间片，允许其他线程执行。它并不会使线程进入阻塞状态，线程依然处于 RUNNABLE 状态。但是它只是向线程调度器提出建议，调度器可能会忽略这个建议。具体行为取决于操作系统和JVM)的线程调度策略。（和 Thread.sleep(0) 功能相同）\npublic static void yield() 设置线程优先级 public final int getPriority() ：返回此线程的优先级 public final void setPriority(int priority)：更改此线程的优先级，规定线程优先级是1~1010的整数，较大的优先级能提高该线程被 CPU 调度的机率 守护线程 public void setDaemon() 将此线程标记为守护线程。\n守护线程：是服务其他的线程，像 Java 中的垃圾回收线程，就是典型的守护线程。\n当最后一个非守护线程束时， JVM 会正常退出，而不管当前是否存在守护线程（守护线程是否结束并不影响 JVM 退出）\n如果某线程是守护线程，那如果所有的非守护线程都结束了，这个守护线程也会自动结束。\n当所有的非守护线程结束时，守护线程会自动关闭，这就免去了还要继续关闭子线程的麻烦。\n线程默认是非守护线程\n提示\nsleep() 和 wait() 的区别（面试题）\n锁行为不同 当线程执行 sleep() 方法时，它不会释放任何锁。也就是说，如果一个线程在持有某个对象的锁时调用了 sleep，它在睡眠期间仍然会持有这个锁。 而当线程执行 wait() 方法时，它会释放它持有的那个对象的锁，这使得其他线程可以有机会获取该对象的锁。 使用条件不同 sleep() 方法可以在任何地方被调用。 wait() 方法必须在同步代码块或同步方法中被调用，这是因为调用 wait() 方法的前提是当前线程必须持有对象的锁。否则会抛出 IllegalMonitorStateException 异常。 唤醒方式不同 调用 sleep() 方法后，线程会进入 TIMED_WAITING 状态（定时等待状态），即在指定的时间内暂停执行。当指定的时间结束后，线程会自动恢复到 RUNNABLE 状态（就绪状态），等待 CPU 调度再次执行。 调用 wait() 方法后，线程会进入 WAITING 状态（无限期等待状态），直到有其他线程在同一对象上调用 notify() 或 notifyAll()，线程才会从 WAITING 状态转变为 RUNNABLE 状态，准备再次获得 CPU 的执行权。 线程的状态 可以使用Thread中的 getState() 方法获取状态\nJava中的线程状态\nNew（初始状态） ：线程对象创建后，但未调用 start() 方法。 Runnable（可运行状态） ：调用 start() 方法后，线程进入就绪状态，等待 CPU 调度。 Blocked（阻塞状态） ：线程试图获取一个对象锁而被阻塞。 Waiting（等待状态）：线程进入等待状态，需要被显式唤醒才能继续执行。 Timed Waiting（含等待时间的等待状态） ：线程进入等待状态，但指定了等待时间，超时后会被唤醒。 Terminated（终止状态） ：线程执行完成或因异常退出。 NEW（初始状态） 处于 NEW 状态的线程此时尚未启动。这里的尚未启动指的是还没调用 Thread 实例的 start() 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 使用synchronized关键字保证这个方法是线程安全的 public synchronized void start() { // threadStatus != 0 表示这个线程已经被启动过或已经结束了 // 如果试图再次启动这个线程，就会抛出IllegalThreadStateException异常 if (threadStatus != 0) throw new IllegalThreadStateException(); // 将这个线程添加到当前线程的线程组中 group.add(this); // 声明一个变量，用于记录线程是否启动成功 boolean started = false; try { // 使用native方法启动这个线程 start0(); // 如果没有抛出异常，那么started被设为true，表示线程启动成功 started = true; } finally { // 在finally语句块中，无论try语句块中的代码是否抛出异常，都会执行 try { // 如果线程没有启动成功，就从线程组中移除这个线程 if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { // 如果在移除线程的过程中发生了异常，我们选择忽略这个异常 } } } 因此\n反复调用同一个线程的 start() 方法不可行 假如一个线程执行完毕（此时处于 TERMINATED 状态），再次调用这个线程的 start() 方法不可行 在调用 start() 之后，threadStatus 的值会改变（ threadStatus !=0 ），再次调用 start() 方法会抛出 IllegalThreadStateException 异常。\nRUNNABLE（正在运行） 表示当前线程正在运行中。当调用线程的 start() 方法后，线程进入可运行状态。处于 RUNNABLE 状态的线程在 Java 虚拟机中运行，也有可能在等待 CPU 分配资源。\n1 2 3 4 5 6 /** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */ Java 线程的RUNNABLE状态其实包括了操作系统线程的ready和running两个状态\n现代操作系统架构通常都是用所谓的时间分片方式进行抢占式轮转调度。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。\nBLOCKED（阻塞状态） 线程在试图获取一个锁以进入同步块/方法时，如果锁被其他线程持有，线程将进入阻塞状态，直到它获取到锁。处于 BLOCKED 状态的线程正等待锁的释放以进入同步区\nWAITING（等待状态） 等待状态。处于等待状态的线程变成 RUNNABLE 状态需要其他线程唤醒\n调用下面这 3 个方法会使线程进入等待状态：\nObject.wait()：使当前线程处于等待状态直到另一个线程唤醒它； Thread.join()：等待线程执行完毕，底层调用的是 Object 的 wait 方法； LockSupport.park()：除非获得调用许可，否则禁用当前线程进行线程调度 TIMED_WAITING（超时等待） 超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。\nThread.sleep(long millis)：使当前线程睡眠指定时间； Object.wait(long timeout)：线程休眠指定时间，等待期间可以通过notify()/notifyAll()唤醒； Thread.join(long millis)：等待当前线程最多执行 millis 毫秒，如果 millis 为 0，则会一直执行； LockSupport.parkNanos(long nanos)： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间 TERMINATE（终止状态） 当线程的 run() 方法执行完毕后，或者因为一个未捕获的异常终止了执行，线程进入终止状态。一旦线程终止，它的生命周期结束，不能再被重新启动，此时线程已执行完毕\n","date":"2024-12-01T10:47:55+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/","title":"Java中的多线程"},{"content":"HashMap的特点 HashMap 是 Java 中的一个基于 哈希表 的集合类，用于存储键值对（key-value）映射。\n基于哈希表实现：\n数据存储在数组中，每个数组位置对应一个链表或红黑树（JDK 1.8 及以上版本）。\n通过哈希值定位键值对的存储位置。（同时重写 equals() 方法和 hashcode() 方法\n非线程安全：\n多线程操作可能导致数据不一致问题。 允许 null：\n键和值均可以为 null，但键只能有一个 null。 动态扩容：\n默认初始容量为 16。\n加载因子为 0.75。\n当使用的存储空间超过阈值（容量 × 加载因子）时，HashMap 会动态扩容。\nHashMap提升性能的建议 合理设置初始容量：如果在使用时可以预估 HashMap 存储的数据量大小，那么需要在创建时设置一个合适的初始容量，以避免频繁的扩容操作。Java 中 HashMap 默认初始容量是 16。 调整负载因子：官方提供的默认负载因子是 0.75。可以根据具体应用场景调整这个值。较低的负载因子会减少冲突，提高查找效率，但会占用更多内存（更加容易触发扩容）。较高的负载因子则会减少内存消耗，但可能增加冲突的概率，降低查找效率。 高并发读取场景：可以降低负载因子，以减少哈希冲突，提高读取性能。 内存受限场景：可以提高负载因子，以减少扩容次数和内存消耗，但可能会降低写入和查询的性能。 确保 hashCode 均匀分布：对应 key 的 hashCode() 方法生成的哈希值需均匀分布，减少哈希冲突。避免使用质量不高的哈希函数，防止大量键映射到相同的槽位上，造成性能瓶颈。 HashMap的常用方法 构造方法 public HashMap()：默认构造方法 public HashMap(int initialCapacity)：指定初始容量的构造方法 public HashMap(int initialCapacity, float loadFactor)：指定初始容量和加载因子的构造方法 public HashMap(Map\u0026lt;? extends K, ? extends V\u0026gt; m)：从其他 Map 初始化的构造方法 添加键值对 public V put(K key, V value)：添加或更新键值对 public void putAll(Map\u0026lt;? extends K, ? extends V\u0026gt; m)：批量添加键值对 删除键值对 public V remove(Object key)：移除键值对 public boolean remove(Object key, Object value)：按键值同时匹配移除 查询键值对 public V get(Object key)：获取值 public boolean containsKey(Object key)：检查是否包含键 public boolean containsValue(Object value)：检查是否包含值 public V getOrDefault(Object key, V defaultValue)：获取默认值 视图操作 public Set\u0026lt;K\u0026gt; keySet()：获取所有键的集合 public Collection\u0026lt;V\u0026gt; values()：获取所有值的集合 public Set\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; entrySet()：获取所有键值对的集合 替换操作 public V replace(K key, V value)：替换值 public boolean replace(K key, V oldValue, V newValue)：条件替换值 遍历操作 使用for-each循环和entrySet()方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import java.util.HashMap; import java.util.Map; public class MapTraversalExample { public static void main(String[] args) { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;key1\u0026#34;, 1); map.put(\u0026#34;key2\u0026#34;, 2); map.put(\u0026#34;key3\u0026#34;, 3); // 使用for-each循环和entrySet()遍历Map for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { System.out.println(\u0026#34;Key: \u0026#34; + entry.getKey() + \u0026#34;, Value: \u0026#34; + entry.getValue()); } } } 使用for-each循环和keySet()方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import java.util.HashMap; import java.util.Map; public class MapTraversalExample { public static void main(String[] args) { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;key1\u0026#34;, 1); map.put(\u0026#34;key2\u0026#34;, 2); map.put(\u0026#34;key3\u0026#34;, 3); // 使用for-each循环和keySet()遍历Map的键 for (String key : map.keySet()) { System.out.println(\u0026#34;Key: \u0026#34; + key + \u0026#34;, Value: \u0026#34; + map.get(key)); } } } 使用 Lambda 表达式和forEach()方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.util.HashMap; import java.util.Map; public class MapTraversalExample { public static void main(String[] args) { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;key1\u0026#34;, 1); map.put(\u0026#34;key2\u0026#34;, 2); map.put(\u0026#34;key3\u0026#34;, 3); // 使用Lambda表达式和forEach()方法遍历Map map.forEach((key, value) -\u0026gt; System.out.println(\u0026#34;Key: \u0026#34; + key + \u0026#34;, Value: \u0026#34; + value)); } } HashMap的底层原理 存储原理 JDK 1.7 以前 在 JDK 1.7 版本之前， HashMap 数据结构是数组和链表，HashMap 通过哈希算法将元素的键映射到数组中的槽位。如果多个键映射到同一个槽位，它们会以链表的形式存储在同一个槽位上，因为链表的查询时间是$O(n)$，所以冲突很严重，一个索引上的链表非常长，效率就很低了。\nHashMap 的默认初始容量为 16，负载因子为 0.75。也就是说，当存储的元素数量超过 16 × 0.75 = 12 个时，HashMap 会触发扩容操作，\n当要塞入一个键值对的时候，会根据一个 hash 算法计算 key 的 hash 值，然后通过数组大小 n-1 \u0026amp; hash 值之后，得到一个数组的下标，然后往那个位置塞入这键值对。当发生哈希冲突时会使用闭散列法\n链表的插入采用的是头插法，即每当发生哈希冲突时，新的节点总是插入到链表的头部，老节点依次向后移动，形成新的链表结构。\n在多线程环境下，头插法可能导致链表形成环，特别是在并发扩容时。当多个线程同时执行 put() 操作时，如果线程 A 正在进行头插，线程 B 也在同一时刻操作链表，可能导致链表结构出现环路，从而引发死循环，最终导致程序卡死或无限循环。\nJDK 1.8以后 在 JDK 1.8 版本的时候做了优化，当一个链表的长度超过 8 且数组大小大于等于 64 的时候就转换数据结构，不再使用链表存储，而是使用红黑树，查找时使用红黑树，时间复杂度为$O(log n)$，可以提高查询性能，但是在红黑树节点数量较少时，即数量小于6 时，会将红黑树转换回链表。\n在 JDK1.8 的时候，改成了尾插法，即新的节点插入到链表的尾部，保持插入的顺序。并且引入了红黑树。\nhash方法的底层实现 1 2 3 4 5 6 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); // 如果键值为 null，则哈希码为 0（依旧是说如果键为 null，则存放在第一个位置）； // 否则，通过调用hashCode()方法获取键的哈希码，并将其与右移 16 位的哈希码进行异或运算。 } 目的：将 key 的 hashCode 值进行处理，得到最终的哈希值。hash 方法就是为了增加随机性，让数据元素更加均衡的分布，减少碰撞\n将哈希值无符号右移 16 位，高位补0，意味着原哈希值的高 16 位被移到了低 16 位的位置。再与自身进行异或操作，从而使得原始哈希值的高 16 位和低 16 位就可以参与到最终用于索引计算的低位中。\n示例\n1 2 3 4 原始: 0001 0010 0011 0100 0101 0110 0111 1000 右移: 0000 0000 0000 0000 0001 0010 0011 0100 异或: --------------------------------------- 结果: 0001 0010 0011 0100 0100 0100 0100 1100 数组索引计算原理 通常基于哈希值计算数组下标使用该公式：hash % length，其中 hash 为以经过 hash() 方法优化后的哈希值， length 为数组容量\n从二进制的角度上是获取 hash 的二进制表示中最低 $log(length)$ 位的值。\n因此取余运算可以使用位运算代替，当 length 是 2 的幂时，n - 1 的二进制表示是全 1（如 length=16，length-1=15，即 1111），这样按位与操作实际上会相当于对 hash 的低 $log(length)$ 位进行保留。\n故可得公式：hash \u0026amp; (length - 1) = hash % length = (length - 1) \u0026amp; hash\n示例：hash 为 14，length 为 8，也就是 n 为3\n1 2 3 4 1110 (hash = 14) \u0026amp; 0111 (length - 1 = 7) ---- 0110 (结果 = 6) 提示\n为什么数组长度（容量）设计为2的n次方\nHashMap 采用 2 的 n 次方倍作为容量，主要是为了提高哈希值的分布均匀性和哈希计算的效率。\nHashMap 通过 (length - 1) \u0026amp; hash 来计算元素存储的索引位置，这种位运算只有在数组容量是 2 的 n 次方时才能确保索引均匀分布。位与运算的效率高于取模运算（hash % length），提高了哈希计算的速度。\n且当 HashMap 扩容时，通过容量为 2 的 n 次方，扩容时只需通过简单的位运算判断是否需要迁移，这减少了重新计算哈希值的开销，提升了重新哈希的效率。\n哈希碰撞的解决方法 Hash 碰撞是指在使用哈希算法时，不同的输入数据通过哈希函数计算后，得到了相同的哈希值（即散列值）。因为哈希值相同，所以这些键会被映射到哈希表的同一个位置，从而引发“碰撞”。\n解决方法\n拉链法（闭散列法）：将哈希表中每个槽的位置变成一个链表，当多个键的哈希值相同时，将它们存储在同一个链表中。 开放寻址法（开散列法）：如果出现碰撞，寻找哈希表中的下一个可用位置。 再哈希法（双重哈希）：在出现碰撞时，使用第二个哈希函数计算新的索引位置，减少碰撞的概率。 拉链法（开散列法） 使用链表来处理冲突，每个哈希表的槽不仅存储单个元素，而是存储指向链表头部的指针。所有具有相同哈希值的元素都会被放入到同一个链表中。!\n优点：\n简单易实现，扩展性好。 在处理大量数据时，性能更为稳定。 缺点：\n如果碰撞频繁，链表会变长，导致查询性能下降。 需要额外的内存来存储链表的指针。 开放寻址法（闭散列法） 在哈希表中寻找下一个空闲的槽位以存储发生碰撞的元素。\n线性探查法：在哈希表中查找下一个连续的空槽，将碰撞的键存入该槽中。 平方探查法：类似于线性探查，但探查的步长是二次方，减少了聚集问题。 双散列法：使用两个不同的哈希函数，第一次哈希决定初始位置，第二次哈希决定探查步长。 优点：\n不需要额外的内存来存储指针或链表结构。 如果负载因子低，查找和插入的效率较高。 缺点：\n随着哈希表的填充度增加，探查的次数会增加，导致性能下降。 删除元素时候，不能真的删除，只能打标，否则会导致查找错误。只能在下一个元素插入时，发现标记后才能替换原来的元素。 再哈希法（双重哈希） 在出现碰撞时，使用第二个哈希函数计算新的索引位置，减少碰撞的概率\n扩容机制 HashMap的默认负载因子为0.75，初始长度为16（初始化时可以指定容量，HashMap 会将这个值转换为大于或等于 17 的最小的 2 的幂。）\n当 HashMap 中的键值对中的数量大于容量*负载因子时发生扩容，容量扩大为当前容量的两倍\n扩容时，HashMap 需要重新计算所有元素的哈希值，并将它们重新分配到新的哈希桶中，这个过程称为 rehashing 。每个元素的存储位置会根据新容量的大小重新计算哈希值，并移动到新的数组中。\nJDK 1.7以前，所有元素的哈希值，并将它们重新分配到新的哈希桶中\nJDK 1.7以后，进行了优化。不需要每个节点重新 hash 算下标。因为元素的新位置只与高位有关\n此时重新哈希只要判断原来的hash拓展后新增的位是0还是1\n若为0则保持在原来的位置（hash 1 保持为 5）\n若为1则被移动到原来的位置加上旧数组长度的地方（hash 2 被移动到 5+16=21 处）\n插入原理（put方法） 根据要添加的键的哈希码（ hashcode() 方法+ hash 方法）计算在数组中的位置（索引） 检查该位置是否为空（即没有键值对存在） 如果为空，则直接在该位置创建一个新的Entry对象来存储键值对。将要添加的键值对作为该Entry的键和值，并保存在数组的对应位置。 如果不为空则遍历链表或者红黑树检查键值对的键是否与要添加的键值对的键相同（ equals() 方法） 如果相同，则表示找到了相同的键，直接将新的值替换旧的值，完成更新操作。 若不相同，根据对应的数据结构进行插入工作 检查链表长度是否达到阈值（默认为 8）：如果链表长度超过阈值，且 HashMap 的数组长度大于等于 64，则会将链表转换为红黑树，以提高查询效率 检查负载因子是否超过阈值（默认为 0.75）：如果键值对的数量（size）与数组的长度的比值大于阈值，则需要进行扩容操作 扩容操作： 创建一个新的两倍大小的数组。 将旧数组中的键值对重新计算哈希码并分配到新数组中的位置。 更新 HashMap 的数组引用和阈值参数。 完成添加操作。 equals方法和hashcode方法 HashMap 在比较元素时\n使用对象的 hashCode() 计算出桶的位置。\n在该位置，通过 equals() 方法检查键是否相等。\n所以 equals 相等的两个对象，hashCode一定相等。hashCode相等的两个对象，equals 不一定相等（比如散列冲突的情况）\n重写了 equals() 方法，不重写 hashCode() 方法时，可能会出现 equals() 方法返回为true，而 hashCode() 方法却返回false，这样的话，这两个逻辑上相同的对象会被放到不同的桶中，这样就会导致 get() 的时候，找不到对应的值。\nJDK 1.8 的改动 改进了哈希函数的计算：JDK 1.8 中优化了哈希函数，使得哈希值的分布更加均匀，减少了哈希冲突的发生。通过在生成哈希值时使用“扰动函数”，确保哈希值的高低位都能参与到桶的选择中。 扩容机制优化：JDK 1.8 改进了扩容时的元素迁移机制。在扩容过程中不再对每个元素重新计算哈希值，而是根据原数组长度的高位来判断元素是留在原位置，还是迁移到新数组中的新位置。这一改动减少了不必要的计算，提升了扩容效率。 头插法变为尾插法：头插法的好处就是插入的时候不需要遍历链表，直接替换成头结点，但是缺点是扩容的时候会逆序，而逆序在多线程操作下可能会出现环，产生死循环，于是改为尾插法。 HashMap的线程安全问题 JDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。 多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。 在一个线程中调用 get() 方法读取数据，而另一个线程同时修改了结构（如增加或删除元素），可能会导致读取操作得到错误的结果或抛出 ConcurrentModificationException 。 自定义HashMap 内部节点类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * 节点类 * * @param \u0026lt;K\u0026gt; * @param \u0026lt;V\u0026gt; */ class Node\u0026lt;K, V\u0026gt; { //键值对 private K key; private V value; //链表，后继 private Node\u0026lt;K, V\u0026gt; next; public Node(K key, V value) { this.key = key; this.value = value; } public Node(K key, V value, Node\u0026lt;K, V\u0026gt; next) { this.key = key; this.value = value; this.next = next; } } 成员变量 1 2 3 4 5 6 7 8 //默认容量 final int DEFAULT_CAPACITY = 16; //负载因子 final float LOAD_FACTOR = 0.75f; //HashMap的大小 private int size; //桶数组 Node\u0026lt;K, V\u0026gt;[] buckets; 构造方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * 无参构造器，设置桶数组默认容量 */ public OwnHashMap() { buckets = new Node[DEFAULT_CAPACITY]; size = 0; } /** * 有参构造器，指定桶数组容量 * * @param capacity */ public OwnHashMap(int capacity) { buckets = new Node[capacity]; size = 0; } 哈希函数 1 2 3 4 5 6 7 8 9 10 11 12 13 /** * 哈希函数，获取地址 * * @param key * @return */ private int getIndex(K key, int length) { //获取hash code int hashCode = key.hashCode(); //和桶数组长度取余 int index = hashCode % length; return Math.abs(index); } 添加键值对 获取元素插入位置 当前位置为空，直接插入 位置不为空，发生冲突，遍历链表 如果元素key和节点相同，覆盖 否则新建节点插入链表头部 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /** * 将元素存入指定的node数组 * * @param key * @param value * @param table */ private void putVal(K key, V value, Node\u0026lt;K, V\u0026gt;[] table) { //获取位置 int index = getIndex(key, table.length); Node node = table[index]; //插入的位置为空 if (node == null) { table[index] = new Node\u0026lt;\u0026gt;(key, value); size++; return; } //插入位置不为空，说明发生哈希冲突，使用闭散列法,遍历链表 while (node != null) { //如果key相同，就覆盖掉 if ((node.key.hashCode() == key.hashCode()) \u0026amp;\u0026amp; (node.key == key || node.key.equals(key))) { node.value = value; return; } node = node.next; } //当前key不在链表中，插入链表头部 Node newNode = new Node(key, value, table[index]); table[index] = newNode; size++; } /** * put方法 * * @param key * @param value * @return */ public void put(K key, V value) { //判断是否需要进行扩容 if (size \u0026gt;= buckets.length * LOAD_FACTOR) resize(); putVal(key, value, buckets); } 扩容机制 创建两倍容量的新数组 将当前桶数组的元素重新散列到新的数组 新数组置为map的桶数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * 扩容 */ private void resize() { //创建一个两倍容量的桶数组 Node\u0026lt;K, V\u0026gt;[] newBuckets = new Node[buckets.length * 2]; //将当前元素重新散列到新的桶数组 rehash(newBuckets); buckets = newBuckets; } /** * 重新散列当前元素 * * @param newBuckets */ private void rehash(Node\u0026lt;K, V\u0026gt;[] newBuckets) { //map大小重新计算 size = 0; //将旧的桶数组的元素全部刷到新的桶数组里 for (int i = 0; i \u0026lt; buckets.length; i++) { //为空，跳过 if (buckets[i] == null) { continue; } Node\u0026lt;K, V\u0026gt; node = buckets[i]; while (node != null) { //将元素放入新数组 putVal(node.key, node.value, newBuckets); node = node.next; } } } 获取键值对的值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * 获取元素 * * @param key * @return */ public V get(K key) { //获取key对应的地址 int index = getIndex(key, buckets.length); if (buckets[index] == null) return null; Node\u0026lt;K, V\u0026gt; node = buckets[index]; //查找链表 while (node != null) { if ((node.key.hashCode() == key.hashCode()) \u0026amp;\u0026amp; (node.key == key || node.key.equals(key))) { return node.value; } node = node.next; } return null; } HashMap的衍生类——LinkedHashMap类 LinkedHashMap 是 Java 集合框架中的一个实现类，它继承自 HashMap，并且保留了键值对的插入顺序或访问顺序。\n它内部是通过维护了一个双向链表来记录元素的插入顺序或访问顺序。\n底层实现 LinkedHashMap 内部追加了双向链表，来维护元素的插入顺序\n1 2 3 4 5 6 static class Entry\u0026lt;K,V\u0026gt; extends HashMap.Node\u0026lt;K,V\u0026gt; { Entry\u0026lt;K,V\u0026gt; before, after; Entry(int hash, K key, V value, Node\u0026lt;K,V\u0026gt; next) { super(hash, key, value, next); } } 在 LinkedHashMap 中，链表中的节点顺序是按照插入顺序维护的。当使用 put() 方法向 LinkedHashMap 中添加键值对时，会将新节点插入到链表的尾部，并更新 before 和 after 属性，以保证链表的顺序关系\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 将指定节点插入到链表的尾部 * * @param p 要插入的节点 */ private void linkNodeLast(LinkedHashMap.Entry\u0026lt;K,V\u0026gt; p) { LinkedHashMap.Entry\u0026lt;K,V\u0026gt; last = tail; // 获取链表的尾节点 tail = p; // 将 p 设为尾节点 if (last == null) head = p; // 如果链表为空，则将 p 设为头节点 else { p.before = last; // 将 p 的前驱节点设为链表的尾节点 last.after = p; // 将链表的尾节点的后继节点设为 p } } 访问顺序 LinkedHashMap 不仅能够维持插入顺序，还能够维持访问顺序。访问包括调用 get() 方法、remove() 方法和 put() 方法。\n只需要在**LinkedHashMap**的构造方法中加入一个 Boolean 参数\n如果为 true 的话，就表示 LinkedHashMap 要维护访问顺序\n如果为 false 的话，就表示 LinkedHashMap 要维护插入顺序。\n默认是 false。\n这样便于使用LRU算法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 public class LRUCache\u0026lt;K,V\u0026gt; { class Node\u0026lt;K,V\u0026gt; { K key; V value; Node\u0026lt;K,V\u0026gt; prev, next; public Node(){} public Node(K key, V value) { this.key = key; this.value = value; } } private int capacity; private HashMap\u0026lt;K,Node\u0026gt; map; // 虚拟头尾节点 private Node\u0026lt;K,V\u0026gt; head; private Node\u0026lt;K,V\u0026gt; tail; public LRUCache(int capacity) { this.capacity = capacity; map = new HashMap\u0026lt;\u0026gt;(capacity); head = new Node\u0026lt;\u0026gt;(); tail = new Node\u0026lt;\u0026gt;(); head.next = tail; tail.prev = head; } public V get(K key) { Node\u0026lt;K,V\u0026gt; node = map.get(key); if (node == null) { return null; } moveNodeToHead(node); return node.value; } public void put(K key, V value) { Node\u0026lt;K,V\u0026gt; node = map.get(key); if (node == null) { if (map.size() \u0026gt;= capacity) { map.remove(tail.prev.key); removeTailNode(); } Node\u0026lt;K,V\u0026gt; newNode = new Node\u0026lt;\u0026gt;(key, value); map.put(key, newNode); addToHead(newNode); //置于表头 } else { node.value = value; moveNodeToHead(node); } } // 将节点添加到表头 private void addToHead(Node\u0026lt;K,V\u0026gt; newNode) { // 新节点和head节点以及head节点的后驱节点双向链接 newNode.prev = head; newNode.next = head.next; // head节点的后驱节点和新节点单向链接 head.next.prev = newNode; // head节点和新节点单向链接 head.next = newNode; } // 将当前节点移动到表头 private void moveNodeToHead(Node\u0026lt;K,V\u0026gt; node) { removeNode(node); addToHead(node); } // 删除当前节点 private void removeNode(Node\u0026lt;K,V\u0026gt; node) { // 当前节点的前驱节点和当前节点的后驱节点双向链接 node.prev.next = node.next; node.next.prev = node.prev; } // 删除尾节点 private void removeTailNode() { removeNode(tail.prev); } public static void main(String[] args) { LRUCache\u0026lt;Integer,Integer\u0026gt; lruCache = new LRUCache\u0026lt;\u0026gt;(3); lruCache.put(1,1); lruCache.put(2,2); lruCache.put(3,3); lruCache.get(1); lruCache.put(4,4); System.out.println(lruCache); } } HashMap的衍生类——TreeMap类 TreeMap 内部是通过红黑树实现的，可以让 key 的实现 Comparable 接口或者自定义实现一个 comparator 传入构造函数，这样塞入的节点就会根据你定义的规则进行排序。\n基本特性： 数据结构：TreeMap 基于红黑树实现，红黑树是一种自平衡的二叉查找树，能够保证基本操作（插入、删除、查找）的时间复杂度为 $O(log n)$。 键的有序性：TreeMap 中的键是有序的，默认按自然顺序（键的 Comparable 实现）排序，也可以通过构造时提供的 Comparator 进行自定义排序。 不允许 null 键：TreeMap 不允许键为 null，但允许值为 null。 与HashMap的区别 HashMap 是基于数组+链表+红黑树实现的，加入元素的时候会先计算 key 的哈希值，然后通过哈希值计算出元素在数组中的存放下标，然后将元素插入到指定的位置，如果发生哈希冲突，会使用链表来解决，如果链表长度大于 8，会转换为红黑树。\nTreeMap 是基于红黑树实现的，加入元素的时候会先判断根节点是否为空，如果为空，直接插入到根节点，如果不为空，会通过 key 的比较器来判断元素应该插入到左子树还是右子树。\n在没有发生哈希冲突的情况下，HashMap 的查找效率是 $O(1)$。适用于查找操作比较频繁的场景。\nTreeMap 的查找效率是 $O(logn)$。并且保证了元素的顺序，因此适用于需要大量范围查找或者有序遍历的场景。\n示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import java.util.Comparator; import java.util.TreeSet; class Person { String name; int age; Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, age=\u0026#34; + age + \u0026#34;}\u0026#34;; } } public class TreeSetExample2 { public static void main(String[] args) { // 自定义排序规则：按名字字典序排列 Comparator\u0026lt;Person\u0026gt; nameComparator = (p1, p2) -\u0026gt; p1.name.compareTo(p2.name); TreeSet\u0026lt;Person\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(nameComparator); treeSet.add(new Person(\u0026#34;Alice\u0026#34;, 30)); treeSet.add(new Person(\u0026#34;Charlie\u0026#34;, 35)); treeSet.add(new Person(\u0026#34;Bob\u0026#34;, 25)); for (Person person : treeSet) { System.out.println(person); } } } HashMap的衍生类——ConcurrentHashMap类 ConcurrentHashMap 是 Java 提供的一种线程安全的哈希表实现，位于 java.util.concurrent 包中，广泛用于高并发环境下。它与传统的 HashMap 不同，能够在多个线程并发操作时保持高效性和一致性。\n特点 线程安全： 多线程可以同时操作不同的桶，提高并发性能。 高效性： 通过细粒度锁或无锁机制（CAS），在高并发场景下效率比 Hashtable 更高。 不允许 null 键和值： 如果尝试插入 null 键或 null 值，会抛出 NullPointerException。 支持部分并发操作： 可以在迭代期间执行插入或删除操作，不会抛出 ConcurrentModificationException。 不支持键或值为null： 构造方法 public ConcurrentHashMap()：创建一个默认的 ConcurrentHashMap 实例\npublic ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)\ninitialCapacity：初始容量。 loadFactor：负载因子。 concurrencyLevel：并发级别（用于估计并发线程数，JDK 1.8 后不再显式使用）。 底层实现 JDK 1.7之前 在 JDK 1.7 中它使用的是数组加链表的形式实现的\n实现思想\n基于 分段锁机制（Segmented Locking），其核心思想是将整个哈希表分成多个段（ Segment ），每个段独立加锁，从而实现线程安全的高效访问。默认是 16 个 Segment ，所以最多有 16 个线程可以并发执行。\n核心数据结构\n一个 ConcurrentHashMap 里包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素。\nSegment：一种可重入锁，继承了 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色用来保护段内的数据安全。 HashEntry：表示一个键值对节点，类似于 HashMap 的链表节点 分段锁技术将数据分成一段一段的存储，然后给每一段数据配一把锁，不同 Segment 之间的操作互不影响，从而提高并发性能。。当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。\n先通过 key 的 hash 函数判断得到 Segment 数组的下标，将这个 Segment 上锁 再次通过 key 的 hash 函数得到 Segment 里 HashEntry 数组的下标 可以简化理解：每个 Segment 数组存放的就是一个单独的 HashMap\n缺陷\nSegment 数组一旦初始化了之后不会扩容，只有 HashEntry 数组会扩容，这就导致并发度过于死板，不能随着数据的增加而提高并发度\nJDK 1.7以后 ConcurrentHashMap 做了更细粒度的锁控制，可以理解为 HashMap 的节点数组的每个位置都是一把锁，这样扩容了锁也会变多，并发度也会增加。\n加锁机制 分段锁加锁机制（JDK 1.7以前） 在 ConcurrentHashMap 中，将整个数据结构分为多个 Segment，每个 Segment 都类似于一个小的 HashMap，每个 Segment 都有自己的锁，不同 Segment 之间的操作互不影响，从而提高并发性能。\n不同 Segment 的并发写入（可以并发执行） 同一 Segment 的一写一读（可以并发执行） 同一 Segment 的并发写入（同一 Segment 的并发写入会被阻塞） 在 ConcurrentHashMap 中，对于插入、更新、删除等操作，需要先定位到具体的 Segment，然后再在该 Segment 上加锁，而不是像传统的 HashMap 一样对整个数据结构加锁。这样可以使得不同 Segment 之间的操作并行进行，提高了并发性能。\nget操作（读操作）\n​\tget操作是无锁的。读操作不会阻塞写操作，从而提高了并发性能\n通过 volatile 保证 HashEntry 的可见性，允许多个线程同时读取。 遍历链表或红黑树时无需加锁。 put/remove操作（写操作）\n写操作如 put() 和 remove() 需要加锁，以确保写入时的线程安全性和一致性\n根据哈希值找到目标 Segment。 使用 lock() 方法（可重入锁）锁定该 Segment。 在加锁状态下，检查是否存在相同键： 存在：更新值。 不存在：插入新节点。 扩容机制\n基于 Segment：ConcurrentHashMap是由多个 Segment 组成的，每个 Segment 中包含一个 HashMap。当某个Segment 内的 HashMap 达到扩容阈值时，单独为该 Segment 进行扩容，而不会影响其他 Segment。 扩容过程：每个 Segment 维护自己的负载因子，当 Segment 中的元素数量超过阈值时，该 Segment 的 HashMap 会扩容，整体的 ConcurrentHashMap 并不是一次性全部扩容。 悲观锁和乐观锁（JDK 1.7以后） JDK 1.8 移除了 Segment，锁的粒度变得更加细化，锁只在链表或红黑树的节点级别上进行。通过 CAS 进行插入操作，只有在更新链表或红黑树时才使用 synchronized ，并且只锁住链表或树的头节点，进一步减少了锁的竞争，并发度大大增加。只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。\nget操作（读操作）\n​\tget操作是无锁的。\n直接定位到目标桶，读取链表或红黑树中的数据。 由于数据节点的 value 是 volatile 修饰的，确保多线程下读取的数据一致性。 put操作（写操作）\n计算键的哈希值，定位目标桶。 如果桶为空，尝试使用 volatile 和 CAS（乐观锁） 创建新节点。 如果 CAS 失败或桶非空，使用 synchronized（悲观锁）锁定该桶： 遍历链表或者红黑树检查键值对的键是否与要添加的键值对的键相同（ equals() 方法） 如果相同，则表示找到了相同的键，直接将新的值替换旧的值，完成更新操作。 若不相同，根据对应的数据结构进行插入工作 如果链表长度超过阈值（8），将链表转换为红黑树。 扩容机制\n全局扩容：ConcurrentHashMap取消了Segment，变成了一个全局的数组（类似于 HashMap）。因此，当 ConcurrentHashMap 中任意位置的元素超过阈值时，整个 ConcurrentHashMap 的数组都会被扩容。 基于 CAS 的扩容：在扩容时，ConcurrentHashMap 采用了类似 HashMap 的方式，但通过CAS 操作确保线程安全，避免了锁住整个数组。在扩容时，多个线程可以同时帮助完成扩容操作。 渐进式扩容：JDK 1.8 的 ConcurrentHashMap 引入了渐进式扩容机制，扩容时并不是一次性将所有数据重新分配，而是多个线程共同参与，逐步迁移旧数据到新数组中，降低了扩容时的性能开销。 为什么不允许键和值为 null ConcurrentHashMap 的 key 和 value 不能为 null 主要是为了避免二义性。null 是一个特殊的值，表示没有对象或没有引用。如果你用 null 作为键，那么你就无法区分这个键是否存在于 ConcurrentHashMap 中，还是根本没有这个键。\n如果你用 null 作为值，那么你就无法区分这个值是否是真正存储在 ConcurrentHashMap 中的，还是因为找不到对应的键而返回的。\nsynchronizedMap方法 Collections.synchronizedMap() 是 Java 提供的线程安全 Map，它包装一个普通 Map（如 HashMap），并在 所有操作上加锁，确保线程安全。\nsynchronizedMap 是通过对所有操作加锁实现的，它的所有方法都被**synchronize**修饰，导致每次只能由一个线程对他进行读写操作\n性能不如**ConcurrentHashMap**：因为对整体加锁的原因导致只有一个线程能够对它进行读写操作，不适合高并发环境\n","date":"2024-11-26T13:02:26+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84hashmap%E7%B1%BB%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E7%B1%BB/","title":"Java中的HashMap类及其衍生类"},{"content":"Map接口的定义 Map 接口是 Java 集合框架中的一部分，用于存储键值对（key-value）的映射关系。Map 中的键是唯一的，而值可以重复。\nMap集合的特点 键值对存储： 每个元素由一个键（key）和一个值（value）组成。 键必须唯一，但值可以重复。 键的唯一性： 键的唯一性是通过调用键的 hashCode() 和 equals() 方法来保证的。 允许的值： 键和值都可以为 null，但实现类的行为可能不同： HashMap：允许一个 null 键和多个 null 值。 TreeMap：不允许 null 键。 Hashtable：不允许 null 键或 null 值。 无序或有序： HashMap 是无序的。 LinkedHashMap 按插入顺序或访问顺序存储。 TreeMap 按键的自然顺序或自定义排序存储。 线程安全性： HashMap 和 TreeMap 是非线程安全的。 Hashtable 和 ConcurrentHashMap 是线程安全的。 Map接口的实现类 HashMap： 基于哈希表实现，允许一个 null 键和多个 null 值。 无序。 LinkedHashMap： 基于哈希表和双向链表，维护插入顺序或访问顺序。 TreeMap： 基于红黑树实现，按自然顺序或自定义比较器排序键。 Hashtable： 线程安全，但性能较差，不允许 null 键或值。 ConcurrentHashMap： 线程安全，支持高并发。 Map 接口常用方法 添加键值对 1 V put(K key, V value) 添加或更新键值对。如果键已存在，返回旧值；否则返回 null。 1 default V putIfAbsent(K key, V value) 如果键不存在，添加键值对。 获取值 1 V get(Object key) 根据键获取对应的值。如果键不存在，返回 null 1 default V getOrDefault(Object key, V defaultValue) 如果键存在，返回对应的值；否则返回 defaultValue。 删除键值对 1 V remove(Object key) 移除指定键的键值对，返回被移除的值。如果键不存在，返回 null。 1 void clear() 清空所有键值对。 1 default boolean remove(Object key, Object value) 如果键存在且值匹配，则移除该键值对。 检查键值对 1 boolean containsKey(Object key) 检查是否包含指定的键。 1 boolean containsValue(Object value) 检查是否包含指定的值。 替换键值对 1 default boolean replace(K key, V oldValue, V newValue) 如果键的当前值等于 oldValue，则替换为 newValue。 1 default V replace(K key, V value) 替换键对应的值（如果键存在）。 集合视图 1 Set\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; entrySet() 返回所有键值对的集合。 1 Collection\u0026lt;V\u0026gt; values() 返回所有值的集合。 1 Set\u0026lt;K\u0026gt; keySet() 返回所有键的集合。 ","date":"2024-11-26T10:44:24+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84map%E6%8E%A5%E5%8F%A3/","title":"Java中的Map接口"},{"content":"Queue接口 Queue 是 Java 集合框架中的一个接口，位于 java.util 包下，用来表示 单向队列数据结构。队列通常遵循 FIFO（First In First Out，先进先出）的原则，即最先插入的元素最先被移除。\n特点 FIFO 顺序：队列通常按照先进先出的顺序处理元素。 不允许插入 null 值：避免产生歧义 常见实现类 LinkedList：实现了 Queue 接口，适用于一般队列操作。 PriorityQueue：基于优先级的队列，元素按照优先级排序。 ArrayDeque：高效的双端队列实现，也可以用作普通队列。 常见方法 添加元素 boolean add(E e)：将指定的元素插入队列。如果队列已满，会抛出 IllegalStateException 异常。 boolean offer(E e)：将指定的元素插入队列。如果队列已满，返回 false。推荐使用此方法以避免异常。 移除元素 E remove()：移除并返回队列头部的元素。如果队列为空，抛出 NoSuchElementException 异常。 E poll()：移除并返回队列头部的元素。如果队列为空，返回 null 获取队头元素 E element()：返回队列头部的元素，但不移除。如果队列为空，抛出 NoSuchElementException 异常。 E peek()：返回队列头部的元素，但不移除。如果队列为空，返回 null。 boolean contains(Object o)：检查队列中是否包含指定的元素。（继承自 Collection 接口） Deque接口 Deque（双端队列）是 Java 集合框架中的一个接口，位于 java.util 包下。它扩展了 Queue 接口，允许在 队列的两端插入和移除元素，既支持 FIFO（先进先出），也支持 LIFO（后进先出） 操作。\n特点 双端操作：支持从头部或尾部插入、删除、查看元素。 灵活性：可以用作 队列 或 栈。 不允许 null 元素：为了避免歧义，Deque 不允许存储 null。 常见实现类 ArrayDeque：基于数组实现，性能高效。 LinkedList：基于链表实现，支持动态扩展。 常见方法 队列操作 添加元素\nvoid addFirst(E e)：将指定元素插入到双端队列的头部。如果操作失败，抛出异常。 boolean offerFirst(E e)：将指定元素插入到双端队列的头部。如果操作失败，返回 false void addLast(E e)：将指定元素插入到双端队列的尾部。如果操作失败，抛出异常 boolean offerLast(E e)：将指定元素插入到双端队列的尾部。如果操作失败，返回 false 删除元素\nE removeFirst()：移除并返回头部的元素。如果双端队列为空，抛出异常。 E pollFirst()：移除并返回头部的元素。如果双端队列为空，返回 null E removeLast()：移除并返回尾部的元素。如果双端队列为空，抛出异常 E pollLast()：移除并返回尾部的元素。如果双端队列为空，返回 null 获取元素\nE getFirst()：返回头部的元素，但不移除。如果双端队列为空，抛出异常。 E peekFirst()：返回头部的元素，但不移除。如果双端队列为空，返回 null E getLast()：返回尾部的元素，但不移除。如果双端队列为空，抛出异常 E peekLast()：返回尾部的元素，但不移除。如果双端队列为空，返回 null 栈操作 void push(E e)：将元素压入到双端队列的头部，等价于入栈。 E pop()：移除并返回双端队列头部的元素，等价于出栈 E peek()：返回栈顶的元素 ArrayDeque类 特点 插入删除高效：\nArrayDeque 不需要维护节点指针，因此在时间和空间上更高效。 插入和删除操作在队列的头部和尾部都具有 $O(1) $的性能（在动态扩容时性能可能下降）。 双端操作：\n允许在 头部 和 尾部 插入、删除元素。 支持队列（FIFO）和栈（LIFO）操作。 动态扩容：\n底层通过动态数组实现，当存储空间不足时，会自动扩容为原来的两倍。 不支持 null 元素：\n为了避免混淆（例如，返回值为 null 时无法判断是队列为空还是插入了 null），ArrayDeque 不允许存储 null。 非线程安全：\nArrayDeque 没有内置的同步机制，若在多线程环境下使用，需要手动同步。 底层实现 ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组，也就是说数组的任何一点都可能被看作起点或者终点。\nhead指向首端第一个有效元素，\ntail指向尾端第一个可以插入元素的空位\naddFirst()方法 addFirst(E e) 的作用是在Deque的首端插入元素，也就是在head的前面插入元素，在空间足够且下标没有越界的情况下，只需要将 elements[--head] = e 即可。\n1 2 3 4 5 6 7 8 //addFirst(E e) public void addFirst(E e) { if (e == null)//不允许放入null throw new NullPointerException(); elements[head = (head - 1) \u0026amp; (elements.length - 1)] = e;//2.下标是否越界 if (head == tail)//1.空间是否够用 doubleCapacity();//扩容 } addLast()方法 addLast(E e) 的作用是在Deque的尾端插入元素，也就是在 tail 的位置插入元素，由于 tail 总是指向下一个可以插入的空位，因此只需要 elements[tail] = e 即可\n1 2 3 4 5 6 7 public void addLast(E e) { if (e == null)//不允许放入null throw new NullPointerException(); elements[tail] = e;//赋值 if ( (tail = (tail + 1) \u0026amp; (elements.length - 1)) == head)//下标越界处理 doubleCapacity();//扩容 } pollFirst()方法 pollFirst()的作用是删除并返回队列首端元素，也即是head位置处的元素。如果容器不空，只需要直接返回elements[head]即可，当然还需要处理下标的问题。由于ArrayDeque中不允许放入null，当 elements[head] == null 时，意味着容器为空。\n1 2 3 4 5 6 7 8 public E pollFirst() { E result = elements[head]; if (result == null)//null值意味着deque为空 return null; elements[h] = null;//let GC work head = (head + 1) \u0026amp; (elements.length - 1);//下标越界处理 return result; } pollLast方法 pollLast() 的作用是删除并返回队列尾端元素，也即是 tail 位置前面的那个元素\n1 2 3 4 5 6 7 8 9 public E pollLast() { int t = (tail - 1) \u0026amp; (elements.length - 1);//tail的上一个位置是最后一个元素 E result = elements[t]; if (result == null)//null值意味着deque为空 return null; elements[t] = null;//let GC work tail = t; return result; } PriorityQueue类 PriorityQueue 是 Java 集合框架中的一个队列实现类，位于 java.util 包下，用于实现基于 优先级堆排序 的队列。它按照元素的自然顺序（Comparable）或通过自定义比较器（Comparator）定义的顺序对队列进行排序，每次从队列中获取或移除的都是 优先级最高的元素。\n特点 底层实现： PriorityQueue 底层基于 小顶堆 实现（默认为自然顺序），用一个动态调整大小的数组存储堆结构。 排序机制： 默认按照元素的自然顺序（对象需要实现 Comparable 接口）。 可以通过构造器传入自定义的 Comparator 定义排序规则。 非线程安全： 适用于单线程环境，多线程环境下需要使用外部同步机制或使用线程安全的队列（如 PriorityBlockingQueue）。 允许 null 元素： 不允许插入 null 元素。 元素的去重： 不提供去重功能，允许重复元素。 动态扩容： 底层数组的容量会根据需求动态调整。 堆 堆是一种完全二叉树，堆的特点是根节点的值最小（小顶堆）或最大（大顶堆），并且任意非根节点i的值都不大于（或不小于）其父节点的值。\n在堆中，每个节点的下标和其在数组中的下标是一一对应的，假设节点下标为 i ，则其父节点下标为 (i-1)/2 ，其左子节点下标为 2i+1 ，其右子节点下标为 2i+2 。\n小顶堆\n1 2 3 4 5 1 / \\ 2 3 / \\ / \\ 4 5 6 7 大顶堆\n1 2 3 4 5 8 / \\ 7 5 / \\ / \\ 6 4 2 1 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import java.util.PriorityQueue; class Task implements Comparable\u0026lt;Task\u0026gt; { private String name; private int priority; public Task(String name, int priority) { this.name = name; this.priority = priority; } public String getName() { return name; } @Override public int compareTo(Task other) { // 按优先级升序排序 return Integer.compare(this.priority, other.priority); } @Override public String toString() { return \u0026#34;Task{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, priority=\u0026#34; + priority + \u0026#39;}\u0026#39;; } } public class CustomObjectPriorityQueueExample { public static void main(String[] args) { PriorityQueue\u0026lt;Task\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(); pq.add(new Task(\u0026#34;Task1\u0026#34;, 5)); pq.add(new Task(\u0026#34;Task2\u0026#34;, 1)); pq.add(new Task(\u0026#34;Task3\u0026#34;, 3)); // 按优先级移除任务 while (!pq.isEmpty()) { System.out.println(pq.poll()); } // 输出顺序：Task2, Task3, Task1 } } ","date":"2024-11-25T13:50:30+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84queue%E6%8E%A5%E5%8F%A3%E5%92%8Cdeque%E6%8E%A5%E5%8F%A3/","title":"Java中的Queue接口和Deque接口"},{"content":"HashSet类 HashSet 是 Java 集合框架中的一个实现类，属于 Set 接口的一种实现，基于哈希表来存储数据。它不允许存储重复元素，并且不保证元素的顺序。\n特点 无重复元素：\nHashSet 使用哈希算法来存储元素，保证集合中没有重复的元素。\n元素的唯一性由 equals() 和 hashCode() 方法决定。\n无序存储：\nHashSet 不保证元素的存储顺序，与插入顺序无关。 允许存储一个 null 值：\n只能包含一个 null 值。 非线程安全：\n默认情况下，HashSet 不是线程安全的。 性能高效：\n添加、删除和查找操作的时间复杂度为 $O(1)$，但需要良好的哈希算法来避免哈希冲突。 注意事项 必须同时重写 hashCode() 方法和 equal() 方法 通过 hashCode() 方法快速找到存储位置（哈希桶）。 再通过 equals() 方法检查对象是否相等，避免重复存储。 hashCode() 方法默认根据地址值计算，equal() 方法默认根据地址值判断对象是否相同 底层原理 HashSet 的底层是由一个 HashMap 实现的，它将需要存储的元素作为 HashMap 的键（key），而值（value）则是一个固定的常量 PRESENT。\n去重原理 HashSet 是基于 哈希表 实现的集合类，它的去重功能依赖于两个方法：\nhashCode() 方法：用于快速定位存储位置（哈希桶）。 equals() 方法：用于确定逻辑相等性（是否是重复元素）。 当调用 HashSet 的 add() 方法时，具体过程如下：\n计算哈希值： 调用元素的 hashCode() 方法，计算出该元素的哈希值，用于确定其存储位置（哈希桶）。 定位哈希桶： 根据哈希值找到对应的哈希桶。 检查冲突： 如果桶中已经有一个或多个元素（两个对象具有相同的哈希值，发生哈希冲突），则调用元素的 equals() 方法，与桶中已有元素逐一比较： 如果 equals() 返回 true，说明两个对象逻辑相等，不添加新元素，去重成功。 如果 equals() 返回 false，说明不是重复元素，将新元素添加到桶中。 存储元素： 如果桶中没有冲突（即不存在相同的哈希值和 equals() 相等的对象），直接存储该元素。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import java.util.HashSet; import java.util.Objects; class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age \u0026amp;\u0026amp; Objects.equals(name, person.name); } @Override public int hashCode() { return Objects.hash(name, age); } @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, age=\u0026#34; + age + \u0026#34;}\u0026#34;; } } public class HashSetExample { public static void main(String[] args) { HashSet\u0026lt;Person\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); Person p1 = new Person(\u0026#34;Alice\u0026#34;, 25); Person p2 = new Person(\u0026#34;Alice\u0026#34;, 25); // 与 p1 逻辑相等 Person p3 = new Person(\u0026#34;Bob\u0026#34;, 30); set.add(p1); set.add(p2); // 不会添加，因为 p1 和 p2 逻辑相等 set.add(p3); System.out.println(\u0026#34;HashSet contains:\u0026#34;); for (Person p : set) { System.out.println(p); } } } 扩容机制 初始容量\nHashSet 的底层 HashMap 默认初始容量为 16。 如果在创建 HashSet 时指定了初始容量，则会根据该容量初始化底层的 HashMap。 负载因子\n默认负载因子为 0.75。 负载因子是一个用来衡量哈希表满的程度的指标。 当哈希表中的元素个数达到 容量 × 负载因子 时，触发扩容。 扩容条件\n当 HashSet 中的元素数量达到容量的 75% 时（即 size ≥ capacity × loadFactor），底层的 HashMap 会触发扩容操作\n扩容过程\n容量翻倍：每次扩容时，HashMap 的容量会 翻倍。 重新哈希：扩容后，所有已有元素需要重新计算哈希值并分配到新的桶中 迁移数据：将原哈希表中的元素迁移到新的哈希表中 遍历旧哈希表中的每个桶。 对每个桶中的元素重新计算哈希值，将其分配到新哈希表中 常见方法 构造方法 public HashSet()：创建一个空的 HashSet，默认容量为 16，负载因子为 0.75。 public HashSet(int initialCapacity)：创建一个具有指定初始容量的空 HashSet。 public HashSet(int initialCapacity, float loadFactor)：创建一个具有指定初始容量和负载因子的空 HashSet。 public HashSet(Collection\u0026lt;? extends E\u0026gt; c)：创建一个包含指定集合中所有元素的 HashSet 添加元素 public boolean add(E e)：如果元素不存在，则添加成功并返回 true；否则返回 false。 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c)：将指定集合中的所有元素添加到当前 HashSet。 删除元素 public boolean remove(Object o)：如果集合中存在该元素，则移除并返回 true；否则返回 false。 public boolean removeAll(Collection\u0026lt;?\u0026gt; c)：从当前集合中移除指定集合中的所有元素 public void clear()：移除集合中的所有元素 查询元素 public boolean contains(Object o)：如果集合中存在指定的元素，则返回 true public boolean containsAll(Collection\u0026lt;?\u0026gt; c)：如果当前集合包含指定集合中的所有元素，则返回 true 集合大小 public boolean isEmpty()：如果集合为空，则返回 true public int size()：返回集合中的元素数量 集合运算 并集（Union） 将两个集合的所有元素合并在一起，去重后返回新集合 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 将指定集合中的所有元素添加到当前集合中 交集（Intersection） 将两个集合中共同的元素取出来 public boolean retainAll(Collection\u0026lt;?\u0026gt; c) 只保留当前集合和指定集合中的交集部分 差集（Difference） 从一个集合中去除另一个集合中的元素 public boolean removeAll(Collection\u0026lt;?\u0026gt; c) 从当前集合中移除与指定集合相交的元素 与HashMap的关系 实际上 HashSet 内部使用 HashMap 来实现，HashSet 中的元素实际上存储在 HashMap 的键中，而所有的值都是一个常量对象 PRESENT。因此，HashSet 仅操作 HashMap 的键部分。\nLinkedHashSet类 LinkedHashSet 是 Java 集合框架中的一个类，它实现了 Set 接口，并且结合了 HashSet 和链表的特性。它是 HashSet 的一个变种，具有元素唯一性和顺序性的特点。LinkedHashSet 维护了元素插入的顺序（即按插入顺序遍历元素），这使得它在保持 Set 接口的特性（元素唯一性）的同时，还能提供元素的顺序遍历。\n特点 元素唯一性：\nLinkedHashSet 和 HashSet 一样，保证集合中的元素不重复，即不允许重复元素。 保持插入顺序：\n与 HashSet 不同的是，LinkedHashSet 维护了元素的插入顺序。也就是说，元素是按照它们被添加到集合中的顺序来存储的。 这使得 LinkedHashSet 在遍历时能按照元素的插入顺序进行。 基于哈希表和链表实现：\n它继承了 HashSet，因此内部使用哈希表来存储元素，同时使用链表来记录元素的插入顺序。\n使用哈希表来实现高效的查找、插入和删除操作。\n底层原理 插入顺序的维护 LinkedHashSet 通过内部维护一个 双向链表 来保持元素的插入顺序。每个元素在哈希表中不仅存储它的哈希值，还会保存指向前一个元素和后一个元素的引用。这使得集合可以按照插入顺序遍历元素。\n插入时创建新节点：\n当调用 add(E e) 方法插入一个新元素时，LinkedHashSet 会先通过哈希表检查该元素是否已存在。如果不存在，它会将元素插入到哈希表中，并在双向链表的末尾添加该元素。\n每次添加元素时，它会被插入到链表的末尾，并通过双向链表保持元素之间的顺序。这样，在遍历 LinkedHashSet 时，元素会按照它们被插入的顺序输出。\nTreeSet类 特点 排序功能：\nTreeSet 中的元素是自动按升序排序的。它使用 自然顺序（元素必须实现 Comparable 接口）或者提供的 Comparator 对元素进行排序。 元素唯一性：\n与 HashSet 一样，TreeSet 保证集合中的元素不重复，即不允许添加重复元素。 基于红黑树实现：\nTreeSet 是基于 红黑树 数据结构实现的。红黑树是一种自平衡的二叉查找树，能够保证树的高度始终处于对数级别，从而保证了操作的效率。\n由于使用了红黑树，TreeSet 可以在对元素进行插入、删除、查找时提供 $O(log n)$ 的时间复杂度。\n不允许 null 元素：\nTreeSet 不允许 null 元素。如果尝试向 TreeSet 中添加 null 元素，将会抛出 NullPointerException。 线程不安全：\nTreeSet 不是线程安全的。如果多个线程同时访问一个 TreeSet，并且至少有一个线程修改了该集合，则必须在外部进行同步。 访问和操作性能：\nTreeSet 的常见操作（如 add()、remove()、contains()）的时间复杂度是 $O(log n)$，这是因为它使用了红黑树来存储元素。 排序规则 对于数值类型默认采用升序排列 对于字符类型默认采用ASCII码排序 对于字符串类型采用字典序进行排列 自定义规则 让元素实现 Comparable 接口 创建集合时传递 Comparator 指定规则 ","date":"2024-11-25T10:21:08+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84set%E5%AE%9E%E7%8E%B0%E7%B1%BB/","title":"Java中的Set实现类"},{"content":"Set接口的定义 Set 是 Java 集合框架中的一个接口，位于 java.util 包中，表示一个不包含重复元素的集合。\nSet集合的特点 无重复元素： Set 不允许存储重复的元素。 元素的唯一性是通过 equals() 方法来判断的。 无顺序保证： Set 本身并不保证元素的顺序。 具体的实现类可能会对顺序有不同的处理，例如： HashSet：无序。 LinkedHashSet：按插入顺序。 TreeSet：自然顺序或自定义排序。 允许存储 null： 大多数 Set 集合实现允许一个 null 元素（例如，HashSet）。 TreeSet 不允许存储 null，因为排序比较时会抛出 NullPointerException。 线程安全： Set 接口的实现类（如 HashSet）不是线程安全的。 可以使用 Collections.synchronizedSet() 创建线程安全的 Set。 Set接口的实现类 HashSet：基于哈希表实现，无序，不保证顺序 LinkedHashSet：基于哈希表和链表实现，按插入顺序存储。 TreeSet：基于红黑树实现，按自然顺序或自定义排序存储 ConcurrentSkipListSet：线程安全的 Set，按自然顺序或自定义排序存储，基于跳表实现 Set接口的常用方法 添加元素 boolean add(E e)：向集合中添加一个元素，如果已存在该元素，则返回 false。 boolean addAll(Collection\u0026lt;? extends E\u0026gt; c)：将指定集合中的所有元素添加到当前集合 删除元素 void clear()：清空集合中的所有元素 boolean remove(Object o)：从集合中移除指定的元素 查询元素 boolean contains(Object o)：判断集合中是否包含指定的元素 获取大小 int size()：返回集合中的元素个数 boolean isEmpty()：判空 ","date":"2024-11-25T10:01:22+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84set%E6%8E%A5%E5%8F%A3/","title":"Java中的Set接口"},{"content":"ArrayList类 ArrayList 是 Java 集合框架中的一个类，属于 java.util 包，是一种 基于动态数组实现的可变长度集合。它实现了 List 接口，提供了一个可调整大小的数组，能够存储任意类型的对象（包括自定义类和基本类型的包装类）。\n特点 动态数组： ArrayList 的大小是可变的，默认容量为 10。当元素数量超过当前容量时，ArrayList 会自动扩容，通常以 1.5 倍的速度增长。 有序： 元素按照插入的顺序存储，可以通过索引访问，顺序不会改变（除非显式调整）。 允许重复元素： ArrayList 允许存储重复的元素。 支持随机访问： 因为底层是数组，ArrayList 支持快速随机访问，时间复杂度为 $ O(1)$ 。 线程不安全： ArrayList 是非同步的，因此在多线程环境下需要手动同步（可以使用 Collections.synchronizedList() 或 CopyOnWriteArrayList 替代）。 常见方法 构造方法 public ArrayList()：创建一个默认初始容量为 10 的空 ArrayList public ArrayList(int initialCapacity)：创建一个具有指定初始容量的空 ArrayList public ArrayList(Collection\u0026lt;? extends E\u0026gt; c)：创建一个包含指定集合中所有元素的 ArrayList，按照集合的迭代器顺序。 添加元素 boolean add(E e)：将指定的元素添加到列表的末尾 void add(int index, E element)：将指定的元素插入到列表的指定位置 boolean addAll(Collection\u0026lt;? extends E\u0026gt; c)：将指定集合中的所有元素添加到当前列表的末尾 boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c)：将指定集合中的所有元素插入到当前列表的指定位置。 删除元素 void clear()：删除全部元素 E remove(int index)：删除列表中指定位置的元素 boolean remove(Object o)：删除列表中第一次出现的指定元素。如果列表中没有该元素，则不做任何操作。 boolean removeAll(Collection\u0026lt;?\u0026gt; c)：删除当前列表中所有与指定集合中的元素相同的元素 void removeRange(int from,int to)：删除索引[from，to）之间的元素 判断元素 boolean contains(Object o)：判断列表中是否包含指定的元素 boolean containsAll(Collection\u0026lt;?\u0026gt; c)：判断列表是否包含指定集合中的所有元素 修改元素 E set(int index, E element)：用指定的元素替换列表中指定位置的元素 访问元素 E get(int index)：返回指定位置的元素 int indexOf(Object o)：返回指定元素在列表中的第一次出现位置的索引。如果列表中没有该元素，则返回 -1 int lastIndexOf(Object o)：返回指定元素在列表中的最后一次出现位置的索引。如果列表中没有该元素，则返回 -1 获取大小 int size()：返回列表中元素的数量 boolean isEmpty()：判断列表是否为空 void ensureCapacity(int minCapacity)：确保列表能够容纳至少指定数量的元素，不会导致扩容。 扩容机制 源码分析 往 ArrayList 中添加元素时会有 ensureCapacityInternal 的判断\n1 2 3 4 5 public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } ensureCapacityInternal 内部会调用 ensureExplicitCapacity 方法，若 minCapacity - elementData.length \u0026gt; 0 即容量不够了，则会调用 grow 方法：\n1 2 3 4 5 6 7 8 9 10 11 /** * 检查并确保集合容量足够，如果需要则增加集合容量。 * * @param minCapacity 所需最小容量 */ private void ensureExplicitCapacity(int minCapacity) { // 检查是否超出了数组范围，确保不会溢出 if (minCapacity - elementData.length \u0026gt; 0) // 如果需要增加容量，则调用 grow 方法 grow(minCapacity); } grow 扩容逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 扩容 ArrayList 的方法，确保能够容纳指定容量的元素 * @param minCapacity 指定容量的最小值 */ private void grow(int minCapacity) { // 检查是否会导致溢出，oldCapacity 为当前数组长度 int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); // 扩容至原来的1.5倍 if (newCapacity - minCapacity \u0026lt; 0) // 如果还是小于指定容量的最小值 newCapacity = minCapacity; // 直接扩容至指定容量的最小值 if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) // 如果超出了数组的最大长度 newCapacity = hugeCapacity(minCapacity); // 扩容至数组的最大长度 // 将当前数组复制到一个新数组中，长度为 newCapacity elementData = Arrays.copyOf(elementData, newCapacity); } 总结 当 ArrayList 中的元素数量超过其当前容量时，会触发扩容机制。\n默认情况下，ArrayList 的初始容量为 10。\n当发生扩容时，ArrayList 会创建一个新的数组，其容量为原数组的 1.5 倍（即 oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1)），若还是小于指定容量的最小值会直接扩容到指定容量的最小值\n然后将原数组中的元素复制到新数组中。复制过程是通过 Arrays.copyOf() 方法实现的。\n更新引用：将 ArrayList 内部指向原数组的引用指向新数组。\n完成扩容：扩容完成后，可以继续添加新元素。\n线程安全问题 为什么是线程不安全的 ArrayList 不是线程安全的。ArrayList 会暴露三个问题;\n部分值为 null（我们并没有add null进去） 索引越界异常 线程1走到扩容那里发现当前 size 是 n，数组容量是n+1不用扩容，cpu让出执行权 线程2也发现不用扩容，这时候数组的容量就是n+1 而线程1 set完之后 size++，这时候线程2再进来 size 就是 n+1，数组的大小只有n+1，而你要设置下标索引为n+1的就会越界（数组的下标索引 size 从0开始）； size 与 add 的数量不符 因为 size++ 本身不是原子操作，可以分为三步： 获取 size 的值 将 size 的值加1 将新的 size 值覆盖掉原来的 线程1和线程2拿到一样的 size 值加完了同时覆盖，就会导致一次没有加上，所以肯定不会与add的数量保持一致的 解决方法 使用Collections类的 synchronizedList 方法将 ArrayList 包装成线程安全的 List\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import java.util.ArrayList; import java.util.Collections; import java.util.List; public class SynchronizedListExample { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = Collections.synchronizedList(new ArrayList\u0026lt;\u0026gt;()); // 同步块中操作列表，保证线程安全 synchronized (list) { list.add(1); list.add(2); System.out.println(list); } } } 使用线程安全的替代类 CopyOnWriteArrayList\n增删查改的机制 查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * 返回列表中指定位置的元素。 * * @param index 要返回的元素的索引 * @return 列表中指定位置的元素 * @throws IndexOutOfBoundsException 如果索引超出范围（index \u0026lt; 0 || index \u0026gt;= size()） */ public E get(int index) { rangeCheck(index); // 检查索引是否合法 return elementData(index); // 调用 elementData 方法获取元素 } /** * 返回列表中指定位置的元素。 * 此方法不进行边界检查，因此只应由内部方法和迭代器调用。 * * @param index 要返回的元素的索引 * @return 列表中指定位置的元素 */ E elementData(int index) { return (E) elementData[index]; // 返回指定索引位置上的元素 } 时间复杂度为$ O(1)$，因为 ArrayList 内部使用数组来存储元素，所以可以直接根据索引来访问元素。\n插入 添加一个元素（调用 add() 方法时）的时间复杂度最好情况为 $O(1)$，最坏情况为 $O(n)$。\n如果在列表末尾添加元素，时间复杂度为 $O(1)$。 如果要在列表的中间或开头插入元素，则需要将插入位置之后的元素全部向后移动一位，时间复杂度为 $O(n)$。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * 在指定位置插入一个元素。 * * @param index 要插入元素的位置 * @param element 要插入的元素 * @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常 */ public void add(int index, E element) { rangeCheckForAdd(index); // 检查索引是否越界 ensureCapacityInternal(size + 1); // 确保容量足够，如果需要扩容就扩容 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 将 index 及其后面的元素向后移动一位 elementData[index] = element; // 将元素插入到指定位置 size++; // 元素个数加一 } 修改 修改一个元素（调用 set() 方法时）可以直接根据索引来访问元素，时间复杂度为 $O(1)$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 用指定元素替换列表中指定位置的元素。 * * @param index 要替换元素的索引 * @param element 要放入列表中的元素 * @return 原来在指定位置上的元素 * @throws IndexOutOfBoundsException 如果索引超出范围（index \u0026lt; 0 || index \u0026gt;= size()） */ public E set(int index, E element) { rangeCheck(index); // 检查索引是否合法 E oldValue = elementData(index); // 获取原来在指定位置上的元素 elementData[index] = element; // 将指定位置上的元素替换为新元素 return oldValue; // 返回原来在指定位置上的元素 } 删除 删除一个元素（调用 remove(Object) 方法时）的时间复杂度最好情况 $O(1)$，最坏情况 $O(n)$。\n如果要删除列表末尾的元素，时间复杂度为 $O(1)$。 如果要删除列表中间或开头的元素，则需要将删除位置之后的元素全部向前移动一位，时间复杂度为 $O(n)$。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /** * 删除指定位置的元素。 * * @param index 要删除的元素的索引 * @return 先前在指定位置的元素 * @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常 */ public E remove(int index) { rangeCheck(index); // 检查索引是否越界 E oldValue = elementData(index); // 获取要删除的元素 int numMoved = size - index - 1; // 计算需要移动的元素个数 if (numMoved \u0026gt; 0) // 如果需要移动元素，就用 System.arraycopy 方法实现 System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // 将数组末尾的元素置为 null，让 GC 回收该元素占用的空间 return oldValue; // 返回被删除的元素 } /** * 删除列表中第一次出现的指定元素（如果存在）。 * * @param o 要删除的元素 * @return 如果列表包含指定元素，则返回 true；否则返回 false */ public boolean remove(Object o) { if (o == null) { // 如果要删除的元素是 null for (int index = 0; index \u0026lt; size; index++) // 遍历列表 if (elementData[index] == null) { // 如果找到了 null 元素 fastRemove(index); // 调用 fastRemove 方法快速删除元素 return true; // 返回 true，表示成功删除元素 } } else { // 如果要删除的元素不是 null for (int index = 0; index \u0026lt; size; index++) // 遍历列表 if (o.equals(elementData[index])) { // 如果找到了要删除的元素 fastRemove(index); // 调用 fastRemove 方法快速删除元素 return true; // 返回 true，表示成功删除元素 } } return false; // 如果找不到要删除的元素，则返回 false } LinkedList类 LinkedList 是 Java 集合框架中的一个类，位于 java.util 包下，它同时实现了 List 和 Deque 接口，是一种基于双向链表的数据结构。\n特点 双向链表： 每个节点包含： 一个存储数据的字段。 两个指针，分别指向前一个节点和后一个节点。 动态容量： LinkedList 的大小可以动态变化，无需像数组那样预定义容量。 线程不安全： LinkedList 是非同步的，因此在多线程环境下需要手动同步 插入和删除效率高： 插入操作：在链表任意位置插入元素的时间复杂度为 $O(1)$，只需调整指针即可（如果已定位到插入点）。 删除操作：删除元素也只需调整相关指针，时间复杂度为 $O(1)$。 有序： 元素按照插入的顺序存储，可以通过索引访问，顺序不会改变（除非显式调整）。 允许重复元素： LinkedList 允许存储重复的元素。 常见方法 构造方法 public LinkedList()：创建一个空的 LinkedList 实例 public LinkedList(Collection\u0026lt;? extends E\u0026gt; c)：使用指定集合中的所有元素初始化 LinkedList 添加元素 boolean add(E e)：将指定的元素添加到链表的末尾 void add(int index, E element)：将指定的元素插入到链表的指定位置 void addFirst(E e)：在链表头部添加元素 void addLast(E e)：在链表尾部添加元素 访问元素 E get(int index)：返回指定位置的元素 E getFirst()：返回链表头部的第一个元素 E getLast()：返回链表尾部的最后一个元素 int indexOf(Object o)：返回指定元素在列表中的首次出现位置，如果列表中不包含该元素，返回 -1 。 int lastIndexOf(Object o)：返回指定元素在列表中最后一次出现的位置，如果列表中不包含该元素，返回 -1 。 删除元素 E remove(int index)：删除指定位置的元素，并返回被删除的元素 boolean remove(Object o)：删除链表中第一个匹配的元素 E removeFirst()：删除并返回链表头部的第一个元素 E removeLast()：删除并返回链表尾部的最后一个元素 void clear()：删除全部元素 判断元素 boolean contains(Object o)：判断列表中是否包含指定的元素 boolean containsAll(Collection\u0026lt;?\u0026gt; c)：判断列表是否包含指定集合中的所有元素 获取大小 int size()：返回列表中元素的数量 boolean isEmpty()：判断列表是否为空 修改元素 E set(int index, E element)：用指定的元素替换列表中指定位置的元素 源码解析 链表节点类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * 链表中的节点类。 */ private static class Node\u0026lt;E\u0026gt; { E item; // 节点中存储的元素 Node\u0026lt;E\u0026gt; next; // 指向下一个节点的指针 Node\u0026lt;E\u0026gt; prev; // 指向上一个节点的指针 /** * 构造一个新的节点。 * * @param prev 前一个节点 * @param element 节点中要存储的元素 * @param next 后一个节点 */ Node(Node\u0026lt;E\u0026gt; prev, E element, Node\u0026lt;E\u0026gt; next) { this.item = element; // 存储元素 this.next = next; // 设置下一个节点 this.prev = prev; // 设置上一个节点 } } 组成结构\n节点上的元素 下一个节点 上一个节点 插入节点 add 方法内部其实调用的是 linkLast 方法\n1 2 3 4 5 6 7 8 9 10 /** * 将指定的元素添加到列表的尾部。 * * @param e 要添加到列表的元素 * @return 始终为 true（根据 Java 集合框架规范） */ public boolean add(E e) { linkLast(e); // 在列表的尾部添加元素 return true; // 添加元素成功，返回 true } linkLast 方法就是在链表的尾部添加元素（尾插法）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 在列表的尾部添加指定的元素。 * * @param e 要添加到列表的元素 */ void linkLast(E e) { final Node\u0026lt;E\u0026gt; l = last; // 获取链表的最后一个节点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(l, e, null); // 创建一个新的节点，并将其设置为链表的最后一个节点 last = newNode; // 将新的节点设置为链表的最后一个节点 if (l == null) // 如果链表为空，则将新节点设置为头节点 first = newNode; else l.next = newNode; // 否则将新节点链接到链表的尾部 size++; // 增加链表的元素个数 } linkFirst 方法就是在链表的头部添加元素，把新的节点设为 first，并将新的 first 的 next 更新为之前的 first。（头插法）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 在列表的开头添加指定的元素。 * * @param e 要添加到列表的元素 */ private void linkFirst(E e) { final Node\u0026lt;E\u0026gt; f = first; // 获取链表的第一个节点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(null, e, f); // 创建一个新的节点，并将其设置为链表的第一个节点 first = newNode; // 将新的节点设置为链表的第一个节点 if (f == null) // 如果链表为空，则将新节点设置为尾节点 last = newNode; else f.prev = newNode; // 否则将新节点链接到链表的头部 size++; // 增加链表的元素个数 } 删除节点 remove(int) 内部调用的是 unlink 方法\n1 2 3 4 5 6 7 8 9 10 11 /** * 删除指定位置上的元素。 * * @param index 要删除的元素的索引 * @return 从列表中删除的元素 * @throws IndexOutOfBoundsException 如果索引越界（index \u0026amp;lt; 0 || index \u0026amp;gt;= size()） */ public E remove(int index) { checkElementIndex(index); // 检查索引是否越界 return unlink(node(index)); // 删除指定位置的节点，并返回节点的元素 } unlink 方法就是更新当前节点的 next 和 prev，然后把当前节点上的元素设为 null。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * 从链表中删除指定节点。 * * @param x 要删除的节点 * @return 从链表中删除的节点的元素 */ E unlink(Node\u0026lt;E\u0026gt; x) { final E element = x.item; // 获取要删除节点的元素 final Node\u0026lt;E\u0026gt; next = x.next; // 获取要删除节点的下一个节点 final Node\u0026lt;E\u0026gt; prev = x.prev; // 获取要删除节点的上一个节点 if (prev == null) { // 如果要删除节点是第一个节点 first = next; // 将链表的头节点设置为要删除节点的下一个节点 } else { prev.next = next; // 将要删除节点的上一个节点指向要删除节点的下一个节点 x.prev = null; // 将要删除节点的上一个节点设置为空 } if (next == null) { // 如果要删除节点是最后一个节点 last = prev; // 将链表的尾节点设置为要删除节点的上一个节点 } else { next.prev = prev; // 将要删除节点的下一个节点指向要删除节点的上一个节点 x.next = null; // 将要删除节点的下一个节点设置为空 } x.item = null; // 将要删除节点的元素设置为空 size--; // 减少链表的元素个数 return element; // 返回被删除节点的元素 } 修改节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 将链表中指定位置的元素替换为指定元素，并返回原来的元素。 * * @param index 要替换元素的位置（从 0 开始） * @param element 要插入的元素 * @return 替换前的元素 * @throws IndexOutOfBoundsException 如果索引超出范围（index \u0026lt; 0 || index \u0026gt;= size()） */ public E set(int index, E element) { checkElementIndex(index); // 检查索引是否超出范围 Node\u0026lt;E\u0026gt; x = node(index); // 获取要替换的节点 E oldVal = x.item; // 获取要替换节点的元素 x.item = element; // 将要替换的节点的元素设置为指定元素 return oldVal; // 返回替换前的元素 } node() 方法用于定位要替换的节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * 获取链表中指定位置的节点。 * * @param index 节点的位置（从 0 开始） * @return 指定位置的节点 * @throws IndexOutOfBoundsException 如果索引超出范围（index \u0026lt; 0 || index \u0026gt;= size()） */ Node\u0026lt;E\u0026gt; node(int index) { if (index \u0026lt; (size \u0026gt;\u0026gt; 1)) { // 如果索引在链表的前半部分 Node\u0026lt;E\u0026gt; x = first; for (int i = 0; i \u0026lt; index; i++) // 从头节点开始向后遍历链表，直到找到指定位置的节点 x = x.next; return x; // 返回指定位置的节点 } else { // 如果索引在链表的后半部分 Node\u0026lt;E\u0026gt; x = last; for (int i = size - 1; i \u0026gt; index; i--) // 从尾节点开始向前遍历链表，直到找到指定位置的节点 x = x.prev; return x; // 返回指定位置的节点 } } node 方法会对下标进行一个初步判断，如果靠近前半截，就从下标 0 开始遍历；如果靠近后半截，就从末尾开始遍历。\nStack类 Stack 是 Java 集合框架中的一个类，位于 java.util 包中，作为 Vector 的子类间接实现了List接口，用于实现 栈（Stack） 数据结构\n特点 Stack 类继承自 Vector 类，因此它是一种 同步的（线程安全的） 集合。 常用方法 入栈操作 public E push(E item)：将元素压入栈顶 出栈操作 public synchronized E pop() 移除并返回栈顶的元素。 如果栈为空，则抛出 EmptyStackException 。 查看栈顶元素 public synchronized E peek() 返回栈顶的元素，但不移除。 如果栈为空，则抛出 EmptyStackException 。 检查栈空 public boolean empty()：判断栈是否为空 搜索元素 public synchronized int search(Object o) 返回元素在栈中的位置（以 1 为基准）。 如果元素不存在，则返回 -1。 CopyOnWriteArrayList类 CopyOnWriteArrayList 是 Java 的一个线程安全的动态数组实现，属于 java.util.concurrent 包。\n它通过写时复制机制，即在每次修改（写入）操作时，复制原始数组的内容来保证线程安全。\n由于写操作涉及复制整个数组，所以它的写操作开销较大，但读取操作则完全无锁。这使得 CopyOnWriteArrayList 适合于读多写少的场景。\n特点 写时复制是一种保证数据一致性和线程安全的技术。核心思想是在进行写操作时，不直接修改原来的数据结构，而是先复制一份副本，在副本上进行修改，然后将修改后的副本替换原来的数据结构。 保证数据一致性和线程安全 常见方法 构造方法 public CopyOnWriteArrayList()：创建一个空的 CopyOnWriteArrayList public CopyOnWriteArrayList(Collection\u0026lt;? extends E\u0026gt; c)：使用指定的集合初始化 CopyOnWriteArrayList public CopyOnWriteArrayList(E[] toCopyIn)：使用指定的数组初始化 CopyOnWriteArrayList 。 添加元素 boolean add(E e) ：将指定的元素添加到链表的末尾 void add(int index, E element) ：将指定的元素插入到链表的指定位置 void addFirst(E e) ：在链表头部添加元素 void addLast(E e) ：在链表尾部添加元素 访问元素 E get(int index) ：返回指定位置的元素 E getFirst() ：返回链表头部的第一个元素 E getLast() ：返回链表尾部的最后一个元素 int indexOf(Object o) ：返回指定元素在列表中的首次出现位置，如果列表中不包含该元素，返回 -1。 int lastIndexOf(Object o)：返回指定元素在列表中最后一次出现的位置，如果列表中不包含该元素，返回 -1。 删除元素 E remove(int index)：删除指定位置的元素，并返回被删除的元素 boolean remove(Object o)：删除链表中第一个匹配的元素 E removeFirst()：删除并返回链表头部的第一个元素 E removeLast()：删除并返回链表尾部的最后一个元素 void clear()：删除全部元素 判断元素 boolean contains(Object o)：判断列表中是否包含指定的元素 boolean containsAll(Collection\u0026lt;?\u0026gt; c)：判断列表是否包含指定集合中的所有元素 获取大小 int size()：返回列表中元素的数量 boolean isEmpty()：判断列表是否为空 修改元素 E set(int index, E element)：用指定的元素替换列表中指定位置的元素 源码分析 CopyOnWriteArrayList 底层也是通过一个数组保存数据，使用 volatile 关键字修饰数组，保证当前线程对数组对象重新赋值后，其他线程可以及时感知到。\n1 private transient volatile Object[] array; 写操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public boolean add(E e) { //获取锁 final ReentrantLock lock = this.lock; //加锁 lock.lock(); try { //获取到当前List集合保存数据的数组 Object[] elements = getArray(); //获取该数组的长度（这是一个伏笔，同时len也是新数组的最后一个元素的索引值） int len = elements.length; //将当前数组拷贝一份的同时，让其长度加1 Object[] newElements = Arrays.copyOf(elements, len + 1); //将加入的元素放在新数组最后一位，len不是旧数组长度吗，为什么现在用它当成新数组的最后一个元素的下标？建议自行画图推演，就很容易理解。 newElements[len] = e; //替换引用，将数组的引用指向给新数组的地址 setArray(newElements); return true; } finally { //释放锁 lock.unlock(); } } 读取当前数组：首先读取当前的数组，这个数组是 CopyOnWriteArrayList 当前持有的数组。 复制数组：创建一个当前数组的副本（新的数组），这个副本会拷贝当前数组中的所有元素。 在副本上进行修改：在副本数组上进行写操作（如添加、删除元素）。 用新数组替换旧数组：将修改后的副本数组设置为 CopyOnWriteArrayList 持有的数组，旧数组将不再使用。 读操作 1 2 3 public E get(int index) { return get(getArray(), index); } 所有读操作都可以无锁地直接读取 CopyOnWriteArrayList 当前持有的数组，因为这个数组在读操作期间不会被修改。\nCopyOnWriteArrayList 和 Collections.synchronizedList 的区别（面试题） 回答要点 CopyOnWriteArrayList\n是一个线程安全的 List 实现，特性就是写时复制。\n每次对 List 的修改操作（如 add, set, remove）都会复制创建一个新的底层数组。读操作不需要加锁，写操作需要加锁。\n优点：\n读操作无锁：每次写操作都会创建并复制新数组，所以读写之间不冲突，因此读操作不需要加锁，能够提供非常高效的并发读性能。 缺点：\n写操作开销大：每次写操作都会创建并复制新数组，且要将数据复制到新的数组中，在写操作频繁的场景下性能会较低。 内存消耗大：每次写操作都会创建并复制新数组，在数据量大的情况下，同一时刻会存在两倍 List 大小的内存占用，开销较大。 Collections.synchronizedList：\n是一个包装方法，可以将任何 List 转换为线程安全的版本，它会对每个访问方法（如 get, set, add, remove）进行同步（加 synchronized 锁），从而保证线程安全。\n优点：\n方便：简单一个方法就可以将 List 变为线程安全版本，非常方便。 缺点：\n并发低：读写操作都需要加锁，高并发场景下性能不高。 Collections.synchronizedList 适用于简单将 List 转为线程安全版本临时使用的场景。特定的场景还需使用并发度高的 JUC 类。\n","date":"2024-11-21T16:00:25+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84list%E5%AE%9E%E7%8E%B0%E7%B1%BB/","title":"Java中的List实现类"},{"content":"网络编程基础 IP地址 在互联网中，一个 IP 地址用于唯一标识一个网络设备。一台联入互联网的计算机肯定有一个 IP 地址，但也可能有多个 IP 地址。\nIP 地址又分为公网 IP 地址和内网 IP 地址。公网 IP 地址可以直接被访问，内网 IP 地址只能在内网访问。\n假设一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址127.0.0.1，还有一个 IP 地址，例如101.202.99.12，可以通过这个 IP 地址接入网络。\n假设路由器或者交换机有两个网卡，它有两个 IP 地址，分别接入不同的网络，让网络之间连接起来。\n如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的 IP 地址前段（网络号）是相同的。\n网络号是 IP 地址与子网掩码过滤后得到的。（子网掩码转换成二进制和IP地址转换成二进制后按位进行与操作）\n1 2 3 IP = 101.202.99.2 Mask = 255.255.255.0 Network = IP \u0026amp; Mask = 101.202.99.0 如果两台计算机计算出的网络号相同，说明两台计算机在同一个网络，可以直接通信。\n如果两台计算机计算出的网络号不同，那么两台计算机不在同一个网络，不能直接通信，它们之间必须通过路由器或者交换机这样的网络设备（网关）间接通信。\n网卡的关键配置\nIP 地址，例如：10.0.2.15 子网掩码，例如：255.255.255.0 网关的 IP 地址，例如：10.0.2.2 域名 直接记忆 IP 地址非常困难，所以通常使用域名访问某个特定的服务。\n域名解析服务器 DNS 负责把域名翻译成对应的 IP，客户端再根据 IP 地址访问服务器。\n端口号 用于标识计算机上的具体应用程序或进程。端口号与 IP 地址结合，共同用于标识一个主机上的具体服务或应用。\n协议 网络通信的规则\n网络套接字Socket Socket（套接字）：网络通信的基本单位，通过 IP 地址和端口号标识。\n套接字（Socket）是一个抽象层，应用程序可以通过它发送或接收数据；就像操作文件那样可以打开、读写和关闭。套接字允许应用程序将 I/O 应用于网络中，并与其他应用程序进行通信。网络套接字是 IP 地址与端口的组合。\nInetAddressIP地址类 InetAddress 是 Java 中用于表示一个 IP 地址的类，它提供了多种方法用于获取和处理与主机名或 IP 地址相关的信息。InetAddress 类位于 java.net 包中，常用于网络编程中。\n常用方法 public static InetAddress getByName(String host) throws UnknownHostException：该方法通过主机名或 IP 地址字符串返回一个 InetAddress 对象 public static InetAddress getByAddress(String host, byte[] addr) throws UnknownHostException：通过给定的 IP 地址（字节数组）和主机名，返回一个 InetAddress 对象。 public static InetAddress getLocalHost() throws UnknownHostException：该方法返回当前计算机的 InetAddress 对象。 public String getHostName()：获取与 InetAddress 对象相关联的主机名。 public String getHostAddress()：获取与 InetAddress 对象相关联的 IP 地址（以字符串形式返回） UDP协议传输 UDP 协议通过 DatagramSocket 和 DatagramPacket 类来实现。\n服务端 创建一个 DatagramSocket 来监听端口。 等待并创建 DatagramPacket 用于接收客户端发送的数据包。 处理数据并可能向客户端发送响应。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import java.net.*; public class UDPServer { public static void main(String[] args) { DatagramSocket socket = null; try { // 创建一个 DatagramSocket 并绑定到端口 9876 socket = new DatagramSocket(9876); System.out.println(\u0026#34;UDP Server is running...\u0026#34;); // 创建一个数据包来接收客户端的数据 byte[] receiveData = new byte[1024]; while (true) { // 创建 DatagramPacket 用于接收数据 DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length); // 接收客户端发送的数据 socket.receive(receivePacket); // 获取客户端的消息 String clientMessage = new String(receivePacket.getData(), 0, receivePacket.getLength()); System.out.println(\u0026#34;Received from client: \u0026#34; + clientMessage); // 创建并发送响应消息 String serverResponse = \u0026#34;Hello from UDP Server!\u0026#34;; byte[] sendData = serverResponse.getBytes(); // 获取客户端的地址和端口 InetAddress clientAddress = receivePacket.getAddress(); int clientPort = receivePacket.getPort(); // 创建一个数据包并发送给客户端 DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, clientAddress, clientPort); socket.send(sendPacket); } } catch (Exception e) { e.printStackTrace(); } finally { if (socket != null \u0026amp;\u0026amp; !socket.isClosed()) { socket.close(); } } } } 客户端 创建一个 DatagramSocket 用于发送数据。 创建一个 DatagramPacket，通过该包发送数据到服务器。 等待接收服务器的响应。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import java.net.*; public class UDPClient { public static void main(String[] args) { DatagramSocket socket = null; try { // 创建一个 DatagramSocket 用于发送数据 socket = new DatagramSocket(); // 服务器的地址和端口 InetAddress serverAddress = InetAddress.getByName(\u0026#34;localhost\u0026#34;); int serverPort = 9876; // 发送到服务器的消息 String message = \u0026#34;Hello, UDP Server!\u0026#34;; byte[] sendData = message.getBytes(); // 创建一个 DatagramPacket 发送消息到服务器 DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, serverAddress, serverPort); socket.send(sendPacket); System.out.println(\u0026#34;Sent to server: \u0026#34; + message); // 接收服务器的响应 byte[] receiveData = new byte[1024]; DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length); socket.receive(receivePacket); // 获取服务器响应并打印 String serverResponse = new String(receivePacket.getData(), 0, receivePacket.getLength()); System.out.println(\u0026#34;Received from server: \u0026#34; + serverResponse); } catch (Exception e) { e.printStackTrace(); } finally { if (socket != null \u0026amp;\u0026amp; !socket.isClosed()) { socket.close(); } } } } 核心类 DatagramSocket网络套接字 DatagramSocket 提供了发送和接收数据包的功能。\n构造方法\npublic DatagramSocket() throws SocketException public DatagramSocket(int port) throws SocketException public DatagramSocket(int port, InetAddress bindAddress) throws SocketException 收发数据\npublic void send(DatagramPacket packet) throws IOException：发送一个数据包到目标地址。 public void receive(DatagramPacket packet) throws IOException：接收来自远程主机的数据包 设置超时\npublic void setSoTimeout(int timeout) throws SocketException：设置超时时间，如果在指定的时间内没有数据到达，则会抛出 SocketTimeoutException。 关闭套接字\npublic void close()：关闭套接字 DatagramPacket数据包类 DatagramPacket 类提供了封装数据包的功能，常用于 UDP 协议的通信中。它可以用于存储接收到的数据或准备发送的数据。\n构造方法\npublic DatagramPacket(byte[] buf, int length) buf：用于存储数据的字节数组。 length：数据包的有效数据长度（在字节数组中的有效数据部分）。 public DatagramPacket(byte[] buf, int length, InetAddress address, int port) buf：用于存储数据的字节数组。 length：数据包的有效数据长度。 address：目标主机的 IP 地址。 port：目标主机的端口号。 获取数据\npublic byte[] getData() ：返回 DatagramPacket 中存储的数据字节数组。 public int getLength() ：返回 DatagramPacket 中有效数据的长度（字节数）。 public InetAddress getAddress() ：返回 DatagramPacket 中目标主机的 IP 地址。 public int getPort()：返回 DatagramPacket 中目标主机的端口号。 设置属性\npublic void setData(byte[] buf) public void setLength(int length) public void setAddress(InetAddress address) public void setPort(int port) TCP协议传输 服务端 创建一个 ServerSocket 来监听端口。 调用ServerSocket的accept()返回一个Socket对象监听客户端的套接字请求 获取连接通道的输入流读取来自客户端的数据 释放资源 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import java.io.*; import java.net.*; public class TCPServer { public static void main(String[] args) { try { // 创建 ServerSocket 监听端口 12345 ServerSocket serverSocket = new ServerSocket(12345); System.out.println(\u0026#34;Server is waiting for a client connection...\u0026#34;); // 接受客户端连接 Socket clientSocket = serverSocket.accept(); System.out.println(\u0026#34;Client connected!\u0026#34;); // 获取输入流读取客户端发送的数据 BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream())); PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true); // 读取客户端数据并响应 String clientMessage; while ((clientMessage = in.readLine()) != null) { System.out.println(\u0026#34;Received from client: \u0026#34; + clientMessage); if (clientMessage.equalsIgnoreCase(\u0026#34;bye\u0026#34;)) { out.println(\u0026#34;Goodbye!\u0026#34;); break; } // 向客户端返回消息 out.println(\u0026#34;Server received: \u0026#34; + clientMessage); } // 关闭连接 in.close(); out.close(); clientSocket.close(); serverSocket.close(); System.out.println(\u0026#34;Server closed.\u0026#34;); } catch (IOException e) { e.printStackTrace(); } } } 客户端 创建客户端的Socket对象 创建Socket对象时同时连接服务端 若服务端不可访问会发生阻塞直到抛出异常 获取连接通道的输出流，写入数据 释放资源 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import java.io.*; import java.net.*; public class TCPClient { public static void main(String[] args) { try { // 连接到服务器 (IP 地址和端口号) Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 12345); System.out.println(\u0026#34;Connected to server.\u0026#34;); // 获取输出流，发送数据 PrintWriter out = new PrintWriter(socket.getOutputStream(), true); // 获取输入流，接收服务器的数据 BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); BufferedReader userInput = new BufferedReader(new InputStreamReader(System.in)); String message; System.out.println(\u0026#34;Enter message to send to server (type \u0026#39;bye\u0026#39; to exit):\u0026#34;); while (true) { message = userInput.readLine(); // 读取用户输入 out.println(message); // 发送消息到服务器 String response = in.readLine(); // 从服务器接收响应 System.out.println(\u0026#34;Server response: \u0026#34; + response); if (message.equalsIgnoreCase(\u0026#34;bye\u0026#34;)) { break; } } // 关闭连接 userInput.close(); in.close(); out.close(); socket.close(); System.out.println(\u0026#34;Client closed.\u0026#34;); } catch (IOException e) { e.printStackTrace(); } } } 核心类 ServerSocket服务端套接字 ServerSocket 类是 Java 中用于实现 TCP 服务器端的类。它主要用于监听客户端的连接请求并接受连接。\n构造方法\npublic ServerSocket(int port) throws IOException public ServerSocket(int port, int backlog) throws IOException public ServerSocket(int port, int backlog, InetAddress bindAddr) throws IOException 接受连接\npublic Socket accept() throws IOException：接受客户端的连接请求。 此方法会阻塞，直到有客户端发起连接请求。 返回一个已连接的 Socket 实例，客户端可以通过该 Socket 与服务器通信。 状态检测\npublic boolean isBound() ：检查 ServerSocket 是否已经绑定到一个本地地址和端口。 public boolean isClosed()：检查 ServerSocket 是否已关闭 Socket客户端套接字 Socket 类是 Java 中用于实现 TCP 客户端通信的类，它提供了与服务器建立连接、发送和接收数据的功能。\n构造方法\npublic Socket(String host, int port) throws UnknownHostException, IOException：创建一个指定主机和端口的 Socket，并与目标主机建立连接。 host：目标主机的 IP 地址或域名。 port：目标主机的端口号。 public Socket(InetAddress address, int port) throws IOException：创建一个指定 IP 地址和端口号的 Socket，并与目标主机建立连接 address：目标主机的 IP 地址（InetAddress 类型）。 port：目标主机的端口号。 获取IO流\npublic InputStream getInputStream() throws IOException：返回与此 Socket 关联的输入流，客户端可以通过该流接收从服务器发送的数据 public OutputStream getOutputStream() throws IOException：返回与此 Socket 关联的输出流，客户端可以通过该流向服务器发送数据。 设置超时时间\npublic void setSoTimeout(int timeout) throws SocketException：设置读取数据的超时时间。如果在指定的时间内没有数据可读取，则会抛出 SocketTimeoutException。 ","date":"2024-11-20T10:04:34+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","title":"Java的网络编程"},{"content":"IO流的定义 Java 的 I/O（输入/输出）流是用于处理输入和输出数据的类库。通过流，程序可以从各种输入源（如文件、网络）读取数据，或将数据写入目标位置（如文件、控制台）。\nI/O 流分为两大类：字节流 和 字符流，分别用于处理字节级和字符级的数据：\n字节流：处理 8 位字节数据，适合于处理二进制文件，如图片、视频等。主要类是 InputStream 和 OutputStream 及其子类。 字符流：处理 16 位字符数据，适合于处理文本文件。主要类是 Reader 和 Writer 及其子类。 字符流和字节流的区别 字节流一般用来处理图像、视频、音频、PPT、Word等类型的文件。字符流一般用于处理纯文本类型的文件，如TXT文件等，但不能处理图像视频等非文本文件。用一句话说就是：字节流可以处理一切文件，而字符流只能处理纯文本文件。 字节流本身没有缓冲区，缓冲字节流相对于字节流，效率提升非常高。而字符流本身就带有缓冲区，缓冲字符流相对于字符流效率提升就不是那么大了。 编码和解码 输出流将缓冲区存储的字符通过查ASCII表转换为对应数字再进行编码\n输入流对文件进行解码转换为ASCII码对应的数字，然后通过查表转换为读取到的字符\n中文编码通常使用GBK字符集\n规则\n汉字使用两个字节进行存储 高位字节以1开头，转换成十进制后为负数 Unicode字符集（万国码）是国家标准字符集同时兼任ASCII码\nUTF-16编码：使用2-4个字节保存 UTF-32编码：固定4个字节保存 UTF-8编码：使用1-4个字节保存 ASCII码：1个字节 简体中文：3个字节 乱码的原因\n字符编码与解码不一致。乱码问题常常由字符编码（比如 UTF-8、GBK）和解码过程的不一致引起。如果在编码时使用了一种字符集，而在解码时使用了另一种，字符将无法正确显示，从而出现乱码。 文件流 一切文件（文本、视频、图片）的数据都是以二进制的形式存储的，传输时也是。所以，字节流可以传输任意类型的文件数据。\n文件字节流 FileOutputStream文件输出流 构造方法\npublic FileOutputStream(String s)：接收文件路径创建输出流，如果文件不存在，则创建一个新文件；如果文件已经存在，则覆盖原有文件。 public FileOutputStream(File file)：使用文件对象创建 FileOutputStream 对象 写入数据\npublic void write(int b)：写入一个ASCII码为b的字符 public void write(char b)：写入一个字符 public void write(byte[] b)：写入一个字节数组 public void write(byte[] b,int off,int len)：从指定的字节数组写入 len 字节到此输出流，从偏移量 off开始。 也就是说从off个字节数开始一直到len个字节结束 追加数据\n在构造方法中加入第二个Boolean类型参数指示是否继续读写\nFileInputStream文件输入流 构造方法\nFileInputStream(String name)：创建一个 FileInputStream 对象，并打开指定名称的文件进行读取。文件名由 name 参数指定。如果文件不存在，将会抛出 FileNotFoundException 异常。 FileInputStream(File file)：创建一个 FileInputStream 对象，并打开指定的 File 对象表示的文件进行读取。 读入数据\npublic int read()：read()方法会读取一个字节并返回其整数表示。如果已经到达文件的末尾，则返回 -1。如果在读取时发生错误，则会抛出 IOException 异常。 public int read(byte[] b) throws IOException：读取数据并将其存储在字节数组 b 中。返回实际读取的字节数。 public int read(byte[] b, int off, int len) throws IOException：从文件中读取最多 len 个字节的数据，存储到字节数组 b 中，从偏移量 off 开始。返回实际读取的字节数。 常见操作 文件拷贝\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class FileCopy { public static void main(String[] args) { String sourceFile = \u0026#34;source.txt\u0026#34;; // 源文件 String destFile = \u0026#34;destination.txt\u0026#34;; // 目标文件 try (FileInputStream fis = new FileInputStream(sourceFile); FileOutputStream fos = new FileOutputStream(destFile)) { byte[] buffer = new byte[1024]; // 缓冲区大小，可以根据需要调整 int length; // 读取源文件并写入目标文件 while ((length = fis.read(buffer)) \u0026gt; 0) { fos.write(buffer, 0, length); } System.out.println(\u0026#34;文件拷贝完成！\u0026#34;); } catch (IOException e) { e.printStackTrace(); } } } 文件夹拷贝\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; public class DirectoryCopy { public static void main(String[] args) { String sourceDir = \u0026#34;sourceDirectory\u0026#34;; // 源文件夹 String destDir = \u0026#34;destinationDirectory\u0026#34;; // 目标文件夹 try { copyDirectory(new File(sourceDir), new File(destDir)); System.out.println(\u0026#34;文件夹拷贝完成！\u0026#34;); } catch (IOException e) { e.printStackTrace(); } } // 递归复制文件夹 public static void copyDirectory(File sourceDir, File destDir) throws IOException { if (!sourceDir.exists()) { throw new IOException(\u0026#34;源文件夹不存在！\u0026#34;); } // 如果目标文件夹不存在，则创建它 if (!destDir.exists()) { destDir.mkdir(); } // 获取源文件夹中的所有文件和子文件夹 File[] files = sourceDir.listFiles(); if (files != null) { for (File file : files) { // 如果是文件，则直接拷贝 if (file.isFile()) { copyFile(file, new File(destDir, file.getName())); } else if (file.isDirectory()) { // 如果是文件夹，则递归调用 copyDirectory(file, new File(destDir, file.getName())); } } } } // 拷贝文件 private static void copyFile(File sourceFile, File destFile) throws IOException { try (InputStream in = new FileInputStream(sourceFile); OutputStream out = new FileOutputStream(destFile)) { byte[] buffer = new byte[1024]; // 缓冲区 int length; // 读取文件并写入目标文件 while ((length = in.read(buffer)) != -1) { out.write(buffer, 0, length); } } } } 文件字符流 字符流 = 字节流 + 编码表\nFileReader文件输入流 一次读取一个字节，遇到中文时一次读入多个字节\n构造方法\nFileReader(File file)：创建一个新的 FileReader，参数为File对象。 FileReader(String fileName)：创建一个新的 FileReader，参数为文件名。 FileReader(File file，Charset set)：创建一个新的 FileReader，参数为File对象和字符集。 读取数据\npublic int read()：每次可以读取一个字符，返回读取的字符（转为 int 类型），当读取到文件末尾时，返回-1 public int read(char[]buffer,int off,int len):读取多个字符到字符数组buffer，返回值为读入的字符数，读到文件末尾返回-1 释放资源\npublic int close()：释放字符流\nFileWriter文件输出流 构造方法\nFileWriter(File file)： 创建一个新的 FileWriter，参数为要读取的File对象。可以后跟Boolean参数指定是否追加数据 FileWriter(String fileName)： 创建一个新的 FileWriter，参数为要读取的文件的名称。可以后跟Boolean参数指定是否追加数据 写入数据\npublic void write(int b)：写入一个ASCII码为b的字符 public void write(String b)：写入字符串 public void write(String str, int off, int len) ：将指定字符串的一部分写入输出流 public void write(char[] cbuf) ：将指定字符数组写入输出流 public void write(char[] cbuf, int off, int len) ：将指定字符数组的一部分写入输出流 关闭和刷新\nflush() ：刷新缓冲区，将缓冲区中的数据强制写入目标设备或流中,流对象可以继续使用。 close() ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 缓冲流： 缓冲流是对基础流的包装，可以显著提高 I/O 性能。常见的缓冲流有 BufferedInputStream、BufferedOutputStream、BufferedReader 和 BufferedWriter，它们通过内部缓冲区减少实际 I/O 操作的次数。\n在处理大文件或频繁 I/O 操作时，使用缓冲流可以有效提高性能。\n字节缓冲流 底层自带8KB的缓冲区\nBufferedInputStream 字节缓冲输入流 构造方法\nBufferedInputStream(InputStream in) ：创建一个新的缓冲输入流，注意参数类型为InputStream。\n读入数据\npublic int read()：read()方法会读取一个字节并返回其整数表示。如果已经到达文件的末尾，则返回 -1。如果在读取时发生错误，则会抛出 IOException 异常。 public int read(byte[] b) throws IOException：读取数据并将其存储在字节数组 b 中。返回实际读取的字节数。 public int read(byte[] b, int off, int len) throws IOException：从文件中读取最多 len 个字节的数据，存储到字节数组 b 中，从偏移量 off 开始。返回实际读取的字节数。 BufferedOutputStream字节缓冲输出流 构造方法\nBufferedOutputStream(OutputStream in) ：创建一个新的缓冲输入流，注意参数类型为OutputStream。\n写入数据\npublic void write(int b)：写入一个ASCII码为b的字符 public void write(String b)：写入字符串 public void write(String str, int off, int len) ：将指定字符串的一部分写入输出流 public void write(char[] cbuf) ：将指定字符数组写入输出流 public void write(char[] cbuf, int off, int len) ：将指定字符数组的一部分写入输出流 关闭和刷新\nflush() ：刷新缓冲区，将缓冲区中的数据强制写入目标设备或流中,流对象可以继续使用。 close() ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。只用关闭高级流的流对象底层会自动关闭基本流 字符缓冲流 BufferedReader字符缓冲输入流 构造方法\nBufferedReader(Reader in) ：创建一个新的缓冲输入流，注意参数类型为Reader。 读取数据\npublic int read()：每次可以读取一个字符，返回读取的字符（转为 int 类型），当读取到文件末尾时，返回-1 public int read(char[]buffer,int off,int len):读取多个字符到字符数组buffer，返回值为读入的字符数，读到文件末尾返回-1 String readLine(): 读一行数据，读取到最后返回 null 释放资源\npublic int close()：释放字符流\nBufferedWriter字符缓冲输出流 构造方法\nBufferedWriter(Writer out)： 创建一个新的缓冲输出流，注意参数类型为Writer。 写入数据\npublic void write(int b)：写入一个ASCII码为b的字符 public void write(String b)：写入字符串 public void write(String str, int off, int len) ：将指定字符串的一部分写入输出流 public void write(char[] cbuf) ：将指定字符数组写入输出流 public void write(char[] cbuf, int off, int len) ：将指定字符数组的一部分写入输出流 public void newLine()：输出换行符 关闭和刷新\nflush() ：刷新缓冲区，将缓冲区中的数据强制写入目标设备或流中,流对象可以继续使用。 close() ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 转换流 将字符流和字节流进行连接，实现互相转换\nInputStreamReader ：将一个字节输入流转换为一个字符输入流，\nOutputStreamWriter ：将一个字节输出流转换为一个字符输出流。\n它们使用指定的字符集将字节流和字符流之间进行转换。常用的字符集包括 UTF-8、GBK、ISO-8859-1 等。\nInputStreamReader 作用 将字节流（InputStream）转换为字符流（Reader） 同时支持指定的字符集编码方式，从而实现字节流到字符流之间的转换。 构造方法 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 常用方法 read()：从输入流中读取一个字符的数据。 read(char[] cbuf, int off, int len)：从输入流中读取 len 个字符的数据到指定的字符数组 cbuf 中，从 off 位置开始存放。 ready()：返回此流是否已准备好读取。 close()：关闭输入流。 OutputStreamWriter 作用 将字符流（Writer）转换为字节流（OutputStream） 同时支持指定的字符集编码方式，从而实现字符流到字节流之间的转换。 构造方法 OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字节流。 OutputStreamWriter(OutputStream in, String charsetName)：创建一个指定字符集的字节流。 常用方法 write(int c)：向输出流中写入一个字符的数据。 write(char[] cbuf, int off, int len)：向输出流中写入指定字符数组 cbuf 中的 len 个字符，从 off 位置开始。 flush()：将缓冲区的数据写入输出流中。 close()：关闭输出流 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 try { // 从文件读取字节流，使用UTF-8编码方式 FileInputStream fis = new FileInputStream(\u0026#34;test.txt\u0026#34;); // 将字节流转换为字符流，使用UTF-8编码方式 InputStreamReader isr = new InputStreamReader(fis, \u0026#34;UTF-8\u0026#34;); // 使用缓冲流包装字符流，提高读取效率 BufferedReader br = new BufferedReader(isr); // 创建输出流，使用UTF-8编码方式 FileOutputStream fos = new FileOutputStream(\u0026#34;output.txt\u0026#34;); // 将输出流包装为转换流，使用UTF-8编码方式 OutputStreamWriter osw = new OutputStreamWriter(fos, \u0026#34;UTF-8\u0026#34;); // 使用缓冲流包装转换流，提高写入效率 BufferedWriter bw = new BufferedWriter(osw); // 读取输入文件的每一行，写入到输出文件中 String line; while ((line = br.readLine()) != null) { bw.write(line); bw.newLine(); // 每行结束后写入一个换行符 } // 关闭流 br.close(); bw.close(); } catch (IOException e) { e.printStackTrace(); } 序列化流 序列化\n是将对象转换为字节流的过程，这样对象可以通过网络传输、持久化存储或者缓存。Java 提供了 java.io.Serializable 接口来支持序列化，只要类实现了这个接口，就可以将该类的对象进行序列化。\n反序列化\n是将字节流重新转换为对象的过程，即从存储中读取数据并重新创建对象。\nObjectOutputStream序列化流 构造方法 ObjectOutputStream(OutputStream out)\n1 2 FileOutputStream fos = new FileOutputStream(\u0026#34;file.txt\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); 写入方法 public final writeObject (Object obj)：写入一个对象 public void write(int b) throws IOException public void write(byte[] b, int off, int len) throws IOException 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class ObjectOutputStreamDemo { public static void main(String[] args) { Person person = new Person(\u0026#34;沉默王二\u0026#34;, 20); try { FileOutputStream fos = new FileOutputStream(\u0026#34;logs/person.dat\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(person); oos.close(); } catch (IOException e) { e.printStackTrace(); } } } class Person implements Serializable { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } } ObjectInputStream反序列化流 ObjectInputStream 可以读取 ObjectOutputStream 写入的字节流，并将其反序列化为相应的对象（包含对象的数据、对象的类型和对象中存储的属性等信息）。\n构造方法 ObjectInputStream(InputStream in) 读入方法 public Object readObject()：读入对象 public void read()：读一个字节 Serializable序列化接口 定义\n1 2 public interface Serializable { } 注意事项\nstatic和 transient修饰的字段是不会被序列化的 被反序列化后，transient 字段的值被设为初始值 Java底层根据类的内容对实现了Serializable接口的类计算出类型为long的版本号serialVersionUID，若类的代码发生改变会使版本号改变导致无法反序列化 Java 虚拟机会把字节流中的 serialVersionUID 与被序列化类中的 serialVersionUID 进行比较，如果相同则可以进行反序列化，否则就会抛出序列化版本不一致的异常 通常使用private ，static ，final 来修饰serialVersionUID transient瞬态关键字 在实际开发过程中，不需要被序列化的字段，比如说用户的一些敏感信息（如密码、银行卡号等），为了安全起见，不希望在网络操作中传输或者持久化到磁盘文件中，那这些字段就可以加上 transient 关键字。\n被 transient 关键字修饰的成员变量在反序列化时会被自动初始化为默认值\n","date":"2024-11-19T16:32:57+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84io%E6%B5%81/","title":"Java中的IO流"},{"content":"File类 File类是文件的抽象表示，用于文件与目录的创建，查找，删除，只能对文件本身操作，不能对文件内容操作\n构造方法 public File(String pathname) // 根据路径创建文件对象 public File(String parent, String child) // 根据父路径和子路径创建文件对象 public File(File parent, String child) // 根据父目录 File 对象和子路径创建文件对象 注意事项\nFile对象代表硬盘中实际存在的文件和目录 File类的构造方法不检查是否存在该路径 常见操作 判断文件/目录 public boolean isFile()：判断是否是文件 public boolean isDirectory()：判断是否为目录 获取文件/目录的基本信息 public String getName()：获取文件名 public String getAbsolutePath()：获取绝对路径 public String getParent()：获取父目录 public long length()：获取文件大小（以B为单位） public long lastModified()：获取最后修改时间 检查读/写/可执行权限 public boolean canRead() public boolean canWrite() public boolean canExecute() 创建文件/目录 public boolean createNewFile() throws IOException：创建文件 原先文件不存在则创建成功返回true 原先文件存在则创建失败返回false 创建目录 public boolean mkdir()：创建单级目录，父目录不存在则创建失败 public boolean mkdirs()：创建多级目录，父目录不存在则一并创建 删除文件目录 public boolean delete() 列举目录文件 public String[] list()：列出目录中的文件名 public File[] listFiles()：列出目录中的File对象 ","date":"2024-11-17T15:48:33+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","title":"Java的文件操作"},{"content":"异常的定义 在 Java 中，异常（Exception） 是程序运行过程中发生的一种错误或意外情况，可能会中断程序的正常执行流程。异常机制通过捕获和处理错误，避免程序崩溃，提供了一种高效的错误管理方式。\n本质：异常是一个对象，表示程序运行中的问题。\n异常的继承结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 java.lang.Object └── java.lang.Throwable ├── java.lang.Error │ ├── VirtualMachineError │ │ ├── OutOfMemoryError │ │ ├── StackOverflowError │ │ └── InternalError │ ├── LinkageError │ └── AssertionError └── java.lang.Exception ├── IOException │ ├── FileNotFoundException │ └── EOFException ├── RuntimeException │ ├── NullPointerException │ ├── ArithmeticException │ ├── ArrayIndexOutOfBoundsException │ ├── ClassCastException │ └── IllegalArgumentException ├── SQLException ├── ParseException └── ClassNotFoundException Throwable 类 所有错误和异常的超类。 定义了 printStackTrace() 、getMessage() 和 toString() 等常用方法。 Error 类 定义：表示程序运行时的严重问题，通常是 JVM 无法处理的情况。 特点 是 Throwable 的子类。 不受检查的异常，编译器不强制要求处理。 程序无法通过代码处理这些错误，通常由 JVM 抛出。 常见类型 OutOfMemoryError：JVM 堆内存耗尽。 StackOverflowError：递归调用过深导致栈溢出。 InternalError：JVM 内部错误。 Exception 类 定义：表示程序中可预料的问题，可以通过代码进行捕获和处理。\n特点：\n是 Throwable 的子类。 包括两种子类： 受检异常（Checked Exception）：在源代码里必须显式地捕获或者抛出，否则编译器会提示你进行相应的操作。 非受检异常（Unchecked Exception，RuntimeException）：通常是由程序逻辑错误导致的，可以通过编码进行规避的，并不需要显式地捕获或者抛出。 Exception和Error的区别 Exception 和 Error 都是 Throwable 类的子类（在 Java 代码中只有继承了 Throwable 类的实例才可以被 throw 或者被 catch）它们表示在程序运行时发生的异常或错误情况。\n总结来看：Exception 表示可以被处理的程序异常，Error 表示系统级的不可恢复错误。\nException：是程序中可以处理的异常情况，表示程序逻辑或外部环境中的问题，可以通过代码进行恢复或处理。Exception 又分为 Checked Exception（编译期异常）和 Unchecked Exception（运行时异常）。\nChecked Exception：在编译时必须显式处理（如使用 try-catch 块或通过 throws 声明抛出）。如 IOException。\nUnchecked Exception：运行时异常，不需要显式捕获。常见的如 NullPointerException、IllegalArgumentException 等，继承自 RuntimeException。\nError：表示严重的错误，通常是 JVM 层次内系统级的、无法预料的错误，程序无法通过代码进行处理或恢复。例如内存耗尽（ OutOfMemoryError ）、栈溢出（ StackOverflowError ）。Error 不应该被程序捕获或处理，因为一般出现这种错误时程序无法继续运行。\n异常的处理方式 JVM默认处理方式 查找异常处理器：\nJVM 会尝试在当前方法调用栈中寻找匹配该异常的处理器（ catch 块）。\n如果找到对应的处理器，程序会进入相应的 catch 块执行。\n未找到处理器：\n如果当前方法没有匹配的异常处理器，JVM 会将该异常抛给调用它的方法。\n这个过程会沿着方法调用栈向上查找，直到主方法 main() 。\n异常到达 main() 方法：\n如果异常传播到 main() 方法仍然未被捕获，JVM 默认的异常处理机制会接管。 异常信息打印：\nJVM 会调用异常对象的 **printStackTrace()**方法，打印异常的堆栈跟踪信息\n异常类型（如 NullPointerException 、ArithmeticException 等）。 异常的详细信息（如异常消息）。 异常发生的代码位置（方法名和行号）。 堆栈信息从异常发生的位置开始，逐步列出调用栈的各个方法。\n终止程序： 打印完堆栈跟踪信息后，JVM 会终止程序的执行。\n捕获并处理异常 try-catch-finally块 使用 try-catch-finally 块捕获异常并对其进行处理。\n语法格式\n1 2 3 4 5 6 7 8 9 try { // 可能抛出异常的代码 } catch (ExceptionType1 e1) { // 处理 ExceptionType1 的异常 } catch (ExceptionType2 e2) { // 处理 ExceptionType2 的异常 } finally { // 可选：无论是否发生异常，都会执行的代码 } try 块中包含可能抛出异常的代码 catch 块用于捕获并处理特定类型的异常。可以有多个catch块来处理不同类型的异常。 finally 块：用于定义无论是否发生异常都会执行的代码块。通常用于释放资源，确保资源的正确关闭。 执行流程\n没有异常\n当 try 块中没有发生异常时：\n执行 try 块中的代码（ return 之前的部分），将 return 中的返回值暂时保存。 跳过 catch 块。 执行 finally 块中的代码，如果 finally 中有 return 则覆盖之前的返回值。 return 返回值并继续执行后续代码。 try中没有return的示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Main { public static void main(String[] args) { try { System.out.println(\u0026#34;try block executed\u0026#34;); } catch (Exception e) { System.out.println(\u0026#34;catch block executed\u0026#34;); } finally { System.out.println(\u0026#34;finally block executed\u0026#34;); } System.out.println(\u0026#34;program continues\u0026#34;); } } // 输出： // try block executed // finally block executed // program continues try中有return的示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Main { public static int test() { try { System.out.println(\u0026#34;try block executed\u0026#34;); return 1; // 返回值暂时保存 } catch (Exception e) { System.out.println(\u0026#34;catch block executed\u0026#34;); return 2; } finally { System.out.println(\u0026#34;finally block executed\u0026#34;); } } public static void main(String[] args) { System.out.println(\u0026#34;Return value: \u0026#34; + test()); } } // 输出： // try block executed // finally block executed // Return value: 1 异常发生且被捕获\n当 try 块中发生异常，并且异常被 catch 块捕获时：\n执行 try 块，直到发生异常的位置。 跳转到对应的 catch 块，执行 return 之前的代码，将返回值暂存。 执行 finally 块中的代码，如果 finally 中有 return 则覆盖之前的返回值。 返回之前的返回值或继续执行后续代码。 catch中没有return的示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Main { public static void main(String[] args) { try { System.out.println(\u0026#34;try block executed\u0026#34;); int result = 10 / 0; // 抛出异常 } catch (ArithmeticException e) { System.out.println(\u0026#34;catch block executed: \u0026#34; + e.getMessage()); } finally { System.out.println(\u0026#34;finally block executed\u0026#34;); } System.out.println(\u0026#34;program continues\u0026#34;); } } // 输出： // try block executed // catch block executed: / by zero // finally block executed // program continues catch中有return的示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Main { public static int test() { try { System.out.println(\u0026#34;try block executed\u0026#34;); int result = 10 / 0; // 抛出异常 } catch (ArithmeticException e) { System.out.println(\u0026#34;catch block executed: \u0026#34; + e.getMessage()); return 2; // 被暂存 } finally { System.out.println(\u0026#34;finally block executed\u0026#34;); return 3; // 覆盖之前的返回值 } } public static void main(String[] args) { System.out.println(\u0026#34;Return value: \u0026#34; + test()); } } // 输出： // try block executed // catch block executed: / by zero // finally block executed // Return value: 3 特点\n当不出现异常时， try 块中的代码正常执行 当 try 块中可能出现多种异常时，书写多个对应的 catch 块捕获异常 一个 catch 只能处理一种异常 可以在 catch 块中同时捕获多种异常，异常之间用|隔开，表示多种异常采用相同的处理方式 当 try 中的异常没有被捕获则执行JVM默认异常处理方式 尽量将特定的异常放在前面，通用型的异常放在后面，不然编译器只会提示通用型的异常，其他的 catch 块永远也不会执行 finally 块的特点 如果 finally 块中包含 return 语句，会覆盖 try 或 catch 块中的 return 值。 finally 块前面必须有 try 块，不要把 finally 块单独拉出来使用。编译器也不允许这样做。 finally 块不是必选项，有 try 块的时候不一定要有 finally 块。 如果 finally 块中的代码可能会发生异常，也应该使用 try-catch 进行包裹。 即便是 try 块中执行了 return 、break、continue 这些跳转语句， finally 块也会被执行。 如果 catch 块抛出一个异常，而 finally 块中也抛出异常，那么最终抛出的将是 finally 块中的异常。 catch 块中的异常会被丢弃，而 finally 块中的异常会覆盖并向上传递。 finally 块中的逻辑一定被执行，无论是否出现异常，如果在 try 或 catch 块中调用了 System.exit() 方法，或者程序被强制终止， finally 块不会执行 try-with-resources 块 try-with-resources 是 Java 中的一种简洁方式，用于自动管理资源。资源在使用完成后会被自动关闭，而无需显式调用 close() 方法，从而减少资源泄漏的风险。\n它是在 Java 7 中引入的，资源必须实现 java.lang.AutoCloseable 接口（或其子接口 java.io.Closeable ）。\n语法格式\n1 2 3 4 5 try (ResourceType resource = new ResourceType()) { // 使用资源的代码 } catch (ExceptionType e) { // 异常处理 } ResourceType：资源类型，例如文件流、数据库连接等。\n资源自动关闭：在 try 块结束后，resource 会自动调用 close() 方法。\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import java.io.BufferedReader; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; public class MultiResourceExample { public static void main(String[] args) { try ( BufferedReader reader = new BufferedReader(new FileReader(\u0026#34;input.txt\u0026#34;)); FileWriter writer = new FileWriter(\u0026#34;output.txt\u0026#34;) ) { String line; while ((line = reader.readLine()) != null) { writer.write(line + \u0026#34;\\n\u0026#34;); } } catch (IOException e) { System.out.println(\u0026#34;Error occurred: \u0026#34; + e.getMessage()); } } } 抛出异常 在方法声明中使用 throws 关键字\n在方法体中使用 throw 手动抛出异常\nthrows关键字 作用：声明一个方法可能抛出的异常，将异常传递给调用者来处理，用于通知调用该方法的代码，必须处理这些异常。 语法：放在方法签名中，位于参数列表和方法体之间。 适用范围：主要用于受检异常（Checked Exception）。 支持多个异常：可以在 throws 后列出多个异常类型，用逗号分隔。 语法格式\n1 method() throws ExceptionType { ... } 使用 throws 关键字，在方法签名上声明可能会抛出的异常，然后在调用该方法的地方使用 try-catch 进行处理。”\n示例\n1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String args[]){ try { myMethod1(); } catch (ArithmeticException e) { // 算术异常 } catch (NullPointerException e) { // 空指针异常 } } public static void myMethod1() throws ArithmeticException, NullPointerException{ // 方法签名上声明异常 } throw 关键字 作用：在方法体或代码块中，实际抛出一个异常对象，用于在代码中触发异常处理逻辑 语法：后面必须紧跟一个异常对象的实例（new ExceptionType(...)）。 适用范围：可以抛出任何异常（受检异常和运行时异常）。 每次只能抛出一个异常：不能同时抛出多个异常。 自定义异常 在 Java 中，除了使用内置异常（如 IOException 或 NullPointerException），还可以根据具体需求定义自己的异常类。自定义异常通常用于表示应用程序中的特定错误场景，提供更清晰的错误语义。\n实现方法 定义异常类：根据业务逻辑定义异常类\n继承现有异常类：\n通常从 Exception 或 RuntimeException 类派生。 如果希望异常必须被显式捕获（受检异常），继承 Exception 。 如果希望异常可以被选择性捕获（非受检异常），继承 RuntimeException 。 提供构造函数：\n提供默认构造函数。 提供接受错误消息和/或原因（Throwable）的构造函数。 定义受检异常 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 自定义受检异常 class CustomCheckedException extends Exception { public CustomCheckedException() { super(); } public CustomCheckedException(String message) { super(message); } public CustomCheckedException(String message, Throwable cause) { super(message, cause); } public CustomCheckedException(Throwable cause) { super(cause); } } public class CheckedExceptionDemo { public static void main(String[] args) { try { throwCustomException(); } catch (CustomCheckedException e) { System.out.println(\u0026#34;Caught exception: \u0026#34; + e.getMessage()); } } public static void throwCustomException() throws CustomCheckedException { throw new CustomCheckedException(\u0026#34;This is a custom checked exception\u0026#34;); } } 定义非受检异常 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 自定义非受检异常 class CustomUncheckedException extends RuntimeException { public CustomUncheckedException() { super(); } public CustomUncheckedException(String message) { super(message); } public CustomUncheckedException(String message, Throwable cause) { super(message, cause); } public CustomUncheckedException(Throwable cause) { super(cause); } } public class UncheckedExceptionDemo { public static void main(String[] args) { try { throwCustomException(); } catch (CustomUncheckedException e) { System.out.println(\u0026#34;Caught exception: \u0026#34; + e.getMessage()); } } public static void throwCustomException() { throw new CustomUncheckedException(\u0026#34;This is a custom unchecked exception\u0026#34;); } } ","date":"2024-11-16T15:20:48+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","title":"Java中的异常处理"},{"content":"MyBatis-Plus对MyBatis的改进 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 MyBatis和MyBatis-Plus开发流程的区别 MyBatis开发流程 引入相关依赖\n定义被@Mapper注解修饰mapper接口以及相关方法\n1 2 3 4 @Mapper public interface DistrictMapper { List\u0026lt;District\u0026gt;searchAll(String tname); } 在对应mapper.xml文件中书写对应的SQL语句或者在mapper接口中使用注解书写SQL语句\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34; \u0026gt; \u0026lt;mapper namespace=\u0026#34;org.example.operator.mapper.DistrictMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;searchAll\u0026#34; resultType=\u0026#34;org.example.operator.pojo.entity.District\u0026#34;\u0026gt; select did,dname,tdid,content,d_url,district.tid from district left join theme on district.tid = theme.tid where theme.tname = #{tname} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 在Service层中创建对应的Service接口\n1 2 3 4 5 6 7 package org.example.operator.service; import org.example.operator.pojo.dto.District.DistrictDTO; public interface DistrictDetailService { public void updateDistrictDetail(DistrictDTO districtDTO,String oldName); } 以及Service接口的实现类注入Mapper对象实现业务逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package org.example.operator.service.impl; import org.example.operator.common.exception.District.DistrictNotFound; import org.example.operator.common.exception.Theme.ThemeNotFound; import org.example.operator.common.utils.AliyunOSSUtils; import org.example.operator.mapper.DistrictMapper; import org.example.operator.mapper.ThemeMapper; import org.example.operator.pojo.dto.District.DistrictDTO; import org.example.operator.pojo.entity.District; import org.example.operator.pojo.entity.Theme; import org.example.operator.service.DistrictDetailService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; @Service public class DistrictDetailServiceImpl implements DistrictDetailService { @Autowired private ThemeMapper themeMapper; @Autowired private DistrictMapper districtMapper; @Autowired private AliyunOSSUtils aliyunOSSUtils; @Transactional @Override public void updateDistrictDetail(DistrictDTO districtDTO, String oldName) { String tname = districtDTO.getTname(); Theme theme = themeMapper.getThemeByName(tname); if (theme == null) { throw new ThemeNotFound(\u0026#34;主题不存在\u0026#34;); } District district = districtMapper.getDistrictByName(oldName); if (district == null) { throw new DistrictNotFound(\u0026#34;展品不存在\u0026#34;); } String durl = district.getD_url(); aliyunOSSUtils.deleteExhibitImage(durl); Long did = district.getDid(); Long tid = themeMapper.getThemeIdByName(districtDTO.getTname()); districtDTO.setDid(did); districtDTO.setTid(tid); districtMapper.updateDistrictDetail(districtDTO); districtMapper.updateDistrictTdid(districtDTO); } } 在Controller层使用Service接口对象进行响应\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.multipart.MultipartFile; @RestController @Slf4j @RequestMapping(\u0026#34;Operator/productDetail\u0026#34;) public class DistrictDetailController { @Autowired private DistrictSummeryService districtSummeryService; @Autowired private AliyunOSSUtils aliyunOSSUtils; @Autowired private DistrictDetailService districtDetailService; @RequestMapping(\u0026#34;/getProduct\u0026#34;) public Result\u0026lt;DistrictDetailVO\u0026gt; getProduct(String dname) { try{ DistrictDetailVO districtDetailVO = districtSummeryService.getDistrictDetail(dname); log.info(\u0026#34;展品详情：{}\u0026#34;, districtDetailVO); return Result.success(\u0026#34;查询展品详情成功\u0026#34;,districtDetailVO); } catch (Exception e){ log.error(\u0026#34;查询展品详情失败\u0026#34;); return Result.error(\u0026#34;查询展品详情失败\u0026#34;); } } } MyBatis-Plus开发流程 引入相关依赖\n自定义Mapper继承MyBatis-Plus提供的接口BaseMapper，对于自定义SQL语句可以在对应mapper.xml文件中书写\n1 2 3 public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt;{ } 在Service层自定义Service接口继承IService接口\n1 2 3 public interface IUserService extends IService\u0026lt;User\u0026gt;{ } 自定义Service实现类，实现自定义接口并继承Servicelmpl类，注入Mapper对象实现业务逻辑（Wrapper条件构造器在这里使用）\n1 2 3 4 @Service public class UserServiceImpl extends ServiceImpl\u0026lt;UserMapper,User\u0026gt; implements IUserService{ } 在Controller层使用Service接口对象进行响应\n具体使用 引入依赖（参见官方文档 ），MyBatisPlus官方提供了starter，其中集成了Mybatis和MybatisPlus的所有功能，并且实现了自动装配效果。因此我们可以用MybatisPlus的starter代替Mybatis的starter:\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-spring-boot3-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 定义Mapper：自定义Mapper继承MyBatis-Plus提供的接口BaseMapper\n1 2 3 public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt;{ } 默认配置 MyBatis-Plus通过扫描实体类，利用反射机制获取实体类的信息作为数据库表的信息\n类名驼峰转下划线作为表名 名为id的字段作为主键 变量名驼峰转下划线作为表的字段名 1 2 3 public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt;{ } 1 2 3 4 5 6 7 8 9 10 11 public class User{ private Long id; private String username; private string password; private String phone; private string info; private Integer status; private Integer balance; private LocalDateTime createTime; //对应表的字段 create_time private LocalDateTime updateTime; //对应表的字段 update_time } 自定义配置 如果不符合Mybatis-Plus的约定就要使用自定义配置。\n基于注解的配置 @TableName：用来指定表名（该注解用于指定实体类对应的数据库表名。当实体类名与数据库表名不一致，或者实体类名不是数据库表名的驼峰写法时，您需要使用这个注解来明确指定表名。） @TableId：用来指定表中的主键字段信息 value：对应数据库表中的主键字段名 type：主键策略 AUTO：数据库自增长 INPUT：通过set方法自行输入 ASSIGN_ID：分配id @TableField ：用来指定表中的普通字段信息 使用场景 成员变量名与数据库字段名不一致 成员变量名以is开头，且是布尔值(经过反射处理，它会将is去掉作为数据库字段名) 成员变量名与数据库关键字冲突 成员变量名不是数据库字段(数据库中不存在该字段) 具体注解参考官方文档\n基于yml的注解 在SpringBoot项目中可以通过修改application.yml来配置\n1 2 3 4 5 6 7 8 9 10 11 mybatis-plus: type-aliases-package: com.gty.mp.domain.po #注册后，在 Mapper 对应的 XML 文件中可以直接使用类名，无需使用全限定类名。 mapper-locations: \u0026#34;classpath*:/mapper/**/*.xml\u0026#34; #mapper.xml文件地址, 默认值 configuration: map-underscore-to-camel-case: true #是否开启下划线和驼峰的映射 cache-enabled: true #是否开启二级映射 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl #开启mybatis打印日志 global-config: db-config: id-type: assign_id #id为雪花算法生成,注解配置大于全局配置 update-strategy: not_null # 更新策略:只更新非空字段 具体详细配置参考官方文档\n条件构造器（Wrapper） MyBatis-Plus 提供了一套强大的条件构造器（Wrapper），用于构建复杂的数据库查询条件。（BaseMapper实现简单的单表查询）\nWrapper 类允许开发者以链式调用的方式构造查询条件，无需编写繁琐的 SQL 语句，从而提高开发效率并减少 SQL 注入的风险。\n通常作为mapper方法（自定义在mapper接口或者MyBatis-Plus已经实现的）的参数在service层使用\n类的继承结构 AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件\nQueryWrapper ： Query条件封装 UpdateWrapper ： Update条件封装 AbstractLambdaWrapper ： 使用Lambda语法 LambdaQueryWrapper ：基于Lambda语法使用的查询Wrapper LambdaUpdateWrapper ： 基于Lambda语法使用的更新Wrapper QueryWrapper和LambdaQueryWrapper通常用来构建select、delete、update的where条件部分\nUpdateWrapper和LambdaUpdateWrapper通常只有在set语句比较特殊才使用\n具体使用 创建Wrapper对象 Wrappers静态方法： public static \u0026lt;T\u0026gt; QueryWrapper\u0026lt;T\u0026gt; query() 通过QueryWrapper对象的构造方法： public QueryWrapper() 通过lambda方法可以将普通Wrapper转换成lambdaWrapper 基于复杂条件构建wrapper，使用链式编程 示例方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package com.dfbz; import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.baomidou.mybatisplus.core.toolkit.Wrappers; import com.dfbz.entity.User; import com.dfbz.mapper.UserMapper; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import java.util.List; /** * @author lscl * @version 1.0 * @intro: */ @SpringBootTest(classes = MyBatisPlusApplication.class) @RunWith(SpringRunner.class) public class Demo06_LambdaQueryMapper { @Autowired private UserMapper userMapper; /** * 使用QueryWrapper * @throws Exception */ @Test public void test1() throws Exception { QueryWrapper\u0026lt;User\u0026gt; wrapper = Wrappers.query(); wrapper.eq(\u0026#34;id\u0026#34;,\u0026#34;1\u0026#34;); List\u0026lt;User\u0026gt; userList = userMapper.selectList(wrapper); for (User user : userList) { System.out.println(user); } } /** * 使用LambdaQueryWrapper * @throws Exception */ @Test public void test2() throws Exception { LambdaQueryWrapper\u0026lt;User\u0026gt; wrapper = Wrappers.lambdaQuery(); // id=1 // wrapper.eq(User::getId,1); // select id,name,age from user where id in (1,2,3) and name like \u0026#34;%a%\u0026#34; wrapper.in(User::getId,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;) .like(User::getName,\u0026#34;a\u0026#34;) .select(User::getId,User::getName,User::getAge); List\u0026lt;User\u0026gt; userList = userMapper.selectList(wrapper); for (User user : userList) { System.out.println(user); } } } 条件方法 方法名 解释 示例 eq 等于 = eq(“name”, “老王”)**---\u0026gt;** name = ‘老王’ ne 不等于 \u0026lt;\u0026gt; ne(“name”, “老王”)**---\u0026gt;** name \u0026lt;\u0026gt; ‘老王’ gt 大于 \u0026gt; gt(“age”, 18)**---\u0026gt;** age \u0026gt; 18 ge 大于等于 \u0026gt;= ge(“age”, 18)**---\u0026gt;** age \u0026gt;= 18 lt 小于 \u0026lt; lt(“age”, 18)**---\u0026gt;** age \u0026lt; 18 le 小于等于 \u0026lt;= le(“age”, 18)**---\u0026gt;** age \u0026lt;= 18 between between 值1 and 值2 between(“age”, 18, 30)**---\u0026gt;** age between 18 and 30 notBetween not between 值1 and 值2 notBetween(“age”, 18, 30)**---\u0026gt;** age not between 18 and 30 like LIKE ‘%值%’ like(“name”, “王”)**---\u0026gt;** name like ‘%王%’ notLike NOT LIKE ‘%值%’ notLike(“name”, “王”)**---\u0026gt;** name not like ‘%王%’ likeLeft LIKE ‘%值’ likeLeft(“name”, “王”)**---\u0026gt;** name like ‘%王’ likeRight LIKE ‘值%’ likeRight(“name”, “王”)**---\u0026gt;** name like ‘王%’ isNull 字段 IS NULL isNull(“name”)**---\u0026gt;** name is null isNotNull 字段 IS NOT NULL isNotNull(“name”)**---\u0026gt;** name is not null in 字段 IN (v0, v1, …) in(“age”, 1, 2, 3)**---\u0026gt;** age in (1,2,3) notIn 字段 NOT IN (v0, v1, …) notIn(“age”, 1, 2, 3)**---\u0026gt;** age not in (1,2,3) inSql 字段 IN ( sql语句 ) inSql(“id”, “select id from table where id \u0026lt; 3”)**---\u0026gt;** id in (select id from table where id \u0026lt; 3) notInSql 字段 NOT IN ( sql语句 ) notInSql(“id”, “select id from table where id \u0026lt; 3”)**---\u0026gt;** id not in (select id from table where id \u0026lt; 3) groupBy 分组：GROUP BY 字段, … groupBy(“id”, “name”)**---\u0026gt;** group by id,name orderByAsc 排序：ORDER BY 字段, … ASC orderByAsc(“id”, “name”)**---\u0026gt;** order by id ASC,name ASC orderByDesc 排序：ORDER BY 字段, … DESC orderByDesc(“id”, “name”)**---\u0026gt;** order by id DESC,name DESC orderBy 排序：ORDER BY 字段, … orderBy(true, true, “id”, “name”)**---\u0026gt;** order by id ASC,name ASC having HAVING ( sql语句 ) 例1：having(“sum(age) \u0026gt; 10”)**---\u0026gt;** having sum(age) \u0026gt; 10 例2：having(“sum(age) \u0026gt; {0}”, 11)**---\u0026gt;** having sum(age) \u0026gt; 11 func 主要解决条件拼接 func(i -\u0026gt; if(true) {i.eq(“id”, 1)} else {i.ne(“id”, 1)}) or 拼接 OR eq(“id”,1).or().eq(“name”,“老王”)**---\u0026gt;** id = 1 or name = ‘老王’ and AND 嵌套 and(i -\u0026gt; i.eq(“name”, “李白”).ne(“status”, “活着”))**---\u0026gt;** and (name = ‘李白’ and status \u0026lt;\u0026gt; ‘活着’) nested 用于多条件拼接时 nested(i -\u0026gt; i.eq(“name”, “李白”).ne(“status”, “活着”))**---\u0026gt;** (name = ‘李白’ and status \u0026lt;\u0026gt; ‘活着’) apply 用于拼接SQL语句 例1：apply(“id = 1”)**---\u0026gt;** id = 1 例2：apply(“id = {0}”,1)**---\u0026gt;** *id = 1 例3：apply(“name like {0} and age \u0026gt; {1}”,“%J%”,18) **\\*\\*---\u0026gt;\\*\\* *name like ‘%J%’ and age \u0026gt; 18 last 无视优化规则直接拼接到 sql 的最后 *last(“limit 1”) **\\*\\*---\u0026gt;\\*\\* *在SQL语句最后面拼接：limit 1 exists 拼接 EXISTS ( sql语句 ) exists(“select id from table where age = 1”)**---\u0026gt;** exists (select id from table where age = 1) notExists 拼接 NOT EXISTS ( sql语句 ) notExists(“select id from table where age = 1”)**---\u0026gt;** not exists (select id from table where age = 1) 具体参见官方文档\n自定义SQL 可以利用MyBatis-Plus的Wrapper来构建复杂的where条件，然后自己定义SQL语句中剩下的部分。\n基于Wrapper定义复杂的Where条件\n在mapper方法参数中用@Param注解声明wrapper变量名称，名称必须为ew或者使用注解 @Param(Constants.WRAPPER) 明确指定参数为 Wrapper 对象。\n1 2 3 4 5 6 7 8 import com.baomidou.mybatisplus.core.conditions.Wrapper; import com.baomidou.mybatisplus.core.toolkit.Constants; import org.apache.ibatis.annotations.Param; public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt; { @Select(\u0026#34;SELECT * FROM user ${ew.customSqlSegment}\u0026#34;) List\u0026lt;User\u0026gt; selectByCustomSql(@Param(Constants.WRAPPER) Wrapper\u0026lt;User\u0026gt; wrapper); } 自定义SQL语句，使用${ew.customSqlSegment}来引用 Wrapper 对象生成的 SQL 片段。\n1 2 3 QueryWrapper\u0026lt;User\u0026gt; queryWrapper = new QueryWrapper\u0026lt;\u0026gt;(); queryWrapper.eq(\u0026#34;name\u0026#34;, \u0026#34;张三\u0026#34;); List\u0026lt;User\u0026gt; userList = userMapper.selectByCustomSql(queryWrapper); Service层接口（IService） MyBatis提供了Service层接口IService和默认实现类ServiceImpl\n使用流程 自定义Service接口继承IService接口（其中IService接口中的泛型为操纵的实体类）\n1 2 3 public interface IUserService extends IService\u0026lt;User\u0026gt;{ } 自定义Service实现类，实现自定义接口并继承Servicelmpl类（其中ServiceImpl中的泛型为对应的Mapper类和实体类）\n1 2 3 4 @Service public class UserServiceImpl extends ServiceImpl\u0026lt;UserMapper,User\u0026gt; implements IUserService{ } LambdaQuery和LambdaUpdate IService中还提供了Lambda功能来简化我们的复杂查询及更新功能。\n在Service层中可以代替Wrapper实现更加复杂的查询/更新\nlambdaQuery()和lambdaUpdate()方法直接获得一个Wrapper的子类通过链式编程简化\n在service层中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Override public List\u0026lt;User\u0026gt; queryUsers(UserQuery userQuery) { return lambdaQuery() .like(userQuery.getName() != null, User::getUsername, userQuery.getName()) .eq(userQuery.getStatus() != null, User::getStatus, userQuery.getStatus()) .ge(userQuery.getMinBalance() != null, User::getBalance, userQuery.getMinBalance()) .le(userQuery.getMaxBalance() != null, User::getBalance, userQuery.getMaxBalance()) .list(); } @Override public void deductionBalance(Long id, Integer money) { // 1.查询用户 User user = getById(id); // 2.校验用户状态 if (user == null || user.getStatus() == UserStatus.FREEZE) { throw new RuntimeException(\u0026#34;用户状态异常!\u0026#34;); } // 3.校验余额是否充足 if (user.getBalance() \u0026lt; money) { throw new RuntimeException(\u0026#34;用户余额不足\u0026#34;); } // 4.扣减余额 int remainBalance = user.getBalance() - money; lambdaUpdate() .set(User::getBalance, remainBalance) .set(remainBalance == 0, User::getStatus, UserStatus.FREEZE) .eq(User::getId, id) .eq(User::getBalance, user.getBalance()) //乐观锁 .update(); } 还需要在链式编程的最后添加一个list()，这是在告诉MP我们的调用结果需要是一个list集合。这里不仅可以用list()，可选的方法有：\n.one()：最多1个结果 .list()：返回集合结果 .count()：返回计数结果 批量插入 1 2 3 4 // 插入（批量） boolean saveBatch(Collection\u0026lt;T\u0026gt; entityList); // 插入（批量） boolean saveBatch(Collection\u0026lt;T\u0026gt; entityList, int batchSize); 效率一般：MybatisPlus的批处理是基于PrepareStatement的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。而想得到最佳性能，最好是将多条SQL合并为一条。\n提升效率的方式\nMySQL的客户端连接参数中有这样的一个参数：rewriteBatchedStatements。顾名思义，就是重写批处理的statement语句。这个参数的默认值是false，我们需要修改连接参数，将其配置为true。\n在配置文件中，在数据库连接配置中在url后面加上 rewriteBatchedStatements=true 的一个参数：\n分页插件 具体参见官方文档\n在配置类中注册MyBatis-Plus的核心插件。同时添加分页插件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Configuration @MapperScan(\u0026#34;scan.your.mapper.package\u0026#34;) public class MybatisPlusConfig { /** * 添加分页插件 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { //创建MyBatis-Plus拦截器 MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); //添加内部拦截器（插件） // 添加分页插件 PaginationInnerInterceptor paginationInnerInterceptor = new PaginationInnerInterceptor(DbType.MYSQL); //可以给分页插件添加属性 //overflow\tboolean\tfalse\t溢出总页数后是否进行处理 //maxLimit\tLong\t单页分页条数限制 //dbType\tDbType\t数据库类型 //dialect\tIDialect\t方言实现类 interceptor.addInnerInterceptor(paginationInnerInterceptor); // 如果配置多个插件, 切记分页最后添加 // 如果有多数据源可以不配具体类型, 否则都建议配上具体的 DbType return interceptor; } } 在Mapper方法使用分页相关API\n设置分页参数\n1 2 3 4 5 6 7 8 //方法一 int pageNo = 1; //页码 int pageSize = 2; //每页大小 Page\u0026lt;User\u0026gt; pageInfo = Page.of(pageNo, pageSize); Page\u0026lt;User\u0026gt;p=userMapper.page(pageInfo); //方法二 Page\u0026lt;User\u0026gt; pageInfo = new Page\u0026lt;\u0026gt;(page,pageSize); Page\u0026lt;User\u0026gt;p = userService.page(pageInfo); 进行分页查询\n1 2 Page\u0026lt;T\u0026gt; page_name=userMapper.selectPage(page, wrapper); //条件分页查询 Page\u0026lt;T\u0026gt; page_name=userMapper.page(page);//普通分页查询 使用相关API\n1 2 3 4 5 6 7 当前页数：page.getCurrent() 总页数： page.getPages() 记录数： page.getTotal() 是否有上一页： page.hasPrevious() 是否有下一页： page.hasNext() 分页数据：page.getRecords() 排序条件：page.addOrder(new OrderItem(\u0026#34;数据库字段名\u0026#34;,true)); //升序为true,降序为false ","date":"2024-11-16T10:56:19+08:00","permalink":"https://Tyritic.github.io/p/mybatis-plus/","title":"MyBatis Plus"},{"content":"泛型的定义 泛型是 Java 编程语言中的一个重要特性，它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型。\n泛型的主要目的是在编译时提供更强的类型检查，并且在编译后能够保留类型信息，避免了在运行时出现类型转换异常。\n泛型的作用 类型安全：泛型允许在编译时进行类型检查，确保在使用集合或其他泛型类时，不会出现类型不匹配的问题，减少了运行时的 ClassCastException 错误。 代码重用：泛型使代码可以适用于多种不同的类型，减少代码重复，提升可读性和维护性。 消除显式类型转换：泛型允许在编译时指定类型参数，从而消除了运行时需要显式类型转换的麻烦。 泛型的使用 泛型类 类的成员变量的类型不确定，可以使用泛型表示\n语法格式\n1 2 3 class className\u0026lt;T\u0026gt;{ } 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 泛型类的定义 public class Box\u0026lt;T\u0026gt; { private T value; public void setValue(T value) { this.value = value; } public T getValue() { return value; } } // 使用泛型类 Box\u0026lt;Integer\u0026gt; intBox = new Box\u0026lt;\u0026gt;(); intBox.setValue(10); Integer intValue = intBox.getValue(); System.out.println(intValue); // 输出: 10 Box\u0026lt;String\u0026gt; stringBox = new Box\u0026lt;\u0026gt;(); stringBox.setValue(\u0026#34;Hello, Generic!\u0026#34;); String strValue = stringBox.getValue(); System.out.println(strValue); // 输出: Hello, Generic! 泛型接口 用类型参数来参数化接口的方法和字段，泛型类和非泛型类都可以实现泛型接口，只是非泛型类给泛型接口提供具体类型\n示例代码\n泛型类实现泛型接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 泛型接口的定义 interface Pair\u0026lt;K, V\u0026gt; { K getKey(); V getValue(); } // 泛型接口的实现 class MyPair\u0026lt;K, V\u0026gt; implements Pair\u0026lt;K, V\u0026gt; { private K key; private V value; public MyPair(K key, V value) { this.key = key; this.value = value; } @Override public K getKey() { return key; } @Override public V getValue() { return value; } } // 使用泛型接口 Pair\u0026lt;String, Integer\u0026gt; pair = new MyPair\u0026lt;\u0026gt;(\u0026#34;Age\u0026#34;, 30); System.out.println(pair.getKey() + \u0026#34;: \u0026#34; + pair.getValue()); // 输出: Age: 30 非泛型类实现泛型接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 泛型接口 interface Pair\u0026lt;K, V\u0026gt; { K getKey(); V getValue(); } // 非泛型类实现泛型接口 class MyPair implements Pair\u0026lt;String, Integer\u0026gt; { private String key; private Integer value; public MyPair(String key, Integer value) { this.key = key; this.value = value; } @Override public String getKey() { return key; } @Override public Integer getValue() { return value; } } public class Main { public static void main(String[] args) { MyPair pair = new MyPair(\u0026#34;Age\u0026#34;, 30); System.out.println(pair.getKey() + \u0026#34;: \u0026#34; + pair.getValue()); // 输出: Age: 30 } } 泛型方法 泛型方法是指在方法的定义中，使用类型参数。与泛型类不同的是，泛型方法的类型参数只适用于该方法，而不影响整个类。\n语法格式\n1 2 3 访问控制符 \u0026lt;T\u0026gt; 方法返回值 方法名(形参列表){ } 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 泛型方法的定义 public class GenericMethodExample { public static \u0026lt;T\u0026gt; void printArray(T[] array) { for (T element : array) { System.out.print(element + \u0026#34; \u0026#34;); } System.out.println(); } public static void main(String[] args) { Integer[] intArray = {1, 2, 3}; String[] strArray = {\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;}; // 调用泛型方法 printArray(intArray); // 输出: 1 2 3 printArray(strArray); // 输出: Hello World } } 泛型的通配符 Java 泛型的上限定符 用于对泛型类型参数进行范围限制\n无界通配符 无界通配符表示泛型类型没有任何限制，可以接受任何类型。它适用于不关心具体类型的场景，常用于方法参数中。\n语法参数\n1 \u0026lt;?\u0026gt; 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.util.List; public class WildcardExample { public static void printList(List\u0026lt;?\u0026gt; list) { for (Object obj : list) { System.out.println(obj); } } public static void main(String[] args) { List\u0026lt;String\u0026gt; stringList = List.of(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); List\u0026lt;Integer\u0026gt; intList = List.of(1, 2, 3); printList(stringList); // 可以传递任何类型的 List printList(intList); } } 上界通配符 语法格式\n1 \u0026lt;? extends T\u0026gt; 上界通配符限制泛型类型必须是指定类型 T 或 T 的子类。这意味着，\u0026lt;? extends T\u0026gt; 可以接受 T 类型及其所有子类型。上界通配符通常用于读取操作，确保可以读取为 T 或 T 的子类的对象。。\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.util.List; public class UpperBoundWildcardExample { public static void printNumbers(List\u0026lt;? extends Number\u0026gt; list) { for (Number number : list) { System.out.println(number); } } public static void main(String[] args) { List\u0026lt;Integer\u0026gt; intList = List.of(1, 2, 3); List\u0026lt;Double\u0026gt; doubleList = List.of(1.1, 2.2, 3.3); printNumbers(intList); // 可以传递 List\u0026lt;Integer\u0026gt; printNumbers(doubleList); // 可以传递 List\u0026lt;Double\u0026gt; } } 下界通配符 语法格式\n1 \u0026lt;? super T\u0026gt; 下界通配符限制泛型类型必须是指定类型 T 或 T 的父类。\u0026lt;? super T\u0026gt; 适用于我们要往集合中添加元素的情况，它保证了能够安全地将 T 类型及其子类型的对象放入容器中。\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import java.util.List; public class LowerBoundWildcardExample { public static void addNumbers(List\u0026lt;? super Integer\u0026gt; list) { list.add(42); // 只允许添加 Integer 或其子类型的元素 } public static void main(String[] args) { List\u0026lt;Number\u0026gt; numberList = List.of(1, 2, 3); List\u0026lt;Object\u0026gt; objectList = List.of(\u0026#34;string\u0026#34;, 10.5); addNumbers(numberList); // 可以传递 List\u0026lt;Number\u0026gt; addNumbers(objectList); // 可以传递 List\u0026lt;Object\u0026gt; } } 使用规则 \u0026lt;? extends T\u0026gt; 的泛型集合中只能读取数据不能写入数据 示例\n1 2 3 4 5 6 7 8 9 10 11 import java.util.List; public class Test { public static void addToList(List\u0026lt;? extends Number\u0026gt; list) { for (Number num : list) { System.out.println(num); // 读取是安全的 } // list.add(1); // 编译错误 // list.add(3.14); // 编译错误 } } 解释\n当使用\u0026lt;? extends T\u0026gt; ,泛型集合中元素的类型是 T 类型或 T 的任意子类型 可读取性：\u0026lt;? extends T\u0026gt; 确保了集合中的每个元素至少是 T 类型或其子类，因此可以安全地以多态（向上转型）赋值给 T 类型的变量 。 不可写入性：List\u0026lt;? extends T\u0026gt; 限定了泛型上界为 T 的子类，但无法保证具体是哪种类型，因此不能添加元素（除了 null），否则会违反类型安全性。 \u0026lt;? super T\u0026gt; 的泛型集合中只能写入数据不能读取数据 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import java.util.List; import java.util.ArrayList; public class Test { public static void addToList(List\u0026lt;? super Integer\u0026gt; list) { list.add(10); // 可以添加 Integer 类型的数据 list.add(100); // 可以继续添加 Integer 类型的数据 } public static void main(String[] args) { List\u0026lt;Number\u0026gt; numberList = new ArrayList\u0026lt;\u0026gt;(); addToList(numberList); // 传入 List\u0026lt;Number\u0026gt; 是安全的 List\u0026lt;Object\u0026gt; objectList = new ArrayList\u0026lt;\u0026gt;(); addToList(objectList); // 传入 List\u0026lt;Object\u0026gt; 也是安全的 Object obj = list.get(0); // 可以读取为 Object 类型 // Integer num = list.get(0); // 编译错误，不能直接读取为 Integer } } 解释\n当使用 \u0026lt;? super T\u0026gt; 时，泛型集合中元素的类型是 T 类型或 T 的任意父类型 可写入性：\u0026lt;? super T\u0026gt; 确保了集合中的每个元素至少是 T 类型或其父类，因此可以安全地写入 T 类型及其子类的变量。 不可读取性：编译器并不知道集合实际存储的具体类型，因此无法确定返回的元素类型是什么，唯一可以确定的是，所有元素至少是 Object 类型，因此只能将读取的元素视为 Object。 PECS 原则 PECS 原则是 Producer Extends, Consumer Super 的缩写，帮助理解何时使用上界和下界限定符：\nProducer Extends：如果某个对象提供数据（即生产者），使用 extends（上界限定符）。 Consumer Super：如果某个对象接收数据（即消费者），使用 super（下界限定符）。 类型擦除和伪泛型 Java 中的泛型被称为 伪泛型（erasure），这是因为 Java 的泛型是通过 类型擦除（type erasure） 实现的\n类型擦除 实现方式 编译时：\n用原始类型替换泛型类型：所有泛型类和方法会被编译为使用原始类型的代码。例如，List\u0026lt;String\u0026gt; 会变成 List ，T 会变成 Object 。 类型边界：如果泛型类或方法有上界限制（如 T extends Number ），那么在擦除时，T 会被替换为这个边界类型（例如 Number ）。 类型参数的强制转换：在泛型类和方法中，编译器会插入强制类型转换，以确保在运行时正确转换类型。 运行时：在运行时，Java 并不保留泛型类型信息，所有泛型类型都被转换成了原始类型。\n示例说明\n编译前\n1 2 3 4 5 6 7 8 9 10 11 public class Box\u0026lt;T\u0026gt; { private T value; public void setValue(T value) { this.value = value; } public T getValue() { return value; } } 编译后\n1 2 3 4 5 6 7 8 9 10 11 public class Box { private Object value; public void setValue(Object value) { this.value = value; } public Object getValue() { return value; } } 作用和影响 作用：泛型擦除确保了 Java 代码的向后兼容性，但它也限制了在运行时对泛型类型的操作。\n影响：\n类型信息丢失：由于类型擦除，无法在运行时获取泛型的实际类型，导致无法进行以下操作 不能创建泛型类型的数组，不能实例化泛型类型的变量 对泛型类型使用 instanceof 检查 类型转换异常：在运行时，由于类型擦除的存在，可能会导致类型转换异常。例如，如果你错误地将 List\u0026lt;Integer\u0026gt; 和 List\u0026lt;String\u0026gt; 混用，编译时可能不会发现问题，而在运行时会导致 ClassCastException 。 无法使用基本类型作为泛型：由于类型擦除的原因，Java 泛型无法直接使用基本数据类型（如 int、char 等），只能使用它们的包装类型（如 Integer、Character）。 利用反射获取泛型类型的情况 因为泛型信息保存在class文件中\n成员变量的泛型 方法入参的泛型 方法返回值的泛型 带来的问题 1 2 3 4 5 6 7 8 9 10 public class Cmower { public static void method(ArrayList\u0026lt;String\u0026gt; list) { System.out.println(\u0026#34;ArrayList\u0026lt;String\u0026gt; list\u0026#34;); } public static void method(ArrayList\u0026lt;Date\u0026gt; list) { System.out.println(\u0026#34;ArrayList\u0026lt;Date\u0026gt; list\u0026#34;); } } 在 Java 中，泛型是在编译时擦除的，这意味着 ArrayList\u0026lt;String\u0026gt; 和 ArrayList\u0026lt;Date\u0026gt; 在编译后会变成相同的类型 ArrayList 。\n当方法重载时，如果两种方法的签名 在类型擦除后相同，就会发生冲突。 在这段代码中，ArrayList\u0026lt;String\u0026gt; 和 ArrayList\u0026lt;Date\u0026gt; 在类型擦除后都会变成 ArrayList，因此，编译器无法区分这两个方法，导致编译时发生冲突。 为什么是伪泛型 泛型只在编译时进行类型检查，运行时并不会保留泛型类型信息。\n在运行时泛型根本没有起作用！也就是说在运行的时候 JVM 获取不到泛型的信息，也会不对其做任何的约束。\n因此，虽然在 IDE 写代码的时候泛型生效了，而实际上在运行的时候泛型的类型是被擦除的。\n一言蔽之，Java的泛型只在编译时生效，JVM 运行时没有泛型。\n","date":"2024-11-16T09:46:03+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B/","title":"Java中的泛型"},{"content":"StringBuffer的定义 StringBuffer 是 Java 中用于创建可变字符串的类，提供了一个与 StringBuilder 类似的功能。它们都用于处理可变的字符串数据，不同之处在于 StringBuffer 是线程安全的，而 StringBuilder 不是。\nStringBuffer 的特点 可变字符串： StringBuffer 提供了修改字符串内容的方法，避免了每次修改字符串时创建新的 String 对象，从而提高了性能。 线程安全： StringBuffer 是线程安全的，意味着它可以在多个线程间安全地共享和操作。StringBuffer 中的方法通常都被同步（使用 synchronized），确保多线程环境下的线程安全。 效率较低： 由于线程安全的特性，StringBuffer 的性能通常比 StringBuilder 略差，因为 StringBuffer 的方法被加锁，而 StringBuffer 的方法没有锁定。 StringBuffer的构造函数 public StringBuffer() ：默认构造，初始化容量为 16 public StringBuffer(String str) ：以指定字符串初始化 public StringBuffer(int capacity)：以指定初始容量初始化 StringBuffer的常见操作 追加数据 public StringBuffer append(String str)：将字符串str追加到 StringBuffer 对象的末尾。 public StringBuffer append(int i)：将 i 转换为字符串并追加到 StringBuffer 对象的末尾。 public StringBuffer append(char c)：将 c 转换为字符串并追加到 StringBuffer 对象的末尾。 作用\nappend() 方法用于在 StringBuffer 对象的末尾追加指定的内容。 支持多种类型的参数，包括 String、int、char 等。调用时会将传入的内容转换为字符串后附加到原字符串的后面。 示例\n1 2 3 StringBuffer sb = new StringBuffer(\u0026#34;Hello\u0026#34;); sb.append(\u0026#34; World\u0026#34;).append(123).append(\u0026#39;!\u0026#39;); System.out.println(sb); // 输出：Hello World123! 插入内容 public StringBuffer insert(int offset, String str) public StringBuffer insert(int offset, int i) public StringBuffer insert(int offset, char c) 作用\ninsert() 方法将指定的内容插入到 StringBuffer 对象中指定位置。 offset 参数表示插入的位置，内容会从这个位置开始插入。 示例\n1 2 3 StringBuffer sb = new StringBuffer(\u0026#34;Hello!\u0026#34;); sb.insert(5, \u0026#34; Java\u0026#34;); System.out.println(sb); // 输出：Hello Java! 删除内容 public StringBuffer delete(int start, int end) 作用：\ndelete() 方法删除 StringBuffer 中从 start 到 end-1 位置的字符。 删除的是一个字符范围，start 是包含的起始位置，end 是不包含的结束位置。 示例：\n1 2 3 StringBuffer sb = new StringBuffer(\u0026#34;Hello Java!\u0026#34;); sb.delete(5, 10); System.out.println(sb); // 输出：Hello! 替换子串 public StringBuffer replace(int start, int end, String str) 作用：\nreplace() 方法将指定范围（start，end-1）内的字符替换为给定的字符串。 start 到 end 范围的字符被替换为 str。 示例：\n1 2 3 StringBuffer sb = new StringBuffer(\u0026#34;Hello World!\u0026#34;); sb.replace(6, 11, \u0026#34;Java\u0026#34;); System.out.println(sb); // 输出：Hello Java! 反转字符串 public StringBuffer reverse() 作用：\nreverse() 方法将 StringBuffer 中的字符序列反转。 例如，Hello 会变成 olleH。 示例：\n1 2 3 StringBuffer sb = new StringBuffer(\u0026#34;Hello\u0026#34;); sb.reverse(); System.out.println(sb); // 输出：olleH 获取属性 public int length()：获取字符串长度 public int capacity()：获取容量 操作指定位置的字符 public char charAt(int index)：获取指定位置的字符 public void setCharAt(int index, char ch)：设置指定位置的字符 截取子串 public String substring(int start) public String substring(int start, int end) 作用：\nsubstring() 方法返回 StringBuffer 中指定位置的子字符串。 如果只有 start 参数，则返回从 start 到最后的子字符串。 如果提供了 start 和 end，则返回该范围内的子字符串。 示例\n1 2 3 StringBuffer sb = new StringBuffer(\u0026#34;Hello World\u0026#34;); System.out.println(sb.substring(6)); // 输出：World System.out.println(sb.substring(0, 5)); // 输出：Hello 查找子串 public int indexOf(String str) public int indexOf(String str, int fromIndex) 作用：\nindexOf() 方法返回指定子字符串首次出现的位置。如果子字符串不存在，则返回 -1。 可以通过 fromIndex 参数指定从哪个位置开始查找。 示例\n1 2 3 StringBuffer sb = new StringBuffer(\u0026#34;Hello World\u0026#34;); System.out.println(sb.indexOf(\u0026#34;World\u0026#34;)); // 输出：6 System.out.println(sb.indexOf(\u0026#34;o\u0026#34;, 5)); // 输出：7 总体使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class StringBufferExample { public static void main(String[] args) { // 创建一个 StringBuffer 对象 StringBuffer sb = new StringBuffer(\u0026#34;Hello\u0026#34;); // 使用 append() 方法追加内容 sb.append(\u0026#34; World!\u0026#34;); System.out.println(sb); // 输出：Hello World! // 使用 insert() 方法插入内容 sb.insert(5, \u0026#34;,\u0026#34;); System.out.println(sb); // 输出：Hello, World! // 使用 delete() 方法删除内容 sb.delete(5, 6); // 删除从索引 5 到 6 的字符 System.out.println(sb); // 输出：Hello World! // 使用 reverse() 方法反转字符串 sb.reverse(); System.out.println(sb); // 输出：!dlroW olleH // 将 StringBuffer 转换为 String String str = sb.toString(); System.out.println(str); // 输出：!dlroW olleH // 获取 StringBuffer 的长度 System.out.println(sb.length()); // 输出：13 // 获取 StringBuffer 的容量 System.out.println(sb.capacity()); // 输出：27 (因为默认容量是16，加上追加的内容后，容量自动扩展) } } String，StringBuffer，StringBuilder的区别（面试题） String\n不可变：String 是不可变类，字符串一旦创建，其内容无法更改。每次对 String 进行修改操作（如拼接、截取等），都会创建新的 String 对象。 适合场景：String 适用于字符串内容不会频繁变化的场景，例如少量的字符串拼接操作或字符串常量。 StringBuffer\n可变：StringBuffer 是可变的，可以进行字符串的追加、删除、插入等操作。 线程安全：StringBuffer 是线程安全的，内部使用了 synchronized 关键字来保证多线程环境下的安全性。 适合场景：StringBuffer 适用于在多线程环境中需要频繁修改字符串的场景。 StringBuilder\n可变：StringBuilder 也是可变的，提供了与 StringBuffer 类似的操作接口。 非线程安全：StringBuilder 不保证线程安全，性能比 StringBuffer 更高。 适合场景：StringBuilder 适用于单线程环境中需要大量修改字符串的场景，如高频拼接操作。 ","date":"2024-11-15T23:03:07+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84stringbuffer/","title":"Java中的StringBuffer"},{"content":"StringBuilder的定义 StringBuilder 是 Java 中的一个 可变字符序列类，位于 java.lang 包中。它用于创建和操作可变的字符串（字符序列），与 String 不同，StringBuilder 的内容是 可变的，不会像 String 那样在每次修改时创建新的对象，从而提高了性能，尤其在需要频繁修改字符串时非常有用。\nStringBuilder的特点 可变性： StringBuilder 维护一个可变的char数组，操作时直接修改这个数组，不会生成新的对象。 效率高： 在进行字符串拼接、插入、删除等操作时，相比 String 创建大量临时对象，StringBuilder 只需在原对象上进行操作，因此效率更高。 线程不安全： 与 StringBuffer（线程安全版本）不同，StringBuilder 不是线程安全的，但在单线程环境下效率更高。 StringBuilder的构造方法 StringBuilder()\n无参构造函数，创建一个初始容量为 16 的空 StringBuilder 对象。\nStringBuilder(int capacity)\n指定初始容量的构造函数，创建一个具有指定初始容量的 StringBuilder 对象，如果在追加字符时超出指定容量，StringBuilder 会自动扩容，扩容规则为：\n新容量 = (旧容量 * 2) + 2\nStringBuilder(String str)\n以指定字符串内容为初始值的构造函数，创建一个包含给定字符串内容的 StringBuilder 对象，同时容量为 str.length() + 16。\nStringBuilder(CharSequence seq)\n以 CharSequence 接口实现类为初始内容的构造函数，创建一个包含指定字符序列的 StringBuilder 对象。\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Main { public static void main(String[] args) { // 无参构造 StringBuilder sb1 = new StringBuilder(); System.out.println(\u0026#34;sb1 的初始容量：\u0026#34; + sb1.capacity()); // 输出：16 // 指定容量构造 StringBuilder sb2 = new StringBuilder(30); System.out.println(\u0026#34;sb2 的初始容量：\u0026#34; + sb2.capacity()); // 输出：30 // 以字符串为初始值的构造 StringBuilder sb3 = new StringBuilder(\u0026#34;Hello\u0026#34;); System.out.println(\u0026#34;sb3 的初始内容：\u0026#34; + sb3.toString()); // 输出：Hello System.out.println(\u0026#34;sb3 的初始容量：\u0026#34; + sb3.capacity()); // 输出：21（5 + 16） // 以 CharSequence 为初始值的构造 CharSequence seq = \u0026#34;World\u0026#34;; StringBuilder sb4 = new StringBuilder(seq); System.out.println(\u0026#34;sb4 的初始内容：\u0026#34; + sb4.toString()); // 输出：World } } StringBuilder的常见操作 追加数据 public StringBuilder append(String str)：将字符串str追加到 StringBuilder 对象的末尾。 public StringBuilder append(int i)：将 i 转换为字符串并追加到 StringBuilder 对象的末尾。 public StringBuilder append(char c)：将 c 转换为字符串并追加到 StringBuilder 对象的末尾。 作用\nappend() 方法用于在 StringBuilder 对象的末尾追加指定的内容。 支持多种类型的参数，包括 String、int、char 等。调用时会将传入的内容转换为字符串后附加到原字符串的后面。 示例\n1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello\u0026#34;); sb.append(\u0026#34; World\u0026#34;).append(123).append(\u0026#39;!\u0026#39;); System.out.println(sb); // 输出：Hello World123! 插入内容 public StringBuilder insert(int offset, String str) public StringBuilder insert(int offset, int i) public StringBuilder insert(int offset, char c) 作用\ninsert() 方法将指定的内容插入到 StringBuilder 对象中指定位置。 offset 参数表示插入的位置，内容会从这个位置开始插入。 示例\n1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello!\u0026#34;); sb.insert(5, \u0026#34; Java\u0026#34;); System.out.println(sb); // 输出：Hello Java! 删除内容 public StringBuilder delete(int start, int end) 作用：\ndelete() 方法删除 StringBuilder 中从 start 到 end-1 位置的字符。 删除的是一个字符范围，start 是包含的起始位置，end 是不包含的结束位置。 示例：\n1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello Java!\u0026#34;); sb.delete(5, 10); System.out.println(sb); // 输出：Hello! 替换子串 public StringBuilder replace(int start, int end, String str) 作用：\nreplace() 方法将指定范围（start，end-1）内的字符替换为给定的字符串。 start 到 end 范围的字符被替换为 str。 示例：\n1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello World!\u0026#34;); sb.replace(6, 11, \u0026#34;Java\u0026#34;); System.out.println(sb); // 输出：Hello Java! 反转字符串 public StringBuilder reverse() 作用：\nreverse() 方法将 StringBuilder 中的字符序列反转。 例如，Hello 会变成 olleH。 示例：\n1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello\u0026#34;); sb.reverse(); System.out.println(sb); // 输出：olleH 获取属性 public int length()：获取字符串长度 public int capacity()：获取容量 操作指定位置的字符 public char charAt(int index)：获取指定位置的字符 public void setCharAt(int index, char ch)：设置指定位置的字符 截取子串 public String substring(int start) public String substring(int start, int end) 作用：\nsubstring() 方法返回 StringBuilder 中指定位置的子字符串。 如果只有 start 参数，则返回从 start 到最后的子字符串。 如果提供了 start 和 end，则返回该范围内的子字符串。 示例\n1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello World\u0026#34;); System.out.println(sb.substring(6)); // 输出：World System.out.println(sb.substring(0, 5)); // 输出：Hello 查找子串 public int indexOf(String str) public int indexOf(String str, int fromIndex) 作用：\nindexOf() 方法返回指定子字符串首次出现的位置。如果子字符串不存在，则返回 -1。 可以通过 fromIndex 参数指定从哪个位置开始查找。 示例\n1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello World\u0026#34;); System.out.println(sb.indexOf(\u0026#34;World\u0026#34;)); // 输出：6 System.out.println(sb.indexOf(\u0026#34;o\u0026#34;, 5)); // 输出：7 equals方法 StringBuilder 类中的 equals() 方法在默认情况下并不按内容比较两个 StringBuilder 对象，而是按 引用 比较，即两个 StringBuilder 对象是否指向相同的内存位置。\nStringBuilder的实现原理 大致核心实现 内部使用字符数组 (char[] value) 来存储字符序列 通过方法如 append()、insert() 等操作，直接修改内部的字符数组，而不会像 String 那样创建新的对象。 每次进行字符串操作时，如果当前容量不足，它会通过扩展数组容量来容纳新的字符，按 2 倍的容量扩展，以减少扩展次数，提高性能。 底层具体实现 StringBuilder 底层使用 char 数组 value 来存储字符，并且用 count 来记录存放的字符数 为了防止频繁地复制和申请内存，需要提供 capacity 参数来设置初始化数组的大小，这样可以减少数组的扩容次数，有效的提升效率！ append()的具体实现 int值转成 char 需要占数组的几位，然后计算一下现在的数组够不够放，如果不够就扩容，然后再把 int 转成 char 放进去，再更新现有的字符数。 扩容时调用 Arrays.copyOf，进行一波扩容加拷贝，扩容之后的数组容量为之前的两倍+2。 insert()的具体实现 这里是把 数据 转成 string 插入前先判断下数组长度足够，若不够就扩容。 移动字符，给待插入的位置腾出空间，然后往对应位置插入字符 最后更新 StringBuilder 已有的字符数 优化方法（JDK 11的优化） char 数组是可以优化的，底层可以用 byte 数组+一个 coder 标志位来实现，这样更节省内存，因为 char 占用两个字节，这样对于 latin 系的字符来说，太大了，就很浪费，所以用 byte 数组，然后配备一个 coder 来标识所用的编码。\n","date":"2024-11-15T21:13:12+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84stringbuilder/","title":"Java中的StringBuilder"},{"content":"一级缓存 一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问\n使一级缓存失效的四种情况: 不同的SqlSession对应不同的一级缓存 同一个SqlSession但是查询条件不同 同一个SqlSession两次查询期间执行了任何一次增删改操作 同一个SqlSession两次查询期间手动清空了缓存 二级缓存 二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存;此后若再次执行相同的查询语句，结果就会从缓存中获取。\n二级缓存开启的条件: 在核心配置文件中，设置全局配置属性cacheEnabled=\u0026ldquo;true\u0026rdquo;，默认为true，不需要设置 在mapper.xml映射文件中设置标签\u0026lt;cache \u0026gt; 二级缓存必须在SqlSession关闭或提交之后有效 查询的数据所转换的实体类类型必须实现序列化的接口 失效的情况 在两次查询之间进行任意的增删改，手动清空缓存只会清空一级缓存\n相关配置 在mapper.xml映射文件中设置标签\u0026lt;cache \u0026gt;\n相关属性参见 MyBatis官方文档\n缓存查询顺序 先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用 如果二级缓存没有命中，再查询一级缓存 如果一级缓存也没有命中，则查询数据库 Sqisession关闭之后，一级缓存中的数据会写入二级缓存 ","date":"2024-11-15T20:31:12+08:00","permalink":"https://Tyritic.github.io/p/mybatis%E7%BC%93%E5%AD%98/","title":"MyBatis缓存"},{"content":"Arrays类是用于对数组进行操作的工具类\n常见操作 排序 static void sort(int[] a) static \u0026lt;T\u0026gt; void sort(T[] a, Comparator\u0026lt;? super T\u0026gt; c) // 使用 Comparator 自定义排序 示例 1 2 3 4 5 6 7 int[] arr = {5, 2, 8, 1, 3}; Arrays.sort(arr); System.out.println(Arrays.toString(arr)); // 输出：[1, 2, 3, 5, 8] String[] strs = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;pear\u0026#34;}; Arrays.sort(strs, (s1, s2) -\u0026gt; s2.compareTo(s1)); // 按降序排序 System.out.println(Arrays.toString(strs)); // 输出：[pear, banana, apple] 二分查找 在已排序的数组中使用二分查找指定元素的索引。\nstatic int binarySearch(int[] a, int key) static \u0026lt;T\u0026gt; int binarySearch(T[] a, T key, Comparator\u0026lt;? super T\u0026gt; c) 示例 1 2 3 int[] arr = {1, 2, 3, 5, 8}; int index = Arrays.binarySearch(arr, 5); System.out.println(\u0026#34;元素 5 的索引：\u0026#34; + index); // 输出：元素 5 的索引：3 判断是否相等 判断两个数组是否相等（长度相同且对应元素相等）。\nstatic boolean equals(int[] a, int[] a2) static \u0026lt;T\u0026gt; boolean equals(T[] a, T[] a2) 示例 1 2 3 4 5 int[] arr1 = {1, 2, 3}; int[] arr2 = {1, 2, 3}; int[] arr3 = {1, 2, 4}; System.out.println(Arrays.equals(arr1, arr2)); // 输出：true System.out.println(Arrays.equals(arr1, arr3)); // 输出：false 判断两个多维数组是否相等\nstatic boolean deepEquals(Object[] a1, Object[] a2) 批量赋值 将数组的所有元素赋值为指定值\nstatic void fill(int[] a, int val) static \u0026lt;T\u0026gt; void fill(T[] a, T val) 示例 1 2 3 int[] arr = new int[5]; Arrays.fill(arr, 9); System.out.println(Arrays.toString(arr)); // 输出：[9, 9, 9, 9, 9] 复制数组 将指定数组复制到新的数组，返回一个新数组。\nstatic int[] copyOf(int[] original, int newLength) static \u0026lt;T\u0026gt; T[] copyOf(T[] original, int newLength) 示例 1 2 3 int[] arr = {1, 2, 3}; int[] newArr = Arrays.copyOf(arr, 5); System.out.println(Arrays.toString(newArr)); // 输出：[1, 2, 3, 0, 0] 将指定数组的某个范围复制到新的数组。\nstatic int[] copyOfRange(int[] original, int from, int to) static \u0026lt;T\u0026gt; T[] copyOfRange(T[] original, int from, int to) 示例\n1 2 3 int[] arr = {1, 2, 3, 4, 5}; int[] newArr = Arrays.copyOfRange(arr, 1, 4); // [from, to) System.out.println(Arrays.toString(newArr)); // 输出：[2, 3, 4] 数组转换为集合 static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; asList(T... a) 示例\n1 2 3 String[] strs = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;pear\u0026#34;}; List\u0026lt;String\u0026gt; list = Arrays.asList(strs); System.out.println(list); // 输出：[apple, banana, pear] ","date":"2024-11-15T17:32:46+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E5%B7%A5%E5%85%B7-arrays%E7%B1%BB/","title":"Java中的数组操作工具 Arrays类"},{"content":"内部类的定义 在 Java 中，内部类（Inner Class） 是定义在另一个类内部的类。内部类可以更方便地访问外部类的成员变量和方法，同时也提升了封装性和代码的逻辑关联性。\n内部类的访问特定 内部类可以直接访问外部类的成员（包括private） 外部类要访问内部类的成员必须创建内部类对象 成员内部类 成员内部类是定义在外部类成员位置中的普通类。它与外部类的实例关联，只有在创建了外部类对象后，才能创建其内部类对象。\n特点 内部类可以直接访问外部类的私有成员。 创建内部类对象需要先创建外部类对象，再通过外部类对象创建内部类对象。 内部类中的变量可以被访问控制符和static修饰 使用格式 1 外部类.内部类 内存实现 在创建内部类对象时使用Outer.this记录外部类对象的地址值\n示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Outer { private String name = \u0026#34;OuterClass\u0026#34;; // 成员内部类 public class Inner { public void display() { System.out.println(\u0026#34;内部类访问外部类的成员: \u0026#34; + name); } } public static void main(String[] args) { Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); // 创建内部类对象 inner.display(); } } 静态内部类 静态内部类使用 static 修饰符定义，可以独立于外部类的实例进行创建\n特点 可以直接访问外部类的静态成员 不可以直接访问外部类的非静态成员,若要访问则要创建外部类对象 不存在Outer.this 语法格式 创建静态内部类对象\n1 外部类.内部类 变量名=new 外部类.内部类构造器 调用静态内部类方法的格式\n非静态方法：先创建静态内部类对象再调用 静态方法：外部类.内部类.方法名() 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Outer { private static String staticName = \u0026#34;StaticOuterClass\u0026#34;; // 静态内部类 public static class StaticInner { public void display() { System.out.println(\u0026#34;静态内部类访问外部类的静态成员: \u0026#34; + staticName); } } public static void main(String[] args) { Outer.StaticInner inner = new Outer.StaticInner(); // 直接创建静态内部类对象 inner.display(); } } 局部内部类 局部内部类是在方法或代码块中定义的类，作用域仅限于所在方法或代码块。\n特点 局部内部类的作用域仅限于定义它的方法或代码块中。 局部内部类可以访问外部类的成员以及方法中的局部变量（需要局部变量使用 final 或隐式 final 修饰）。 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Outer { public void method() { class LocalInner { public void display() { System.out.println(\u0026#34;这是局部内部类\u0026#34;); } } LocalInner inner = new LocalInner(); // 创建局部内部类对象 inner.display(); } public static void main(String[] args) { Outer outer = new Outer(); outer.method(); } } 匿名内部类 匿名内部类是没有名字的内部类，它是在定义类的同时创建该类的对象，通常用于简化代码，尤其在需要实现接口或继承抽象类时，可以避免单独定义实现类。\n本质：隐藏了名字的内部类\n使用前提：必须继承一个父类或实现一个接口\n特点 没有名字：匿名内部类在创建时定义，没有类名。\n一次性使用：匿名内部类只能使用一次，不能重复创建多个实例。\n可以继承类或实现接口：\n如果继承一个类，匿名内部类只能继承一个父类。\n如果实现一个接口，匿名内部类可以实现该接口并提供方法实现。\n与外部类关系：\n匿名内部类可以直接访问外部类的成员（包括私有成员）。\n如果匿名内部类是在局部方法中定义的，它只能访问 final 的局部变量。\n不能有构造方法：因为匿名内部类没有名字，无法定义构造方法。\n语法格式 1 2 3 new 接口名或父类名() { // 方法实现 }; Lambda表达式 Lambda 表达式是 Java 8 引入的一种新特性，旨在简化代码，特别是当使用匿名内部类实现接口时。Lambda 表达式可以理解为一种匿名函数，直接将行为（函数）作为参数传递，使代码更加简洁、可读。\n语法格式 1 (参数列表) -\u0026gt; { 方法体 } 可以用于简写匿名内部类 Lambda表达式只能简化实现函数式接口的匿名内部类\n函数式接口：有且仅有一个抽象方法的接口，被@FunctionalInterface注解\n省略规则 在参数列表中，参数类型可以省略，因为编译器会根据上下文推断参数的类型。 当 Lambda 表达式只有一个参数时，可以省略参数两边的小括号 () 当 Lambda 表达式的方法体中只有一条语句时，可以省略大括号 {}。同时，如果这条语句是 return 语句，可以省略 return 关键字。 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import java.util.Comparator; public class LambdaExample { public static void main(String[] args) { // 匿名内部类 Comparator\u0026lt;String\u0026gt; comparatorAnonymous = new Comparator\u0026lt;String\u0026gt;() { @Override public int compare(String s1, String s2) { return s1.length() - s2.length(); } }; // Lambda 表达式完整格式 Comparator\u0026lt;String\u0026gt; comparatorFull = (String s1, String s2) -\u0026gt; { return s1.length() - s2.length(); }; // Lambda 表达式省略格式 Comparator\u0026lt;String\u0026gt; comparatorSimplified = (s1, s2) -\u0026gt; s1.length() - s2.length(); // 使用匿名内部类 String resultAnonymous = max(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, comparatorAnonymous); System.out.println(\u0026#34;使用匿名内部类较长的字符串是：\u0026#34; + resultAnonymous); // 使用 Lambda 表达式完整格式 String resultFull = max(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, comparatorFull); System.out.println(\u0026#34;使用 Lambda 完整格式较长的字符串是：\u0026#34; + resultFull); // 使用 Lambda 表达式省略格式 String resultSimplified = max(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, comparatorSimplified); System.out.println(\u0026#34;使用 Lambda 省略格式较长的字符串是：\u0026#34; + resultSimplified); } // 辅助方法：根据 Comparator 返回较长的字符串 public static String max(String s1, String s2, Comparator\u0026lt;String\u0026gt; comparator) { return comparator.compare(s1, s2) \u0026gt; 0 ? s1 : s2; } } ","date":"2024-11-15T16:14:45+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB/","title":"Java中的内部类"},{"content":"JavaWeb的三大组件 Servlet Servlet是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容。\n狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。\n作用： 接收请求数据 处理请求 完成响应 使用方法 实现javax.servlet.Servlet接口； 继承javax.servlet.GenericServlet类； 继承javax.servlet.http.HttpServlet类； 工作原理 ​\tServlet接口定义了Servlet与servlet容器之间的契约。这个契约是：Servlet容器将Servlet类载入内存，并产生Servlet实例和调用它具体的方法。但是要注意的是，在一个应用程序中，每种Servlet类型只能有一个实例。\n​\t用户请求致使Servlet容器调用Servlet的Service（）方法，并传入一个ServletRequest对象和一个ServletResponse对象。ServletRequest对象和ServletResponse对象都是由Servlet容器（例如TomCat）封装好的，并不需要程序员去实现，程序员可以直接使用这两个对象。\nServletRequest中封装了当前的Http请求，因此，开发人员不必解析和操作原始的Http数据。ServletResponse表示当前用户的Http响应，程序员只需直接操作ServletResponse对象就能把响应轻松的发回给用户。 对于每一个应用程序，Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）的环境详情。每个应用程序只有一个ServletContext。每个Servlet对象也都有一个封装Servlet配置的ServletConfig对象。 生命周期 init( ),当Servlet第一次被请求时，Servlet容器就会开始调用这个方法来初始化一个Servlet对象出来，但是这个方法在后续请求中不会在被Servlet容器调用，就像人只能“出生”一次一样。我们可以利用init（ ）方法来执行相应的初始化工作。调用这个方法时，Servlet容器会传入一个ServletConfig对象进来从而对Servlet对象进行初始化。 service( )方法，每当请求Servlet时，Servlet容器就会调用这个方法。就像人一样，需要不停的接受老板的指令并且“工作”。第一次请求时，Servlet容器会先调用init( )方法初始化一个Servlet对象出来，然后会调用它的service( )方法进行工作，但在后续的请求中，Servlet容器只会调用service方法了。 destory,当要销毁Servlet时，Servlet容器就会调用这个方法，就如人一样，到时期了就得死亡。在卸载应用程序或者关闭Servlet容器时，就会发生这种情况，一般在这个方法中会写一些清除代码。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class MyFirstServlrt implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { System.out.println(\u0026#34;Servlet正在初始化\u0026#34;); } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { //专门向客服端提供响应的方法 System.out.println(\u0026#34;Servlet正在提供服务\u0026#34;); } @Override public String getServletInfo() { return null; } @Override public void destroy() { System.out.println(\u0026#34;Servlet正在销毁\u0026#34;); } } ServletRequest接口 Servlet容器对于接受到的每一个Http请求，都会创建一个ServletRequest对象，并把这个对象传递给Servlet的Sevice( )方法。其中，ServletRequest对象内封装了关于这个请求的许多详细信息。\n1 2 3 4 5 6 7 8 9 public interface ServletRequest { int getContentLength();//返回请求主体的字节数 String getContentType();//返回主体的MIME类型 String getParameter(String var1);//返回请求参数的值 } ServletResponse接口 javax.servlet.ServletResponse接口表示一个Servlet响应，在调用Servlet的Service( )方法前，Servlet容器会先创建一个ServletResponse对象，并把它作为第二个参数传给Service( )方法。ServletResponse隐藏了向浏览器发送响应的复杂过程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public interface ServletResponse { String getCharacterEncoding(); String getContentType(); ServletOutputStream getOutputStream() throws IOException; PrintWriter getWriter() throws IOException; void setCharacterEncoding(String var1); void setContentLength(int var1); void setContentType(String var1); //在发送任何HTML之前，应该先调用setContentType（）方法，设置响应的内容类型，并将“text/html”作为一个参数传入，这是在告诉浏览器响应的内容类型为HTML，需要以HTML的方法解释响应内容而不是普通的文本，或者也可以加上“charset=UTF-8”改变响应的编码方式以防止发生中文乱码现象。 void setBufferSize(int var1); int getBufferSize(); void flushBuffer() throws IOException; void resetBuffer(); boolean isCommitted(); void reset(); void setLocale(Locale var1); Locale getLocale(); } HttpServlet抽象类 HttpServlet抽象类是继承于GenericServlet抽象类而来的。使用HttpServlet抽象类时，还需要借助分别代表Servlet请求和Servlet响应的HttpServletRequest和HttpServletResponse对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doPut(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doDelete(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } HttpServletRequest接口 HttpServletRequest表示Http环境中的Servlet请求。它扩展于javax.servlet.ServletRequest接口，并添加了几个方法。\n获取请求的相关数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 String getContextPath();//返回请求上下文的请求URI部分 Cookie[] getCookies();//返回一个cookie对象数组 String getHeader(String var1);//返回指定HTTP标题的值 String getMethod();//返回生成这个请求HTTP的方法名称 String getQueryString();//返回请求URL中的查询字符串 HttpSession getSession();//返回与这个请求相关的会话对象 String getRequestURI(); StringBuffer getRequestURL(); String[] getParameterValues(String name); //获得如checkbox类（名字相同，但值有多个）的数据。 接收数组变量 String getParameter(String name)； //获得相应名的数据，如果有重复的参数名，则返回第一个的值 HttpServletResponse接口 在Service API中，定义了一个HttpServletResponse接口，它继承自ServletResponse接口，专门用来封装HTTP响应消息。 由于HTTP请求消息分为状态行，响应消息头，响应消息体三部分，因此，在HttpServletResponse接口中定义了向客户端发送响应状态码，响应消息头，响应消息体的方法。\n设置响应的相关数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void addCookie(Cookie var1);//给这个响应添加一个cookie void addHeader(String var1, String var2);//给这个请求添加一个响应头 void sendRedirect(String var1) throws IOException;//发送一条响应码，讲浏览器跳转到指定的位置 void setStatus(int var1);//设置响应行的状态码 void addHeader(String name, String value);//添加响应头 void addIntHeader(String name, int value) void addDateHeader(String name, long date) void setHeader(String name, String value) void setDateHeader(String name, long date) void setIntHeader(String name, int value) PrintWriter getWriter();//获得字符流，通过字符流的write(String s)方法可以将字符串设置到response 缓冲区中，随后Tomcat会将response缓冲区中的内容组装成Http响应返回给浏览器端。 ServletOutputStream getOutputStream();//获得字节流，通过该字节流的write(byte[] bytes)可以向response缓冲区中写入字节，再由Tomcat服务器将字节内容组成Http响应返回给浏览器。 Filter 参见先前博客 Filter\nListener 概述 ​\t监听器就是监听某个对象的状态变化的组件，监听web应用中某些对象、信息的创建、销毁、增加，修改，删除等动作的发生，然后作出相应的响应处理\n具体实现 实现ServletContextListener接口\n1 2 3 4 5 6 7 8 9 10 public class MyListener implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent sce){ System.out.println(\u0026#34;Servlet上下文---\u0026gt;当前web项目启动\u0026#34;); } @Override public void contextDestroyed(ServletContextEvent sce){ System.out.println(\u0026#34;当前类销毁\u0026#34;); } } 注册Listenner监听器\nSpringBoot对三大组件的集成 SpringBoot中内嵌的Servlet容器是Tomcat服务器\n嵌入式Servlet容器配置修改 方法一：通过全局配置文件Application.yml修改\n可以通过server.xxx 来进行web服务配置， 没有带服务器名称的则是通用配置,通过带了具体的服务器名称则是单独对该服务器进行设置，比如server.tomcat.xxx 就是专门针对tomcat的配置,具体配置参见SpringBoot官方文档\n1 2 3 server: port: 8080 tomcat: 方法二：通过注册一个实现 WebServerFactoryCustomizer 接口的Spring Bean\n1 2 3 4 5 6 7 8 9 10 11 12 13 import org.springframework.boot.web.server.WebServerFactoryCustomizer; import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory; import org.springframework.stereotype.Component; @Component public class MyWebServerFactoryCustomizer implements WebServerFactoryCustomizer\u0026lt;ConfigurableServletWebServerFactory\u0026gt; { @Override public void customize(ConfigurableServletWebServerFactory server) { server.setPort(9000); } } 修改server.xxx 配置的相关内容 会跟配置文件形成互补 三大组件的注册 方法一：servlet3.0规范提供的注解方式注册\n在组件的实现类使用提供的注解注册\n1 2 3 4 5 6 7 8 @WebServlet(name=\u0026#34;HelloServlet\u0026#34;,urlPatterns = \u0026#34;/HelloServlet\u0026#34;) public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { PrintWriter writer = resp.getWriter(); writer.println(\u0026#34;hello servlet!\u0026#34;); } } @WebServlet @WebListener @WebFilter 在SpringBoot启动类上添加注解@ServletComponentScan\n1 2 3 4 5 6 7 @SpringBootApplication @ServletComponentScan public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } }\t方法二：SpringBoot提供的注册方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package com.hzl.boot.config.filter; import org.springframework.boot.web.servlet.FilterRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.servlet.Filter; /** * @description * @create: 2024-09-23 22:25 **/ @Configuration public class FilterRegistrationDemo { @Bean public FilterRegistrationBean filterRegistrationBean(){ FilterRegistrationBean\u0026lt;Filter\u0026gt; registrationBean = new FilterRegistrationBean\u0026lt;\u0026gt;(); // 设置自己的过滤器 registrationBean.setFilter(new MyFilter()); // 设置自定义的拦截规则 registrationBean.addUrlPatterns(\u0026#34;/*\u0026#34;); // 设置拦截器的顺序 registrationBean.setOrder(1); return registrationBean; } } ServletRegistrationBean FilterRegistrationBean ServletListenerRegistrationBean 切换内嵌Servlet容器 SpringBoot包含了对Tomcat,Jetty（Socket)等服务器的支持\n通过修改pom.xml的依赖即可排除相关依赖并添加相关依赖即可\n排除原有的tomcat依赖\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring‐boot‐starter‐web\u0026lt;/artifactId\u0026gt; \u0026lt;!‐‐1.排除tomcat‐‐\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;spring‐boot‐starter‐tomcat\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 引入相关依赖\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!‐‐2.依赖jetty --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;artifactId\u0026gt;spring‐boot‐starter‐jetty\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!‐‐3.依赖undertow ‐‐\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;artifactId\u0026gt;spring‐boot‐starter‐undertow\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;/dependency\u0026gt; ","date":"2024-11-15T15:55:52+08:00","permalink":"https://Tyritic.github.io/p/springboot%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6/","title":"SpringBoot中的三大组件"},{"content":"接口的定义 接口 (Interface) 是 Java 中一种特殊的引用类型，类似于类，但是接口只定义方法的签名，而不包含方法的实现。接口用于定义类应该遵循的行为规范，即一组方法的集合，而具体的实现由实现接口的类来完成。\n可以理解为特殊的类，接口的所有字段为 public static final ，不包含构造方法，成员方法中除了 默认方法 (default methods) 和静态方法 (static methods) 以外都是抽象方法\n接口的主要特点 接口无法实例化，不存在构造方法 接口的实现类要么是抽象类，要么实现接口中全部的抽象方法 接口允许多实现（一个实现类同时实现多个接口） 在 Java8 之前接口是无法定义具体方法实现的，所以即使有多个接口必须子类自己实现，所以并不会发生歧义。 Java8 之后出了默认方法（default method），该方法具有方法体，为了避免菱形继承的问题，强制规定，如果多个接口内有相同的默认方法，子类必须重写这个方法。 接口允许多继承 不要在定义接口的时候使用 final 关键字 Java为什么允许多实现不允许多继承 为什么不允许多继承 多继承会产生菱形继承的问题\nBC 继承了 A，然后 D 继承了 BC, 假设此时要调用 D 内定义在 A 的方法，因为 B 和 C 都有不同的实现，此时就会出现歧义，不知道应该调用哪个了\n为什么接口可以多实现？ 在 Java8 之前接口是无法定义具体方法实现的，所以即使有多个接口必须子类自己实现，所以并不会发生歧义。\nJava8 之后出了默认方法（default method），此时不就又出现的多继承的菱形继承问题了？\n所以 Java 强制规定，如果多个接口内有相同的默认方法，子类必须重写这个方法。\n接口的语法实现 定义接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 接口定义 public interface InterfaceName { // 常量（隐式 public static final） int CONSTANT_VALUE = 100; // 抽象方法（隐式 public abstract） void method1(); // 默认方法（Java 8 引入） default void defaultMethod() { System.out.println(\u0026#34;This is a default method.\u0026#34;); } // 静态方法（Java 8 引入） static void staticMethod() { System.out.println(\u0026#34;This is a static method.\u0026#34;); } } 实现接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 实现接口的类 public class MyClass implements InterfaceName { // 实现接口中的抽象方法 @Override public void method1() { System.out.println(\u0026#34;Method1 implemented in MyClass.\u0026#34;); } // 实现接口中的默认方法（可选） @Override public void defaultMethod(){ // 重写该方法 } } 接口中的变量 接口中的变量默认为public static final 接口中定义的变量会在编译的时候自动加上 public static final 修饰符 接口中的方法 抽象方法 抽象方法是接口的核心部分，所有实现接口的类都必须实现这些方法。接口中的方法默认为 public abstract（没有使用 private 、default 或者 static 关键字修饰的方法是隐式抽象的，在编译的时候会自动加上 public abstract 修饰符）\n注意事项 接口的抽象方法不能是 private、protected 或者 final 默认方法 接口中允许定义默认方法，默认方法被default修饰，必须具有方法体可供实现类使用或者重写，为实现该接口而不覆盖该方法的类提供默认实现\n定义格式 1 public default 返回值类型 方法名(形参列表){} 注意事项 默认方法可以被子接口继承 default 方法不需要被强制重写 如果子类没有重写接口中的默认方法，那么会直接使用接口中提供的默认实现 若子类重写了默认方法，要去除该方法中的 default 关键字 public 可以省略 不能通过接口名调用 如果子类实现了多个接口且多个接口内有相同的默认方法，子类必须重写这个方法。 静态方法 属于接口本身的方法，具有方法体，不依赖具体的实现类就能调用\n定义格式 1 public static 返回值类型 方法名(形参列表){} 调用格式 1 接口名.静态方法名() 私有方法 Java 9 引入了 接口私有方法，允许在接口中定义只能供默认方法和静态方法调用的私有辅助方法。这进一步增强了接口的灵活性和代码复用能力，同时隐藏了实现细节。\n方法类型 实例私有方法\n只能被默认方法调用。 不能被实现类调用，也不能被接口外部访问。 使用 private 关键字修饰。 静态私有方法\n只能被静态方法调用。 不能被默认方法或实现类调用。 接口的使用 作为变量类型 在 Java 中，接口不仅可以定义方法的签名，还可以作为 类型的约束，使得不同的类能够遵循相同的行为约定。\n在 Java 中，所有的类、接口、数组和枚举类型都被视为引用类型。接口定义了类应该具备的方法签名，但它本身不能直接创建实例。实际上，接口是用于为类定义一个“行为契约”的类型。接口可以作为变量类型，来指向那些实现了该接口的类的实例。\n多态性 Java 中的接口支持 多态性，这意味着一个接口类型的变量可以指向任何实现该接口的对象，哪怕是不同类的对象。因此，作为接口类型的变量，可以引用任何实现了接口的对象，而无需关心具体是哪一个类。\n接口和抽象类的区别 使用动机 抽象类的设计是 自下而上 的，当设计了很多类之后，发现类之间具有共性，有很多公共冗余的代码，于是设计抽象类将公共代码封装起来减少代码冗余\n接口的设计是 自上而下 的，我们事先知晓某一行为，基于这些行为约束定义了接口，一些类需要有这些行为，因此实现对应的接口。\n自上而下 指的是先约定接口，再实现。\n自下而上的 是先有一些类，才抽象了共同父类\n实际区别 方法实现 接口中的方法默认是 public 和 abstract（但在 Java8 之后可以设置 default 方法或者静态方法，而且default方法可以被实现类重写）。 抽象类可以包含 abstract 方法（没有实现）和具体方法（有实现）。它允许子类继承并重用抽象类中的方法实现。 构造函数和成员变量 接口不能包含构造函数，接口中的成员变量默认为 public static final ，即常量。 抽象类可以包含构造函数，成员变量可以有不同的访问修饰符（如 private 、protected 、public ），并且包含实例变量和静态变量。 多继承 抽象类只能单继承 接口可以有多个实现。 常见接口 Comparable接口 Comparable 接口是 Java 提供的一个用于定义对象自然排序的接口。它位于 java.lang 包中，常用于让类的对象能够通过 Collections.sort() 或 Arrays.sort() 方法进行排序。\n接口定义\n1 2 3 public interface Comparable\u0026lt;E\u0026gt; { public int compareTo(E o); } 接口使用\n让实现类实现该接口中的compareTo方法，返回值如下\n返回负值：当前对象小于参数对象 o。\n返回零值：当前对象等于参数对象 o。\n返回正值：当前对象大于参数对象 o。\n升序：当当前对象小于参数对象时，compareTo 返回负值。\n降序：当当前对象小于参数对象时，compareTo 返回正值。\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Person implements Comparable\u0026lt;Person\u0026gt; { private String name; private int age; // 构造方法 public Person(String name, int age) { this.name = name; this.age = age; } // 实现 compareTo 方法，按年龄升序排序 @Override public int compareTo(Person other) { return this.age - other.age; } // 重写 toString 方法，方便打印 @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } 缺点：需要在类定义时就要实现\nComparator接口 Comparator 是 Java 提供的一个用于定义对象自定义排序的接口，位于 java.util 包中。与 Comparable 接口不同，Comparator 可以让我们在不修改类本身代码的情况下，通过外部比较器灵活定义多种排序规则。\nComparator接口支持多排序规则：可以为同一类对象定义多种不同的排序规则，而不需要修改类本身。\n核心方法： compare\n1 int compare(T o1, T o2); 返回负值：当前对象o1小于参数对象 o2。\n返回零值：当前对象o1等于参数对象 o2。\n返回正值：当前对象o1大于参数对象 o2。\n升序：当当前对象小于参数对象时，compare 返回负值。\n降序：当当前对象小于参数对象时，compare 返回正值。\n使用方法\n声明一个比较器类实现Comparator接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 比较器类 import java.util.Comparator; public class AgeComparator implements Comparator\u0026lt;Person\u0026gt; { @Override public int compare(Person p1, Person p2) { return p1.getAge() - p2.getAge(); } } // 测试代码 import java.util.ArrayList; import java.util.Collections; import java.util.List; public class Test { public static void main(String[] args) { List\u0026lt;Person\u0026gt; people = new ArrayList\u0026lt;\u0026gt;(); people.add(new Person(\u0026#34;Alice\u0026#34;, 25)); people.add(new Person(\u0026#34;Bob\u0026#34;, 20)); people.add(new Person(\u0026#34;Charlie\u0026#34;, 30)); // 使用 AgeComparator 进行排序 Collections.sort(people, new AgeComparator()); // 输出排序结果 for (Person p : people) { System.out.println(p); } } } 在Collections.sort 或 Arrays.sort 方法，通过传入 Comparator 对象（匿名内部类）来进行排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import java.util.*; public class Test { public static void main(String[] args) { List\u0026lt;Person\u0026gt; people = new ArrayList\u0026lt;\u0026gt;(); people.add(new Person(\u0026#34;Alice\u0026#34;, 25)); people.add(new Person(\u0026#34;Bob\u0026#34;, 20)); people.add(new Person(\u0026#34;Charlie\u0026#34;, 30)); // 使用匿名内部类按年龄排序 Collections.sort(people, new Comparator\u0026lt;Person\u0026gt;() { @Override public int compare(Person p1, Person p2) { return p1.getAge() - p2.getAge(); } }); System.out.println(\u0026#34;按年龄排序：\u0026#34; + people); } } 其他方法\ncomparing(Function\u0026lt;T, U\u0026gt; keyExtractor)\t按指定字段升序排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import java.util.*; public class Test { public static void main(String[] args) { List\u0026lt;Person\u0026gt; people = Arrays.asList( new Person(\u0026#34;Alice\u0026#34;, 25), new Person(\u0026#34;Bob\u0026#34;, 20), new Person(\u0026#34;Charlie\u0026#34;, 30) ); // 按年龄升序排序 people.sort(Comparator.comparing(Person::getAge)); System.out.println(\u0026#34;按年龄升序排序：\u0026#34; + people); } } class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } reversed()\t将当前排序顺序反转\n1 2 people.sort(Comparator.comparing(Person::getAge).reversed()); System.out.println(\u0026#34;按年龄降序排序：\u0026#34; + people); thenComparing()\t在已有排序规则基础上追加新的排序规则\n1 2 people.sort(Comparator.comparing(Person::getAge).thenComparing(Person::getName)); System.out.println(\u0026#34;按年龄排序后再按姓名排序：\u0026#34; + people); naturalOrder()\t生成按自然顺序排序的 Comparator\n1 2 3 List\u0026lt;String\u0026gt; names = Arrays.asList(\u0026#34;Charlie\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;); names.sort(Comparator.naturalOrder()); System.out.println(\u0026#34;按自然顺序排序：\u0026#34; + names); reverseOrder()\t生成按自然顺序的反序排序 Comparator\n1 2 names.sort(Comparator.reverseOrder()); System.out.println(\u0026#34;按降序排序：\u0026#34; + names); nullsFirst()\t处理 null 值，null 排在前面\nnullsLast()\t处理 null 值，null 排在后面\nCloneable接口 Cloneable 接口是 Java 中的一个标记接口（Marker Interface），它位于 java.lang 包中。实现了 Cloneable 接口的类表示该类的对象可以使用 Object 类的 clone() 方法进行浅拷贝。\n深拷贝和浅拷贝 深拷贝：在复制对象的同时，将对象内部的所有引用类型字段的内容也复制一份，而不是共享引用。换句话说，深拷贝会递归复制对象内部所有引用类型的字段，生成一个全新的对象以及其内部的所有对象。\n浅拷贝：只复制对象本身和其内部的值类型字段，但不会复制对象内部的引用类型字段。换句话说，浅拷贝只是创建一个新的对象，然后将原对象的字段值复制到新对象中，但如果原对象内部有引用类型的字段，只是将引用复制到新对象中，两个对象指向的是同一个引用对象。\n浅拷贝的实现方式 使用 Object.clone() 方法是浅拷贝的常见方式。默认情况下，clone() 方法只是对对象的字段进行字段拷贝，对于基本类型的字段会复制值，对于引用类型的字段则复制引用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import java.util.*; public class Person implements Cloneable { private String name; private List\u0026lt;String\u0026gt; hobbies; public Person(String name, List\u0026lt;String\u0026gt; hobbies) { this.name = name; this.hobbies = hobbies; } @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, hobbies=\u0026#34; + hobbies + \u0026#39;}\u0026#39;; } @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); // 浅拷贝 } public static void main(String[] args) { try { List\u0026lt;String\u0026gt; hobbies = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;Reading\u0026#34;, \u0026#34;Traveling\u0026#34;)); Person p1 = new Person(\u0026#34;Alice\u0026#34;, hobbies); Person p2 = (Person) p1.clone(); System.out.println(\u0026#34;原对象：\u0026#34; + p1); System.out.println(\u0026#34;克隆对象：\u0026#34; + p2); // 修改原对象的 hobbies p1.hobbies.add(\u0026#34;Swimming\u0026#34;); // 查看克隆对象的 hobbies 是否也发生了变化 System.out.println(\u0026#34;修改后的原对象：\u0026#34; + p1); System.out.println(\u0026#34;修改后的克隆对象：\u0026#34; + p2); } catch (CloneNotSupportedException e) { e.printStackTrace(); } } } // 输出结果 // 原对象：Person{name=\u0026#39;Alice\u0026#39;, hobbies=[Reading, Traveling]} // 克隆对象：Person{name=\u0026#39;Alice\u0026#39;, hobbies=[Reading, Traveling]} // 修改后的原对象：Person{name=\u0026#39;Alice\u0026#39;, hobbies=[Reading, Traveling, Swimming]} // 修改后的克隆对象：Person{name=\u0026#39;Alice\u0026#39;, hobbies=[Reading, Traveling, Swimming]} 深拷贝的实现方式 实现 Cloneable 接口并重写 clone() 方法\n要求对象及其所有引用类型字段都实现 Cloneable 接口，并且重写 clone() 方法。在 clone() 方法中，通过递归克隆引用类型字段来实现深拷贝。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Address implements Cloneable { String city; public Address(String city) { this.city = city; } @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); // 浅拷贝 } } class Person implements Cloneable { String name; int age; Address address; public Person(String name, int age, Address address) { this.name = name; this.age = age; this.address = address; } @Override protected Object clone() throws CloneNotSupportedException { Person cloned = (Person) super.clone(); // 创建了一个浅拷贝的 Person 对象 cloned，此时 cloned 中的 address 引用与原始 Person 对象的 address 引用指向同一个 Address 对象。 cloned.address = (Address) address.clone(); // address 是当前对象（this）中的 Address 字段，调用 address.clone() 会对这个 Address 对象进行克隆，生成一个新的 Address 对象 return cloned; } } 手动递归复制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Person { String name; int age; Address address; public Person(String name, int age, Address address) { this.name = name; this.age = age; this.address = address; } // 手动复制字段 public Person(Person person) { this.name = person.name; this.age = person.age; this.address = new Address(person.address.city); } } class Address { String city; public Address(String city) { this.city = city; } } public class Main { public static void main(String[] args) { Address address = new Address(\u0026#34;河南省洛阳市\u0026#34;); Person person1 = new Person(\u0026#34;王二\u0026#34;, 18, address); Person person2 = new Person(person1); System.out.println(person1.address == person2.address); // false } } 序列号和反序列化的方式\n通过将对象序列化为字节流，再从字节流反序列化为对象来实现深拷贝。要求对象及其所有引用类型字段都实现 Serializable 接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import java.io.*; // Address 类实现 Serializable 接口 class Address implements Serializable { private static final long serialVersionUID = 1L; String city; public Address(String city) { this.city = city; } @Override public String toString() { return \u0026#34;Address{city=\u0026#39;\u0026#34; + city + \u0026#34;\u0026#39;}\u0026#34;; } } // Person 类实现 Serializable 接口 class Person implements Serializable { private static final long serialVersionUID = 1L; String name; int age; Address address; public Person(String name, int age, Address address) { this.name = name; this.age = age; this.address = address; } // 使用序列化和反序列化来实现深拷贝 public Person deepClone() throws IOException, ClassNotFoundException { // 序列化 ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); // 将当前对象写入字节流 // 反序列化 ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return (Person) ois.readObject(); // 从字节流中读取对象 } @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, age=\u0026#34; + age + \u0026#34;, address=\u0026#34; + address + \u0026#34;}\u0026#34;; } } public class DeepCopyDemo { public static void main(String[] args) throws IOException, ClassNotFoundException { // 创建原始对象 Address address = new Address(\u0026#34;New York\u0026#34;); Person person1 = new Person(\u0026#34;Alice\u0026#34;, 25, address); // 深拷贝 Person person2 = person1.deepClone(); // 修改原始对象的地址字段 person1.address.city = \u0026#34;Los Angeles\u0026#34;; // 输出两个对象 System.out.println(\u0026#34;原始对象: \u0026#34; + person1); System.out.println(\u0026#34;深拷贝对象: \u0026#34; + person2); } } ","date":"2024-11-15T10:46:39+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3/","title":"Java中的接口"},{"content":"抽象方法 定义 抽象方法是没有方法体的方法。它只是声明了方法的签名（方法名、返回类型、参数），而没有提供具体的实现。抽象方法只能出现在抽象类中，且必须由子类实现。\n特点 没有方法体： 抽象方法只定义方法的签名，没有具体实现。 必须由子类实现： 如果一个类继承了抽象类，必须实现抽象类中的所有抽象方法，除非子类本身也是抽象类。 语法格式 1 2 3 abstract class ClassName { abstract void methodName(); } 抽象类 定义 抽象类是一个不能直接实例化的类，通常包含抽象方法（未实现的方法）和已实现的方法。抽象类作为其他类的父类，提供通用的接口和功能，而让子类去实现和完善。\n特点： 不能实例化： 你不能直接创建抽象类的对象，只能通过其子类来实例化。\n可以有抽象方法和非抽象方法：\n抽象类可以包含抽象方法（没有方法体的方法），也可以包含已实现的方法（有方法体的普通方法）。 抽象类的子类必须实现所有抽象方法，除非子类本身也是抽象类。 抽象类不一定包含抽象方法，但是有抽象方法的一定是抽象类 构造方法： 抽象类可以有构造方法，构造方法可以被子类调用，用于初始化父类的成员变量。\n可以有字段（成员变量）： 抽象类可以定义实例字段（成员变量）和静态字段。\n可以实现接口： 抽象类可以实现接口，因此也可以被用于约定子类需要实现的接口方法。\n抽象类不能被final修饰：\nJava中的抽象类是用来被继承的，而final修饰符用于禁止类被继承或方法被重写，因此，抽象类和final修饰符是互斥的，不能同时使用。\n语法格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 abstract class ClassName { // 抽象方法（没有方法体） abstract void abstractMethod(); // 非抽象方法（有方法体） void concreteMethod() { System.out.println(\u0026#34;This is a concrete method.\u0026#34;); } // 可以有构造方法 public ClassName() { System.out.println(\u0026#34;Abstract class constructor.\u0026#34;); } } ","date":"2024-11-15T10:21:43+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/","title":"Java中的抽象类和抽象方法"},{"content":"局部代码块 定义 局部代码块 是 Java 中一种由一对大括号 {} 包裹的代码块，通常用于限制变量的作用域，或者在某些情况下提供代码逻辑的分隔。\n特点 作用域限制：局部代码块中的变量只在代码块内有效，代码块外不可访问，因此可以避免变量命名冲突，增强代码的可读性和可维护性。 不影响程序的控制流：局部代码块只是对代码逻辑的封装，不会改变程序的控制流。它通常是为了作用域控制或某些资源的临时管理。 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Test { public static void main(String[] args) { int x = 10; // 局部代码块 { int y = 20; // y的作用域仅限于该局部代码块 System.out.println(\u0026#34;x = \u0026#34; + x); // 可以访问外部的x System.out.println(\u0026#34;y = \u0026#34; + y); // 可以访问该代码块内定义的y } // System.out.println(\u0026#34;y = \u0026#34; + y); // 编译错误，y超出了作用域 } } 构造代码块 定义 构造代码块 是 Java 类中的一块独立代码，由一对大括号 {} 包裹，直接定义在类中，不属于任何方法或构造方法。当创建类的对象时，构造代码块会在每次调用构造方法前自动执行。\n构造代码块的作用是将一些对象的公共初始化逻辑集中起来，避免在每个构造方法中重复编写相同的代码。\n特点 构造代码块的书写位置在类的定义中，用于收集构造函数中的公共逻辑 类实例化的时候执行构造代码块，而且构造代码块内的逻辑在构造方法内的逻辑执行之前执行 代码初始化块里的执行顺序是从前到后的 构造代码块的实现原理 对象在初始化的时候会先调用构造方法，构造方法在执行的时候会把代码初始化块放在构造方法中其他代码之前\n静态代码块 定义 静态代码块（Static Block）是 Java 中的一种特殊代码块，它用于在类加载时执行一次初始化操作。静态代码块由 static 关键字修饰，通常用于初始化类的静态变量，或者执行一些静态资源的初始化工作。\n特点 只在类加载时执行一次： 静态代码块在类第一次被加载到内存时执行，不依赖于类的对象实例化。 在构造函数之前执行： 类的构造函数在对象创建时执行，而静态代码块在类加载时就执行，因此它会先于任何构造函数或实例方法执行。 可以访问类的静态成员： 静态代码块可以访问类的静态变量和静态方法，但不能访问实例变量和实例方法，因为此时类的实例尚未创建。 执行顺序： 如果类中有多个静态代码块，它们会按照定义的顺序依次执行。 语法格式 1 2 3 4 5 class ClassName { static { // 静态代码块中的初始化代码 } } 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 public class Example { // 静态变量 public static int staticVar = 1; // 实例变量 public int instanceVar = 2; // 静态初始化块 static { System.out.println(\u0026#34;执行静态初始化块\u0026#34;); staticVar = 3; } // 实例初始化块 { System.out.println(\u0026#34;执行实例初始化块\u0026#34;); instanceVar = 4; } // 构造方法 public Example() { System.out.println(\u0026#34;执行构造方法\u0026#34;); } public static void main(String[] args) { System.out.println(\u0026#34;执行main方法\u0026#34;); Example e1 = new Example(); Example e2 = new Example(); System.out.println(\u0026#34;e1的静态变量：\u0026#34; + e1.staticVar); System.out.println(\u0026#34;e1的实例变量：\u0026#34; + e1.instanceVar); System.out.println(\u0026#34;e2的静态变量：\u0026#34; + e2.staticVar); System.out.println(\u0026#34;e2的实例变量：\u0026#34; + e2.instanceVar); } } //执行结果 // 执行静态初始化块 // 执行main方法 // 执行实例初始化块 // 执行构造方法 // 执行实例初始化块 // 执行构造方法 // e1的静态变量：3 // e1的实例变量：4 // e2的静态变量：3 // e2的实例变量：4 ","date":"2024-11-15T09:35:34+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97/","title":"Java中的代码块"},{"content":"作用 final 关键字用于修饰不可被改变的变量/方法\n修饰方式 方法：被 final 修饰的方法不能被继承，同时也意味着不能被重写 类：被 final 修饰的类无法被继承 变量：表明这个变量是常量，只能被赋值一次 修饰基本数据类型则变量存储的数值不变 修饰引用数据类型则变量存储的地址值不变，但是对象的属性可以改变 ","date":"2024-11-14T23:16:07+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84final%E5%85%B3%E9%94%AE%E5%AD%97/","title":"Java中的final关键字"},{"content":"什么是封装 封装是指利用抽象将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。\n数据被保护在类的内部，尽可能地隐藏内部的实现细节，只保留一些对外接口使之与外部发生联系。\n其他对象只能通过已经授权的操作来与这个封装的对象进行交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。\n基本概念 数据隐藏：通过将类的字段（成员变量）声明为 private 或 protected，避免直接被外部访问。只有通过类提供的公共方法（如 getter 和 setter）才能访问和修改这些字段。 公共接口：通过公共方法（如 getter 和 setter）提供访问对象数据的方式。这样可以对数据进行控制和验证，确保数据的一致性和合法性。 保护数据：封装通过限制对数据的直接访问，减少了对对象状态的不安全修改和潜在的错误。 优势 数据保护：通过隐藏数据和提供受控的访问方法，可以防止外部代码对数据进行不合法的修改。 维护性：封装使得对象的内部实现与外部接口分离，可以更容易地对内部实现进行更改，而不影响外部使用者。 简化接口：提供简洁的公共接口，减少外部代码对类的复杂性理解，从而降低系统的耦合度。 代码复用：通过封装，类可以重用已有的功能而不必重新实现，有助于构建模块化和可维护的代码。 ","date":"2024-11-14T23:02:48+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%B0%81%E8%A3%85/","title":"Java中的封装"},{"content":"什么是多态 多态是指同一个接口或父类引用变量可以指向不同的对象实例，并根据实际指向的对象类型执行相应的方法。\n它允许同一方法在不同对象上表现出不同的行为，是面向对象编程（OOP）的核心特性之一\n多态的前提条件 子类继承父类 子类重写父类的方法 父类引用指向子类的对象 语法格式\n1 father_className father=new son_className () 多态的运行特点 调用成员变量 遵守规则：编译看声明类型（左边），运行看声明类型（左边）\n编译代码时，会看左边的父类中有没有该变量，若不存在该变量则编译失败\n运行代码时，实际获取的是左边父类中成员变量的值\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Parent { public int num = 10; } class Child extends Parent { public int num = 20; } public class Test { public static void main(String[] args) { Parent obj = new Child(); // 左边是Parent类型，右边是Child类型 System.out.println(\u0026#34;num = \u0026#34; + obj.num); // 访问属性 } } // 输出：num = 10 调用成员方法 遵守规则：编译看声明类型（左边），运行看实际类型（右边）\n编译代码时，会看左边的父类中有没有该方法，若不存在该方法则编译失败\n运行代码时，实际执行的是右边父子中成员方法\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Parent { public void show() { System.out.println(\u0026#34;Parent的show方法\u0026#34;); } } class Child extends Parent { @Override public void show() { System.out.println(\u0026#34;Child的show方法\u0026#34;); } } public class Test { public static void main(String[] args) { Parent obj = new Child(); // 左边是Parent类型，右边是Child类型 obj.show(); // 调用show方法 } } // 输出：Child的show方法 多态的实现原理 动态绑定 多态通过动态绑定实现，Java 使用虚方法表存储方法指针，方法调用时根据对象实际类型从虚方法表查找具体实现。\n多态的实现方式 编译时多态和运行时多态是面向对象编程中多态性的两种实现方式，它们分别在不同的阶段决定方法的绑定。\n编译时多态：通过方法重载实现，在编译时确定方法的调用。 运行时多态：通过方法重写实现，在运行时确定方法的调用。 编译时多态（Compile-time Polymorphism） 编译时多态，也称为静态多态，是在编译阶段确定方法的调用。编译时多态主要通过 方法重载（Method Overloading） 实现。\n方法重载：指在同一个类中定义多个方法，这些方法的名称相同但参数列表（参数的类型或数量）不同。Java 编译器在编译时会根据方法调用时传入的参数类型和数量，决定调用哪一个重载方法。\n注意事项\n重载中的方法同名但参数列表不同（参数个数、类型或顺序），注意和返回值没有关系，方法的签名仅是名字和参数列表，不包括返回值。\n重载通常用于提供同一操作的不同实现，例如构造函数的重载、不同类型输入的处理等。\n运行时多态（Runtime Polymorphism） 运行时多态，也称为动态多态，是在运行时确定方法的调用。运行时多态通过 方法重写（Method Overriding） 实现。\n方法重写：子类重写父类的一个或多个方法。通过父类引用调用方法时，实际执行的是子类重写后的方法。这种多态性是在运行时根据对象的实际类型决定的。\n注意事项\n在重写时，子类方法不能使用比父类更严格的访问级别。例如，父类的方法是 protected ，子类不能将其修改为 private ，但可以改为 public 。\n子类方法抛出的异常必须与父类一致，或者是其父类异常的子类。\n重写通常用于在子类中提供父类方法的具体实现，以实现多态性。例如，子类对父类方法进行扩展或修改以适应特定需求 。\n方法重载和方法重写的比较 方法重载（Overloading） ：在同一个类中，允许有多个同名方法，只要它们的参数列表不同（参数个数、类型或顺序）。主要关注方法的签名变化，适用于在同一类中定义不同场景下的行为，实现编译时多态性。\n方法重写（Overriding）：子类在继承父类时，可以重写父类的某个方法（参数列表、方法名必须相同），从而为该方法提供新的实现。主要关注继承关系，用于子类改变父类的方法实现，实现运行时多态性。\n区别 重载 重写 发生的场所 在同一个类中 在继承关系的子类和父类之间 参数列表 必须不同（参数的数量、类型或顺序不同） 必须相同，不能改变参数列表 返回类型 可以不同 必须与父类方法的返回类型相同，或者是父类返回类型的子类（协变返回类型） 访问修饰符 不受访问修饰符影响 子类方法的访问修饰符不能比父类更严格，通常是相同或更宽泛 静态和非静态方法 可以是静态方法或非静态方法 只能重写非静态方法，静态方法不能被重写（静态方法可以被隐藏） 异常处理 方法的异常处理可以不同 子类的异常不能抛出比父类更多的异常（可以抛出更少的或相同类型的异常） 向上转型和向下转型 向上转型（儿子变父亲） 向上转型是使用父类类型的引用指向子类对象，通过子类对象(小范围)实例化父类对象(大范围)\n父类引用变量指向子类对象后，只能使用父类已声明的方法，但方法如果被重写会执行子类的方法，如果方法未被重写那么将执行父类的方法。\n语法格式\n1 2 3 father_className father=new son_className () // 声明类型：father_className // 实际类型：son_className 向下转型（父亲变儿子） 向下转型是将父类引用转回其子类类型，通过父类对象(大范围)实例化子类对象(小范围)，但在执行前需要确认父类引用变量实际引用必须是子类对象才能成功转型以避免 ClassCastException\n向下转型允许我们通过父类引用访问子类特有的方法和属性\n语法格式 1 son_className son=(son_className) father 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Animal { public void makeSound() { System.out.println(\u0026#34;Animal makes a sound\u0026#34;); } } class Dog extends Animal { public void makeSound() { System.out.println(\u0026#34;Dog barks\u0026#34;); } public void wagTail() { System.out.println(\u0026#34;Dog wags its tail\u0026#34;); } } public class Test { public static void main(String[] args) { Animal animal = new Dog(); // 向上转型，父类引用指向子类对象 animal.makeSound(); // 调用子类重写的方法，输出：Dog barks // 向下转型，将Animal引用强制转换为Dog类型 if (animal instanceof Dog) { Dog dog = (Dog) animal; dog.wagTail(); // 输出：Dog wags its tail } else { System.out.println(\u0026#34;animal 不是 Dog 类型\u0026#34;); } Animal animal = new Cat(); // Animal引用指向Cat对象 // 强制将Cat对象转为Dog类型，会引发ClassCastException Dog dog = (Dog) animal; dog.makeSound(); } } instance of关键字 判断对象是否符合指定的类型，结果要么是 true，要么是 false\n语法格式\n1 2 3 4 5 6 (object) instanceof (className) // JDK16的新用法 if (obj instanceof String s) { // 如果类型匹配 直接使用 s } 判定为true的条件\nobject 是 ClassName 类型或其子类（或实现类）的对象 ClassName 是 object 实现的接口。 无论右边的类型是什么，null 对象总是返回 false。即：null instanceof SomeClass // 结果为 false\n","date":"2024-11-14T22:00:32+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81/","title":"Java中的多态"},{"content":"继承的定义 继承（inheritance）是面向对象中的一个概念。它使得复用以前的代码非常容易。\n在 Java 语言中继承就是子类继承父类的属性和方法，使得子类对象（实例）具有父类的属性和方法，或子类从父类继承方法，使得子类具有父类相同的方法。\n继承的优缺点 优点：\n代码复用：子类可以复用父类的代码，减少重复实现。 易于维护：可以通过修改父类代码来影响所有子类。 缺点：\n紧耦合：子类依赖于父类的实现，父类的修改可能会影响子类。 灵活性差：继承层次结构可能会变得复杂，不易于调整或扩展。 继承的特点 Java不允许多重继承（一个子类同时继承多个父类）但是支持多层继承，一个类只能继承一个父类 Object 类是所有类中的公共父类 继承当中子类抛出的异常必须是父类抛出的异常或父类抛出异常的子异常 子类可以继承父类的部分属性和方法 继承的语法实现 1 class 子类名 extends 父类名{} 子类继承的内容 父类的所有属性 子类继承父类的所有的属性（但是被private修饰的变量被隐藏无法直接使用）\n如果要使用父类的 private 属性可以通过父类的 getter 方法和 setter 方法\n父类的构造方法不能被继承 父类的构造方法不能被子类继承：因为构造方法语法是与类同名，而继承则不更改方法名，如果子类继承父类的构造方法，那明显与构造方法的语法冲突了。\n成员方法（虚方法） 方法传递机制 Java虚拟机从最顶级的父类开始设置虚方法表，父类会将虚方法表传递给自己的子类，然后在父类的虚方法表的基础上添加自己的虚方法从而形成自己的虚方法表\n虚方法的条件\n非 static 非 final 非**private** 只有虚方法表中的方法会被子类继承\nsuper关键字 super 关键字用于指代父类的存储空间\n指向父类对象； 调用父类的方法； super() 可以调用父类的无参构造方法。 继承中成员变量调用规则 成员变量的调用规则满足就近原则\n寻找顺序为：方法局部位置——\u0026gt;本类的成员位置——\u0026gt;父类成员位置\n逐级向上寻找\n使用 this 直接调用本类的变量\n使用 super 调用父类的变量\n继承中成员方法调用规则 直接调用 成员方法的调用规则满足就近原则\n寻找顺序为：方法局部位置——\u0026gt;本类的成员方法——\u0026gt;父类成员方法\n逐级向上寻找\n使用 this 直接调用本类的方法\n使用 super 调用父类的方法\n方法重写 子类中重写父类中的方法，保持返回值类型，方法名，参数列表不变，它建立在继承的基础上。\n重写条件 重写方法的名称、形参列表必须与父类中的一致。 子类重写父类方法时，访问权限子类必须大于等于父类( default \u0026lt; protected \u0026lt; public) 子类重写父类方法时，返回值类型子类必须小于等于父类 只有被添加到虚方法表中的方法才能被重写（静态方法，私有方法，被 final 修饰的方法不能重写） 继承当中子类抛出的异常必须是父类抛出的异常或父类抛出异常的子异常 底层实现 子类重写的新方法覆盖从父类继承来的虚方法表中父类的同名方法\n示例代码 1 2 3 4 5 6 7 8 9 10 11 class E1{ public void doA(int a){ System.out.println(\u0026#34;这是父类的方法\u0026#34;); } } class E2 extends E1{ @Override public void doA(int a) { System.out.println(\u0026#34;我重写父类方法，这是子类的方法\u0026#34;); } } 构造方法 子类的所有构造方法默认必须调用其父类的构造方法再执行自己的构造方法：Java 虚拟机构造子类对象前会先构造父类对象，父类对象构造完成之后再来构造子类特有的属性，这被称为内存叠加。 如果子类的构造方法中没有显式地调用父类构造方法，则系统默认调用父类无参数的构造方法：所有子类的构造方法第一行必须为**super()** 任何情况下实例化对象会调用继承链的所有父类构造方法 子类无法继承父类的构造方法但是可以通过super关键字来调用 当父类只有有参构造函数时，子类必须显式调用 super 并传入合适的参数。 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 正确继承演示 class A{ public String name; public A() {//无参构造 } public A (String name){//有参构造 } } class B extends A{ public B() {//无参构造 super(); } public B(String name) {//有参构造 //super(); super(name); } } 继承中类的加载顺序 在Java继承中，父子类初始化先后顺序为：\n父类中静态成员变量和静态代码块 子类中静态成员变量和静态代码块 父类中普通成员变量和代码块，父类的构造函数 子类中普通成员变量和代码块，子类的构造函数 总的来说，就是静态\u0026gt;非静态，父类\u0026gt;子类，非构造函数\u0026gt;构造函数。同一类别（例如普通变量和普通代码块）成员变量和代码块执行从前到后，需要注意逻辑。\n","date":"2024-11-14T19:21:51+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/","title":"Java中的继承"},{"content":"不可变类的定义 一个类的对象在通过构造方法创建后如果状态不会再被改变，那么它就是一个不可变（immutable）类。\n它的所有成员变量的赋值仅在构造方法中完成，不会提供任何 setter 方法供外部类去修改，这种类的实例在整个生命周期内保持不变。\n不可变类的实现 类被 final 修饰，保证该类不被继承 所有的字段都是 private 和 final 的，确保它们在初始化后不能被更改 不提供 setter 方法 通过构造函数初始化所有字段 如果类包含可变对象的引用，确保这些引用在对象外部无法被修改。例如 getter 方法中返回对象的副本（new 一个新的对象）来保护可变对象 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // 不可变类 Writer public final class Writer { private final String name; private final int age; private final Book book; public Writer(String name, int age, Book book) { this.name = name; this.age = age; this.book = book; } public int getAge() { return age; } public String getName() { return name; } // 确保返回的是可变对象的副本 public Book getBook() { Book clone = new Book(); clone.setPrice(this.book.getPrice()); clone.setName(this.book.getName()); return clone; } } // 可变类 Book public class Book { private String name; private int price; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getPrice() { return price; } public void setPrice(int price) { this.price = price; } @Override public String toString() { return \u0026#34;Book{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, price=\u0026#34; + price + \u0026#39;}\u0026#39;; } } 不可变类的特点 优点：\n线程安全：由于不可变对象的状态不能被修改，它们天生是线程安全的，在并发环境中无需同步。 缓存友好：不可变对象可以安全地被缓存和共享，如 String 的字符串常量池。 防止状态不一致：不可变类可以有效避免因意外修改对象状态而导致的不一致问题。 缺点：\n性能问题：不可变对象需要在每次状态变化时创建新的对象，这可能会导致性能开销，尤其是对于大规模对象或频繁修改的场景（例如 String 频繁拼接）。 ","date":"2024-11-14T19:07:43+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/","title":"Java中的不可变对象"},{"content":"static关键字 用于修饰成员变量，成员方法，代码块以及内部类，表示这是静态的，归属于整个类\n静态变量 被 static 修饰的成员变量\n特点 该变量被类的所有对象共享 静态变量不属于单个对象而属于整个类 随着类的加载而加载，在对象的产生之前存在 静态变量只会获取一次内存空间，所以任何对象对它的修改都会得到保留。如果一个实例修改了静态变量的值，其他实例也会看到这个更改。 内存原理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Student { String name; int age; static String school = \u0026#34;华南理工大学\u0026#34;; public Student(String name, int age) { this.name = name; this.age = age; } public static void main(String[] args) { Student s1 = new Student(\u0026#34;沉默王二\u0026#34;, 18); Student s2 = new Student(\u0026#34;沉默王三\u0026#34;, 16); } } s1 和 s2 这两个引用变量存放在栈区（stack） 沉默王二+18 这个对象和沉默王三+16 这个对象存放在堆区（heap） school 这个静态变量存放在公共的地址（静态区）。 调用方式 类名.静态变量（推荐） 对象名.静态变量 静态方法 被 static 修饰的成员方法\n特点 无须依赖类的实例就可以使用 只能访问静态变量和其他静态方法 不能使用 this 关键字，因为 this 代表当前对象实例，而静态方法属于类，不属于任何实例。 静态方法可以被重载（同类中方法名相同，但参数不同），但不能被子类重写（因为方法绑定在编译时已确定） 静态方法不具有多态性，即不支持方法的运行时动态绑定。 典型使用场景 工具类 工厂方法 调用方式 类名.静态方法（推荐） 对象名.静态方法 静态方法和实例方法的区别 特性 静态方法 实例方法 关键字 static 无 归属 类 对象 调用方式 通过类名或对象调用 通过对象调用 访问权限 只能访问静态变量和静态方法 可以访问实例变量、实例方法、静态变量和静态方法 典型用途 工具类方法、工厂方法 操作对象实例变量、与对象状态相关的操作 生命周期 类加载时存在，类卸载时消失 对象创建时存在，对象销毁时消失 ","date":"2024-11-14T17:11:24+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/","title":"Java中的静态变量和静态方法"},{"content":"MVC设计模式 MVC 是一种常见的软件设计模式，用于分离应用程序的不同部分以实现松散耦合和高内聚性。MVC 模式由三个核心组件组成：\n模型（Model）：表示应用程序的数据和业务逻辑。模型处理应用程序的数据，并根据控制器的指令执行相应的操作。 视图（View）：提供模型数据的用户界面。视图通常是模板、HTML 页面、XML 文件或其他格式，可以呈现模型数据给用户。 控制器（Controller）：处理用户交互并更新模型和视图。控制器负责接收来自视图的用户输入，对模型进行相应的操作，并更新视图以反映更改。 MVC 模式的优点是可以将代码分离成三个独立的组件，使得应用程序更易于维护和扩展。例如，如果要更改视图的外观，可以修改视图而不影响模型和控制器；如果要更改数据存储方式，可以修改模型而不影响视图和控制器。同时，MVC 模式还有助于降低应用程序中的耦合度，使得各组件更加独立和可重用。\nSpringMVC模块 概述： Spring MVC 是非常著名的 Web 应用框架，现在的大多数 Web 项目都采用 Spring MVC。它与 Spring 有着紧密的关系。是 Spring 框架中的模块，专注 Web 应用，能够使用 Spring 提供的强大功能，IOC、AOP等。 Spring MVC 框架底层是基于 Servlct 技术。遵循 Servlet 规范，Web 组件 Servlet 、Filter、Listener在 Spring MVC 中都能使用。同时 Spring MVC 也是基于 MVC 架构模式的，职责分离，每个组件只负责自己的功能，组件解耦。 Spring Boot 的自动配置、按约定编程极大简化，提高了 Web 应用的开发效率。 响应流程 大体流程：请求到控制器（controller），经过业务模型（model）处理后返回响应给视图层。\n具体流程：\n客户端请求：用户通过浏览器发送 HTTP 请求，所有请求都被 DispatcherServlet 接收。 执行拦截器的 preHandle()：如果配置了拦截器，Spring MVC 会首先执行 preHandle() 方法。如果返回 false，请求处理终止；否则，继续处理。 请求映射：DispatcherServlet 根据配置的处理器映射器（HandlerMapping）查找与请求 URL 对应的控制器 Controller 。 调用控制器方法 ：找到控制器后，DispatcherServlet 将使用 HandlerAdapter 来调用 Controller 的处理方法。转发给对应的控制器方法进行处理。控制器方法处理业务逻辑后，通常返回一个 ModelAndView 对象，包含数据模型和视图名称。 执行拦截器的 postHandle()：如果返回视图，拦截器的 postHandle() 方法会在视图渲染之前执行。对于 JSON 响应，该方法仍然会执行。 视图解析：DispatcherServlet 根据控制器返回的视图名称，使用视图解析器（ ViewResolver ）将逻辑视图名称解析为实际的视图 视图渲染返回：视图渲染引擎根据数据模型渲染视图，并将生成的 HTML 响应返回给客户端 结构组件 控制器controller 控制器是一种由 Spring 管理的 Bean 对象，赋予角色是“控制器”。\n作用：处理请求，接收浏览器发送过来的参数，将数据或视图应答给浏览器或者客户端 App等。\n具体实现：一个Java类，使用@Controller或@RestController\n提示\n@Controller 和 @RestController 注解的区别：\n@RestController 包含了 @Controller 的功能，同时加入了 @ResponseBody 的注解。 表示当前控制器类中的方法，都会默认加入 @ResponseBody 的功能。方法的返回值是数据可以通过 HttpServletResponse 输出给浏览器。 接收请求\n@RequestMapping ：用于将 Web 请求映射到控制器类的方法。此方法处理请求。可用作在类上或方法上。在类上和方法上同时使用。\n1 2 3 @RequestMapping(value = \u0026#34;/updateProduct\u0026#34;,method = RequestMethod.POST) public Result\u0026lt;String\u0026gt; updateProduct(@RequestParam MultipartFile file, @RequestParam String dname, @RequestParam String tname, @RequestParam String content,@RequestParam String olddname) Value：别名 path 表示请求的 URI，在类和方法上同时使用 value，方法上的继承类上的 value。 method：请求方式，支持 GET、POST、HEAD、OPTIONS、PUT、PATCH、DELETE、TRACE。值为：RequestMethod[] method()，RquestMethod 是 enum 类型。 快捷注解：\n@GetMapping: 表示 get 请求方式的@RequestMapping @PostMapping:表示 post 请求方式的@RequestMapping @PutMapping：表示 put 请求方式的@RequestMapping @DeleteMapping: 表示 delete 请求方式的@RequestMapping 接收请求参数\n@RequestParam：把请求中的指定名称的参数传递给控制器中的形参赋值\nvalue属性值指定请求中的参数 required 属性指定请求中的参数是否必须，默认为 true ，如果加上 required=false，没对应上则不会报错，而是获取值为 null。 如果参数前不写@RequestParam(xxx)的话，那么就前端可以有可以没有对应的参数名字都行，如果有参数名的话，那么就会自动匹配；没有的话，请求也能正确发送。 HttpServletRequest对象 使用 HttpServletRequest 对象接收参数，request.getParameter(\u0026quot;XXX\u0026quot;)获取对应的值，这是原始的 JavaWeb 中的方式 @RequestBody：主要用来接收前端传递给后端的json字符串中的数据的(通常json字符串放在请求体中)\nGET方式无请求体，所以使用@RequestBody接收数据时，前端不能使用GET方式提交数据，而是用POST方式进行提交。 在后端的同一个接收方法里，@RequestBody与@RequestParam()可以同时使用，@RequestBody最多只能有一个，而@RequestParam()可以有多个。 如果后端参数是一个对象，且该参数前是以@RequestBody修饰的，那么前端传递json参数时，必须满足以下要求：后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类(即：@RequestBody后面的类)时，会根据json字符串中的key来匹配对应实体类的属性，如果匹配一致且json中的该key对应的值符合(或可转换为)实体类的对应属性的类型要求时，会调用实体类的setter方法将值赋给该属性 @RequestHeader：从请求头中获取某些值\n1 2 3 4 5 6 7 8 9 10 11 12 import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestHeader; import org.springframework.web.bind.annotation.RestController; @RestController public class MyController { @GetMapping(\u0026#34;/greet\u0026#34;) public String greet(@RequestHeader(\u0026#34;User-Agent\u0026#34;) String userAgent) { return \u0026#34;Hello! You are using \u0026#34; + userAgent; } } 返回值\n不使用 @ResponseBody的 String 返回值，返回的是一个页面视图 使用 @ResponseBody的 String 返回值，返回的是一个JSON数据 返回ModelAndView ，返回的是一个视图其中包含数据。（最后数据都是放到 Request 中的） 返回自定义的对像，默认的返回格式是json字符串（有jackson工具） 返回 Map，默认的返回格式是json字符串（有jackson工具） 返回ResponseEntity：包含数据和自定义的HttpStatus Code。（默认转为json格式的字符串） 模型 Model 在许多实际项目需求中，后台要从控制层直接返回前端所需要的数据，这时 Model 大家族就派上用场了。 Model Spring MVC 中的 ”M“，是用来传输数据的。从控制层直接返回数据给前端。内置的 JSP，模板技术能够展现 Model 中存储的数据。 Model 可以是承载数据的，也可以是处理具体业务的类，这些都是指 Spring MVC 中的Model。 视图 View Spring MVC 中的 View（视图）用于展示数据的，视图技术的使用是可插拔的。无论选择使用 thymleaf、jsp 还是其他技术，classpath 有 jar 就能使用视图了。开发者主要就是更改配置。SpringBoot3 不推荐使用 FreeMarker、JSP 这些了。建议使用 Thymeleaf。 SpringMVC的核心组件 DispatcherServlet：核心的中央处理器，负责接收请求、分发，并给予客户端响应。\n当客户端发送请求时，DispatcherServlet 会先接收请求。 然后，它会根据请求 URL 通过 HandlerMapping 找到合适的处理器（Controller）。 处理完请求后，它会根据 ViewResolver 找到对应的视图，将处理结果发送回客户端。 HandlerMapping：处理器映射器，根据 URL 去匹配查找能处理的 Handler ，并会将请求涉及到的拦截器和 Handler 一起封装。\nHandlerAdapter：处理器适配器，根据 HandlerMapping 找到的 Handler ，适配执行对应的 Handler；\nHandler：请求处理器，处理实际请求的处理器。\n接收来自 DispatcherServlet 的请求，处理业务逻辑，并将处理结果返回给视图层。 ViewResolver：视图解析器，根据 Handler 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 DispatcherServlet 响应客户端\n根据控制器返回的视图名称找到对应的视图文件 ModelAndView ：控制器返回的对象，包含模型数据和视图名称。模型部分包含业务数据，视图部分指定渲染该数据的视图\nHandlerInterceptor ：在请求处理的各个阶段（如控制器方法执行前后）进行拦截。它可以用于实现日志记录、权限验证等功能。模板。\nSpringBoot框架中对SpringMVC框架的集成 自动配置：SpringBoot会自动配置一个嵌入式的Servlet容器（如Tomcat），并为我们提供默认的SpringMVC配置。这样我们无需手动配置Servlet容器和SpringMVC，只需添加相应的依赖即可快速搭建一个Web应用。 视图解析器：SpringBoot默认使用Thymeleaf作为视图解析器，如果需要更换其他视图解析器，可以在pom.xml中修改对应的依赖。 静态资源处理：SpringBoot默认会处理静态资源（如HTML、CSS、JavaScript等），并将其放在项目的/static或/public目录下。如果需要自定义静态资源的处理方式，可以通过编写一个类实现WebMvcConfigurer接口，并重写addResourceHandlers方法来实现。 拦截器：SpringBoot支持自定义拦截器，可以通过实现HandlerInterceptor接口来创建拦截器，同时编写一个类实现WebMvcConfigurer接口，并重写addInterceptors方法来实现。 异常处理：SpringBoot默认使用WhitelabelErrorView来处理异常，如果需要自定义异常处理方式，可以通过编写一个类实现ErrorController接口，并重写errorHtml方法来实现。 参数绑定：SpringBoot支持多种参数绑定方式，如@RequestParam、@PathVariable、@RequestBody等。如果需要自定义参数绑定方式，可以通过编写一个类实现MethodArgumentResolver接口，并重写resolveArgument方法来实现。 跨域支持：SpringBoot默认支持CORS跨域请求，如果需要自定义跨域配置，可以通过编写一个类实现WebMvcConfigurer接口，并重写addCorsMappings方法来实现。 Spring Boot中配置Spring MVC 配置方法 因为Spring Boot自动装配机制的存在，一般来说我们不需要对Spring MVC进行配置，如果要进行特别定制化的配置，Spring Boot也支持配置文件或者编写代码的两种方式来进行配置。\n方法一：修改application.xml 可以通过修改application.xml的spring.mvc属性来修改SpringBoot对SpringMVC的默认配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 spring: mvc: # 启用Spring MVC enabled: true # 配置静态资源路径 static-path-pattern: /static/** static-locations: classpath:/static/ # 配置视图解析器 view.prefix: /WEB-INF/views/ view.suffix: .jsp # 配置拦截器 interceptor: exclude-path-patterns: /login,/logout include-path-patterns: /admin/** # 配置HTTP缓存 resources: cache: period: 3600 servlet: # 配置文件上传 multipart: max-file-size: 10MB max-request-size: 10MB # 配置会话管理 session: timeout: 1800 cookie.max-age: 1800 # 配置JSON序列化 jackson: serialization: indent_output: true date-format: yyyy-MM-dd HH:mm:ss # 配置异常处理 error: whitelabel: enabled: false 方法二：编写一个被注解@WebMvcConfiguration修饰的Java配置类 WebMvcConfigurer 接口是Spring提供的一个用于自定义Spring MVC配置的接口，主要提供了WebMvcConfigurer接口是Spring提供的一个用于自定义Spring MVC配置的接口，主要提供了多个回调方法，包括添加或修改Spring MVC的配置，如添加拦截器，自定义消息转换器等。具体来说，WebMvcConfigurer 接口的主要方法包括：\nconfigurePathMatch（S）：此方法用于配置路由请求规则。 configureContentNegotiation（S）：该方法用于内容协商配置。 configureAsyncSupport（S）：该方法用于异步支持配置。 configureDefaultServletHandling（S）：该方法用于配置默认静态资源处理器。 addFormatters（S）：此方法用于注册自定义转化器。 addInterceptors（S）：此方法用于拦截器配置。 addResourceHandlers（S）：此方法用于资源处理。 addCorsMappings（S）：此方法用于CORS配置。 在使用时，只需要实现WebMvcConfigurer接口，重写上述的方法即可完成自定义配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @Configuration public class MyWebMvcConfig implements WebMvcConfigurer { // 配置视图解析器 @Override public void configureViewResolvers(ViewResolverRegistry registry) { InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix(\u0026#34;/WEB-INF/views/\u0026#34;); resolver.setSuffix(\u0026#34;.jsp\u0026#34;); registry.viewResolver(resolver); } // 配置静态资源 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\u0026#34;/static/**\u0026#34;).addResourceLocations(\u0026#34;/static/\u0026#34;); } // 配置拦截器 @Autowired private MyInterceptor myInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(myInterceptor).addPathPatterns(\u0026#34;/**\u0026#34;); } // 配置消息转换器 @Override public void configureMessageConverters(List\u0026lt;HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converters) { MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter(); List\u0026lt;MediaType\u0026gt; supportedMediaTypes = new ArrayList\u0026lt;MediaType\u0026gt;(); supportedMediaTypes.add(MediaType.APPLICATION_JSON); converter.setSupportedMediaTypes(supportedMediaTypes); converters.add(converter); } // 配置异常处理器 @ControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(value = Exception.class) public ModelAndView handleException(HttpServletRequest req, Exception e) { ModelAndView mav = new ModelAndView(); mav.addObject(\u0026#34;exception\u0026#34;, e); mav.addObject(\u0026#34;url\u0026#34;, req.getRequestURL()); mav.setViewName(\u0026#34;error\u0026#34;); return mav; } } // 配置全局跨域资源共享（CORS） @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\u0026#34;/user/*\u0026#34;) // 映射服务器中那些http接口运行跨域访问 .allowedOrigins(\u0026#34;http://localhost:8081\u0026#34;) // 配置哪些来源有权限跨域 .allowedMethods(\u0026#34;GET\u0026#34;,\u0026#34;POST\u0026#34;,\u0026#34;DELETE\u0026#34;,\u0026#34;PUT\u0026#34;); // 配置运行跨域访问的请求方法 } // 配置文件上传 @Bean public MultipartResolver multipartResolver() { CommonsMultipartResolver resolver = new CommonsMultipartResolver(); resolver.setMaxUploadSize(10485760); resolver.setMaxInMemorySize(4096); return resolver; } // 配置请求缓存 @Bean public KeyGenerator keyGenerator() { return new DefaultKeyGenerator(); } @Bean public RequestCache requestCache() { return new HttpSessionRequestCache(); } // 配置视图控制器 @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\u0026#34;/\u0026#34;).setViewName(\u0026#34;index\u0026#34;); registry.addViewController(\u0026#34;/login\u0026#34;).setViewName(\u0026#34;login\u0026#34;); } } 提示\n使用Springboot框架对SpringMVC的默认设置：直接编写控制器逻辑\n手动设置SpringMVC的部分功能，定义MVC的底层组件：@Configuration+配置WebMvcConfiguration，不要使用@EnableWebMvc\n手动设置SpringMVC的所有功能：@Configuration+配置WebMvcConfiguration+@EnableMvc\n使用 @EnableWebMvc 会完全覆盖 SpringBoot 对 SpringMVC 的自动配置，因此如果使用了 @EnableWebMvc，就需要自己配置 Spring MVC 的全部内容，包括视图解析器、资源处理、异常处理等。通常情况下，只有在需要非常精细的控制 Spring MVC 配置时才会使用 @EnableWebMvc。\n","date":"2024-11-14T16:21:47+08:00","permalink":"https://Tyritic.github.io/p/springmvc%E6%A8%A1%E5%9D%97/","title":"SpringMVC模块"},{"content":"构造方法的作用 用于给对象实例进行初始化，只有在构造方法被调用的时候，对象才会被分配内存空间。\n构造方法的调用时机 每次使用 new 关键字创建对象的时候，构造方法至少会被调用一次。\n定义构造方法的规则 构造方法的名字必须和类名一样 构造方法没有返回类型，包括 void 构造方法不能是抽象的（ abstract ）、静态的（ static ）、最终的（ final ）、同步的（ synchronized ）。 由于构造方法不能被子类继承，所以用 final 和 abstract 关键字修饰没有意义； 构造方法用于初始化一个对象，所以用 static 关键字修饰没有意义； 多个线程不会同时创建内存地址相同的同一个对象，所以用 synchronized 关键字修饰没有必要。 无参构造方法（默认构造方法） 如果一个构造方法中没有任何参数，那么它就是一个默认构造方法，也称为无参构造方法。\n通常情况下，无参构造方法是可以缺省的，开发者并不需要显式的声明无参构造方法，编译器将提供一个无参数，方法体为空的构造方法。\n当用户显式定义了构造方法后，系统将不再提供默认构造函数。\n默认构造方法的目的主要是为对象的字段提供默认值\n有参构造方法 有参数的构造方法被称为有参构造方法，参数可以有一个或多个。有参构造方法可以为不同的对象提供不同的值。\n如果没有有参构造方法的话，就需要通过 setter 方法给字段赋值了。\n重载构造方法 构造方法它也可以像方法一样被重载。构造方法的重载只需要提供不同的参数列表即可。编译器会通过参数的数量来决定应该调用哪一个构造方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class OverloadingConstrutorPerson { private String name; private int age; private int sex; public OverloadingConstrutorPerson(String name, int age, int sex) { this.name = name; this.age = age; this.sex = sex; } public OverloadingConstrutorPerson(String name, int age) { this.name = name; this.age = age; } public void out() { System.out.println(\u0026#34;姓名 \u0026#34; + name + \u0026#34; 年龄 \u0026#34; + age + \u0026#34; 性别 \u0026#34; + sex); } public static void main(String[] args) { OverloadingConstrutorPerson p1 = new OverloadingConstrutorPerson(\u0026#34;王二\u0026#34;,18, 1); p1.out(); OverloadingConstrutorPerson p2 = new OverloadingConstrutorPerson(\u0026#34;王三\u0026#34;,16); p2.out(); } } 拷贝构造方法 利用一个已有对象将该对象的参数字段直接传递给新的对象\n语法格式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 语法格式 class_name(class_name obj) { //字段赋值操作 } //示例代码 public class CopyConstrutorPerson { private String name; private int age; public CopyConstrutorPerson(String name, int age) { this.name = name; this.age = age; } public CopyConstrutorPerson(CopyConstrutorPerson person) { this.name = person.name; this.age = person.age; } public void out() { System.out.println(\u0026#34;姓名 \u0026#34; + name + \u0026#34; 年龄 \u0026#34; + age); } public static void main(String[] args) { CopyConstrutorPerson p1 = new CopyConstrutorPerson(\u0026#34;沉默王二\u0026#34;,18); p1.out(); CopyConstrutorPerson p2 = new CopyConstrutorPerson(p1); p2.out(); } } ","date":"2024-11-14T12:15:40+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/","title":"Java中的构造方法"},{"content":"就近原则 通常是指在方法调用过程中，编译器或 JVM 根据 \u0026ldquo;就近\u0026rdquo; 的方式来解析某些元素，特别是 变量、方法、类型、类 等的访问。\n示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Example { private int x = 10; // 类成员变量 public void myMethod(int x) { // 参数 x 会遮蔽成员变量 x System.out.println(\u0026#34;Local x: \u0026#34; + x); // 使用的是方法参数 x System.out.println(\u0026#34;Member x: \u0026#34; + this.x); // 使用成员变量 x } public static void main(String[] args) { Example obj = new Example(); obj.myMethod(20); } } this关键字 this关键字用于指代类实例化后的当前实例\n使用场景 当局部变量和实例变量重名时进行区分 其中被this修饰的变量是实例变量\n不被 this修饰的变量是局部变量\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class WithThisStudent { String name; int age; WithThisStudent(String name, int age) { this.name = name; this.age = age; } void out() { System.out.println(name+\u0026#34; \u0026#34; + age); } public static void main(String[] args) { WithThisStudent s1 = new WithThisStudent(\u0026#34;王二\u0026#34;, 18); WithThisStudent s2 = new WithThisStudent(\u0026#34;王三\u0026#34;, 16); s1.out(); s2.out(); // 输出： // 王二 18 // 王三 16 } } 调用当前类的方法 可以在一个类中使用 this 关键字来调用另外一个方法，如果没有使用的话，编译器会自动帮我们加上\n调用当前类的其他构造方法 this关键字可以用于在当前类的构造方法中调用当前类的其他构造方法，但是this() 必须放在构造方法的第一行\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 调用当前类的无参构造方法 public class InvokeConstrutor { InvokeConstrutor() { System.out.println(\u0026#34;hello\u0026#34;); } InvokeConstrutor(int count) { this(); System.out.println(count); } public static void main(String[] args) { InvokeConstrutor invokeConstrutor = new InvokeConstrutor(10); } // 输出 // hello // 10 } // 调用当前类的有参构造方法 public class InvokeParamConstrutor { InvokeParamConstrutor() { this(10); System.out.println(\u0026#34;hello\u0026#34;); } InvokeParamConstrutor(int count) { System.out.println(count); } public static void main(String[] args) { InvokeParamConstrutor invokeConstrutor = new InvokeParamConstrutor(); } } 作为方法的参数 this 关键字可以作为参数在方法中传递，此时，它指向的是当前类的对象。\n作为返回值实现链式调用 this 关键字作为方法的返回值的时候，方法的返回类型为类的类型\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class ThisAsMethodResult { ThisAsMethodResult getThisAsMethodResult() { return this; } void out() { System.out.println(\u0026#34;hello\u0026#34;); } public static void main(String[] args) { new ThisAsMethodResult().getThisAsMethodResult().out(); } } 内存实现 this代表当前调用方法的对象引用，哪个对象调用方法，this就代表哪个对象的地址值\n","date":"2024-11-14T11:44:37+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84this%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E5%B0%B1%E8%BF%91%E5%8E%9F%E5%88%99/","title":"Java中的this关键字和就近原则"},{"content":"面向对象编程和面向过程编程 面向对象编程 面向对象编程是一种编程范式，它将现实世界中的事物抽象为对象，把类或对象作为基本单元来组织代码，对象具有属性（称为字段或属性）和行为（称为方法）。面向对象编程的设计思想是以对象为中心，通过对象之间的交互来完成程序的功能，具有灵活性和可扩展性，通过封装和继承可以更好地应对需求变化。\n面向过程编程 面向过程编程是一种以过程或函数为中心的编程范式，以过程作为基本单元来组织代码。过程其实就是动作，对应到代码中来就是函数，面向过程中函数和数据是分离的，数据就是成员变量。\n主要区别 数据与行为的关系：\n面向对象：数据和行为封装在对象内部，数据操作由对象方法进行管理。 面向过程：数据和函数是分离的，函数对数据进行操作。 可扩展性和复用性：\n面向对象：通过继承、接口、多态等机制支持代码的高复用性和扩展性。 面向过程：复用性较低，扩展需要修改已有代码，影响整体稳定性。 面向对象的特性和设计原则 三大特性 封装：将数据和行为封装在对象内部，提供接口进行访问，隐藏实现细节，提高安全性。 继承：子类可以继承父类的属性和方法，实现代码复用和扩展。 多态：对象可以通过父类或接口进行多态性调用，不同对象在运行时执行不同的行为。 六大设计原则 单一职责原则（SRP）：一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例子：考虑一个员工类，它应该只负责管理员工信息，而不应负责其他无关工作。 开放封闭原则（OCP）：软件实体应该对扩展开放，对修改封闭。例子：通过制定接口来实现这一原则，比如定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身。 里氏替换原则（LSP）：子类对象应该能够替换掉所有父类对象。例子：一个正方形是一个矩形，但如果修改一个矩形的高度和宽度时，正方形的行为应该如何改变就是一个违反里氏替换原则的例子。 接口隔离原则（ISP）：客户端不应该依赖那些它不需要的接口，即接口应该小而专。例子：通过接口抽象层来实现底层和高层模块之间的解耦，比如使用依赖注入。 依赖倒置原则（DIP）：高层模块不应该依赖低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。例子：如果一个公司类包含部门类，应该考虑使用合成/聚合关系，而不是将公司类继承自部门类。 最少知识原则 (Law of Demeter)：一个对象应当对其他对象有最少的了解，只与其直接的朋友交互。 类的组成结构 变量（属性） 静态变量：归属于整个类 实例变量：归属于一个对象 方法（行为） 静态方法：归属于整个类 实例方法：归属于一个对象 实现细节 打印对象名可以输出该对象的内存地址 成员变量具有默认值 一个源文件中可以定义多个类但是只能出现一个主类（被 public 修饰）且该类与源文件的文件名相同 内存原理 对象在内存中的创建过程 加载 .class 文件 在栈区声明局部变量（对象的引用） 在堆区中开辟内存空间并产生对象的地址值 默认初始化（对成员变量赋默认值） 显式初始化（对常量进行初始化） 构造方法初始化 单个对象的内存情况 栈区 主方法 main\n对象的引用\n堆区 对象的变量 成员方法的地址 项目开发中类的种类 Bean类 使用场景 用于描述事物的类\n特点 至少两个构造方法，一个无参构造方法，一个有参构造方法 成员变量为 private 为所有成员变量提供 getter 和 setter 工具类（Utils) 使用场景 将常用的方法封装成工具类\n特点 构造方法是 private 的 方法都是静态方法（ static ） 测试类 使用场景 用于检查代码的正确性\n特点 带有 main 方法 ","date":"2024-11-14T10:26:52+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","title":"Java中的类与对象"},{"content":"简介 Springdoc-OpenApi是一个规范且完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。\nSpringdoc-OpenApi 的目标是对 REST API 定义一个标准且和语言无关的接口，可以让人和计算机拥有无须访问源码、文档或网络流量监测就可以发现和理解服务的能力。\n具体使用 引入具体依赖springfox\n1 2 3 4 5 6 \u0026lt;!-- 导入相关依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springdoc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springdoc-openapi-starter-webmvc-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 添加配置类用于Api文档的基本配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package org.example.user.config; import io.swagger.v3.oas.models.OpenAPI; import io.swagger.v3.oas.models.info.Contact; import io.swagger.v3.oas.models.info.Info; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class SpringDocConfig { // OpenAPI类用于定制全局文档信息 @Bean public OpenAPI customOpenAPI() { return new OpenAPI() // 定制文档基本信息 .info(new Info() //关于文档信息 .title(\u0026#34;API 文档标题\u0026#34;) .description(\u0026#34;API 文档描述\u0026#34;) .version(\u0026#34;1.0.0\u0026#34;) .termsOfService(\u0026#34;https://example.com/terms\u0026#34;) //关于开发者 .contact(new Contact() .name(\u0026#34;开发者姓名\u0026#34;) .url(\u0026#34;开发者网址\u0026#34;) .email(\u0026#34;开发者邮箱\u0026#34;)) //关于许可证 .license(new License() .name(\u0026#34;许可证名称\u0026#34;) .url(\u0026#34;许可证文件\u0026#34;))) //配置服务器信息（可选） .servers(List.of( new Server().url(\u0026#34;服务器url\u0026#34;).description(\u0026#34;服务器描述\u0026#34;), new Server().url(\u0026#34;https://api.example.com\u0026#34;).description(\u0026#34;生产服务器\u0026#34;))) //配置外部文档信息（可选） .externalDocs(new ExternalDocumentation() .description(\u0026#34;外部文档描述\u0026#34;) .url(\u0026#34;外部文档url\u0026#34;)); } } 修改application.yml配置文件\n1 2 3 4 5 springdoc: api-docs: enable: true swagger-ui: enable: true 其余属性参见官方文档 SpringDoc-OpenApi官方文档\n提示\n1 2 3 4 5 6 7 8 springdoc: group-configs: #进行文档分组每个组配置对应的请求路径以及区分所在包 - group: \u0026#39;user\u0026#39; paths-to-match: \u0026#39;/api/users/**\u0026#39; packages-to-scan: com.toher.springdoc.user - group: \u0026#39;product\u0026#39; paths-to-match: \u0026#39;/api/product/**\u0026#39; packages-to-scan: com.toher.springdoc.product 可以在微服务架构中进行分组\n查看接口文档\nSwagger-UI接口文档：http://localhost:8080/swagger-ui/index.html Json形式接口文档：localhost:8080/v3/api-docs 使用注解编写接口文档\n常用注解 对实体类的描述 @Schema：用于描述类或字段的数据结构和属性，支持OpenAPI 3规范中的各种特性，如类型、格式、默认值等。\n1 2 3 4 5 6 7 8 9 10 11 12 @Data @NoArgsConstructor @AllArgsConstructor @Builder public class User { @Schema(description = \u0026#34;用户ID\u0026#34;, example = \u0026#34;1\u0026#34;) private int id; @Schema(description = \u0026#34;用户姓名\u0026#34;, example = \u0026#34;张三\u0026#34;) private String name; @Schema(description = \u0026#34;用户年龄\u0026#34;, example = \u0026#34;18\u0026#34;) private int age; } 对方法的描述 @Operation：用于方法级别，提供对API操作的详细描述，包括摘要、描述、响应、参数等信息。\nsummary：操作的简要描述。 description：操作的详细描述。 tags：与操作相关的标签。 operationId：操作的唯一标识符。 parameters：操作的参数列表。 responses：操作的响应列表。 1 2 3 4 5 6 7 8 9 10 @Operation( summary = \u0026#34;获取用户信息\u0026#34;, description = \u0026#34;根据用户ID获取用户详细信息\u0026#34;, tags = {\u0026#34;用户操作\u0026#34;}, operationId = \u0026#34;getUserById\u0026#34; ) @RequestMapping(\u0026#34;/users\u0026#34;) public User getUserById(@PathVariable Long id) { // 实现逻辑 } @ApiResponses是一个容器注解，用于收集多个@ApiResponse，描述方法可能返回的各种响应情况。\n@ApiResponse描述了API操作的一个特定响应，包括响应的状态码、描述、内容类型等。\nresponseCode：响应代码。 description：响应描述。 content：响应内容。 1 2 3 4 5 6 7 8 9 10 11 12 13 @RequestMapping(value=\u0026#34;/{id}\u0026#34;, method = RequestMethod.GET) @Operation(summary = \u0026#34;findById方法\u0026#34;, description = \u0026#34;根据id查询用户\u0026#34;) @Parameter(name = \u0026#34;id\u0026#34;, description = \u0026#34;用户id\u0026#34;, required = true, in = ParameterIn.PATH) @ApiResponses(value = { @ApiResponse(responseCode = \u0026#34;200\u0026#34;, description = \u0026#34;查询成功\u0026#34;,content={@Content(mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = Result.class))}), @ApiResponse(responseCode = \u0026#34;500\u0026#34;, description = \u0026#34;查询失败\u0026#34;,content={@Content(mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = Result.class))}) }) public Result\u0026lt;User\u0026gt; findById(@PathVariable Integer id) { return Result.success(\u0026#34;查询成功\u0026#34;, new User(id, \u0026#34;张三\u0026#34;, 20)); } @Parameters是一个容器注解，用于收集多个@Parameter注解，描述方法的多个请求参数。\n@Parameter：用于描述单个请求参数，可以是查询参数、路径参数、请求头等。\nname：参数名。 description：参数描述。 required：是否必需参数。 in：参数所在位置（query、header、path、cookie）。 1 2 3 4 5 6 7 8 @Parameters(value = { @Parameter(name = \u0026#34;name\u0026#34;, description = \u0026#34;姓名\u0026#34;, in = ParameterIn.PATH), @Parameter(name = \u0026#34;age\u0026#34;, description = \u0026#34;年龄\u0026#34;, in = ParameterIn.QUERY) }) @GetMapping(\u0026#34;/{name}\u0026#34;) public List\u0026lt;Programmer\u0026gt; getProgrammers(@PathVariable(\u0026#34;name\u0026#34;) String name, @RequestParam(\u0026#34;age\u0026#34;) Integer age) { ... } 对类的描述 @Tag：用于标记API控制器或方法属于哪一个功能分类或标签，有助于组织和分类API文档中的不同部分\n1 2 3 4 5 6 @Tag(name = \u0026#34;程序员\u0026#34;, description = \u0026#34;程序员乐园\u0026#34;) @RestController @RequestMapping(\u0026#34;/api/programmer\u0026#34;) public class ProgrammerController { ... } ","date":"2024-11-12T10:01:20+08:00","permalink":"https://Tyritic.github.io/p/springboot%E6%95%B4%E5%90%88springdoc-openapi/","title":"SpringBoot整合Springdoc-OpenApi"},{"content":"Restful服务 Restful是目前流行的互联网软件服务架构设计风格。REST（Representational State Transfer）是一种 无状态 的架构风格，它以 HTTP 协议为基础，通过 定义资源 和 标准的操作方法 来组织接口，使得客户端和服务器之间的交互更加简单、清晰和高效。\n服务特点 每一个URL代表一种资源 客户端使用GET、POST、PUT、DELETE四种表示操作方式的动词对服务端资源进行操作：GET用于获取资源，POST用于新建资源（也可以用于更新资源），PUT用于更新资源，DELETE用于删除资源。 通过操作资源的表现形式来实现服务端请求操作。 资源的表现形式是JSON或者HTML。 客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都包含必需的信息。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @RestController public class UserController{ @ApiOperation(\u0026#34;获取用户\u0026#34;) @GetMapping(\u0026#34;/user/{id}\u0026#34;) public String getUserById(@PathVariable int id){ System.out.println(id); return \u0026#34;根据ID获取用户信息\u0026#34;; } @PostMapping(\u0026#34;/user\u0026#34;) public String save(User user){ return \u0026#34;添加用户\u0026#34;; } @PutMapping(\u0026#34;/user\u0026#34;) public String update(User user){ return \u0026#34;更新用户\u0026#34;; } @DeleteMapping(\u0026#34;/user/{id}\u0026#34;) public String deleteById(@PathVariable int id){ System.out.println(id); return \u0026#34;根据ID删除用户\u0026#34;; } } 最佳实现 接口设计 URL的组成 网络协议 服务器地址 接口名称 ？参数列表（GET方法） 响应设计 Content-body用来存放数据 用于描述数据的msg和code放入Content-header中 RestTemplate 简介 RestTemplate是Spring提供的用于访问Rest服务的，RestTemplate提供了多种便捷访问远程Http服务的方法，传统情况下在java代码里访问restfuI服务，一般使用Apache的HttpClient，不过此种方法使用起来太过繁琐。spring提供了一种简单便捷的模板类来进行操作，这就是RestTemplate.（常用于客户端和微服务）\n具体使用 以微服务为例\n创建一个Controller类（用 @RestController 修饰）\n创建一个Config类对RestTemplate进行配置和创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Configuration public class RestTemplateConfig { /** * 没有实例化RestTemplate时，初始化RestTemplate * 性能上OkHttp优于Apache的HttpClient，Apache的HttpClient优于HttpURLConnection（默认）。 * @return */ @ConditionalOnMissingBean(RestTemplate.class) @Bean public RestTemplate restTemplate(){ RestTemplate restTemplate = new RestTemplate(getClientHttpRequestFactory()); return restTemplate; } /** * 使用OkHttpClient作为底层客户端 * @return */ private ClientHttpRequestFactory getClientHttpRequestFactory(){ OkHttpClient okHttpClient = new OkHttpClient.Builder() .connectTimeout(5, TimeUnit.SECONDS) .writeTimeout(5, TimeUnit.SECONDS) .readTimeout(5, TimeUnit.SECONDS) .build(); return new OkHttp3ClientHttpRequestFactory(okHttpClient); } } 进行依赖注入并使用该Bean对象\n常见方法 GET请求 getForObject：获取请求体\n不带参数：(uri, \u0026lt;T \u0026gt;.class) 代表 请求地址、HTTP响应转换被转换成的对象类型 带参数(uri, String.class, paramMap) 代表 请求地址、HTTP响应转换被转换成的对象类型，请求参数 getForEntity：获取整个请求，除了包含响应体，还包含HTTP状态码、contentType、contentLength、Header等信息\nPOST请求 postForObject：获取请求体 postForEntity：获取整个请求，除了包含响应体，还包含HTTP状态码、contentType、contentLength、Header等信息 PUT请求 put： Delete请求 delete： 通用请求 exchange(String url, HttpMethod method,@Nullable HttpEntity\u003c?\u003e requestEntity, Class responseType, Map uriVariables) url: 请求地址； method: 请求类型(如：POST,PUT,DELETE,GET)； requestEntity: 请求实体，封装请求头，请求内容 responseType: 响应类型，根据服务接口的返回类型决定 uriVariables: url中参数变量值 ","date":"2024-11-11T18:48:31+08:00","permalink":"https://Tyritic.github.io/p/resttemplate%E5%92%8Crestful%E9%A3%8E%E6%A0%BC%E6%8E%A5%E5%8F%A3/","title":"RestTemplate和Restful风格接口"},{"content":"List集合的定义 在 Java 中，List 是一个接口，继承自 Collection 接口，表示一个有序的元素集合。List 集合中的元素是按插入顺序排列的，允许元素重复。\nList集合的特点 集合中允许重复元素 集合中的元素是按插入顺序排列 集合支持动态扩容 只能存储引用数据类型，基本数据类型要转化成包装类 List接口的实现类 ArrayList：基于动态数组实现，支持快速随机访问，插入和删除操作效率相对较低，适用于查询频繁的场景。 LinkedList：基于双向链表实现，支持快速插入和删除，查询效率较低，适用于频繁修改的场景。 Vector：与 ArrayList 类似，但它是同步的，线程安全的，适用于多线程并发的场景（但现在不常用）。 Stack：继承自 Vector，实现了栈的功能，支持后进先出（LIFO）操作。 List接口的常用方法 增加元素 boolean add(E e)：将指定的元素添加到列表的末尾 void add(int index, E element)：将指定的元素插入到列表的指定位置 boolean addAll(Collection\u0026lt;? extends E\u0026gt; c)：将指定集合中的所有元素添加到当前列表的末尾 boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c)：将指定集合中的所有元素插入到当前列表的指定位置。 删除元素 void clear()：删除全部元素 E remove(int index)：删除列表中指定位置的元素 boolean remove(Object o)：删除列表中第一次出现的指定元素。如果列表中没有该元素，则不做任何操作。 boolean removeAll(Collection\u0026lt;?\u0026gt; c)：删除当前列表中所有与指定集合中的元素相同的元素 void removeRange(int from,int to)：删除索引[from，to）之间的元素 判断元素 boolean contains(Object o)：判断列表中是否包含指定的元素 boolean containsAll(Collection\u0026lt;?\u0026gt; c)：判断列表是否包含指定集合中的所有元素 修改元素 E set(int index, E element)：用指定的元素替换列表中指定位置的元素 访问元素 E get(int index)：返回指定位置的元素 int indexOf(Object o)：返回指定元素在列表中的第一次出现位置的索引。如果列表中没有该元素，则返回 -1 int lastIndexOf(Object o)：返回指定元素在列表中的最后一次出现位置的索引。如果列表中没有该元素，则返回 -1 获取大小 int size()：返回列表中元素的数量 boolean isEmpty()：判断列表是否为空 ","date":"2024-11-11T15:34:52+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84list%E6%8E%A5%E5%8F%A3/","title":"Java中的List接口"},{"content":"集合体系结构 Collection 接口：单列数据，所有集合类的根接口，提供基本的集合操作方法 List 接口：元素有序（存储顺序与存放顺序一致），可重复有索引的集合 ArrayList ：基于动态数组，查询速度快，插入、删除慢，线程不安全。 LinkedList ：基于双向链表，插入、删除快，查询速度慢，线程不安全。 Vector ：线程安全的动态数组，类似于 ArrayList，但开销较大。 Set 接口：元素无序，不可重复，无索引的集合 HashSet ：基于哈希表，元素无序，不允许重复。 LinkedHashSet ：基于链表和哈希表，维护插入顺序，不允许重复。 TreeSet ：基于红黑树，元素有序（元素是按照自然顺序或提供的比较器进行排序的），不允许重复。 Queue 接口：表示一个先进先出的集合 PriorityQueue ：基于优先级堆，元素按照自然顺序或指定比较器排序。 LinkedList ：可以作为队列使用，支持 FIFO（先进先出）操作。 ArrayQueue ：基于数组实现的双端队列 Map 接口：双列数据，保存具有映射关系的键值对 HashMap ：基于哈希表，键值对无序，不允许键重复，线程不安全。 LinkedHashMap ：基于链表和哈希表，维护插入顺序，不允许键重复。 TreeMap ：基于红黑树，键值对有序，不允许键重复。 Hashtable ：线程安全的哈希表，不允许键或值为 null。 ConcurrentHashMap ：线程安全的哈希表，适合高并发环境，不允许键或值为 null。 Collection接口 Collection 接口是 Java 集合框架的根接口，定义了集合类的基本操作方法。\n添加元素 boolean add(E e) ：将指定的元素添加到集合中，如果集合允许该元素的添加（比如没有重复元素限制），则返回 true，如果集合已经包含该元素，则返回 false 向 List 集合中添加数据则方法将固定返回 true ，List 集合中允许添加重复元素 向 Set 集合中添加数据若当前元素已经存在返回 false，若当前元素不存在返回 true boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) ：将指定集合中的所有元素添加到当前集合中 如果当前集合因为某些原因没有改变（例如集合为空或元素没有添加成功），则返回 false，否则返回 true。 删除元素 void clear() ：移除集合中的所有元素，使集合为空。 boolean remove(Object o) ：从集合中移除指定的元素。 如果集合中包含该元素并且成功移除，返回 true；如果元素不存在，返回 false。 boolean removeAll(Collection\u0026lt;?\u0026gt; c)：移除集合中与指定集合相同的所有元素。 如果集合因移除操作发生变化，则返回 true；如果没有任何元素被移除，则返回 false。 boolean retainAll(Collection\u0026lt;?\u0026gt; c) ：只保留集合中与指定集合相同的元素，移除其他元素。 如果集合发生变化（即移除了某些元素），则返回 true；如果没有元素被移除，则返回 false。 判断元素 boolean contains(Object o) ：判断集合是否包含指定元素 如果集合中包含该元素，返回 true；否则返回 false。 boolean containsAll(Collection\u0026lt;?\u0026gt; c)：判断当前集合是否包含指定集合中的所有元素。 boolean isEmpty()：判断集合是否为空 如果集合中没有元素，返回 true ；否则返回 false。 遍历方法 迭代器 Iterator 是 Java 集合框架中用于遍历集合元素的接口，允许开发者依次访问集合中的每一个元素，而不需要关心集合的具体实现。它提供了一种统一的方式来遍历 List、Set 等集合类型，通常与 Collection 类接口一起使用。Iterator 只能单向遍历集合，不能向前遍历。\n核心方法 hasNext() ：返回 true 表示集合中还有下一个元素，返回 false 则表示遍历完毕。 next()：返回集合中的下一个元素，如果没有更多元素则抛出 NoSuchElementException。 remove()：从集合中移除最近一次通过 next() 方法返回的元素，执行时只能在调用 next() 之后使用。这个方法是可选的，不是所有的实现都支持该操作。如果不支持，调用时会抛出 UnsupportedOperationException。 注意事项 迭代器越界会报错 迭代器遍历完毕，指针不会复位 迭代器遍历时不允许使用集合的方法进行添加和删除 （fail—fast）， 在用迭代器遍历一个集合对象时，如果线程 A 遍历过程中，线程 B 对集合对象的内容进行了修改（增加、删除、修改），则会抛出 Concurrent Modification Exception。 原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class IteratorExample { public static void main(String[] args) { // 创建一个List集合并添加元素 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;Apple\u0026#34;); list.add(\u0026#34;Banana\u0026#34;); list.add(\u0026#34;Cherry\u0026#34;); // 获取集合的迭代器 Iterator\u0026lt;String\u0026gt; iterator = list.iterator(); // 使用迭代器遍历集合 while (iterator.hasNext()) { String element = iterator.next(); System.out.println(element); // 输出元素 // 删除元素（示例：删除“Banana”） if (element.equals(\u0026#34;Banana\u0026#34;)) { iterator.remove(); // 删除“Banana” } } // 打印修改后的集合 System.out.println(\u0026#34;Modified list: \u0026#34; + list); } } // 输出： // Apple // Banana // Cherry // Modified list: [Apple, Cherry] ListIterator（List 特有的迭代器） ListIterator 是 Iterator 的子接口，专门用于操作 List 类型集合。与 Iterator 不同，它支持双向遍历和元素修改。\n核心方法\nhasPrevious()：判断是否还有前一个元素。 previous()：返回前一个元素。 add(E e)：向当前遍历的位置插入元素。 set(E e)：修改当前元素。 for-each循环 语法格式 1 2 3 for (Type item : collection) { // 使用 item } 主要特点 简洁性：语法更简单，减少了初始化、条件检查和更新的样板代码。适合用于遍历数组和实现了 Iterable 接口的集合。 只读访问：不提供对当前索引的访问，因此不适合需要根据索引进行复杂操作的场景。 安全性：在遍历过程中不能修改集合的结构（例如，不能在遍历 List 的同时添加或删除元素），否则会抛出 ConcurrentModificationException。 底层实现 实际上是通过 Iterator 实现的。Java 编译器会将 for-each 循环转换为一个使用 Iterator 或索引的标准迭代过程。\nLambda表达式遍历（forEach方法） 集合类（如 List、Set）实现了 Iterable 接口，Iterable 接口提供了一个默认的 forEach 方法，可以直接与 Lambda 表达式结合，进行遍历。\n语法格式 1 2 3 4 5 6 7 8 foreach(new Consumer\u0026lt;? super T\u0026gt; action) { @Override public void accept(T s) { //重写 } } ","date":"2024-11-11T09:36:04+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E5%92%8C%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/","title":"Java中的集合体系和集合遍历方式"},{"content":"devtool热部署 为了进一步提高开发效率,springboot为我们提供了全局项目热部署,日后在开发过程中修改了部分代码以及相关配置文件后,不需要每次重启使修改生效,在项目中开启springboot全局热部署之后只需要在修改之后等待几秒即可使修改生效。\n开启热部署 引入相关依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; Java的日志体系 日志门面 每一种日志框架都有自己单独的API，要使用对应的框架就要使用其对应的API，这就大大的增加应用程序代码对于日志框架的耦合性。\n为了解决这个问题，就是在日志框架和应用程序之间架设一个沟通的桥梁，对于应用程序来说，无论底层的日志框架如何变，都不需要有任何感知。只要门面服务做的足够好，随意换另外一个日志框架，应用程序不需要修改任意一行代码，就可以直接上线。总而言之，日志门面用于整合不同日志框架的日志（类似接口），不实现具体日志\n常见的日志门面\nJCL（Java Common Logging）：Java自带的日志门面 SLF4J：目前最常用的日志门面 JCL 用户可以自由选择第三方的日志组件作为具体实现，像log4j，或者jdk自带的jul， common-logging会通过动态查找的机制，在程序运行时自动找出真正使用的日志库。\nJCL默认的情况下，会使用JUL日志框架做日志的记录操作。\nJCL使用原则：如果有log4j，优先使用log4j，如果没有任何第三方日志框架的时候，使用的就是JUL。再没有则使用JCL内部提供的 SimpleLog 实现\n具体实现\n导入相关依赖\n编写业务代码\n1 2 3 4 5 6 7 public class JulMain { public static void main(String[] args){ Log log= LogFactory.getLog(JulMain.class) log.info(\u0026#34;Hello world\u0026#34;); } } SLF4J 简单日志门面(Simple Logging Facade For Java) SLF4J主要是为了给Java日志访问提供一套标准、规范的API框架，\n主要意义：提供接口，具体的实现可以交由其他日志框架，例如log4j和logback等。\n对于一般的Java项目而言，日志框架会选择slf4j-api作为门面，配上具体的实现框架（log4j、logback等），中间使用桥接器完成桥接。所以我们可以得出SLF4J最重要的两个功能就是对于日志框架的绑定以及日志框架的桥接。\n具体使用\n引入相关依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!--slf4j 核心依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--slf4j 自带的简单日志实现 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-simple\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--具体日志框架的slf4j桥接器（可选）--\u0026gt; 编写业务代码(如果在没有任何其他日志实现框架集成的基础之上，slf4j使用的就是自带的框架slf4j-simple，slf4j-simple也必须以单独依赖的形式导入进来。)\n1 2 3 4 5 6 7 8 9 10 public class SLF4JTest01 { // 都是slf4j包下的 Logger logger = LoggerFactory.getLogger(SLF4JTest.class); logger.trace(\u0026#34;trace信息\u0026#34;); logger.debug(\u0026#34;debug信息\u0026#34;); logger.info(\u0026#34;info信息\u0026#34;); logger.warn(\u0026#34;warn信息\u0026#34;); logger.error(\u0026#34;error信息\u0026#34;); } 日志实现和对应的日志门面 日志实现 日志门面 log4j（已经淘汰） JCL/SLF4J JUL（java.utils.logging) JCL log4j2 SLF4J logback SLF4J 提示\n记录日志不能直接使用日志实现框架，必须通过日志门面来实现\n日志实现 JUL JUL全称 Java Util Logging，核心类在java.util.logging包下，它是java原生的日志框架，使用时不需要另外引用第三方的类库，相对其他的框架使用方便，学习简单，主要是使用在小型应用中。\n组件构成\nLogger：被称为记录器，应用程序通过获取Logger对象，调用其API来发布日志信息。Logger通常被认为是访问日志系统的入口程序。 Handler：处理器，每个Logger都会关联一个或者是一组Handler，Logger会将日志交给关联的Handler去做处理，由Handler负责将日志做记录。Handler具体实现了日志的输出位置，比如可以输出到控制台或者是文件中等等。 Filter：过滤器，根据需要定制哪些信息会被记录，哪些信息会被略过。 Formatter：格式化组件，它负责对日志中的数据和信息进行转换和格式化，所以它决定了我们输出日志最终的形式。 Level：日志的输出级别，每条日志消息都有一个关联的级别。我们根据输出级别的设置，用来展现最终所呈现的日志信息。根据不同的需求，去设置不同的级别。 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 日志示例 public static void test02() { /* 日志的级别，总共七级 Level.SEVERE：（最高级）错误 Level.WARNING：警告 Level.INFO：（默认级别）消息 Level.CONFIG：配置级别 Level.FINE：详细信息（少） Level.FINER：详细信息（中） Level.FINEST：（最低级）详细信息（多） 两个特殊的级别： Level.OFF；可用来关闭日志记录 Level.ALL：启用所有日志记录 */ // Logger创建方式，参数为当前类全路径字符串com.demo.logger.jul.JULTest Logger logger = Logger.getLogger(JULTest.class.getCanonicalName()); logger.severe(\u0026#34;severe信息\u0026#34;); logger.warning(\u0026#34;warning信息\u0026#34;); logger.info(\u0026#34;info信息\u0026#34;); logger.config(\u0026#34;config信息\u0026#34;); logger.fine(\u0026#34;fine信息\u0026#34;); logger.finer(\u0026#34;finer信息\u0026#34;); logger.finest(\u0026#34;finest信息\u0026#34;); /* 输出内容：我们看到，默认是输出info及比info信息级别高的信息 三月 20, 2023 9:47:27 下午 com.demo.logger.jul.JULTest test02 严重: severe信息 三月 20, 2023 9:47:27 下午 com.demo.logger.jul.JULTest test02 警告: warning信息 三月 20, 2023 9:47:27 下午 com.demo.logger.jul.JULTest test02 信息: info信息 */ } SpringBoot日志框架 SpringBoot框架底层使用slf4j+logback的方式进行日志记录同时对于其他日志实现都提供了slf4j日志门面的集成\nSpringBoot日志使用 日志级别 trace：日志追踪信息 debug：日志详细信息 info：日志的关键信息 默认打印级别 warn：日志警告信息 error：日志错误信息 只有级别大于日志核心配置文件的 rootlevel 的信息才会输出，SpringBoot默认的 rootlevel 是info\n可以在application.yml中进行 rootlevel 的修改\n1 2 3 4 5 6 7 8 9 10 #修改全局的rootlevel logging: level: root: #可以只修改某个包下日志的rootlevel #示例 logging: level: com: example: 日志记录器声明 方法一：Java语句声明\n1 2 //1.声明日志记录器 Logger logger=LoggerFactory.getLogger(全类名) 方法二：使用注解@Slf4j(这个注解基于lombok依赖)\n1 2 3 4 @Slf4j public class userController{ } ​\n日志格式 默认格式 日期和时间：毫秒精度，易于排序 日志级别：ERROR，WARN，INFO，DEBUG，或TRACE 进程ID \u0026mdash;：分离器来区分实际日志消息的开始。 线程名称:用方括号括起来(对于控制台输出可能会被截断) 记录器名称:这通常是源类名称(通常缩写)。 日志消息。 修改默认格式 可以在application.yml中修改logging.pattern.console属性来修改格式详情常见SpringBoot官方文档\n1 2 3 logging: pattern: console: SpringBoot官方文档\n日志输出 日志默认在控制台输出，可以通过修改applicaiton.yml中的logging.file.name和logging.file.path来输出日志文件\n1 2 3 4 5 6 7 8 logging: file: #只指定name属性不指定path属性则默认日志文件输出在项目的根目录中 #name属性可以同时指定输出路径和日志文件名例如D:/mylog.log name:日志文件名 #不可以指定文件名，只能指定一个物理文件夹路径，默认文件名为spring.log path:日志文件的输出路径 日志的归档和迭代 在application.yml中可以设置相关参数实现日志的归档和迭代\n名称 描述 logging.logback.rollingpolicy.file-name-pattern 归档的文件名 logging.logback.rollingpolicy.clean-history-on-start 是否在应用程序启动时进行日志归档清理。 logging.logback.rollingpolicy.max-file-size 归档前日志文件的最大大小。 logging.logback.rollingpolicy.total-size-cap 删除日志档案之前可以使用的最大大小 logging.logback.rollingpolicy.max-history 保留日志存档的天数(默认为7) 示例代码\n1 2 3 4 5 6 logging: file: name: 日志文件名 path: 日志文件的输出路径 max-file-size: 日志文件的最大大小(日志文件超出该大小则生成归档的压缩包) max-history: 日志文件保留的时间 切换日志框架 将SpringBoot底层默认日志框架logback修改为log4j2\n排除logback的场景启动器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;!‐‐starter‐web里面自动添加starter‐logging 也就是logback的依赖‐‐\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring‐boot‐starter‐web\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;!‐‐排除starter‐logging 也就是logback的依赖‐‐\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;spring‐boot‐starter‐logging\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 添加log4j2的场景启动器\n1 2 3 4 5 \u0026lt;!‐‐Log4j2的场景启动器‐‐\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring‐boot‐starter‐log4j2\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; ","date":"2024-11-09T19:20:26+08:00","permalink":"https://Tyritic.github.io/p/springboot%E7%83%AD%E9%83%A8%E7%BD%B2%E5%92%8C%E6%97%A5%E5%BF%97/","title":"SpringBoot热部署和日志"},{"content":"分模块设计与开发 将项目的不同业务功能划分为不同的Maven模块\n优点\n方便项目的维护拓展 方便模块的相互调用 继承 概念：继承描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。 作用：简化依赖配置、统一管理依赖（所有子工程共有的依赖配置在父工程中）\n所有的SpringBoot项目都继承一个统一的父工程spring-boot-starter-parent\n具体实现： 创建maven模块，该工程为父工程，设置打包方式pom(默认jar)\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.itheima\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.8-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; 在子工程的pom.xml文件中，配置继承关系。\n1 2 3 4 5 6 \u0026lt;parents \u0026lt;groupId\u0026gt;com.itheima\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;../ tlias-parent/pom,xml\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; 提示\n在子工程中，配置了继承关系之后，坐标中的groupId是可以省略的，因为会自动继承父工程的 relativePath指定父工程的pom文件的相对位置(如果不指定，将从本地仓库/远程仓库查找该工程)。 在父工程中配置各个工程共有的依赖(子工程会自动继承父工程的依赖)。 提示\n若子工程和父工程的依赖版本不同，以子工程的为准 打包方式 pom：父工程，该模块无代码只进行依赖管理 jar：内嵌Tomcat服务器 war：普通web程序，部署在在外部Tomcat服务器 版本锁定 在maven中，可以在父工程的pom文件中通过\u0026lt;dependencyManagement \u0026gt;来统一管理依赖版本。\n在父工程的pom文件中指定依赖版本后，子工程引入依赖时不需要指定依赖版本，变更依赖版本时在父工程的pom文件中统一更改\n示例\n1 2 3 4 5 6 7 8 9 10 11 #父工程 \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--JWT令牌--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 1 2 3 4 5 6 7 #子工程 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 提示\n\u0026lt; dependencies \u0026gt;和\u0026lt; dependencyManage \u0026gt;的区别\n\u0026lt; dependencies \u0026gt;是直接依赖，子工程的pom无须引入 \u0026lt; dependencyManage \u0026gt;是版本管理，子工程的pom依然需要引入 自定义属性/引用属性 可以在pom文件中使用标签\u0026lt;properties\u0026gt;标签来自定义属性\n1 2 3 4 \u0026lt;properties\u0026gt; \u0026lt;lombok.versiqn\u0026gt;1.18.24\u0026lt;/lombok.version\u0026gt; \u0026lt;jjwt.version\u0026gt;8.9.0\u0026lt;/jjwt.version\u0026gt; \u0026lt;/properties\u0026gt; 然后使用${}来引用自定义属性\n1 2 3 4 5 6 7 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 聚合 概述：将多个模块组织成一个整体，同时进行项目的构建。 聚合工程：一个不具有业务功能的“空”工程(有且仅有一个pom文件)通常是继承中的父工程 具体实现：在父工程中使用标签\u0026lt;module\u0026gt;指定子模块\n1 2 3 4 5 \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;../tlias-pojo\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;,./tlias-utils\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../tlias-web-management\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; 提示\n聚合工程中所包含的模块，在构建时，会自动根据模块间的依赖关系设置构建顺序，与聚合工程中模块的配置书写位置无关。\n继承和聚合的区别 作用\n聚合用于快速构建项目 继承用于简化依赖配置、统一管理依赖 相同点\n聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中 聚合与继承均属于设计型模块，并无实际的模块内容 不同点\n聚合是在聚合工程中配置关系，聚合可以感知到参与聚合的模块有哪些 继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己 ","date":"2024-11-09T12:27:38+08:00","permalink":"https://Tyritic.github.io/p/maven%E9%AB%98%E7%BA%A7/","title":"Maven高级"},{"content":"起步依赖 原理：SpringBoot框架提供的起步依赖通过Maven的依赖传递集成了开发中常见的依赖\nSpringBoot的启动流程 @SpringBootApplication 注解 这是SpringBoot启动的核心注解\n组成部分 @SpringBootConfiguration：\nSpring 的 @Configuration 注解的特殊形式，表示这是一个 Spring 配置类，Spring 会根据该类来加载和注册 Bean。\n作用类似于传统的 XML 配置文件，它让类中的 @Bean 方法生效，并将其注册到 Spring 容器中。\n@EnableAutoConfiguration：\nSpring Boot 的自动配置机制的核心，负责启用 Spring Boot 的自动配置功能。\nSpring Boot 会根据应用的类路径、已添加的依赖以及定义的配置（如 application.properties 或 application.yml），自动配置 Spring 应用的相关组件和 Bean，简化了手动配置\n@ComponentScan：\n启用组件扫描功能，自动发现并注册 @Component、@Service、@Repository、@Controller 等注解标注的 Spring 组件。\n它会扫描 @SpringBootApplication 所在类的当前包及其子包，自动将符合条件的组件加载到 Spring 容器中。\n作用 简化配置 ：通过这个组合注解，Spring Boot 项目可以不用手动配置 @Configuration、@EnableAutoConfiguration、@ComponentScan，使应用更易于启动和管理。 自动配置 ：借助自动配置机制，开发者无需手动配置许多 Spring 组件，Spring Boot 会根据项目依赖来自动注入所需的 Bean。 组件扫描 ：自动扫描和加载定义在项目中的 Spring 组件，简化了 Bean 注册过程。 总体流程 启动 main() 方法\n应用从 main() 方法启动，并通过 SpringApplication.run() 引导应用启动。\n应用会创建SpringApplication 对象，推断应用类型、设置初始化器、设置启动监听器、确定主应用类。\n准备环境（ConfigurableEnvironment）\nSpring Boot 在启动过程中准备应用环境，加载配置文件、系统环境变量以及命令行参数。 创建ApplicationContext\n创建应用上下文，加载配置类和自动配置类，注册 Bean 并执行依赖注入等初始化操作。 刷新ApplicationContext并启动内嵌 Web 服务器\n对于 Web 应用，Spring Boot 会自动启动嵌入式 Web 容器（如 Tomcat），并注册相关的 Servlet 和 Filter。 自动配置\n通过 @EnableAutoConfiguration 自动配置各种组件 请求处理\n内嵌的 DispatcherServlet 负责处理 HTTP 请求。 自动配置 概念 当spring容器启动后，一些配置类、bean对象就自动存入到了IOC容器中，不需要手动去声明，从而简化了开发，省去了繁琐的配置操作。\n实现方案 方案一：@ComponentScan 组件扫描依赖 1 2 3 4 @SpringBootApplication @ComponentScan({\u0026#34;com.alibaba\u0026#34;,\u0026#34;com.google\u0026#34;,\u0026#34;org.springframework\u0026#34;,\u0026#34;org.mybatis\u0026#34;,...} public class springbootWebconfig2Application{ } 方案二：@lmport 导入 使用 @lmport 导入的类会被Spring加载到I0C容器中，导入形式主要有以下几种:\n导入 普通类 导入 配置类 导入 ImportSelector 接口实现类 @EnableXXX注解，封装了@Import 1 2 3 4 5 @Import({TokenParser.class,Headerconfig.class}) @SpringBootApplication public class springbootWebconfig2Application{ } 源码分析 查看启动类的注解 @SpringBootApplication 的源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //自定义组件所需的元注解 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited //表示启动类也是一个配置类 @SpringBootConfiguration //自动配置功能 @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) 提示\n为什么在启动类中可以声明第三方Bean对象？\n@SpringBootApplication 中封装了 @SpringBootConfiguration ，表明启动类也是一个配置类\n为什么启动类只会扫描启动类所在包及其子包的组件\n@SpringBootApplication 中封装了 @ComponentScan 的注解\n由 @SpringBootApplication 的注解源码可知自动配置由注解 @EnableAutoConfiguration 提供，查看 @EnableAutoConfiguration 的注解\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import({AutoConfigurationImportSelector.class}) public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = \u0026#34;spring.boot.enableautoconfiguration\u0026#34;; Class\u0026lt;?\u0026gt;[] exclude() default {}; String[] excludeName() default {}; } 可以看出 @EnableAutoConfiguration 注解通过 @Import 注解导入 ImportSelector 接口实现类来实现自动配置\n查看 AutoConfigurationImportSelector.class 的源码\n1 2 3 4 5 6 7 8 public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!this.isEnabled(annotationMetadata)) { return NO_IMPORTS; } else { AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); } } selectImports 方法返回要导入的Bean对象的全类名\n从 AutoConfigurationImportSelector.class 的源码可以知道返回值从 autoConfigurationEntry.getConfigurations() 获得而 autoConfigurationEntry 由 AutoConfigurationImportSelector.getAutoConfigurationEntry 方法获得。查看 getAutoConfigurationEntry 的源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) { if (!this.isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } else { AnnotationAttributes attributes = this.getAttributes(annotationMetadata); List\u0026lt;String\u0026gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); configurations = this.removeDuplicates(configurations); Set\u0026lt;String\u0026gt; exclusions = this.getExclusions(annotationMetadata, attributes); this.checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = this.getConfigurationClassFilter().filter(configurations); this.fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); } } 从 AutoConfigurationImportSelector.getAutoConfigurationEntry 看出 configuration 是一个List\u0026lt;String\u0026gt;对象，从 AutoConfigurationImportSelector.getCandidateConfigurations(annotationMetadata, attributes) 中获得。查看 AutoConfigurationImportSelector.getCandidateConfigurations(annotationMetadata, attributes) 的源码\n1 2 3 4 5 protected List\u0026lt;String\u0026gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List\u0026lt;String\u0026gt; configurations = ImportCandidates.load(AutoConfiguration.class, this.getBeanClassLoader()).getCandidates(); Assert.notEmpty(configurations, \u0026#34;No auto configuration classes found in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you are using a custom packaging, make sure that file is correct.\u0026#34;); return configurations; } SpringBoot框架会自动加载 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 的配置文件并封装到 configurations 这个List集合中\n实现过程 @SpringBootApplication 注解封装了 @EnableAutoConfiguration 来实现自动配置\n@EnableAutoConfiguration 封装了 @Import 注解，该注解以引入 ImportSelector 接口的实现类 AutoConfigurationImportSelector 来完成自动装配\nAutoConfigurationImportSelector 获取 AutoConfigurationEntry 对象，该对象具有成员变量 Configurations 用于存储Bean对象的全类名\nAutoConfigurationEntry 使用 getCandidateConfigurations 方法，SpringBoot框架会自动加载 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 配置文件并封装到 configurations 这个List集合中\nMETA-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 中封装了Bean对象的声明\n总而言之\n@SpringBootApplication 内封装了 @SpringBootConfiguration 表示SpringBoot启动类本身就是一个配置类，同时封装了**@EnableConfiguration** 注解实现自动装配 @EnableConfiguration 通过 @Import 引入了 AutoConfigurationImportSelector 类，这个类实现了**ImportSelector** 接口，这个接口的作用就是收集需要导入的配置类，配合 @Import() 就将相应的类导入到 Spring 容器中。 扫描 classpath 下所有的 META-INF/spring.factories 中的文件，根据文件中指定的配置类加载相应的 Bean 的自动配置。 条件配置 @Conditional 作用：按照一定的条件进行判断，在满足给定条件后才会注册对应的bean对象到SpringIOC容器中。\n位置：方法、类\n@Conditional 本身是一个父注解，派生出大量的子注解:\n@Conditional0nClass ：判断环境中是否有对应字节码文件，才注册bean到IOC容器。 @ConditionalOnMissingBean ：判断环境中没有对应的bean(类型或名称)，才注册bean到IOC容器。 @ConditionalOnProperty：判断配置文件中有对应属性和值，才注册bean到IOC容器。 ","date":"2024-11-08T18:47:12+08:00","permalink":"https://Tyritic.github.io/p/springboot%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","title":"SpringBoot底层原理"},{"content":"概述 AOP全称是 Aspect Oriented Programming (面向切面编程)，是一种编程范式，用于将跨领域的关注点（如日志记录、安全检查、事务管理等）与业务逻辑分离开来。它允许开发者通过“切面”（Aspect）将这些通用功能模块化，并将其应用到应用程序中的多个地方，从而避免代码重复。\n核心思想：AOP 的核心思想是将与业务逻辑无关的横切关注点抽取出来，通过声明的方式动态地应用到业务方法上，而不是将这些代码直接嵌入业务逻辑中。\n底层实现 ：动态代理是面向切面编程最主流的实现。主要通过底层的动态代理机制，对特定的方法进行编程。\n应用场景\n记录操作日志 权限控制 事务管理 具体实现 导入相关依赖\n创建一个服务类（目标方法）\n1 2 3 4 5 6 7 8 9 10 11 @Service public class MyService { public void performTask() { System.out.println(\u0026#34;Task performed\u0026#34;); } public String sayHello(String name) { return \u0026#34;Hello, \u0026#34; + name; } } 定义切面（Aspect）和通知（Advice）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @Aspect @Component public class LoggingAspect { // 切入点：匹配 MyService 类中所有方法 @Pointcut(\u0026#34;execution(* com.example.service.MyService.*(..))\u0026#34;) public void serviceMethods() {} // 前置通知：在目标方法执行之前执行 @Before(\u0026#34;serviceMethods()\u0026#34;) public void logBefore(JoinPoint joinPoint) { System.out.println(\u0026#34;Before executing method: \u0026#34; + joinPoint.getSignature()); } // 后置通知：在目标方法执行之后执行 @After(\u0026#34;serviceMethods()\u0026#34;) public void logAfter(JoinPoint joinPoint) { System.out.println(\u0026#34;After executing method: \u0026#34; + joinPoint.getSignature()); } // 环绕通知：在目标方法执行前后都能执行 @Around(\u0026#34;serviceMethods()\u0026#34;) public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\u0026#34;Before method execution: \u0026#34; + joinPoint.getSignature()); Object result = joinPoint.proceed(); // 执行目标方法 System.out.println(\u0026#34;After method execution: \u0026#34; + joinPoint.getSignature()); return result; } } AOP的底层原理 Spring AOP的实现依赖于动态代理技术。动态代理是在运行时动态生成代理对象，而不是在编译时。它允许开发者在运行时指定要代理的接口和行为，从而实现在不修改源码的情况下增强方法的功能。\nSpring AOP支持两种动态代理：\n基于JDK的动态代理：使用 java.lang.reflect.Proxy 类和 java.lang.reflect.InvocationHandler 接口实现。这种方式需要代理的类实现一个或多个接口。Java动态代理会创建一个实现了相同接口的代理类，然后在运行时动态生成该类的实例。 创建接口 创建接口的实现类 创建工厂类实现 InvocationHandler 接口 在客户端创建代理类，当通过代理对象调用一个方法时，这个方法的调用会被转发为由 InvocationHandler 接口的 invoke() 方法来进行调用。 基于CGLIB的动态代理：当被代理的类没有实现接口时，Spring会使用CGLIB库生成一个被代理类的子类作为代理。CGLIB（Code Generation Library）是一个第三方代码生成库，通过继承方式实现代理。基于类继承，通过字节码技术生成目标类的子类，来实现对目标方法的代理 AOP核心概念 连接点（JoinPoint） ：可以被AOP控制的方法(暗含方法执行时的相关信息)，目标对象的所属类中，定义的所有方法\n通知（Advice） ：指重复的逻辑，也就是共性功能，增强的逻辑或代码，也即拦截到目标对象的连接点之后要做的事情\n1 2 3 4 @Before(\u0026#34;execution(* com.example.service.*.*(..))\u0026#34;) public void logBefore() { System.out.println(\u0026#34;Method is about to execute\u0026#34;); } 切入点（PointCut） ：匹配连接点的条件，通知仅会在切入点方法执行时被应用\n1 2 @Pointcut(\u0026#34;execution(* com.example.service.*.*(..))\u0026#34;) public void serviceMethods() {} 切面（Aspect） ：描述通知与切入点的对应关系（通知+切入点），定义了在何处以及何时执行通知，将切面的一些东西模块化了，即定义横切关注点的模块，封装了不同模块共享的功能。\n1 2 3 4 5 6 7 @Aspect public class LoggingAspect { @Before(\u0026#34;execution(* com.example.service.*.*(..))\u0026#34;) public void logBefore() { System.out.println(\u0026#34;Logging before method execution\u0026#34;); } } 目标对象（Target） ：通知所应用的对象，也就是原本的业务类。\n代理（Proxy） ：向目标对象应用通知之后创建的代理对象，代理对象包含目标对象的原始方法和增强逻辑。\n织入（Weaving） ：将通知应用到目标对象，进而生成代理对象的过程动作\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @Aspect @Component public class LoggingAspect { // 定义切入点，匹配 service 包中的所有方法 @Pointcut(\u0026#34;execution(* com.example.aopdemo.service.*.*(..))\u0026#34;) public void serviceMethods() {} // 前置通知：在方法执行前记录日志 @Before(\u0026#34;serviceMethods()\u0026#34;) public void logBefore(JoinPoint joinPoint) { System.out.println(\u0026#34;Before method: \u0026#34; + joinPoint.getSignature().getName()); } // 后置通知：在方法执行后记录日志 @After(\u0026#34;serviceMethods()\u0026#34;) public void logAfter(JoinPoint joinPoint) { System.out.println(\u0026#34;After method: \u0026#34; + joinPoint.getSignature().getName()); } // 返回通知：在方法成功返回结果后记录日志 @AfterReturning(pointcut = \u0026#34;serviceMethods()\u0026#34;, returning = \u0026#34;result\u0026#34;) public void logAfterReturning(JoinPoint joinPoint, Object result) { System.out.println(\u0026#34;Method returned with value: \u0026#34; + result); } // 异常通知：在方法抛出异常后记录异常信息 @AfterThrowing(pointcut = \u0026#34;serviceMethods()\u0026#34;, throwing = \u0026#34;error\u0026#34;) public void logAfterThrowing(JoinPoint joinPoint, Throwable error) { System.out.println(\u0026#34;Method threw exception: \u0026#34; + error.getMessage()); } // 环绕通知：在方法执行前后记录日志，且可以控制方法是否执行 @Around(\u0026#34;serviceMethods()\u0026#34;) public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\u0026#34;Before executing method: \u0026#34; + joinPoint.getSignature().getName()); Object result = joinPoint.proceed(); // 执行目标方法 System.out.println(\u0026#34;After executing method: \u0026#34; + joinPoint.getSignature().getName()); return result; } } AOP执行流程 底层为目标对象生成代理对象 在代理对象中使用通知对目标对象的连接点做功能增强 在依赖注入时注入代理对象 AOP通知 通知类型 @Around ：环绕通知，此注解标注的通知方法在目标方法前、后都被执行 @Before ：前置通知，此注解标注的通知方法在目标方法前披执行 @After ：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行 @AfterReturning ：返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行，它可以访问目标方法的返回值，但无法修改返回值。可以用于记录日志或清理资源等操作。 @AfterThrowing ：异常后通知，此注解标注的通知方法发生异常后执行，它可以访问目标方法抛出的异常，并且可以根据异常类型进行相应的处理，例如记录异常信息或执行异常处理逻辑。 在注解的属性中指定方法\n提示\n@Around 环绕通知需要自己调用 ProceedingJoinPoint.proceed() 来让原始方法执行，其他通知不需要考虑目标方法 执行 @Around 环绕通知方法的返回值，必须指定为Object，来接收原始方法的返回值。 通知顺序 当有多个切面的切入点都匹配到了目标方法，目标方法运行时，多个通知方法都会被执行\n不同切面类的通知顺序 目标方法前的通知方法：字母排名靠前的先执行 目标方法后的通知方法：字母排名靠前的后执行 用注解 @Order(数字) 加在切面类上来控制顺序 目标方法前的通知方法:数字小的先执行 目标方法后的通知方法:数字小的后执行 同一个切面类的通知顺序 正常情况 环绕之前通知 前置通知Before 被增强的方法 AfterReturning后置通知 After最终通知 环绕之后通知 异常情况 环绕之前通知 前置通知Before 被增强的方法 AfterThrowing异常通知 After最终通知 切入点表达式 切入点表达式：描述切入点方法的一种表达式 作用：主要用来决定项目中的哪些方法需要加入通知\nexecution(….)根据方法的签名来匹配 execution 主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配\n语法：execution(访问修饰符? 返回值 包名.类名.?方法名(方法参数)throws 异常?)\n带?的部分可以省略\n访问修饰符:可省略(比如:public、protected) 包名.类名: 可省略 throws 异常:可省略(注意是方法上声明抛出的异常，不是实际抛出的异常) 通配符\n* ：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分\n1 execution(* com.*.service.*.update*(*)) : ：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数\n1 execution(* com.itheima..Deptservice.*(..)) @annotation(.):根据注解匹配 @annotation 切入点表达式，用于匹配标识有特定注解的方法\n语法：@annotation(全类名)\n1 2 3 4 @Before(\u0026#34;@annotation(com.itheima.anno.Log)\u0026#34;) public void before(){ log.info(\u0026#34;before ....\u0026#34;); } 提示\n@PointCut 该注解的作用是将公共的切点表达式抽取出来，需要用到时引用该切点表达式即可\n1 2 3 4 5 6 @Pointcut(\u0026#34;execution()\u0026#34;) public void pt(){} @Around(\u0026#34;pt()\u0026#34;) public Object recordrime(ProceedingjoinPoint joinPoint) throws Throwable { } 注意事项\nprivate：仅能在当前切面类中引用该表达式 public：其他外部的切面类中也可以引用该表达式 连接点 在Spring中用JoinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等。\n对于 @Around 通知，获取连接点信息只能使用 ProceedingJoinPoint\n对于其他四种通知，获取连接点信息只能使用 JoinPoint ，它是 ProceedingJoinPoint 的父类型\n相关方法\n1 2 3 4 5 6 7 8 9 @Around(\u0026#34;execution()\u0026#34;) public object around(ProceedingJoinPoint joinPoint)throws Throwable { String className=joinPoint.getTarget().getc1ass().getName(); //获取目标类名 Signature signature=joinPoint.getsignature();//获取目标方法签名 String methodName= joinPoint.getsignature().getName();//获取目标方法名 0bject[]args = joinPoint.getArgs();//获取目标方法运行参数 0bject res= joinPoine.proceed();/执行原始方法,获取返回值(环绕通知) return res; } 1 2 3 4 5 6 7 8 @Before(\u0026#34;execution(\u0026#34;\u0026#34;)) public void befored(JoinPoint joinPoint) { String className=joinPoint.getTarget().getclass().getName();//获取目标类名 Signature signature=joinPoint.getsignature();//获取目标方法签名 String methodName =joinPoint.getsignature().getName();//获取目标方法名 0bject[]args= joinPoint.getArgs();//获取目标方法运行参数 } SpringAOP 框架 和 AspectJ 框架 Spring AOP：是 Spring 框架提供的一种 AOP 实现，主要用于运行时的代理机制。\n特点：Spring AOP 是基于动态代理实现的，适用于 Spring 容器管理的 Bean，较轻量级，使用方便。 使用场景：适合大部分业务场景，尤其是需要简单 AOP 功能的 Spring 应用。 AspectJ：AspectJ 是功能更强大的 AOP 框架，支持编译时、类加载时和运行时的 AOP 功能。\n特点：AspectJ 支持更加灵活的切点和增强操作，提供编译期和加载期的织入方式，性能较高。 使用场景：适合对性能要求较高或需要复杂切点匹配的场景，如日志、监控等。 提示\nSpring AOP 属于运行时增强，主要具有如下特点：\n基于动态代理来实现，默认如果使用接口的，用 JDK 提供的动态代理实现，如果是方法则使用 CGLIB 实现 Spring AOP 需要依赖 IoC 容器来管理，并且只能作用于 Spring 容器，使用纯 Java 代码实现 在性能上，由于 Spring AOP 是基于动态代理来实现的，在容器启动时需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 的那么好。 Spring AOP 致力于解决企业级开发中最普遍的 AOP(方法织入)。 AspectJ 是一个易用的功能强大的 AOP 框架，属于编译时增强， 可以单独使用，也可以整合到其它框架中，是 AOP 编程的完全解决方案。\n编译期织入（Compile-time weaving）：如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译期的时候就进行织入，否则没法编译类 B。 编译后织入（Post-compile weaving）：也就是已经生成了 .class 文件，或已经打成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。 类加载后织入（Load-time weaving）：指的是在加载类的时候进行织入 ","date":"2024-11-07T18:38:05+08:00","permalink":"https://Tyritic.github.io/p/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8Baop/","title":"面向切面编程(AOP)"},{"content":"数据库中的事务 概念：事务是一组操作的集合，它是一个不可分割的工作单位，这些操作 要么同时成功，要么同时失败。\n操作\n开启事务(一组操作开始前，开启事务)\n1 start transaction; 提交事务(这组操作全部成功后，提交事务)\n1 commit; 回滚事务(中间任何一个操作出现异常，回滚事务)\n1 rollback; Spring中的事务管理 Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的。Spring 只提供统一事务管理接口，具体实现都是由各数据库自己实现，数据库事务的提交和回滚是通过数据库自己的事务机制实现。\n编程式事务 编程式事务是指将事务管理代码嵌入嵌入到业务代码中，来控制事务的提交和回滚。\n编程式事务可以使用 TransactionTemplate 和 PlatformTransactionManager 来实现，需要显式执行事务。允许我们在代码中直接控制事务的边界，通过编程方式明确指定事务的开始、提交和回滚。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Autowired private TransactionTemplate transactionTemplate; public void testTransaction() { transactionTemplate.execute(new TransactionCallbackWithoutResult() { @Override protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) { try { // .... 业务代码 } catch (Exception e){ //回滚 transactionStatus.setRollbackOnly(); } } }); } 声明式事务 声明式事务是建立在 AOP 之上的。其本质是通过 AOP 功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前启动一个事务，在目标方法执行完之后根据执行情况提交或者回滚事务。\n@Transactional 注解\n位置：service层的方法，类，接口上\n修饰方法：该注解只能应用到 public 方法上，否则不生效。\n1 2 3 4 5 6 @Transactional @Override public void delete(Integer id){ deptMapper.delete(id); empMapper.deleteByDeptId(id); } 修饰类：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。\n1 2 3 4 @Transactional @Service public class DeptServiceImpl implements DeptService{ } 修饰接口\n1 2 3 4 @Transactional public interface DeptService { } 作用：将当前方法交给spring进行事务管理\n方法执行前，开启事务; 成功执行完毕，提交事务; 出现异常，回滚事务 属性名 说明 propagation 事务的传播行为，默认值为 REQUIRED isolation 事务的隔离级别，默认值采用 DEFAULT timeout 事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。 readOnly 指定事务是否为只读事务，默认值为 false。 rollbackFor 用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。 事务属性 回滚 默认情况下，只有出现 RuntimeException 才回滚异常。rollbackFor 属性用于控制出现何种异常类型，回滚事务。\n示例代码\n1 2 3 4 5 6 @Transactional(rollbackFor=Exception.class) @Override public void delete(Integer id)throws Exception { deptMapper.deleteById(id); empMapper.deleteByDeptId(id); } 传播行为 传播行为：指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制。主要作用是定义和管理事务边界，尤其是一个事务方法调用另一个事务方法时，事务如何传播的问题。它解决了多个事务方法嵌套执行时，是否要开启新事务、复用现有事务或者挂起事务等复杂情况。\n常见的传播行为属性\n属性值 含义 REQUIRED 【默认值】需要事务，有则加入，无则创建新事务 REQUIRES_NEW 需要新事务，无论有无，总是创建新事务 SUPPORTS 支持事务，有则加入，无则在无事务状态中运行 NOT_SUPPORTED 不支持事务，在无事务状态下运行,如果当前存在已有事务,则挂起当前事务 MANDATORY 必须有事务，否则抛异常 NESTED 如果当前事务存在，则在嵌套事务中执行，内层事务依赖外层事务，如果外层失败，则会回滚内层，内层失败不影响外层。 NEVER 必须没事务，否则抛异常 使用场景\nREQUIRED：大部分情况下都是用该传播行为。 如果外部方法没有开启事务的话，Propagation.REQUIRED修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。 如果外部方法开启事务并且被Propagation.REQUIRED的话，所有Propagation.REQUIRED修饰的内部方法和外部方法均属于同一事务 ，只要一个方法回滚，整个事务均回滚。 REOUIRES NEW：当我们不希望事务之间相互影响时，可以使用该传播行为。 创建一个新的事务，如果当前存在事务，则把当前事务挂起。 隔离级别 DEFAULT（默认）：使用底层数据库的默认隔离级别。如果数据库没有特定的设置，通常默认为 READ_COMMITTED。 READ_UNCOMMITTED（读未提交）：最低的隔离级别，允许事务读取尚未提交的数据，可能会导致脏读、不可重复读和幻读。 READ_COMMITTED（读已提交）：仅允许读取已经提交的数据，避免了脏读，但可能会出现不可重复读和幻读问题。 REPEATABLE_READ（可重复读）：确保在同一个事务内的多次读取结果一致，避免脏读和不可重复读，但可能会有幻读问题。 SERIALIZABLE（可串行化）：最高的隔离级别，通过强制事务按顺序执行，完全避免脏读、不可重复读和幻读，代价是性能显著下降。 提示\n脏读（Dirty Read）：一个事务读取了另一个尚未提交的事务的数据，如果该事务回滚，则数据是不一致的。 不可重复读（Non-repeatable Read）：在同一事务内的多次读取，前后数据不一致，因为其他事务修改了该数据并提交。 幻读（Phantom Read）：在一个事务内的多次查询，查询结果集不同，因为其他事务插入或删除了数据。 声明式事务的实现原理 Spring 的声明式事务管理是通过 AOP（面向切面编程）和代理机制实现的。\n在 Bean 初始化阶段创建代理对象 Spring 容器在初始化单例 Bean 的时候，会遍历所有的 BeanPostProcessor 实现类，并执行其 postProcessAfterInitialization 方法。 在执行 postProcessAfterInitialization 方法时会遍历容器中所有的切面，查找与当前 Bean 匹配的切面，这里会获取事务的属性切面，也就是 @Transactional 注解及其属性值。 然后根据得到的切面创建一个代理对象，默认使用 JDK 动态代理创建代理，如果目标类是接口，则使用 JDK 动态代理，否则使用 Cglib。 在执行目标方法时进行事务增强操作 当通过代理对象调用 Bean 方法的时候，会触发对应的 AOP 增强拦截器，声明式事务是一种环绕增强，对应接口为MethodInterceptor 声明式事务失效的情况 rollbackFor 设置错误，Spring默认没有任何设置（RuntimeException 或者 Error 才能捕获），则方法内抛出其他异常则不会回滚 同一个类中方法调用，因此事务是基于动态代理实现的，同类的方法调用不会走代理方法，因此事务自然就失效了。 @Transactional 应用在非 public 修饰的方法上，Spring 事务管理器判断非公共方法则不应用事务。 ","date":"2024-11-07T16:51:41+08:00","permalink":"https://Tyritic.github.io/p/spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/","title":"Spring事务管理"},{"content":"项目开发过程中会遇到异常问题\n全局异常处理器 @RestControllerAdvice：用于修饰类表示全局异常处理器\n创建一个类并使用 @ControllerAdvice 注解标记。 在该类中定义带有 @ExceptionHandler 注解的方法，用于捕获异常。 全局异常处理类会捕获应用中所有控制器抛出的异常。 @ExceptionHandler ：用于修饰异常处理方法，用于局部的异常处理，通常定义在控制器类中。它可以捕获特定的异常，并返回自定义的错误信息或视图。\n在控制器类中定义处理异常的方法。 使用 @ExceptionHandler 指定要捕获的异常类型。 可以返回自定义的视图或 JSON 响应。 示例代码\n1 2 3 4 5 6 @RestControllerAdvice puhlic class GlobalExceptionHandler { @ExceptionHandler(Exception.class) public Result ex(Exception ex){ex.printstackTrace(); return Result.error(”对不起,操作失败,请联系管理员\u0026#34;); } 可以设置HTTP的状态码\n@ResponseStatus 注解可以直接用于自定义异常类或异常处理方法中，设置返回的 HTTP 状态码。\n1 2 3 4 5 6 @ExceptionHandler(UserNotFoundException.class) @ResponseStatus(HttpStatus.NOT_FOUND) public String handleUserNotFound(UserNotFoundException ex, Model model) { model.addAttribute(\u0026#34;errorMessage\u0026#34;, ex.getMessage()); return \u0026#34;errorPage\u0026#34;; } ResponseEntity 可以灵活地控制返回的 HTTP 状态码和响应体，常用于 REST API 中的异常处理。\n全局异常 在common包下定义基本异常BaseException，其余的异常为这个类的子类\n示例代码\n1 2 3 4 5 6 7 8 9 10 public class BaseException extends RuntimeException { public BaseException() { } public BaseException(String msg) { super(msg); } } ","date":"2024-11-07T16:33:35+08:00","permalink":"https://Tyritic.github.io/p/springmvc%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","title":"SpringMVC的异常处理"},{"content":"简介 Spring框架中提供的，用来动态拦截控制器方法的执行。拦截器可以用于实现诸如 权限验证、日志记录、性能监控 等功能，而无需将这些逻辑直接耦合在控制器代码中。 作用 ：用于在请求处理流程的不同阶段拦截 HTTP 请求和响应，并对其进行预处理或后处理。\n具体实现 定义 Interceptor 类，实现 HandlerInterceptor 接口并重写方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Component public class LoginCheckInterceptor implements HandlerInterceptor { @0verride //目标资源方法执行前执行，放回true:放行，返回false:不放行 public boolean prehandle(HttpServletRequest reg, HttpServletResponse resp, object handler) throws Exception { System.out.println(\u0026#34;preHandle ...\u0026#34;); return true; } @Override //目标资源方法执行后执行 public void postHandle(HttpservletRequest req, HttpServletResponse resp, object handler, ModelAndview modelAndview){ System.out.println(\u0026#34;postHandle..\u0026#34;); } @0verride //视图渲染完毕后执行，最后执行 public void afterCompletion (HttSservietReguest reg, HttpServletResponse resp, Object handler, Exception ex) { System.out.println(\u0026#34;aftercompletion ...\u0026#34;); } } 注册拦截器\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class webConfig implements WebMvcConfigurer { @Autowired private LoginCheckInterceptor logincheckInterceptor; @Override public void addInterceptors(InterceptorRegistry registry){ registry.addInterceptor (logincheckInterceptor) .addPathPatterns(\u0026#34;拦截路径\u0026#34;) .excludePathPatterns(\u0026#34;放行路径\u0026#34;) } } 拦截路径 拦截器可以根据需求，配置不同的拦截路径:\n拦截路径 含义 示例 /* 所有的一级路径 /depts /** 任意级路径 /depts，/depts/1 /depts/* /depts下的一级路径 /depts/1 /depts/** /depts下的任意级路径 /depts/emp/1 执行流程 请求先进入过滤器还未进入Spring容器中 经过过滤器的校验后进入**DispatcherServlet** 请求到达拦截器进行校验 提示\n过滤器和拦截器的区别\n接口规范不同:\n过滤器需要实现Filter接口 拦截器需要实现Handlerinterceptor接口。 拦截范围不同:\nFilter会拦截所有的资源，它通常用于处理全局的任务，如跨域请求处理（CORS）、编码转换等。 Interceptor只会拦截Spring环境中的资源。 拦截顺序不同\n过滤器比拦截器提前拦截请求 来源不同\n过滤器是Servlet规范的一部分，更加接近底层 拦截器是SpringMVC的一部分，更加接近业务层 ","date":"2024-11-07T15:49:32+08:00","permalink":"https://Tyritic.github.io/p/%E6%8B%A6%E6%88%AA%E5%99%A8interceptor/","title":"拦截器Interceptor"},{"content":"概述 Filter 过滤器是JavaWeb 三大组件(Servlet、Filter、Listener)之一。\n作用：过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。\n使用场景：过滤器一般完成一些通用的操作，比如:登录校验、统一编码处理、敏感字符处理等。\n具体实现 定义Filter类：实现 Filter接口，并重写其所有方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @WebFilter(urlPatterns =\u0026#34;/*\u0026#34;) public class DemoFilter implements Filter { //初始化方法,Web服务器启动,创建Filter时调用，只调用一次 public void init (Filterconfig filterconfig)throws ServletException { Filter.super.init(filterConfig); } ///拦截到请求时,调用该方法,可调用多次 public void doFilter (ServletRequest request, servletResponse response, Filterchain chain){ System.out.println(\u0026#34;拦截方法执行，拦截到了请求...\u0026#34;); System.out.println(\u0026#34;执行放行前的逻辑...\u0026#34;); chain.doFilter(request,response);// 放行请求 System.out.println(\u0026#34;执行放行后的逻辑...\u0026#34;); } //销毁方法，服务器关闭时调用，只调用一次 public void destroy(){ Filter.super.destroy(); } } 配置Filter：使用 @WebFilter 注解，配置拦截资源的路径。\n引导类上加 @ServletComponentScan 开启Servlet组件支持。\n1 2 3 4 5 @ServletComponentScan @SpringBootApplication public class TliasWebManagementApplication{public static void main(stringl] args){ SpringApplication.run(TliasWebManagementApplication.class, args); } 执行流程 过滤器拦截到请求 过滤器执行 doFilter() 之前的部分作为放行前的逻辑 过滤器执行 doFilter() 放行请求 过滤器执行 doFilter() 之后的部分作为放行后的逻辑 提示\n放行后访问对应资源，资源访问完成后，还会回到Filter中 回到Filter中执行放行后的逻辑 拦截路径 Filter 可以根据需求，配置不同的拦截资源路径\n拦截路径 urlPattern 含义 拦截具体路径 /login 只有访问/login才被拦截 目录拦截 /emp/* 访问emp目录下的资源都被拦截 拦截所有 /* 访问所有资源都被拦截 过滤器链 一个web应用中，可以配置多个过滤器，这多个过滤器就形成了一个过滤器链\n顺序：注解配置的Filter，优先级是按照过滤器类名(字符串)的自然排序\n","date":"2024-11-07T14:50:40+08:00","permalink":"https://Tyritic.github.io/p/%E8%BF%87%E6%BB%A4%E5%99%A8filter/","title":"过滤器Filter"},{"content":"登录功能实现的基本思路 登录标记 用户登录成功之后，每一次请求中，都可以获取到该标记，\n常见技术\n会话技术 JWT令牌 登录校验 对接收到的请求进行统一拦截\n常见技术\n过滤器（Filter） 拦截器（Interceptor） 登录标记 会话技术 用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。\n会话跟踪 一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。\n会话跟踪方案\n客户端会话跟踪技术：Cookie 服务端会话跟踪技术：Session Cookie 什么是 Cookie\nCookie 是存储在用户浏览器端的一个小型数据文件，用于跟踪和保存用户的状态信息。\n主要用于保持用户登录状态、跟踪用户行为、存储用户偏好等。\n存储在浏览器端。\n基本流程\n浏览器第一次向服务端发出请求时，服务端设置 Cookie 服务端给浏览器响应并设置响应头的 Set-Cookie 来传递Cookie 浏览器解析 Cookie 值并保存在浏览器本地 后续的每次请求中浏览器会将 Cookie 数据放入请求头中 优点：HTTP协议支持的技术\n缺点\n移动端APP不支持 Cookie\n状态管理： Session 基于服务器端的状态管理，而移动端应用通常是无状态的。移动设备的连接可能不稳定或中断，因此难以维护长期的会话状态。如果使用 Session 进行身份认证，移动应用需要频繁地与服务器进行会话维护，增加了网络开销和复杂性; 兼容性：移动端应用通常会面向多个平台。每个平台对于 Session 的管理和存储方式可能不同，可能导致跨平台兼容性的问题; 安全性：移动设备通常处于不受信任的网络环境，存在数据泄露和攻击的风险。将敏感的会话信息存储在移动设备上增加了被攻击的潜在风险。 不安全：用户可以自己禁用 Cookie\nCookie不能跨域\n提示\n跨域被分为三个维度：协议，IP，端口，三者有一个不同就是跨域\nSession 什么是 Session\nSession 是服务器端保存用户状态的机制，每个用户会话都有一个唯一的 Session ID。\n主要用于跟踪用户在服务器上的状态信息，例如登录状态和购物车内容。\n存储在服务器端，然后对应的 Session ID 通过 Cookie 保存在客户端浏览器中。\n基本流程\n浏览器第一次向服务器端发出请求，此时服务器端没有 Session 对象 服务器端生成 Session 对象并将 Session 对象的 ID 放入响应的响应头（Set-Cookies） 浏览器保存 Session 对象并且此后浏览器的每次请求中以请求头的 Cookie 数据附带 Session 对象以维持会话状态 服务器会寻找到请求 Cookie 中的 Session 对象从而实现数据共享 优点 ：存储在服务器端更加安全\n缺点\n服务器集群中无法直接使用 Session 技术 Session 技术基于Cookie 技术，继承了Cookie的全部缺点 令牌技术 基本流程\n浏览器发出请求后，服务端生成令牌作为身份凭证放入响应 此后的客户端每一次的请求会在请求头（通常是 Authorization 头）携带令牌 服务端则会该令牌的有效性以进行用户身份验证 优点:\n支持PC端、移动端 解决集群环境下的认证问题 减轻服务器端存储压力 Session-Cookie 方案 用户向服务器发送用户名、密码、验证码用于登陆系统。 服务器验证通过后，服务器为用户创建一个 Session，并将 Session 信息存储起来。 服务器向用户返回一个 SessionID，写入用户的 Cookie 。 当用户保持登录状态时，Cookie 将与每个后续请求一起被发送出去。 服务器可以将存储在 Cookie 上的 SessionID 与存储在内存中或者数据库中的 Session 信息进行比较，以验证用户的身份，返回给用户客户端响应信息的时候会附带用户当前的状态 JWT令牌技术 简介：JSON Web Token(https://jwt.io/) 定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。\n令牌结构 Header (头)：描述 JWT 的元数据，定义了生成签名的算法以及 Token 令牌的类型。Header 被 Base64Url 编码后成为 JWT 的第一部分。 typ（Type）：令牌类型。 alg（Algorithm）：签名算法。 Payload(有效载荷)：携带所传递的数据。Payload 被 Base64Url 编码后成为 JWT 的第二部分。 Signature (签名)：防止Token被篡改、确保安全性。服务器通过 Payload、Header 和一个密钥(Secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。生成的签名会成为 JWT 的第三部分。 Header + Payload 存放在服务端的密钥(一定不要泄露出去)。 优点 自包含： JWT 中包含了所有必要的信息，因此在验证时不需要查询数据库，提升了性能。 跨语言：由于 JWT 是基于JSON的，几乎所有编程语言都支持它的生成和解析。 无状态 ：JWT 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 JWT 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。 提示\nJWT与Session的对比\n无状态认证：JWT 通常用于无状态认证，即服务器不存储会话数据。相比之下，Session 认证通常需要服务器存储用户的会话信息。 扩展性：由于 JWT 不依赖服务器存储，因此在分布式系统中更具扩展性。Session 认证在多服务器环境中需要依赖共享存储或会话粘性（Session Stickiness），从而增加了系统复杂度。 拓展知识：如何废除一个未过期的令牌\n因为 JWT 是无状态的，一般服务器并不保存已签发的 JWT ，所以服务器无法主动撤销一个已经签发的 JWT 。\n不过可以通过以下思路实现\n使用黑名单（Blacklist） 实现思路：在服务器端维护一个黑名单（或者叫作废列表），该列表包含所有已被废除的 JWT 标识符（通常使用 JWT 的jti声明）。每次服务器验证 JWT 时，除了验证签名和其他标准信息外，还需要检查该 JWT 是否在黑名单中。 优点：可以精确废除特定的 JWT ，不影响其他合法的 JWT 。 缺点：需要在服务器端存储和管理黑名单，违背了 JWT 的无状态特性，增加了系统复杂度。如果黑名单列表变大，查询效率可能成为问题。 使用版本控制（Token Versioning） 实现思路：在用户信息中引入一个“Token 版本号”的字段，每次生成 JWT 时，将这个版本号作为 JWT 的一部分（可以放在 Payload 的自定义声明中）。当需要废除某个用户的 JWT 时，只需将用户的版本号递增。在服务器验证 JWT 时，检查 JWT 中的版本号与用户当前的版本号是否匹配，若不匹配，则视为无效。 优点：无需维护黑名单，可以较容易地废除特定用户的所有 JWT 。 缺点：在多用户、多设备情况下，如果一个设备上的 JWT 被废除，所有设备上的 JWT 都会失效。需要在服务器端存储和管理用户的版本号。 具体实现 引入 JWT 相关依赖 将 JWT 数字签名的相关部分放入Properties文件中以备引用 书写 JWT 工具类的生成方法和解析方法 生成JWT令牌 具体思路\n指定签名算法 使用令牌持续时间来计算令牌的过期时间 生成 JWT 令牌函数 Jwts.builder() 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * 创建jwt * 加密算法：HS256 * 私钥使用jwtProperties中的userSecretKey * @param claims 载荷 * @return jwt */ public String createJwt(Map\u0026lt;String, Object\u0026gt;claims) { String userSecretKey = jwtProperties.getUserSecretKey(); //自定义密钥 long userTtl = jwtProperties.getUserTtl(); //令牌持续时间 SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; //指定签名算法 long nowMillis = System.currentTimeMillis(); Date exp = new Date(nowMillis + userTtl); //令牌过期时间 JwtBuilder builder = Jwts.builder() //生成JWT令牌 .setClaims(claims) //设置载荷 .signWith(signatureAlgorithm, userSecretKey.getBytes()) //设置数字签名（签名算法，过期时间） .setExpiration(exp); //设置过期时间 return builder.compact(); } 解析JWT令牌 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * 解密jwt * @param token jwt * @return jwt中的数据 */ public Claims parseJwt(String token) { //获取jwtProperties中的userSecretKey String userSecretKey = jwtProperties.getUserSecretKey(); return Jwts.parser() .setSigningKey(userSecretKey.getBytes(StandardCharsets.UTF_8)) .parseClaimsJws(token) .getBody(); } JWT身份认证方案 在基于 JWT 进行身份验证的的应用程序中，服务器通过 Payload、Header 和 Secret(密钥)创建 JWT 并将 JWT 发送给客户端。客户端接收到 JWT 之后，会将其保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。\n![ JWT 身份验证示意图](jwt-authentication process.png)\n用户向服务器发送用户名、密码以及验证码用于登陆系统。\n如果用户用户名、密码以及验证码校验正确的话，服务端会返回已经签名的 Token，也就是 JWT。\n用户以后每次向后端发请求都在 Header 中带上这个 JWT 。\n服务端检查 JWT 并从中获取用户相关信息。\n登录校验 过滤器（Filter） 参见博客Filter\n拦截器（interceptor） 参见博客Interceptor\n","date":"2024-11-07T13:11:16+08:00","permalink":"https://Tyritic.github.io/p/%E7%99%BB%E5%BD%95%E9%89%B4%E6%9D%83%E6%9C%BA%E5%88%B6/","title":"登录鉴权机制"},{"content":"配置方法 通过配置文件配置 配置文件的种类 SpringBoot提供了多种属性配置方式\napplication.properties\n1 2 server.port=8080 server.address=127.0.0.1 application.yml\n1 2 3 server: port:8080 address:127.0.0.1 application.yaml\n1 2 3 server: port:8080 address:127.0.0.1 配置文件优先级 优先级从高到低：properties\u0026gt;yml\u0026gt;yaml\n外部配置文件的优先级（从低到高）\nclasspath（resource文件夹） classpath根config 项目根目录（对于存在继承/聚合关系的maven项目项目根目录是父工程的根目录） 项目根目录/config 直接子目录/config 多配置文件的加载 Profile意思是配置，不同环境可能需要不同的配置需要\nSpringBoot框架提供了多profile的管理功能，我们可以使用profile文件来区分不同环境的配置\n如果需要创建自定义的yml文件时，可以用application-{profile}.yml的命名方式\n切换不同环境的yml文件时在application.yml中配置\n1 2 3 spring: profiles: active: profile 其他配置方式 Java系统属性 执行maven打包指令package\n执行java指令，运行jar包，在执行java命令时添加参数\n参数格式\n1 -Dxxx=xxx 命令行参数 执行maven打包指令package\n执行java指令，运行jar包，在执行java命令时添加参数\n参数格式\n1 --xxx=xxx 配置方法的优先级 优先级从低到高\napplication.yaml(忽略) application.yml application.properties java系统属性(-Dxxx=xxx) 命令行参数(\u0026ndash;xxx=xxx) yml文件语法 基本语法 大小写敏感 数值前边必须有空格，作为分隔符 使用缩进表示层级关系，缩进时，不允许使用Tab键，只能用空格(idea中会自动将Tab转换为空格) 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 #表示注释，从这个字符一直到行尾，都会被解析器忽略 数据格式 对象/Map集合\n1 2 3 4 user: name: zhangsan age: 18 password:123456 数组/List集合\n1 2 3 4 hobby: -java -game -sport 参数配置化 利用注解进行参数配置化 @Value 通常用于外部配置的属性注入，具体用法为: @Value(\u0026quot;${配置文件中的key}\u0026quot;)\n在 Spring 框架中，@Value 注解用于注入外部化的配置值到 Spring 管理的 Bean 中。通过 @Value 注解，可以将属性文件、环境变量、系统属性等外部资源中的值注入到 Spring Bean 的字段、方法参数或构造函数参数中。\n示例代码\n1 2 3 4 aliyun.oss.endpoint=https://oss-cn-hangzhou.aliyuncs.com aliyun.oss.accessKeyId=LTAI4GCHlvX6DKqJWxdбnEuW aliyun.oss.accessKeySecret=yBshYweHOpqDuhCArrVHwIiBKPYqSL aliyun.oss.bucketName=web-tlias 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Component pubiic class AliossUti1s{ @Value(\u0026#34;${aliyun.oss.endpoint}\u0026#34;) private string endpoint; @Value(\u0026#34;${aliyun.oss.accessKeyId}\u0026#34;) private string accesskeyId; @Value(\u0026#34;${aliyun.oss.accessKeySecret}\u0026#34;) private String accessKeySecret; @Value (\u0026#34;${aliyun.oss.bucketName } \u0026#34;) private String bucketName } 使用自定义配置类进行参数配置化 自定义properties文件使用 @Component 注册为Bean对象，使用 @ConfigurationProperties 注解批量的将yml配置文件的属性和Bean对象属性绑定，@ConfigurationProperties 的prefix属性指定application.yml的子节点，该节点中的子节点将自动和属性进行绑定\n示例代码\n1 2 3 4 5 6 7 8 9 10 @Data @Component @ConfigurationProperties(prefix = \u0026#34;operator.aliyun.oss\u0026#34;) public class AliyunOSSProperties { String endpoint; String accessKeyId; String accessKeySecret; String bucketName; String region; } @ConfigurationProperties 支持jsr-300数据校验使用 @Validate\n提示\n​\tjsr-300数据校验\n@Null：被注释的元素必须为 null @NotNull：被注释的元素必须不为nu11 @AssertTrue：被注释的元素必须为true @AssertFalse：被注释的元素必须为false @Min(value)：被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value)：被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value)：被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value)：被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max，min)：被注释的元素的大小必须在指定的范围内 @Digits (integer,fraction)：被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past：被注释的元素必须是一个过去的日期 @Future：被注释的元素必须是一个未来的日期 ","date":"2024-11-07T10:19:39+08:00","permalink":"https://Tyritic.github.io/p/springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","title":"SpringBoot配置文件"},{"content":"简介 文件上传，是指将本地图片、视频、音频等文件上传到服务器，供其他用户浏览或下载的过程。\n实现要点 前端页面 表单项 type=“file” 表单提交方式 post 表单的enctype属性 multipart/form-data 后端controller类 使用MultipartFile接收文件 实现方式 上传到本地 常见方法\n1 2 3 4 5 - String getOriginalFilename(); //获取原始文件名 - void transferTo(File dest); //将接牧的文件转存到磁盘文件中 - long getSize(); //获取文件的大小，单位:字节 - byte[] getBytes();//获取文件内容的字节数组 - InputStream getinputStream(); //获取接收到的文件内容的输入流 具体实现\n1 2 3 4 5 6 7 8 9 10 11 12 @RestController public class UploadController { @PostMapping(\u0026#34;/upload\u0026#34;) public Result upload(MultipartFile image) throws IOException //获取原始文件名 String originalFilename =image.getOriginalFilename(): //构建新的文件名 String newfileName = UUID.,randomUUID.toString()+originalFilename.substring(originalFilename.lastindexOf(\u0026#34;.\u0026#34;)); //将文件保存在服务器端 E:/images目景下 image.transferTo(new File(\u0026#34;E:/images/\u0026#34;+newFileName)): return Result,success(); } 提示\n在SpringBoot中，文件上传，默认单个文件允许最大大小为1M。如果需要上传大文件，可以进行在application.yml如下配置:\n1 2 3 4 spring: servlet: multipart.max-file-size=10MB #配置单个文件最大上传大小 max-request-size=100MB #配置单个请求最大上传大小(一次请求可以上传多个文件) 阿里云OSS存储 基本概念\nBucket：存储空间是用户用于存储对象(0bject，就是文件)的容器，所有的对象都必须隶属于某个存储空间。 SDK:Software Development Kit 的缩写，软件开发工具包，包括辅助软件开发的依赖(jar包)、代码示例等，都可以叫做SDK。 具体实现\n创建bucket并获取AccessKey\n在pom.xml中引入相关依赖\n将aliyunOSS服务所需的相关参数写入配置文件application.yml中，并专门建立一个properties配置文件\n将相关方法写入工具类中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 public String upload(MultipartFile file) throws ClientException { if(file==null||file.isEmpty()){ return null; } String endpoint = aliyunOSSProperties.getEndpoint(); String bucketName = aliyunOSSProperties.getBucketName(); String region = aliyunOSSProperties.getRegion(); String accessKeyId = aliyunOSSProperties.getAccessKeyId(); String accessKeySecret = aliyunOSSProperties.getAccessKeySecret(); // 创建OSSClient实例 ClientBuilderConfiguration clientBuilderConfiguration = new ClientBuilderConfiguration(); CredentialsProvider defaultCredentialProvider = new DefaultCredentialProvider(accessKeyId, accessKeySecret); OSS ossClient= OSSClientBuilder.create() .endpoint(endpoint) .credentialsProvider(defaultCredentialProvider) .clientConfiguration(clientBuilderConfiguration) .region(region) .build(); String originalFilename = file.getOriginalFilename(); String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(\u0026#34;.\u0026#34;)); try { InputStream fileInputStream = file.getInputStream(); ossClient.putObject(bucketName, fileName, fileInputStream); String url=endpoint.split(\u0026#34;//\u0026#34;)[0]+\u0026#34;/\u0026#34;+bucketName+\u0026#34;.\u0026#34;+endpoint.split(\u0026#34;//\u0026#34;)[1]+\u0026#34;/\u0026#34;+fileName; return url; } catch (Exception e) { log.error(\u0026#34;上传文件失败\u0026#34;, e); throw new ClientException(\u0026#34;上传文件失败\u0026#34;); } finally { ossClient.shutdown(); } } public void deleteExhibitImage(String d_url) { String endpoint = aliyunOSSProperties.getEndpoint(); String bucketName = aliyunOSSProperties.getBucketName(); String region = aliyunOSSProperties.getRegion(); String accessKeyId = aliyunOSSProperties.getAccessKeyId(); String accessKeySecret = aliyunOSSProperties.getAccessKeySecret(); String fileName=d_url.substring(d_url.lastIndexOf(\u0026#34;/\u0026#34;)+1);//从url中获取bucket中的文件名 // 创建OSSClient实例 ClientBuilderConfiguration clientBuilderConfiguration = new ClientBuilderConfiguration(); CredentialsProvider defaultCredentialProvider = new DefaultCredentialProvider(accessKeyId, accessKeySecret); OSS ossClient= OSSClientBuilder.create() .endpoint(endpoint) .credentialsProvider(defaultCredentialProvider) .clientConfiguration(clientBuilderConfiguration) .region(region) .build(); try { ossClient.deleteObject(bucketName, fileName); } catch (Exception e) { log.error(\u0026#34;删除文件失败\u0026#34;, e); } finally { ossClient.shutdown(); } } ","date":"2024-11-07T09:52:26+08:00","permalink":"https://Tyritic.github.io/p/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","title":"文件上传"},{"content":"BigInteger类和BigDecimal类 BigInteger类支持任意精度的整数，表示任何大小的整数\nBigDecimal类支持任意长度的小数\nBigInteger类和BigDecimal都是不可变类，一旦创建其值无法更改，只要产生计算操作就会产生新的对象\nBigInteger创建方法 通过有参构造器 BigInteger(String val) BigInteger(byte[] val) 通过valueOf()静态方法 BigInteger.valueOf(long val)\n1 2 3 4 5 6 7 8 9 10 import java.math.BigInteger; public class BigIntegerExample { public static void main(String[] args) { // 从 long 值创建 BigInteger 对象 BigInteger bigInt2 = BigInteger.valueOf(123456789L); System.out.println(bigInt2); // 输出：123456789 } } BigDecimal创建方法 通过有参构造器 类 创建方式 示例 注意事项 BigDecimal new BigDecimal(String val) new BigDecimal(\u0026quot;123.456789\u0026quot;) 推荐通过字符串创建，精度不会丢失。 new BigDecimal(double val) new BigDecimal(123.456) 精度可能丢失，尽量避免使用。 new BigDecimal(long val) new BigDecimal(123) 使用 long 值创建。 new BigDecimal(int val) new BigDecimal(123) 使用 int 值创建。 new BigDecimal(byte[] val) new BigDecimal(byteArray) 用字节数组创建。 通过静态方法valueOf() 1 2 3 4 5 6 7 8 9 import java.math.BigDecimal; public class BigDecimalExample { public static void main(String[] args) { // 从 long 值创建 BigDecimal 对象 BigDecimal decimal1 = BigDecimal.valueOf(123456789L); System.out.println(decimal1); // 输出：123456789 } } 创建 BigDecimal 时优先使用字符串类型的构造方法，以避免 double 转换时精度丢失。\n计算方法 操作 BigInteger 方法 BigDecimal 方法 加法 add() add() 减法 subtract() subtract() 乘法 multiply() multiply() 除法 divide() divide() 取余 mod() remainder() 幂运算 pow() pow() 比较 compareTo() compareTo() 相反数 negate() negate() BigDecimal保证精度不丢失的机制 BigDecimal 能够保证精度，是因为它使用了任意精度的整数表示法，而不是浮动的二进制表示。\nBigDecimal 内部使用两个字段存储数字，一个是整数部分 intVal，另一个是用来表示小数点的位置 scale，避免了浮点数转化过程中可能的精度丢失。\n计算时通过整数计算，再结合小数点位置和设置的精度与舍入行为，控制结果精度，避免了由默认浮点数舍入导致的误差。\n源码展示\n1 2 3 4 5 6 7 8 9 10 public class BigDecimal extends Number implements Comparable\u0026lt;BigDecimal\u0026gt; { private final BigInteger intVal; // 存储整数部分 private final int scale; // 存储小数点的位置 public BigDecimal(String val) { // 使用 BigInteger 来表示数值 intVal = new BigInteger(val.replace(\u0026#34;.\u0026#34;, \u0026#34;\u0026#34;)); scale = val.contains(\u0026#34;.\u0026#34;) ? val.length() - val.indexOf(\u0026#34;.\u0026#34;) - 1 : 0; } } ","date":"2024-11-06T23:18:11+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/","title":"Java中的高精度运算"},{"content":"包装类简介 包装类将基本数据类型包装成对象，用于集合操作等操作\n常见包装类 基本数据类型与包装类对照表： 基本数据类型 包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 创建方法 通过有参构造器创建 包装类不存在无参构造方法，\n通过valueOf()创建 一个常用静态方法，它用于将给定的基本数据类型或字符串转换为对应的包装类对象\n1 2 3 4 5 6 7 8 9 // 语法格式：包装类名.valueOf() public class ValueOfExample { public static void main(String[] args) { String str = \u0026#34;100\u0026#34;; Integer integerValue = Integer.valueOf(str); // 将字符串 \u0026#34;100\u0026#34; 转换为 Integer int i = 200; Integer integerValue = Integer.valueOf(i); // 将 int 200 转换为 Integer } } 自动装箱和自动拆箱 定义 自动装箱（Autoboxing）：指的是 Java 编译器自动将基本数据类型转换为它们对应的包装类型。比如，将 int 转换为 Integer。\n自动拆箱（Unboxing）：指的是 Java 编译器自动将包装类型转换为基本数据类型。比如，将 Integer 转换为 int 。\n主要作用 它在 Java 5 中引入，主要是为了提高代码的可读性，减少手动转换操作，简化了代码编写，开发者可以更方便地在基本类型和包装类型之间进行转换。\n常见于：\n集合类如 List\u0026lt;Integer\u0026gt; 中无法存储基本类型，通过自动装箱，可以将 int 转换为 Integer 存入集合。\n1 2 3 4 int i = 99; //声明基础数据类型int变量 ArrayList list = new ArrayList(); list.add(i); //触发自动装箱，int类型自动转换成 Integer System.out.println(list); 自动装箱和拆箱经常在算术运算中出现，尤其是包装类型参与运算时。\n底层实现 自动装箱和拆箱并不是通过语法糖实现的，它是通过调用包装类型的 valueOf() 和 xxxValue() 方法实现的。\n自动装箱调用：Integer.valueOf(int i) 自动拆箱调用：Integer.intValue() 示例：\n1 2 Integer a = Integer.valueOf(10); // 自动装箱 int b = a.intValue(); // 自动拆箱 注意点 性能影响 自动装箱和拆箱虽然简化了编码，但在频繁使用的场景，可能导致性能开销，尤其是在循环中频繁发生装箱或拆箱时，容易引入不必要的对象创建和垃圾回收。\n所以尽量避免在性能敏感的代码中频繁使用自动装箱和拆箱。例如：\n1 2 3 4 Integer sum = 0; for (int i = 0; i \u0026lt; 10000; i++) { sum += i; // sum 是包装类型，导致多次装箱和拆箱 } NullPointerException 在进行拆箱操作时，如果包装类对象为 null，会抛出 NullPointerException。\n计算方法 Java 允许包装类和基本数据类型之间的自动转换，因此你可以直接对包装类对象进行算术运算，Java 会自动进行拆箱和装箱。\n缓存机制 包装类型中的 Byte 、Short 、Integer 和 Long 对某些范围内的值（例如 Integer，Long,Byte 缓存 -128 到 127）会使用对象缓存来提升性能。因此，同一数值的包装类型对象可能是同一个实例。\n在 -128 到 127 范围内的 Integer 对象会被缓存和复用。\n包装类的存在意义 存在意义就是将基本数据类型封装成对象\n对象封装的好处\n可以把属性也就是数据跟处理这些数据的方法结合在一起，比如 Integer 就有 parseInt() 等方法来专门处理int型相关的数据。 Java中绝大部分方法或类都是用来处理类类型对象的，如 ArrayList 集合类就只能以类作为他的存储对象， 在Java中，泛型只能使用引用类型，而不能使用基本类型。 包装类和基本数据类型的对比 基本类型和引用类型 ：基本数据类型是Java中最基本的数据类型，它们是预定义的，不需要实例化就可以使用。而引用类型则需要通过实例化对象来使用。这意味着，使用基本数据类型来存储一个整数时，不需要任何额外的内存分配，而使用包装类时，必须为对象分配内存。在性能方面，基本数据类型的操作通常比相应的引用类型快。 自动装箱和拆箱 ：包装可以实现自动装箱和拆箱。自动装箱是指将基本类型转化为相应的包装类类型，而自动拆箱则是将包装类类型转化为相应的基本类型。这使得Java程序员更加方便地进行数据类型转换。 空指针异常 ：int变量可以直接赋值为0，而 Integer 变量必须通过实例化对象来赋值。如果对一个未经初始化的 Integer 变量进行操作，就会出现空指针异常。这是因为它被赋予了null值，而null值是无法进行自动拆箱的。 性能区别 ：基本数据类型占用内存小，效率高，适合频繁使用的简单操作。包装类因为是对象，涉及内存分配和垃圾回收，性能相对较低。 比较方式 ：基本数据类型比较用 == ，直接比较数值。包装类比较时，== 比较的是对象的内存地址，而 equals() 比较的是对象的值。 存储方式：对于基本数据类型如果是局部变量则保存在栈上面，如果是成员变量则在堆中。对于包装类保存在堆上（成员变量，在不考虑 JIT 优化的栈上分配时，都是随着对象一起保存在堆上的） ","date":"2024-11-06T22:46:11+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB/","title":"Java中的包装类"},{"content":"在Mapper接口中基于注解书写sql语句 设置动态参数 1 #{参数名} 如果mapper接口中的方法参数名和mapper.xml中sql语句中的字段名一致，spring会自动进行封装\n设置mappper接口方法参数名和mapper.xml中的sql语句中的字段一致 如果mapper接口中的方法参数名和mapper.xml中sql语句中的字段名不一致，需要通过注解@Param来指定对应关系\n1 @Param(Sql语句中的字段名) 方法参数名 示例\n1 User selectUser(@param(“name”)String personName); 1 2 3 \u0026lt;select id=\u0026#34; selectUser\u0026#34; resultMap=\u0026#34;BaseResultMap\u0026#34;\u0026gt; select * from user where user_name = #{name} \u0026lt;/select\u0026gt; 删除操作 sql语句 1 delete from emp where id=#{id} 接口方法 1 2 3 4 5 @Mapper public interface EmpMapper //根据ID删除数据 @Delete(\u0026#34;delete from emp where id=#{id}\u0026#34;) public void delete(Integer id): 添加操作 sql语句 1 2 insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) values(#{username), #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptld}, #{createTime}, #{updateTime} 接口方法 1 2 3 4 5 @Mapper public interface EmpMapper //根据ID添加数据 @Insert(\u0026#34;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time)\u0026#34; +\u0026#34;values(#{username), #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptld}, #{createTime}, #{updateTime}\u0026#34;) public void insert(Emp emp); 主键返回 描述：在数据添加成功后，需要获取插入数据库数据的主键。\n实现：在@Insert上添加注解 @Options(keyProperty = \u0026ldquo;id\u0026rdquo;, useGeneratedKeys = true) 会自动将生成的主键值赋给id属性\n更新操作 sql语句 1 update emp set username=#{username),name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_Id=#{deptld}, create_time=#{createTime}, update_time=#{updateTime} where id=#{id} 接口方法 1 2 3 4 @Mapper public interface EmpMapper @Update(\u0026#34;update emp set username=#{username), name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_Id=#{deptld}, create_time=#{createTime}, update_time=#{updateTime} where id=#{id}\u0026#34;) public void update(Emp emp); 提示\n数据封装\n实体类属性名和数据库表查询返回的字段名一致，mybatis会自动封装。 如果实体类属性名 和 数据库表查询返回的字段名不一致，不能自动封装。 解决方案\n方案一：给字段起别名与实体类属性名相同\n方案二：使用@Results注解手动指定映射，@Result封装映射\ncolumn属性指定数据库字段 property属性指定实体类属性 1 2 3 @Results({ @Result(column=\u0026#34;数据库字段\u0026#34;,property=\u0026#34;实体类属性\u0026#34;) }) 查询操作 sql语句 1 2 3 select * from emp where name like \u0026#39;%李%\u0026#39; 接口方法 1 2 3 4 @Mapper public interface EmpMapper @Select(\u0026#34;select * from emp where name like \u0026#39;%#{name}%\u0026#39;\u0026#34;) public List\u0026lt;User\u0026gt; list(String name) 警告\n在模糊匹配中%#{name}%不建议使用（不是预编译sql语句）\n可以使用concat(‘%\u0026rsquo;,\u0026rsquo;#{name}\u0026rsquo;,\u0026rsquo;%')\n在Mapper.xml中基于映射文件属性sql语句 使用规范 XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下(同包同名)。\nXML映射文件的namespace属性为Mapper接口全限定名一致。\nXML映射文件中sql语句的id与Mapper 接口中的方法名一致，并保持返回类型一致。\n编写sql语句的格式\n1 2 3 \u0026lt;操作名 id=\u0026#34;函数名\u0026#34; resultType=\u0026#34;单条记录的实体类全类名\u0026#34;\u0026gt; sql语句 \u0026lt;/操作名\u0026gt; 提示\n只有select操作需要resultType\n动态SQL语句 \u0026lt; if \u0026gt;标签 ​\t描述：用于判断条件是否成立。使用test属性进行条件判断，如果条件为true，则拼接SQL\n​\t示例代码\n1 2 3 4 5 6 7 8 \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.itheima.pojo.Emp\u0026#34;\u0026gt; select * from omp where \u0026lt;if test=\u0026#34;name !=null\u0026#34;\u0026gt; name like concat(\u0026#34;%\u0026#34;,#{name},\u0026#34;%\u0026#34;) \u0026lt;/if\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;where\u0026gt;标签 ​\t描述：动态生成where子句，若子标签的条件都不满足则不会生成where子句，同时会删除子句开头的条件运算符\n​\t示例代码\n1 2 3 4 5 6 7 8 9 \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.itheima.pojo.Emp\u0026#34;\u0026gt; select * from emp \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name !=null\u0026#34;\u0026gt; name like concat(\u0026#34;%\u0026#34;,#{name},\u0026#34;%\u0026#34;) \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;set\u0026gt;标签 描述：动态生成set子句\n示例代码\n1 2 3 4 5 6 7 8 9 \u0026lt;update id=\u0026#34;update\u0026#34;\u0026gt; update emp \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;name !=null\u0026#34;\u0026gt; name=#{name} \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id=#{id} \u0026lt;/update\u0026gt; \u0026lt;foreach\u0026gt;标签 描述：用于遍历元素\n属性\ncollection：遍历的集合 item：集合中的元素 separator：分隔符 open：遍历开始前的SQL语句 close：遍历结束后的SQL语句 示例代码\n1 2 3 4 5 6 \u0026lt;delete id=\u0026#34;delete\u0026#34;\u0026gt; delete from emp where id in \u0026lt;foreach collection=\u0026#34;遍历的集合\u0026#34;,item=\u0026#34;集合中的元素\u0026#34;,separator=\u0026#34;分隔符\u0026#34;,open=\u0026#34;(\u0026#34;,close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; \u0026lt;sql\u0026gt;标签和\u0026lt;include\u0026gt;标签 \u0026lt;sql\u0026gt;:定义可重用的 SQL片段。 \u0026lt;include\u0026gt;:通过属性refid，指定包含的sql片段。 示例代码\n1 2 3 4 5 6 7 8 9 10 \u0026lt;sql id=\u0026#34;commonSelect\u0026#34;\u0026gt; select id, username from emp \u0026lt;/sql\u0026gt; \u0026lt;select id=\u0026#34;getById\u0026#34; resultTypea\u0026#34;com.itheima.pojo.Emp\u0026#34;\u0026gt; \u0026lt;include refid=\u0026#34;commonselect\u0026#34;/\u0026gt; where id = #{id} \u0026lt;/select\u0026gt; \u0026lt; trim \u0026gt;标签 prefix：将trim标签中内容前面添加指定内容 suffix：将trim标签中内容前面添加指定内容 prefixOverride：将trim标签中内容前面去除指定内容 suffixOverride：将trim标签中内容后面去除指定内容 \u0026lt;choose\u0026gt;,\u0026lt;when\u0026gt;,\u0026lt;otherwise\u0026gt; 相当于switch，if，else\n1 2 3 4 5 6 \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;满足的条件\u0026#34;\u0026gt; \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; 字段名和属性名的映射关系 通常情况下当数据表中的字段名和实体类的属性名对应相等时，MyBatis会将查询出的字段数据自动赋值给实体类\n当字段名和属性名不一致时 在sql语句中给字段名起别名使得字段名与属性名相同\n通过resultMap解决，其他的sql语句设置resultMap属性来确定映射关系\n1 2 3 4 \u0026lt;resultMap id=\u0026#34;resultMap_name\u0026#34;,type=\u0026#34;实体类\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;属性名\u0026#34;,column=\u0026#34;主键字段名\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;属性名\u0026#34;,column=\u0026#34;其他字段名\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultMap\u0026gt; 多对一的映射关系 示例：查询员工及其对应部门信息时，将员工的did和dname合并为一个dept对象，作为emp对象的成员变量\n通过resultMap中的级联属性解决，其他的sql语句设置resultMap属性来确定映射关系\nresultMap使用级联属性对应成员对象名\n1 2 3 4 5 6 7 8 9 \u0026lt;resultMap id=\u0026#34;empAndDeptResultMapone\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34;column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;dept.did\u0026#34; column=\u0026#34;did\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;dept.deptName\u0026#34; column=\u0026#34;dept_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultMap\u0026gt; 通过resultMap中的association标签解决，其他的sql语句设置resultMap属性来确定映射关系\nassociation具有两个属性，property对应实体类中的成员对象名，javaType对应该成员对象的java类型\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;resultMap id=\u0026#34;empAndDeptResultMapone\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34;column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;association property=\u0026#34;dept\u0026#34; javaType=\u0026#34;Dept\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;did\u0026#34; column=\u0026#34;did\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;dept.deptName\u0026#34; column=\u0026#34;dept_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; 一对多的映射方式 示例：查询部门及其下属员工时，一个部门作为实体类具有一个员工对象的集合作为成员变量\n通过resultMap的collection标签解决，其他的sql语句设置resultMap属性来确定映射关系\ncollection具有两个属性，property对应实体类中的成员对象名，ofType对应该成员对象的java类型\n1 2 3 4 5 6 7 8 9 \u0026lt;resultMap id=\u0026#34;empAndDeptResultMapone\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;collection property=\u0026#34;成员变量名\u0026#34; ofType=\u0026#34;集合内的泛型\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34;column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; ","date":"2024-11-06T17:26:14+08:00","permalink":"https://Tyritic.github.io/p/mybatis%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","title":"MyBatis基本使用"},{"content":"Lombok简介 Lombok是一个实用的java类库，能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法 并可以自动化生成日志变量，简化iava开发\n常见注解 注解 作用 @Getter/@Setter 为所有的属性提供get/set方法 @Builder 通过建造者模式来创建对象，这样就可以通过链式调用的方式进行对象赋值 @ToString 会给类自动生成易阅读的toString 方法 @EqualsAndHashCode 根据类所拥有的非静态字段自动重写 equals方法和 hashcode 方法 @Data 提供了更综合的生成代码功能(@Getter+@Setter+@ToString+@EqualsAndHashCode) @NoArgsConstructor 为实体类生成无参的构造器方法 @AllArgsConstructor 为实体类生成除了static修饰的字段之外带有各参数的构造器方法 ","date":"2024-11-06T17:19:27+08:00","permalink":"https://Tyritic.github.io/p/lombok%E7%B1%BB%E5%BA%93/","title":"Lombok类库"},{"content":"什么是MyBatis MyBatis是一款优秀的 持久层框架，用于简化JDBC的开发。 MyBatis本是 Apache的一个开源项目iBatis,2010年这个项目由apache迁移到了google code，并且改名为MyBatis。2013年11月迁移到Github。 官网:https://mybatis.org/mybatis-3/zh/index.html MyBatis的配置 在pom.xml中配置相关依赖\n在application.yml中的spring.database属性下配置相关数据库连接信息\n指定驱动类名称：driver-class-name 数据库连接的url：url 连接数据库的用户名 连接数据库的密码 编写sql语句\n在mapper文件夹下编写接口，用 @Mapper 修饰\n在每一个函数上根据操作名使用对应的注解修饰sql语句\n1 2 3 4 5 @Mapper public interface UserMapper{ @Select(\u0026#34;select * from user\u0026#34;) public List\u0026lt;User\u0026gt;list(); } 或者在resource文件夹下创建和接口全名（包名.接口名）一致的xml，在xml文件中根据具体的接口函数编写对应的sql语句\n1 2 3 4 5 6 7 8 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34; \u0026gt; \u0026lt;mapper namespace=\u0026#34;org.example.operator.mapper.userMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;list\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 数据库连接池 什么是数据连接池 数据库连接池是个容器，负责分配、管理数据库连接(Connection) 它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个 释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏 优势 资源重用 提升系统响应速度 避免数据库连接遗漏 常见产品 C3PO DBCP Druid Hikari(springboat默认) ","date":"2024-11-06T16:50:26+08:00","permalink":"https://Tyritic.github.io/p/mybatis%E7%AE%80%E4%BB%8B/","title":"MyBatis简介"},{"content":"基本概念 索引(index)：帮助数据库高效获取数据的数据结构，索引和数据就是位于存储引擎中\n优点\n提高数据查询的效率，降低数据库的I0成本， 通过索引列对数据进行排序，降低数据排序的成本，降低CPU消耗。 缺点\n索引会占用存储空间。 索引大大提高了查询效率，同时却也降低了insert、 update、delete的效率。 索引操作 创建索引\n1 create [unique] index index_name on table_name(字段名,...) 查看索引\n1 show index from table_name 删除索引\n1 drop index index_name on table_name 提示\n主键字段，在建表时，会自动创建主键索引。 添加唯一约束时，数据库实际上会添加唯一索引。 索引加速查询的原理 数据库文件是存储在磁盘上的，磁盘 I/O 是数据库操作中最耗时的部分之一。没有索引时，数据库会进行全表扫描（Sequential Scan），这意味着它必须读取表中的每一行数据来查找匹配的行（时间效率为 $O(n)$）。当表的数据量非常大时，就会导致大量的磁盘 I/O 操作。\n有了索引，就可以直接跳到索引指示的数据位置，而不必扫描整张表，从而大大减少了磁盘 I/O 操作的次数。\n索引分类 按数据结构分类 B+Tree 索引 ：通过树形结构存储数据，适用于范围查询（如 BETWEEN ）和精确查询（如 = ），支持有序数据的快速查找、排序和聚合操作。是 MySQL 默认的索引类型，常用于 InnoDB 和 MyISAM 引擎。 HASH 索引：基于哈希表的结构，适用于等值查询（如 =），查询速度非常快，但不支持范围查询（如 \u0026gt; 、\u0026lt; ）。哈希索引不存储数据的顺序，常用于 Memory 引擎。 Full-Text 索引 ：用于全文搜索，将全文分词，通过存储词与文档的映射，支持模糊匹配和关键字搜索。特别适合用于大文本字段，如 TEXT 类型的列，用于查找包含特定词语的记录。 在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：\n如果有主键，默认会使用主键作为聚簇索引的索引键（key）； 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）； 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key） 创建的主键索引和二级索引默认使用的是 B+Tree 索引。\nB+树索引 B+ 树是 B 树的升级版。具有以下特点\n而且每个节点里的数据是 按主键顺序存放 的。每一层父节点的索引值都会出现在下层子节点的索引值中 B+ 树中的非叶子节点都不存储数据，只存储索引。 叶子节点中存储了所有的数据，并且构成了一个从小到大的有序双向链表，使得在完成一次树的遍历定位到范围查询的起点后，可以直接通过叶子节点间的指针顺序访问整个查询范围内的所有记录，而无需对树进行多次遍历。这在处理大范围的查询时特别高效。 一棵三层的 B+ 树在 MySQL 中可以存储大约 2000 万条记录 。\n提示\n为什么选择B+树作为索引的数据结构\n高效的查找性能：B+ 树是一种自平衡树，每个叶子节点到根节点的路径长度相同，B+ 树在插入和删除节点时会进行分裂和合并操作，以保持树的平衡，但它又会有一定的冗余节点，使得删除的时候树结构的变化小，更高效。查找、插入、删除等操作的时间复杂度为 O(log n)，能够保证在大数据量情况下也能有较快的响应时间。 树的高度增长不会过快，使得查询磁盘的 I/O 次数减少：B+ 树不像红黑树，数据越多树的高度增长就越快。它是多叉树，非叶子节点仅保存主键或索引值和页面指针，使得每一页能容纳更多的记录，因此内存中就能存放更多索引，容易命中缓存，使得查询磁盘的 I/O 次数减少。 范围查询能力强：B+ 树特别适合范围查询。因为叶子节点通过链表链接，从根节点定位到叶子节点查找到范围的起点之后，只需要顺序扫描链表即可遍历后续的数据，非常高效 B树和B+树的区别以及不使用B树作为索引的原因\n节点结构不同\nB 树每个节点都存储了完整的数据 B+ 树非叶子节点仅存储 key 和指针，完整数据存储在叶子节点。这使得 B+ 树可以在内存中存放更多索引页，减少磁盘查询次数。 叶子节点的独立性\nB+ 树叶子组成了链表，便于区间查找。 B 树的叶子节点都是独立的 查询效率的稳定性\nB+ 树查询时间更平均、稳定，都需要从根节点扫描到叶子节点。 B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。 查询过程\n数据从根节点找起，根据比较数据键值与节点中存储的索引键值，确定数据落在哪个区间，从而确定分支，从上到下最终定位到叶子节点 叶子节点存储实际的数据行记录，但是一页有 16kb 大小，存储的数据行不止一条 叶子节点中数据行以组的形式划分，利用 页目录 结构，通过二分查找可以定位到对应的组 定位组后，利用链表遍历就可以找到对应的数据行 Hash索引 基于哈希表的结构，适用于等值查询（如 =），查询速度非常快，但不支持范围查询（如 \u0026gt; 、\u0026lt; ）。哈希索引不存储数据的顺序，常用于 Memory 引擎。\n按物理存储分类 从物理存储的角度来看，索引分为聚集索引和辅助索引\n聚簇索引 聚簇索引就是索引结构和数据一起存放的索引。查询到了索引就可以直接访问到整个记录。\nInnoDB 中的主键索引就属于聚簇索引。在聚簇索引中，它的B+树索引的叶子节点中包含整条记录，可以直接访问完整数据。在整个数据库有且只有一个\n非聚簇索引 非聚簇索引就是索引结构和数据分开存放的索引，查询到了索引还需要通过索引中指向记录的指针访问记录。\nMySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。\n对于非聚簇索引，它的B+树索引的叶子节点只包含主键值和索引值。\n通过非聚簇索引查找记录的过程（回表）\n找到二级索引中的 B+Tree 的索引值，找到对应的叶子节点， 要先找到主键，然后通过主键再到聚簇索引中找到对应的记录行 当非聚集索引同时是 覆盖索引 时就不需要回表。比如使用该二级索引去查找主键\n提示\n回表\n回表是指在使用二级索引（非聚簇索引）作为条件进行查询时，由于二级索引中只存储了索引字段的值和对应的主键值，无法得到其它数据。如果要查询数据行中的其它数据，需要根据主键去聚簇索引查找实际的数据行\n覆盖索引\n覆盖索引：一个二级索引包含（或者说覆盖）所有需要查询的字段的值，从而使查询可以仅通过访问二级索引而不需要访问实际的表数据（主键索引）。\n表现为查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到\n按字段特性分类 主键索引：建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。 唯一索引：建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。 普通索引：普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。 前缀索引：对文本的前几个字符创建索引，相比普通索引建立的数据更小 按字段个数分类 从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。\n建立在单列上的索引称为单列索引，比如主键索引； 建立在多列上的索引称为联合索引 联合索引 联合索引：通过将多个字段组合成一个索引\n联合索引的匹配过程遵循最左前缀匹配原则\n提示\n最左匹配原则\n最左前缀匹配原则指的是在使用 联合索引 时，查询条件必须从索引的最左侧开始匹配。MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用索引来过滤数据。最左匹配原则会一直向右匹配，直到遇到范围查询 （如 \u0026gt;、\u0026lt;） 就会停止匹配。在范围查询字段的后面的字段无法用到联合索引。注意，对于 \u0026gt;=、\u0026lt;=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配\n假设有一个联合索引 (column1, column2, column3) ，其从左到右的所有前缀为 (column1)、(column1, column2)、(column1, column2, column3)（创建 1 个联合索引相当于创建了 3 个索引），包含这些列的所有查询都会走索引而不会全表扫描。\n底层原理：因为联合索引在 B+ 树中的排列方式遵循“从左到右”的顺序，例如联合索引 (first_name, last_name, age) 会按照 (first_name, last_name, age) 的顺序在 B+ 树中进行排序\n根据最左匹配原则，建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中 建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到。\n对联合索引的优化：索引下推\n索引下推（Index Condition Pushdown, ICP）是一种减少回表查询，提高查询效率的技术。它允许 MySQL 在使用索引查找数据时，将部分查询条件下推到存储引擎层过滤，从而减少需要从表中读取的数据行，减少了 IO（本该由 Server 层做操作，交由存储引擎层因此叫做 “下推” ） 。\n使用了聚簇索引（主键）查询，索引下推也不会生效，因为其是对于非聚簇索引来进行减少回表次数。\n索引的设计原则 选择合适的字段建立索引 不为 NULL 的字段 ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。 被频繁查询的字段 ：创建索引的字段应该是查询操作非常频繁的字段。被作为 WHERE 条件查询的字段，应该被考虑建立索引。 频繁需要排序的字段 ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。 被经常频繁用于连接的字段 ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。 字段有唯一性限制的：比如商品编码； 不需要创建索引的情况 字段中存在大量重复数据，不需要创建索引：比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。 表数据太少不需要建立索引：表数据太少的时候不需要创建索引 经常更新的字段不用创建索引：因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。 长文本字段（非常长的 varchar 或 JSON、BLOB 和 TEXT 类型，这些类型的列通常包含大量数据） 数据量大排序时都无法用内存排，只能利用磁盘文件，排序很慢。 数据量大，每个页能存放的行数就少，扫描查询可能会涉及大量的 I/O。 提示\n索引并不是越多越好。因为索引不论从时间还是空间上都是有一定成本的\n从时间上 每次对表中的数据进行增删改(INSERT、UPDATE 或 DELETE)的时候，索引也必须被更新，这会增加写入操作的开销。例如删除了一个 name 为面试鸭的记录，不仅主键索引上需要修改，如果 name 字段有索引，那么 name 索引也需要修改，所以 索引越多需要修改的地方也就越多，时间开销就大了，并且 B+ 树可能会有页分裂、合并等操作，时间开销就会更大。 MySQL 有个查询优化器，它需要分析当前的查询，选择最优的计划，这过程就需要考虑选择哪个索引的查询成本低。如果索引过多，那么会导致优化器耗费更多的时间在选择上。 从空间上 每建立一个二级索引，都需要新建一个 B+ 树，默认每个数据页都是 16kb，如果数据量很大，索引又很多，占用的空间可不小。 索引失效的情况和排查 索引失效情况 创建了联合索引，但查询条件未遵守最左匹配原则\n在索引列上进行表达式计算、函数、隐式类型转换等操作\n表达式计算和函数的失效原理：因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。 MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。 以 % 开头的 LIKE 查询（左模糊或者左右模糊匹配）比如 LIKE '%abc'\n查询条件中使用 OR，且 OR 的前后条件中有一个列没有索引，涉及的索引都不会被使用到\n索引失效排查方法 使用 EXPLAIN 命令，通过在查询前加上**EXPLAIN**，可以查看 MySQL 选择的执行计划，了解是否使用了索引、使用了哪个索引、估算的行数等信息。\n主要观察 EXPLAIN 结果以下几点：\ntype（访问类型）：这个属性显示了查询使用的访问方法，例如 ALL 、index 、range 等。当查询使用索引时，这个属性通常会显示为 index 或 range ，表示查询使用了索引访问。如果这个值是 ALL ，则表示查询执行了全表扫描，没有使用索引。 key（使用的索引）：这个属性显示了查询使用的索引，如果查询使用了索引，则会显示索引的名称。如果这个值是 NULL ，则表示查询没有使用索引。 rows（扫描的行数）：这个属性显示了查询扫描的行数，需要评估下扫描量。 索引优化方法 前缀索引优化 前缀索引：使用某个字段中字符串的前几个字符建立索引。使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。\n覆盖索引优化 覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。\n主键尽量自增 主键索引最好是自增的：\n如果使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次 插入一条新记录，都是追加操作，不需要重新移动数据 ，因此这种插入数据的方法效率非常高。 如果使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为 页分裂 。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。 避免在索引列上使用函数和表达式计算 在 where 子句中直接对列使用函数会导致索引失效，因为数据库需要对每行的列应用函数后再进行比较，无法直接利用索引。不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。\n避免对索引使用最左模糊匹配 因为索引 B+ 树是按照 索引值 有序排列存储的，只能根据前缀进行比较。所以不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。\n","date":"2024-11-04T19:18:04+08:00","permalink":"https://Tyritic.github.io/p/mysql%E7%B4%A2%E5%BC%95/","title":"MySQL索引"},{"content":"概念 事务是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作 要么同时成功，要么同时失败。\n提示\nMySQL会立即隐式的提交事务。默认MySQL的事务是自动提交的，\n事务控制语句 开启事务\n1 start transaction； 提交事务\n1 commit; 回滚事务\n1 rollback; 四大特性 原子性（Atomicity）：事务是不可分割的最小单元，要么全部成功，要么全部失败 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态 隔离性（lsolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的 实现原理\n持久性是通过 redo log （重做日志）来保证的 原子性是通过 undo log （回滚日志） 来保证的 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的 一致性则是通过持久性+原子性+隔离性来保证 MVCC MVCC（Multi-Version Concurrency Control，多版本并发控制）是一种并发控制机制，允许多个事务同时读取和写入数据库，而无需互相等待，从而提高数据库的并发性能。\n在 MVCC 中，数据库为每个事务创建一个数据快照。每当数据被修改时，MySQL 不会立即覆盖原有数据，而是生成新版本的记录。每个记录都保留了对应的版本号或时间戳。\n版本链 在 InnoDB 中，每一行数据都有两个隐藏的列：一个是 DB_TRX_ID ，另一个是 DB_ROLL_PTR 。\nDB_TRX_ID ：保存创建这个版本的事务 ID。 DB_ROLL_PTR ：指向 undo 日志记录的指针，这个记录包含了该行的前一个版本的信息。通过这个指针，可以访问到该行数据的历史版本。 当事务更新一行数据时，InnoDB 不会直接覆盖原有数据，而是创建一个新的数据版本，并更新 DB_TRX_ID 和 DB_ROLL_PTR，使得它们指向前一个版本和相关的 undo 日志。这样，老版本的数据不会丢失，可以通过版本链找到。\nReadView ReadView（读视图）是 InnoDB 为了实现一致性读而创建的数据结构，它用于确定在特定事务中哪些版本的行记录是可见的。可以理解为数据快照\nRead View 有四个重要的字段：\nm_ids ：指的是在创建 Read View 时，当前数据库中 活跃事务 的 事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务。 min_trx_id ：指的是在创建 Read View 时，当前数据库中 活跃事务 中事务 id 最小的事务 ，也就是 m_ids 的最小值。 max_trx_id ：这个并不是 m_ids 的最大值，而是 创建 Read View 时当前数据库中应该给下一个事务的 id 值 ，也就是全局事务中最大的事务 id 值（m_ids 的最大值） + 1； creator_trx_id ：指的是 创建该 Read View 的事务的事务 id 。 可见性实现 如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在创建 Read View 前 已经提交的事务生成的，所以该版本的记录对当前事务 可见 。 如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在创建 Read View 后才启动的事务生成的，所以该版本的记录对当前事务 不可见 。 如果记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间，需要判断 trx_id 是否在 m_ids 列表中： 如果记录的 trx_id 在 m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务不可见。 如果记录的 trx_id 不在 m_ids 列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务 可见 。 快照读和当前读 快照读 快照读是指事务在执行查询时，不直接读取当前最新的数据，而是读取数据的历史版本（快照）。MySQL InnoDB 通过多版本并发控制（MVCC）来实现快照读。快照读只会返回在事务开始时可见的数据，即使其他事务在之后修改了这些数据，快照读也不会受影响。\n当前读 MySQL 里除了普通查询是快照读，其他都是 当前读，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。\n当前读是指读取数据的最新版本，并且会加锁以确保数据的一致性。即使其他事务对这个数据的修改在当前读的事务之后，这个修改也会反映在当前读的结果中。（如果事务 2 开始时间发生在事务 1 之后，那么正常情况下事务 2 的修改对事务 1 不可见，但是事务 1 的当前读可见这个修改）。\n并发问题 脏读 定义：一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据\n示例：假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取余额数据，然后再执行更新操作，如果此时事务 A 还没有提交事务，而此时正好事务 B 也从数据库中读取余额数据，那么事务 B 读取到的余额数据是刚才事务 A 更新后的数据，即使没有提交事务。\n不可重复读 定义：在同一事务中，读取同一数据两次，但由于其他事务的提交，读取的结果不同。\n示例：假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取余额数据，然后继续执行代码逻辑处理，在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。\n幻读 定义：在一个事务内多次查询某个符合查询条件的记录数量，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了幻读现象。\n提示\n幻读和不可重复读的区别\n幻读 ：在事务期间，对于数据总量的突然增加或减少，将别的事务提交的读取到了（针对于数据的数量） 不可重复读 ：对于同一条数据，在事务执行期间，里面的字段内容发生了变化，读取到了别的事务提交修改的数据。（针对于数据的内容）。 事务隔离级别 四大隔离级别 隔离级别 脏读 不可重复读 幻读 Read uncommitted （读取未提交） √ √ √ Read committed （读取已提交） × √ √ Repeatable Read(默认) （可重复读） × × √ Serializable （串行化） × × × 其中 Serializable 数据安全性更好但是性能最差，Read uncommitted反之\n读未提交（READ UNCOMMITTED）： 这是最低的隔离级别，在该级别下，一个事务可以看到另一个事务尚未提交的数据修改。这可能会导致 脏读 问题，即读取到其他事务未提交的数据。 读已提交（READ COMMITTED）： 在这个级别下，一个事务只能看到已经提交的其他事务所做的修改。这可以避免脏读问题，但是可能会引发 不可重复读 问题，即在同一个事务中，相同的查询可能返回不同的结果。 可重复读（REPEATABLE READ）： 指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的。在这个级别下，确保在一个事务中的多个查询返回的结果是一致的。这可以避免不可重复读问题，但是可能会引发 幻读 问题，即在同一个事务中，多次查询可能返回不同数量的行（MySQL 默认的隔离级别）。 串行化（SERIALIZABLE）： 可串行化执行被定义为：并发执行的 SQL 事务的操作，其效果与这些 SQL 事务按某种顺序串行执行的效果相同。串行执行是指每个 SQL 事务在下一个 SQL 事务开始之前完成其全部操作 这是最高的隔离级别，在这个级别下，保证事务间的操作结果相当于一个按顺序执行的单线程操作。这可以避免所有的并发问题，但是会大大降低并发性能。该级别会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行 隔离级别的实现 读已提交 每次读取数据前都生成一个 Read_View，保证每次读操作都是最新的数据。 正是因为在读提交隔离级别下，事务每次读数据时都重新创建 Read View，那么在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。\n可重复读 可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View。\n可重复读隔离级别下在事务期间读到的记录都是事务启动前的记录。具体过程如下\n记录被另一个事务修改时会修改记录中的 trx_id ，同时记录的 roll_pointer 指向该记录的上一个版本的版本 当事务发现记录的 trx_id 被修改后根据Read_View的可见机制判断该记录是否可读 事务从头到尾都是使用事务启动时创建的Read_View 相关SQL语句 查看事务隔离级别 1 select @@transaction isolation; 设置事务隔离级别 1 set [ session | global] transaction isolation level { read uncommitted | read committed | repeatable read | serializable } MySQL的日志级别 binlog ：是 MySQL 中的二进制日志文件，用于记录 MySQL 服务器上的所有更新和修改操作。它可以记录所有的 DDL和 DML操作，包括对表结构的更改、数据的插入、修改、删除等等。 binlog 是在事务提交后生成的，因此可以用于恢复数据库。是位于 Server 层的日志\nSTATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致； ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已； MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式； redo log ：用于恢复数据，保证数据的一致性和持久性。当 MySQL 发生修改时，redolog 会将这些操作记录下来，并写入磁盘。这样，当 MySQL 发生宕机或崩溃时，通过重放 redolog 就可以恢复数据。实现了事务中的 持久性 ，主要用于故障恢复；\nundo log ：用于回滚操作。当 MySQL 发生事务回滚时，undo log 会记录这些操作并将其写入磁盘。这样，当 MySQL 需要回滚时，通过重放 undo log 就可以回滚事务。实现了事务中的 原子性 ，主要 用于事务回滚和 MVCC 。\nundo log undo log （回滚日志），它保证了事务的 ACID 特性 (opens new window)事务中的原子性（Atomicity）\n原理 undo log 是一种用于撤销回退的日志。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。\n在发生回滚时，就读取 undo log 里的数据，然后做原先相反操作。比如当 delete 一条记录时， undo log 中会把记录中的内容都记下来，然后执行回滚操作的时候，就读取 undo log 里的数据，然后进行 insert 操作。\n作用 实现事务回滚，保障事务的原子性 ：事务处理过程中，如果出现了错误或者用户执行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。 实现 MVCC（多版本并发控制）关键因素之一 ：MVCC 是通过 ReadView + undo log 实现的。 undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。 redo log redo log 是物理日志，记录了某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新，每当执行一个事务就会产生这样的一条或者多条物理日志。通常用于保存事务已经提交但未写入磁盘的数据。\n原理 在事务提交时，先将 redo log 持久化到磁盘即可。\n当系统崩溃时，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。\n写入方式 写入 redo log 的方式使用了追加操作， 磁盘操作是顺序写，\n写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是随机写。MySQL 的写操作并不是立刻更新到磁盘上，而是先记录在日志上，然后在合适的时间再更新到磁盘上 。\n因此MySQL 的写操作从磁盘的随机写变成了顺序写，提升语句的执行性能。\n默认情况下， InnoDB 存储引擎有 1 个重做日志文件组( redo log Group），重做日志文件组由有 2 个 redo log 文件组成，这两个 redo 日志的文件名叫 ：ib_logfile0 和 ib_logfile1 。\n重做日志文件组是以循环写的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形。\n所以 InnoDB 存储引擎会先写 ib_logfile0 文件，当 ib_logfile0 文件被写满的时候，会切换至 ib_logfile1 文件，当 ib_logfile1 文件也被写满时，会切换回 ib_logfile0 文件。\n作用 实现事务的持久性：能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失； 将写操作从随机写变成了顺序写 ：提升 MySQL 写入磁盘的性能。 提示\nWAL技术\nWAL（Write-Ahead Logging）技术是一种数据库事务日志管理技术，它确保在修改真正的数据之前，先将修改记录写入日志。这使得即使系统崩溃，通过日志也能恢复数据。保证了数据的持久性和一致性。\n其中redolog就是WAL技术的体现\n当一个事务开始时，所有对数据库的修改首先记录到重做日志缓冲区中。\n重做日志缓冲区的数据会周期性地刷新到磁盘上的重做日志文件。\n当事务提交时，InnoDB 确保重做日志已写入磁盘，然后将数据页的修改写入数据文件。\n如果系统崩溃，InnoDB 会在启动时通过重做日志重新应用所有未完成的事务，以恢复数据库到一致状态。\nbinlog binlog 日志是一种逻辑日志，用于记录所有事务执行的数据库的修改操作（如插入、更新、删除等），以便在需要时进行数据恢复、数据复制和数据同步等操作。\n作用 数据恢复： binlog 日志可以用于回滚到之前的某个时间点，从而恢复数据。 数据复制： binlog 日志可以用于在主从数据库之间复制数据，从而实现数据的高可用和负载均衡等功能 提示\n如果不小心整个数据库的数据被删除了，能使用 redo log 文件恢复数据吗？\n因为 redo log 文件是循环写，是会边写边擦除日志的，只记录未被刷入磁盘的数据的物理日志，已经刷入磁盘的数据都会从 redo log 文件里擦除。 binlog 文件保存的是全量的日志，也就是保存了所有数据变更的情况，理论上只要记录在 binlog 上的数据，都可以恢复，所以如果不小心整个数据库的数据被删除了，得用 binlog 文件恢复数据。 redo log和binlog的区别\n写入方式 binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。 redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。 引擎类型 binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用； redo log 是 Innodb 存储引擎实现的日志； 日志内容 binlog 是逻辑日志，记录数据库的修改操作（如插入、更新、删除等） redo log 是物理日志，记录的是在某个数据页做了什么修改 主从复制 MySQL 的主从同步机制是一种数据复制技术，用于将主数据库（Master）上的数据同步到一个或多个从数据库（Slave）中。\n主要是通过二进制日志（Binary Log，简称 binlog）实现数据的复制。主数据库在执行写操作时，会将这些操作记录到 binlog 中，然后推送给从数据库，从数据库重放对应的日志即可完成复制。\n写入 Binlog：主库写 binlog 日志，提交事务，并更新本地存储数据。 MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog ，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。 同步 Binlog：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。 从库会创建一个专门的 I/O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。 回放 Binlog：回放 binlog，并更新存储引擎中的数据。 从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。 二阶段提交 事务提交后， redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成主库和从库数据不一致。这是因为 redo log 影响主库的数据， binlog 影响从库的数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致\n二阶段提交的过程 准备阶段（Prepare Phase）：在事务提交时，MySQL 的 InnoDB 引擎会先写入 redo log，并将其状态标记为prepare，表示事务已经准备提交但还未真正完成。此时的 redo log 是预提交状态，还未标记为完成提交。 提交阶段（Commit Phase）：当 redo log 的状态变为 prepare 后，MySQL Server 会写入 binlog（记录用户的 DML 操作）。binlog 写入成功后，MySQL 会通知 InnoDB，将 redo log 状态改为commit，完成整个事务的提交过程。 提示\n半成功状态的情况\n先写完 redo log，再写 binlog 写完 redo log 后，MySQL 异常宕机，binlog 还未写入数据。重启后 redo log 记录了，因此可以从 redo log 恢复事务的修改，但是 binlog 并没有本次事务提交的数据。后续从库通过 binlog 恢复的时候，本次事务的修改就丢了。 先写完 binlog，再写 redo log 写完 binlog 后，MySQL 异常宕机， redo log 还未写入数据。重启后因为 redo log 中没有记录，所以无法恢复本次事务的修改，但是 binlog 记录了本次事务提交的数据。后续从库通过 binlog 恢复的时候，本次事务的修改可以复原，但是这和原库的数据又不一致了。 异常宕机过程 redo log 处于 prepare 阶段，binlog 还未写入 ，此时 MySQL 异常宕机：由于 redo log 还未 commit ，所以异常恢复后， redo log 中记录的数据也不作数， binlog 内也没有记录数据，此时数据是一致的。 redo log 处于 prepare 阶段，binlog 已写入，但 redo log 还未 commit ，此时 MySQL 异常宕机：此时对比 redo log 中 prepare 的数据和 binlog 中的数据是都一致即可。如果一致，则提交事务。不一致，则回滚事务。 ","date":"2024-11-04T19:06:51+08:00","permalink":"https://Tyritic.github.io/p/mysql%E4%BA%8B%E5%8A%A1/","title":"MySQL事务"},{"content":"基本查询 基本语法\n1 2 3 4 5 6 7 8 9 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from table_name where condition #条件列表 #以下均为可选选项 group by 聚合函数（字段列表） having 对分组条件的过滤操作 order by 对字段列表的排序 #（ASC升序，DESC降序） limit 分页参数 (起始索引，查询记录数) #索引从0开始，起始索引=（查询页码-1)*每页记录数 条件查询 常见条件运算符 比较运算符 功能 \u0026gt; 大于 \u0026gt;= 大于等于 \u0026lt; 小于 \u0026lt;= 小于等于 \u0026lt;\u0026gt;或!= 不等于 常见逻辑运算符 逻辑运算符 功能 and 或 \u0026amp;\u0026amp; 与 or 或 || 或 not 或 | 非 单表查询 1 2 3 4 5 6 7 8 9 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from table_name where condition #条件列表 #以下均为可选选项 group by 聚合函数（字段列表） having 对分组条件的过滤操作 order by 对字段列表的排序 #（ASC升序，DESC降序） limit 分页参数 (起始索引，查询记录数) #索引从0开始，起始索引=（查询页码-1)*每页记录数 select子句：指定所需的属性，对应关系代数中的投影操作\n默认允许重复的元组\n显式指示使用all关键字\n强制去除重复使用distinct关键字\n查询所有属性可以简写为*\nfrom子句：确定查询中需要访问的表\nwhere子句：指定结果满足的特定条件\n附加的基本操作 更名运算 作用 长命名改为短命名 比较同一个关系的元组 放置位置：位置灵活，无限制 1 2 3 4 5 6 7 8 9 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from old_name as new_name where condition #条件列表 #以下均为可选选项 group by 聚合函数（字段列表） having 对分组条件的过滤操作 order by 对字段列表的排序 #（ASC升序，DESC降序） limit 分页参数 (起始索引，查询记录数) #索引从0开始，起始索引=（查询页码-1)*每页记录数 显示顺序 在查询语句的结尾使用order by子句来决定显示按顺序还是倒序，默认为顺序\ndes：降序 asc：升序（默认） 1 2 3 select columns from table order by column_name [asc | desc]; 字符串相关操作 放置位置\nwhere子句中充当条件 select子句中充当元素 常见操作\n标识一个字符串\n1 \u0026#39;字符串\u0026#39; 模式匹配\nlike关键字\n1 2 3 4 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from table_name as s where s.name like %|_% escape \u0026#39;|\u0026#39; #匹配任何包含_的字符串 百分号%：匹配任意子串\n例如以substring开头：substring%\n匹配任何包含substring的字符串：%substring%\n下划线_：匹配任意字符\n定义转义字符：escape\u0026rsquo;转义字符'\nregexp：正则表达式匹配\n1 2 3 select * from users where name regexp \u0026#39;^张.$\u0026#39;; 字符串串联\nconcat(str1, str2, \u0026hellip;)\n1 2 select concat(first_name, \u0026#39; \u0026#39;, last_name) as full_name from users; str1|| str2\n1 2 select first_name || \u0026#39; \u0026#39; || last_name as full_name from users; concat_ws(separator, str1, str2, \u0026hellip;)：允许指定分隔符\n1 2 select concat_ws(\u0026#39;, \u0026#39;, first_name, last_name) as full_name from users; 大小写以及首尾去除空格\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #转小写 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from table_name as s where s.name =lower(\u0026#39;hEllO world\u0026#39;) #与hello world匹配的字符串 #转大写 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from table_name as s where s.name =upper(\u0026#39;hEllO world\u0026#39;) #与HELLO WORLD匹配的字符串 #去除首尾空格 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from table_name as s where s.name =upper(\u0026#39; hEllO world \u0026#39;) #与hEllO world匹配的字符串 大写：upper(str) 小写：lower(str) 去除空格：trim(str) where子句谓词 between min_value and max_value：说明一个值位于某个范围,大于等于min_value，小于等于max_value\n1 2 3 select columns from table as t where t.age between 10 and 100 #年龄在10岁到100岁 元组比较：元组之间使用字典序进行比较\n1 2 3 select name, course_id from instructor, teaches where (instructor.ID, dept_name) = (teaches.ID, ’Biology’); 集合运算 所有的集合运算默认去除重复，若保留重复则在集合运算符后面加上关键字all\n查找在 2009 年秋季或 2010 年春季开设的课程（使用并运算）\n1 2 3 (select course_id from section where sem = ‘Fall’ and year = 2009) union (select course_id from section where sem = ‘Spring’ and year = 2010) 查找在 2009 年秋季和2010 年春季开设的课程（使用交运算）\n1 2 3 (select course_id from section where sem = ‘Fall’ and year = 2009) intersect (select course_id from section where sem = ‘Spring’ and year = 2010) 查找在 2009 年秋季开课但未在 2010 年春季开课的课程（使用差运算）\n1 2 3 (select course_id from section where sem = ‘Fall’ and year = 2009) except (select course_id from section where sem = ‘Spring’ and year = 2010) 分组查询 基本聚合函数 函数 功能 sum 求和 avg 平均值 count 计数 max 最大值 min 最小值 提示\nnull不参与聚合函数的运算\n使用关键字*指代所有\n可以在聚集表达式中使用关键字distinct修饰被聚合的属性来删除重复的元组如count (distinct id)\ngroup by子句 将聚集函数用于一组元组集上而利用属性进行的分组操作\n1 2 3 4 #正确示范 select dept_name, avg(salary)as avg_salary) from instructor group by dept_name; 提示\nselect子句中的字段为用于分组的字段（group by中的属性，当只有一个聚合函数时可以不存在）和聚合函数（保证select子句中非聚集的属性只能是出现在group by子句）\n1 2 3 4 5 #错误查询，select子句中的非聚合属性ID #没出现在group by子句中 select dept_name, ID, avg(salary) from instructor group by dept_name ; 在默认情况下，系统按照group by子句中指定的列升序排列，但是可以使用order by子句指定新的排列顺序。\nhaving子句 对group by后的分组进行过滤操作\n可以使用聚集函数\n1 2 3 4 5 select course_id,semester,year,sec_id,avg(tot_cred) from takes natural join student where year = 2009 group by course_id,semester,year,sec_id having count(ID)\u0026gt;=2; 提示\nhaving和where的区别\n执行时机不同:where是分组之前进行过滤，不满足where条件，不参与分组;而having是分组之后对结果进行过滤。\n判断条件不同:where不能对聚合函数进行判断，而having可以。\n保证出现在having子句中的非聚集的属性只能出现在group by子句中\n1 2 3 4 5 6 # 错误示范 having子句中非聚集的属性salary # 没有出现在group by中 select department,AVG(salary)AS avg_salary from employees group by department having salary \u0026gt;5000; 查询的执行顺序 根据from子句计算出关系 若出现了where子句则将where子句中的谓词应用到from子句的结果关系上 若出现了group by子句，满足where子句的元组通过group by子句形成分组，若没有group by子句则满足where子句谓词的整个元组集被当成一个分组 若出现了having子句，将被应用到每一个分组，不满足子句谓词的分组将被抛弃 select子句利用剩下的分组产生出查询结果中的元组，在每个分组上应用聚集函数来得到单个结果元组 多表查询 连接查询 笛卡尔积\n描述：输出两个关系中输出所有的元组对（无论在共同属性上的取值是否相同）\n若关系r中属性和关系s中的属性相同则区分命名\n属性名不相同 属性名相同 示例代码：\n1 2 3 4 #隐式笛卡尔积 table a,table b #显式笛卡尔积 table a join table b 内连接\n描述：查询A表和B表相交的部分（有条件的笛卡尔积）\n性质：不保留未匹配元组的连接运算（合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行）\n语法：\n1 2 3 4 5 6 7 8 9 #隐式内连接 select 字段列表 from table a,table b where condition #显式内连接 select 字段列表 from table a join table b on 连接条件 外连接：\n描述：通过在表中创建包含空值元组的方式保留未匹配元组的连接运算\n左外连接：只保留出现在左外连接运算之前（左边）的关系中的元组。 右外连接：只保留出现在右外连接运算之后（右边）的关系中的元组。 全外连接：保留出现在两个关系中的元组。 语法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #左外连接 select 字段列表 from table a left join table b on 连接条件 #右外连接 select 字段列表 from table a right join table b on 连接条件 #mysql不直接支持全外连接,可以通过左外连接和右外连接union操作后实现 select 字段列表 from table a left join table b on 连接条件 union select 字段列表 from table a right join table b on 连接条件 自然连接\n描述：从A表和B表中输出在具有相同名字的所有属性上取值相同的元组对，基于两个表中共同属性的值相等的元组进行合并。\n1 2 3 4 #自然连接 select 字段列表 from table a natural join table b on 连接条件 提示\n自然连接和内连接的区别\n若两张表具有同名的属性，自然连接会删除重复的属性而内连接不会删除而是保留重复的属性\n嵌套子查询 子查询：SQL语句中嵌套select语句\n类别\n标量子查询：子查询返回的结果为单个值 列子查询：子查询返回的结果为一列 行子查询：子查询返回的结果为一行 表子查询：子查询返回的结果为多行多列 子查询的位置\nselect后面：标量子查询（作为所需要的一个字段） from后面：表子查询 where/having（作为条件的一部分）：标量子查询/列子查询/行子查询 with子句 with定义了临时关系，只对with子句所在的查询有效 其中as子句内定义临时关系，后面紧跟查询语句 可以使用多个as对应多个临时关系 1 2 3 4 5 6 7 8 9 10 with it department as( select department,AVG(salary) as avg_salary from employees where department =IT group by department ) select e.name,e.salary,it.avg_salary from employees e join it department it on e.department = it.department where e.salary \u0026gt;it.avg_salary; where子句中的子查询 子查询类型\n行子查询：子查询返回的结果为一行 列子查询：子查询返回的结果为一列 检测集合的成员资格（列子查询）\nin连接字检测元组是否是集合中的成员\n1 2 3 4 5 6 7 #查找 2009 年秋季和 2010 年春季提供的课程 select distinct course_id from section where semester = ’Fall’ and year= 2009 and course_id in (select course_id from section where semester = ’Spring’ and year= 2010); not in连接检测元组是否不是集合中的成员\n1 2 3 4 5 6 7 #查找 2009 年秋季提供的课程，但不在2010 年春季提供的课程 select distinct course_id from section where semester = ’Fall’ and year= 2009 and course_id not in (select course_id from section where semester = ’Spring’ and year= 2010); 空关系测试（行子查询）\nexist结构在作为参数的子查询非空时返回true，not exist在作为参数的子查询为空时返回true\n关系A包含关系B可以写为not exists (B except A)\n1 2 3 4 5 6 7 8 9 10 # 查找所有参加过生物系提供的所有课程的学生。 select distinct S.ID, S.name from student as S where not exists ( (select course_id from course where dept_name = ’Biology’) except (select T.course_id from takes as T where S.ID = T.ID)); 测试重复元组（行子查询）\nunique结构：如果作为参数的子查询结果中没有重复的元组，则返回true\n1 2 3 4 5 6 select T.course_id from course as T where not unique (select R.course_id from section as R where T.course_id= R.course_id and R.year = 2009); 集合的比较（列子查询）\nall:指代集合中的每一个元素\n1 2 3 4 5 6 # 查找薪水大于 Biology 系中所有教员薪水的所有教员的姓名。 select name from instructor where salary \u0026gt; all (select salary from instructor where dept_name = ’Biology’); some：指代集合中的其中一个元素\n1 2 3 4 5 6 # 查找薪水高于 Biology 系中某些（至少一名）讲师的讲师的姓名。 select name from instructor where salary \u0026gt; some (select salary from instructor where dept_name = ’Biology’); 视图 描述 ​\t一种虚拟表，它基于 SQL 查询结果创建。视图并不存储数据，而是动态地从基础表中提取数据。这使得视图像一个窗口，可以用来查看和操作表的数据。\n特点 虚拟表： 视图本身不存储数据，它的内容来自于定义视图时的查询语句。 每次访问视图时，都会动态执行查询以生成视图的数据。 逻辑隔离： 视图是基础表的一种逻辑表示，对视图的操作不会直接修改基础表。 安全性： 通过视图，可以限制用户访问表的部分数据，而不是直接授予表的访问权限。 可简化复杂查询： 视图可以封装复杂的 SQL 查询逻辑，从而简化对数据的访问。 创建过程 ​\t视图关系在概念上包含查询结果中的元组， 但并不进行预计算和存储（数据库系统存储视图的定义本身， 而不存储定义该视图的查询表达式的执行结果）。相反， 数据库系统存储与视图关系相关联的查询表达式。 当视图关系被访问时， 其中的元组是通过计算查询结果而被创建出来的。 从而，视图关系是在需要的时候才被创建的。\n在查询中使用视图 ​\t在任何给定时刻， 视图关系中的元组集是该时刻视图定义中的查询表达式的计算结果。当我们定义一个视图时， 数据库系统存储视图的定义本身， 而不存储定义该视图的查询表达式的执行结果。一旦视图关系出现在查询中，它就被已存储的查询表达式代替。因此， 无论我们何时执行这个查询， 视图关系都被重新计算。\n物化视图 定义：创建一个物理表，其中包含定义视图的查询结果中的所有元组\n如果查询中使用的关系已更新，则物化视图结果将过时，因此需要维护视图，通过在底层关系更新时更新视图\n语法 1 2 3 # 创建视图（可以通过其他视图进行创建） create view view_name as \u0026lt;查询表达式\u0026gt; ","date":"2024-11-04T15:07:25+08:00","permalink":"https://Tyritic.github.io/p/mysql%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C/","title":"MySQL表数据查询操作"},{"content":"插入元组 指定字段添加元组\n1 insert into table_name (字段1,子段2,...子段n) values(值1,..值n); 全部字段添加元组\n1 insert into table_name values(值1,值2,...值n); 批量添加指定子段的元组\n1 insert into table_name (子段1,子段2,...子段n) values(值1,...值n),..(值1,...值n); 全部数据批量添加\n1 insert into table_name values(值1,...值n),..(值1,...值n); 更新元组 更新符合指定条件的元组\n1 update table_name set 字段1=值1,..字段n=值n [where condition] 删除元组 删除表中的元组但是不删除表（当不存在条件时为删除所有元组\n1 delete from table_name [where condition] 删除表中的所有元组但是保留表结构（同时按照原来的建表语句重新建立表）\n1 truncate table table_name ","date":"2024-11-04T14:57:14+08:00","permalink":"https://Tyritic.github.io/p/mysql%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/","title":"MySQL表数据操作"},{"content":"创建表结构 代码结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 创建一个新的表 create table table_name( 字段1 字段类型[约束] [comment \u0026#39;关于字段的描述\u0026#39;], ... 字段n 字段类型[约束] [comment \u0026#39;关于字段的描述\u0026#39;] \u0026lt;完整性约束\u0026gt;, ... \u0026lt;完整性约束\u0026gt; )[comment 关于表的描述] #创建与现有的某个表的模式相同的表 create table new_table like old_name #将查询结果保存为一张表,默认插入数据 create table new_table as \u0026lt;查询表达式\u0026gt;; 约束 概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据\n目的：保证数据库中数据的正确性、有效性和完整性。\n常见约束参考\n约束 描述 关键字 非空约束 限制该字段不能为null not null 唯一约束 保证该字段的所有数据都是唯一，不存在重复 unique 主键约束 主键是一个元组的唯一标识，要求非空且唯一 primary key 默认约束 保存数据时要是未指定该字段值则存入默认值 default 谓词约束 保证所有数据都满足条件谓词 check 外键约束 通过外键建立两张表的联系，保证数据的一致性和完整性 foreign key 示例代码\n1 2 3 4 5 6 7 8 9 10 create table student (ID varchar (5) comment[\u0026#39;唯一标识符\u0026#39;], name varchar (20) not null,unique dept_name varchar (20), tot_cred numeric (3,0) check (tot_cred \u0026gt;= 0), age int default 18 #默认约束 primary key (ID), #主键约束 foreign key (dept_name) references department(dept_name) #外键约束 on delete set null) #违反约束的方法：置为null unique(name,age); #多列唯一约束 数据类型 数值类型 类型 大小（byte) 有符号范围 无符号范围 描述 备注 tinyint 1 (-128,127) (0,255) 小整数 smallint 2 (-32768,32767) (0,65535) 大整数 mediumint 3 (-8388608,8388607) (0,1677215) 大整数 int 4 (-2^31 ,2^31-1) (0,2^32-1) 大整数 bigint 8 (-2^63 ,2^63-1) (0,2^64-1) 极大整数 float 4 单精度浮点值 float(5,2)，其中5为数字长度，2为小数位数 double 8 双精度浮点值 double(5,2)，其中5为数字长度，2为小数位数 decimal 小数值（精度最高） 字符类型 类型 大小（byte） 描述 备注 char 0~255 定长字符串 char(10),最多只能存10个字符，不足10个字符也占有10个字符空间 varchar 0~63315 变长字符串 varchar(10),最多只能存10个字符，不足10个字符按实际长度存储 tinyblob 0~255 不超过255个字符的二进制数据 tinytext 0~255 短文本字符串 blob 0~65535 二进制形式长文本数据 text 0~65535 长文本数据 mediumblob 0~16777215 二进制形式中等长文本数据 mediumtext 0~16777215 中等长度文本数据 longblob 0~4294967295 二进制形式的极大文本数据 longtext 0~4294967295 极大文本数据 日期类型 类型 大小（byte） 格式 范围 描述 date 3 YYYY-MM-DD 1000-01-01到 9999-12-31 日期值 time 3 HH:MM:SS -838:59:59 到 838:59:59 时间值或持续时间 year 1 YYYY 1901到2155 年份值 datetime 8 YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00到 9999-12-31 23:59:59 混合日期和时间值 timestamp 4 YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00到 9999-12-31 23:59:59 混合日期和时间值，时间戳 时间域的提取\n1 2 3 extract(unit from date) ## unit为所提取的时间域 ## date为字符串 字符串转时间类型\n1 cast(\u0026#39;2024-12-21\u0026#39; as date) 大对象类型 大对象类型\n字符数据：clob\n二进制数据：blob\n查询表结构 查询当前数据库的所有表\n1 show tables 查询指定表的表结构\n1 desc table_name 查询建表语句\n1 show create table table_name 修改表结构 添加字段\n1 2 alter table table_name add 字段名 字段类型（长度） [comment \u0026#39;关于字段的描述\u0026#39;] [约束]; 修改字段类型\n1 2 alter table table_name modify 字段名 新字段类型（长度）; 修改字段名和字段类型\n1 2 alter table table_name change 旧字段名 新字段名 新类型（长度）[comment \u0026#39;关于字段的描述\u0026#39;] [约束]; 删除字段\n1 2 3 4 5 alter table table_name drop column 字段名; #column可以不填写 alter table table_name drop 字段名; 修改表名\n1 rename table 旧表名 to 新表名; 删除表结构 删除表中所有元组以及表的结构\n1 drop table 表名; ","date":"2024-11-03T18:46:17+08:00","permalink":"https://Tyritic.github.io/p/mysql%E8%A1%A8%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C/","title":"MySQL表结构操作"},{"content":"切换数据库 1 use database_name; 创建数据库 1 create database[if not exists] database_name; 查询数据库 查询所有的数据库\n1 show databases; 查询当前正在使用的数据库\n1 select database(); 删除数据库 1 drop database [if exist] database_name 授权机制 权限类型 数据库各部分的授权形式 Read：允许读取数据，但不允许修改数据。 Insert - 允许插入新数据，但不允许修改现有数据。 Update：允许修改数据，但不允许删除数据。 Delete：允许删除数据。 修改数据库架构的授权形式 Index - 允许创建和删除索引。 Resource - 允许创建新关系。 Alteration - 允许在关系中添加或删除属性。 Drop - 允许删除关系。 用户与角色 用户是指可以连接到数据库并执行操作的实体。每个用户有一个唯一的用户名和密码，通过这些凭证来认证和识别该用户。用户具有访问数据库和执行某些操作的权限。通常情况下，用户是直接与权限绑定的。\n每个用户可以拥有一个或多个权限，这些权限控制用户能在数据库中执行哪些操作（如查询、插入、更新、删除等）。 用户可以是数据库的实际操作实体，如开发人员、管理员、应用程序等。 创建用户\n1 2 3 4 create user \u0026#39;username\u0026#39;@\u0026#39;host\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; # username：用户名 # host：主机名，\u0026#39;%\u0026#39; 代表任何主机 # password：密码 角色是一种逻辑上的权限集合，它允许将多个权限组合在一起并赋予用户。角色是权限的集合，用户可以通过赋予某个角色来间接获得角色所包含的权限。这样，通过角色管理权限比直接授予权限给用户更简洁和灵活，尤其是当多个用户需要相同权限时。\n角色是一个权限集合，可以包含多个权限，用户通过赋予角色来获得这些权限。 角色并不直接与具体的数据库操作实体（如用户）绑定，而是充当权限的管理和分配工具。 创建角色\n1 create role \u0026#39;developer\u0026#39;; 授权规范 授予权限 代码语法\n1 2 3 4 grant \u0026lt;权限列表\u0026gt; #all privileges表示全部权限 on \u0026lt;视图名/关系名\u0026gt; to \u0026lt;角色/用户列表\u0026gt; with grant option #可选表示被授予权限的用户／角色可以把得到的权限再授予给另外的用户／角色 注意事项\n权限的授予者必须已经拥有指定项目的权限（或者是数据库管理员）。 授予对视图的特权并不意味着授予对基础关系的任何特权。 默认情况下， 被授予权限的用户／角色无权把此权限授予其他用户／角色，除非使用with grant option子句 视图的授权\n创建视图的用户不需要获得该视图上的所有权限。他得到的那些权限不会为他提供超越他已有权限的额外授权。例如，如果一个创建视图的用户在用来定义视图的关系上没有update 权限的话，那么他不能得到视图上的update权限。 如果用户创建一个视图， 而此用户在该视图上不能获得任何权限，系统会拒绝这样的视图创建请求 模式的授权\n默认情况：只有模式的拥有者才能够执行对模式的任何修改， 诸如创建或删除关系， 增加或删除关系的属性， 以及增加或删除索引 referrence权限允许用户在创建关系时声明外码，例如你有两个表：orders 和 customers，其中 orders表中的 customer_id列引用了 customers 表中的 id 列作为外键。这时，在创建外键约束时，用户需要拥有对 customers 表的 REFERENCES 权限。 一个用户/角色的权限\n所有直接授予用户／角色的权限。\n所有授予给用户／角色所拥有角色的权限。\n收回权限 代码语法\n1 2 3 revoke \u0026lt;权限列表\u0026gt; on \u0026lt;视图名/关系名\u0026gt; from \u0026lt;角色/用户列表\u0026gt; 注意事项\n若权限列表中包含public,所有用户都将失去该权限，但明确授予该权限的用户除外。 如果不同的授权者两次向同一用户授予相同的权限，则用户在权限撤销后可以保留该权限 所有依赖于被撤销的权限的权限也将被撤销。 收回权限的方式 cascade：级联收回，从一个用户／角色那里收回权限可能导致其他用户／角色也失去该权限 restrict：不需要级联收回 可以收回grant option ","date":"2024-11-03T18:26:36+08:00","permalink":"https://Tyritic.github.io/p/mysql%E5%BA%93%E6%93%8D%E4%BD%9C/","title":"MySQL库操作"},{"content":"MySQL配置使用 启动服务：\n1 net start mysql 停止服务：\n1 net stop mysql 登录MySQL\n1 mysql -u[用户名] -p[密码] [-h 数据库服务器IP -p 端口号] 退出MySQL\n1 exit MySQL数据模型 关系型数据库(RDBMS)：建立在关系模型基础上，由多张相互连接的二维表组成的数据库\n特点\n使用表存储数据，格式统一，便于维护 使用SQL语言操作，标准统一，使用方便，可用于复杂查询 SQL简介 SQL：一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准。\n通用语法 SOL语句可以单行或多行书写，以分号结尾。 SOL语句可以使用空格/缩进来增强语句的可读性。 MySQL数据库的SQL语句不区分大小写。 注释 单行注释：\u0026ndash;注释内容或者#注释内容 （MySQL特有） 多行注释：/* 注释内容 */ 分类 分类 全称 说明 DDL Data Definition Language 数据定义语言，用来定义数据库对象(数据库，表，字段) DML Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改 DQL Data Query Lanquage 数据查询语言，用来查询数据库中表的记录 DCL Data Control Language 数据控制语言，用来创建数据库用户、控制数据库的访问权限 ","date":"2024-11-03T17:02:26+08:00","permalink":"https://Tyritic.github.io/p/mysql%E7%AE%80%E4%BB%8B/","title":"MySQL简介"},{"content":"IOC容器 概念定义 IOC 容器是 Spring 框架的核心部分，负责管理应用程序中的对象生命周期和依赖注入。\n容器接口 BeanFactory 接口是 IOC 的底层容器 。负责管理和配置应用中的 Bean。主要负责配置、创建和管理 bean，为 Spring 提供了基本的依赖注入（DI）支持。\nApplicationContext 是 BeanFactory 的子接口，在 BeanFactory 的基础上添加了企业级的功能支持。\n核心容器 BeanFactory 国际化 MessageSource 资源获取 ResourceLoader 环境信息 EnvironmentCapable 事件发布 ApplicationEventPublisher 其中 ApplicationContext 具有以下实现类\nClassPathXmlApplicationContext ：通过读取类路径（resources）下的 XML格式的配置文件创建IOC容器对象 FileSystemXmlApplicationContext ：通过文件系统路径读取 XML 格式的配置文件创建IOC 容器对象 AnnotationConfigApplicationContext ：通过读取 Java 配置类创建 IOC 容腊对象 WebApplicationContext ：专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 城中。 容器获取\n根据name获取bean: Object getBean(String name) 根据类型获取bean：\u0026lt;T\u0026gt;T getBean(class\u0026lt;T\u0026gt; requiredType) 根据name获取bean(带类型转换)：\u0026lt;T\u0026gt;T getBean(String name,Class\u0026lt;T\u0026gt;requiredType) 启动过程 启动 配置加载 ：加载配置文件或配置类，IoC 容器首先需要加载应用程序的配置信息，这些配置信息可以是 XML 配置文件、Java 配置类或注解配置等方式。 创建容器 ：Spring 创建 IOC 容器（BeanFactory 、 ApplicationContext），准备加载和管理 Bean。 Bean 定义注册 解析和注册 ：BeanDefinitionReader 读取解析配置中的 Bean 定义，并将其注册到容器中，形成 BeanDefinition 对象。 实例化和依赖注入 实例化 ：根据 BeanDefinition 创建 Bean 的实例。 依赖注入 ：根据 BeanDefinition 中的依赖关系，可以通过构造函数注入、Setter 注入或字段注入，将依赖注入到 Bean 中。 初始化 BeanPostProcessor 处理：这些处理器会在 Bean 初始化生命周期中加入定义的处理逻辑 Aware 接口调用 ：如果 Bean 实现了 Aware 接口（如 BeanNameAware、BeanFactoryAware），Spring 会回调这些接口，传递容器相关信息。 初始化方法调用 ：调用 Bean 的初始化方法（如通过 @PostConstruct 注解标注的方法，或实现 InitializingBean 接口的 bean 会被调用 afterPropertiesSet 方法） Bean对象 概念定义 任何通过 Spring 容器实例化、组装和管理的 Java 对象都可以被称为 Spring Bean。Bean 可以在 Spring 容器中被定义并且通过依赖注入来与其他 Bean 进行互相依赖。\n即 Bean 可以看作是 Spring 应用中的一个对象，它的生命周期（创建、初始化、使用、销毁等过程）完全由 Spring 容器管理。\n生命周期 过程定义 实例化：当 Spring 容器启动时，根据配置文件或注解，Spring 会首先实例化 Bean。\nSpring 容器根据 Bean 的定义创建 Bean 的实例，相当于执行构造方法，也就是 new 一个对象。 依赖注入：在实例化之后，Spring 容器会通过构造器、setter 方法或注解将其他 Bean 的依赖注入进来。\n相当于执行 setter 方法为字段赋值。 初始化：如果 Bean 实现了 InitializingBean 接口或者使用了 @PostConstruct 注解，Spring 会在依赖注入完成后调用相应的初始化方法。\n初始化阶段允许执行自定义的逻辑，比如设置某些必要的属性值、开启资源、执行预加载操作等，以确保 Bean 在使用之前是完全配置好的。 销毁：如果 Bean 实现了 DisposableBean 接口或使用了 @PreDestroy 注解，Spring 会在容器关闭时调用销毁方法。\n相当于执行 = null，释放资源。 生命周期的拓展 @PostConstruct 注解用于标识某个方法是 Bean 初始化后的回调方法。当 Spring 完成对 Bean 的依赖注入之后，它会自动调用带有 @PostConstruct 注解的方法。 使用场景 依赖注入后做额外的初始化工作：例如，某个服务需要在依赖注入后连接外部系统。 进行状态检查：在 Bean 初始化后验证某些关键属性是否正确配置。 执行时机 @PostConstruct 方法在依赖注入完成后立即执行，但在 Bean 可以被其他对象使用之前调用（即在 Bean 完成初始化前调用，Bean 处于准备状态）。 @PreDestroy 注解用于标识当 Bean 被销毁时应该调用的方法。这个方法通常用于释放资源、关闭连接或者其他清理操作。Spring 容器在关闭时，会自动调用这些方法来进行资源的释放。 使用场景 资源清理：例如关闭数据库连接、文件句柄、线程池等。 会话管理：例如在 Web 应用中，清理用户会话或缓存。 执行时机： @PreDestroy 方法在 Bean 即将被销毁时调用，一般是在 Spring 容器关闭时执行。对于单例（singleton）作用域的 Bean，会在容器关闭时调用；对于原型（prototype）作用域的 Bean，不会调用销毁方法，因为容器不管理其生命周期。 BeanPostProcessor接口： 通过实现 BeanPostProcessor 接口，开发者可以在 Bean 初始化前后添加自定义逻辑，如动态代理、AOP 增强等。 BeanFactoryPostProcessor接口： BeanFactoryPostProcessor 允许开发者在 Bean 实例化之前，修改 Bean 的定义信息（如属性值），它在所有 Bean 实例化之前执行。 Aware 接口： Spring 提供了多个 Aware 接口，如 BeanNameAware、BeanFactoryAware、ApplicationContextAware 等，允许 Bean 获取 Spring 容器的相关信息，进一步定制生命周期。 声明方式 基于xml配置文件 早期的 Spring 应用通常通过 XML 文件定义 Bean，使用 \u0026lt;bean\u0026gt; 标签来指定类、构造器参数和依赖关系。\n具体实现步骤\n编写配置文件（元数据） 示例化IOC容器 获取Bean对象 基于注解定义Bean对象 注解 说明 位置 @Component 声明Bean对象的基本注解 不属于以下三类时使用该注解 @Service @Component的衍生注解，用于标识业务逻辑层的类。它具有明确的语义，表明该类承担业务操作 标注在ServiceImpl类上 @Controller @Component的衍生注解，用于处理 HTTP 请求，并将结果返回给客户端。 标注在Controller类上 @Repository @Component的衍生注解，用于数据访问层（DAO）的类，与数据库交互。 标注在数据访问类上（现在有mybatis，使用频率少） 示例\n1 2 3 @Component public class UserService { } 注意事项\n声明bean的时候，可以通过value属性指定bean的名字，如果没有指定，默认为类名首字母小写 使用以上四个注解都可以声明bean，但是在springboot集成web开发中，声明控制器bean只能用 @Controller 具体实现步骤\n在组件中添加对应注解 指定组件扫描范围 Spring：修改xml配置文件 SpringBoot：默认扫描的范围是启动类所在包及其子包。@ComponentScan 注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解 @SpringBootApplication 中 从IOC容器中获取容器 提示\n@Bean 和 @Component 的区别\n@Bean 注解通常用于 Java 配置类的方法上，以声明一个 Bean 并将其添加到 Spring 容器中，用于显示声明。 使用场景：用于配置第三方库或复杂对象 控制权限：@Bean 注解允许开发人员手动控制Bean的创建和配置过程 @Component 注解用于类级别，将该类标记为 Spring 容器中的一个组件，自动检测并注册为 Bean（需要扫对应的包），用于自动扫描和注入。 使用场景：用于自动发现并注册自定义类 控制权限：@Component 注解修饰的类是出Spring框架来创建和初始化的 基于配置类定义Bean对象 可以使用Java配置类来代替xml文件对Bean对象进行配置。\n@Configuration 用于修饰一个类，指示某个Java类是配置类\n@Bean 用于修饰一个方法，标识该方法的返回值是一个Bean对象\n创建Bean类 创建对应的Java配置类，并使用 @Configuration 进行修饰，并在配置类中定义一个返回值为Bean对象的方法，这个方法用 @Bean 修饰 从IOC容器中获取Bean对象 示例代码\n1 2 3 4 5 6 @Configuration public class commonconfig{ @Bean //将方法返回值交给I0C容器管理,成为IOC容器的bean对象 public SAXReader saxReader(){ return new SAXReader(); } 提示\n通过 @Bean 注解的name或value属性可以声明bean的名称，如果不指定，默认bean的名称就是方法名 如果第三方bean需要依赖其它bean对象，直接在bean定义方法中设置形参即可，容器会根据类型自动装配。 作用域 五大作用域 Spring支持五种作用域，后三种在web环境才生效\n作用域 说明 singleton 容器内同名称 的 bean 只有一个实例(单例)(默认) prototype 每次使用该 bean 时会创建新的实例(非单例) request 每个请求范围内会创建新的实例(web环境中) session 每个会话范围内会创建新的实例(web环境中) application 每个应用范围内会创建新的实例(web环境中) 使用 @Scope 注解来指定作用域\n1 2 3 4 5 @Scope(\u0026#34;prototype\u0026#34;) @RestController @RequestMapping(\u0026#34;/depts\u0026#34;) public class DeptController { } 警告\n注意事项\nsingleton 的bean，在容器启动时被创建，可以使用 @Lazy 注解来延迟初始化(延迟到第一次使用时) prototype 的bean，每一次使用该bean的时候都会创建一个新的实例。 实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性。 Spring 中的 Bean 默认都是单例的。 作用域对生命周期的影响 Spring 只帮我们管理单例模式 Bean 的完整生命周期，对于 prototype 的 Bean，Spring 在创建好交给使用者之后，则不会再管理后续的生命周期。\n线程安全问题 prototype 作用域下，每次获取都会创建一个新的 bean 实例，不存在资源竞争问题，所以不存在线程安全问题。\nsingleton 作用域下，IoC 容器中只有唯一的 bean 实例，可能会存在资源竞争问题（取决于 Bean 是否有状态）。在多线程环境中，如果 Bean 中包含全局可变状态（如实例变量或非线程安全资源），则可能会引发线程安全问题。\n区分要素 在 Spring 中，id 和 name 用于唯一标识 Bean，确保在 IOC 容器 中可以正确获取 Bean。\n属性 作用 定义方式 唯一性 id Bean 的唯一标识符 只能是 一个 必须唯一 name Bean 的别名，可有多个 允许 多个别名 可以重复 Spring 默认以类名（首字母小写） 作为Bean的 name\n默认情况下，id 属性和 name 属性的值是相同的。如果只配置了 id 属性而没有配置 name 属性，则 name 属性默认与 id 属性相同。\n提示\n使用xml文件配置时，同一个xml配置文件中不允许存在多个相同的id，在多个xml配置文件中允许存在多个相关id，但是\n在同一个配置类文件中，如果存在多个 id 相同的Bean对象，容器内只会注册第一个Bean对象\n什么是控制反转（IOC) IOC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。\nIOC容器作为中间位置“第三方”，也就是，使得A、B、C、D这四个对象没有了耦合关系，齿轮之间的传动全部依靠IOC容器，全部对象的控制权上交给IOC容器，所以IOC容器成了整个系统的关键核心，它起到一个“粘合剂”的作用，把系统中所有对象粘合在一起发挥作用。\n控制 ：指的是对象创建（实例化、管理）的权力 反转 ：控制权交给外部环境（IoC 容器） IOC理论推导 反转之前 写一个UserDao接口 1 2 3 public interface UserDao { public void getUser(); } 再去写Dao的实现类 1 2 3 4 5 6 public class UserDaoImpl implements UserDao { @Override public void getUser() { System.out.println(\u0026#34;获取用户数据\u0026#34;); } } 然后去写UserService的接口 1 2 3 public interface UserService { public void getUser(); } 最后写Service的实现类 1 2 3 4 5 6 7 8 public class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoImpl(); @Override public void getUser() { userDao.getUser(); } } 测试 1 2 3 4 5 @Test public void test(){ UserService service = new UserServiceImpl(); service.getUser(); } 假如把Userdao的实现类增加一个\n1 2 3 4 5 6 public class UserDaoMySqlImpl implements UserDao { @Override public void getUser() { System.out.println(\u0026#34;MySql获取用户数据\u0026#34;); } } 就要同时修改UserService的实现类\n1 2 3 4 5 6 7 8 public class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoMySqlImpl(); @Override public void getUser() { userDao.getUser(); } } 反转后 1 2 3 4 5 6 7 8 9 10 11 12 public class UserServiceImpl implements UserService { private UserDao userDao; // 利用set实现 public void setUserDao(UserDao userDao) { this.userDao = userDao; } @Override public void getUser() { userDao.getUser(); } } 利用 set 替换 userDao的类型\nIOC的关键点 谁控制谁： 传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象； 而IOC是有专门一个容器来创建这些对象，即由IOC容器来控制对象的创建； 控制了什么 那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 什么是反转： 传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转 而反转则是由容器来帮忙创建及注入依赖对象 为什么是反转：因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象。 哪些方面反转了：依赖对象的获取被反转了。 IOC的优点 松耦合 ：在对象之间添加了中间层，统一管理对象，对象之间不再直接耦合 提高可维护性 ：由于 对象的创建和管理 由 Spring IOC 容器 负责，开发者无需关心对象的创建和生命周期，可以专注于业务逻辑。 IOC的设计要点 Bean的生命周期管理：需要设计Bean的创建、初始化、销毁等生命周期管理机制，可以考虑使用工厂模式和单例模式来实现。 依赖注入：需要实现依赖注入的功能，包括属性注入、构造函数注入、方法注入等，可以考虑使用反射机制和XML配置文件来实现。 Bean的作用域：需要支持多种Bean作用域，比如单例、原型、会话、请求等，可以考虑使用Map来存储不同作用域的Bean实例。 AOP功能的支持：需要支持AOP功能，可以考虑使用动态代理机制和切面编程来实现。 异常处理：需要考虑异常处理机制，包括Bean创建异常、依赖注入异常等，可以考虑使用try-catch机制来处理异常。 配置文件加载：需要支持从不同的配置文件中加载Bean的相关信息，可以考虑使用XML、注解或者Java配置类来实现。 IOC的过程 所有的类都会在IOC容器中登记，告诉spring你是个什么对象，你需要什么对象， 然后spring会在系统运行到适当的时候，把对象要的东西主动给对象，同时也把这个对象交给其他需要这个对象的对象。 所有的类的创建、销毁都由spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。 对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。 依赖注入（DI） 定义 DI（Dependency Injection，依赖注入）是 Spring 框架中用于实现控制反转（IOC） 的一种机制。DI 的核心思想是由容器负责对象的依赖注入，而不是由对象自行创建或查找依赖对象。\n通过 DI，Spring 容器在创建一个对象时，会自动将这个对象的依赖注入进去，这样可以让对象与其依赖的对象解耦，提升系统的灵活性和可维护性。\n关键点 谁依赖于谁：应用程序依赖于IOC容器； 为什么需要依赖：应用程序需要IOC容器来提供对象需要的外部资源 谁注入谁：IOC容器注入应用程序依赖的对象 注入了什么：注入某个对象所需要的外部资源（包括对象、资源、常量数据） 注入方式 构造方法注入 具体实现：在构造方法中初始化Bean对象。如果类中存在无参构造方法则需要使用 @Autowired 修饰有参构造方法来告知spring使用哪个构造方法来创建对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Controller public class UserController { private UserService userService; public UserController(){} @Autowired public UserController(UserService userService){ this.userService =userService; } public void sayHi(){ System.out.println(\u0026#34;Hi, userController...\u0026#34;); userService.sayHi(); } } 优点\n可以注⼊ final 修饰的属性\n注⼊的对象不会被修改\n依赖对象在使⽤前⼀定会被完全初始化，因为依赖是在类的构造⽅法中执⾏的，⽽构造⽅法是在类加载阶段就会执⾏的⽅法.\n通⽤性好,构造⽅法是JDK⽀持的,所以更换任何框架,他都是适⽤的\n缺点: 注⼊多个对象时,代码会⽐较繁琐\n字段注入(不推荐) 具体实现：使用 @Autowired 注解修饰要注入的对象\n1 2 @Autowired userMapper mapper; 不推荐的理由\n不能像构造方法那样使用 final 注入不可变对象 隐藏了依赖关系，调用者可以看到构造方法注入或者 setter 注入，但无法看到私有字段的注入 setter方法注入 具体实现：在设置set⽅法的时候需要加上 @Autowired 注解\n1 2 3 4 5 6 7 8 9 10 11 12 @Controller public class UserController { private UserService userService; @Autowired public void setUserService(UserService userService){ this.userService =userService; } public void sayHi(){ System.out.println(\u0026#34;Hi, userController..\u0026#34;); userService.sayHi(); } } 优点: ⽅便在类实例之后,重新对该对象进⾏配置或者注⼊ 缺点: 不能注⼊⼀个Final修饰的属性 注⼊对象可能会被改变,因为setter⽅法可能会被多次调⽤,就有被修改的⻛险. 依赖注入的相关注解 @Autowired @Autowired 是 Spring 框架 提供的 依赖注入（DI） 注解，作用是 自动装配（自动注入）Bean。它可以用于 构造方法、Setter 方法、字段（属性），让 Spring 自动找到合适的 Bean 并注入。\n默认按照类型（byType）注入\n提示\nBean对象的默认名称是类名首字母小写\n存在的问题\n当同⼀类型存在多个bean时（一个接口存在多个Bean实现类）,在使⽤ @Autowired 就会存在问题，因为这个时候 Spring 会根据类型同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。\n解决方案\n注解 @Qualifier和 @Autowired 配合使用，@Qualifier 用于在依赖注入时消除歧义。当一个类型有多个实现时，@Qualifier 注解通过 value 属性可以指定需要注入哪一个具体的 Bean。\n1 2 3 4 5 6 @Component public class UserService { @Autowired @Qualifier(\u0026#34;orderServiceA\u0026#34;) // 指定使用 orderServiceA private OrderService orderService; } 在Bean对象的定义时使用 @Primary 注解，用于标记当存在多个候选 Bean 时，注入的优先级\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import org.springframework.context.annotation.Primary; import org.springframework.stereotype.Component; public interface MyService { void performAction(); } @Component @Primary public class MyServiceImpl1 implements MyService { @Override public void performAction() { System.out.println(\u0026#34;1\u0026#34;); } } @Component public class MyServiceImpl2 implements MyService { @Override public void performAction() { System.out.println(\u0026#34;2\u0026#34;); } } // 使用 @ Primary 注解后，此时会优先注入 MyServiceImpl1。 让bean对象名称与属性名相匹配：当同⼀类型存在多个bean时（一个接口存在多个Bean实现类）, @Autowired 会转为注入方式会变为 byName（根据名称进行匹配）\n@Resource @Resource 属于 JDK 提供的注解，默认注入方式为 byName。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为byType。\n@Resource 有两个常用的属性：name（名称）、type（类型）。\n如果仅指定 name 属性则注入方式为byName，如果仅指定 type 属性则注入方式为byType，如果同时指定name 和type属性（不建议这么做）则注入方式为byType+byName。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Component public class Usercomponent { @Bean({\u0026#34;u1\u0026#34;, \u0026#34;u2\u0026#34;}) public UserInfo userInfo(){ return new UserInfo(1,\u0026#34;张三\u0026#34;); @Bean public UserInfo userInfo2(){ return new UserInfo( 2,\u0026#34;李四\u0026#34;); } } @Controller public class Usercontroller { @Resource(name =\u0026#34;u1\u0026#34;) private UserInfo userInfo; public void sayHi(){ System.out.println(\u0026#34;Hi,userController...\u0026#34;); System.out.println(userInfo); } } 提示\n@Autowired 和 @Resource 的区别\n@Autowired 是spring框架提供的注解，⽽ @Resource 是JDK提供的注解 @Autowired 默认是按照类型注⼊，⽽ @Resource 是按照名称注⼊.相⽐于 @Autowired 来说，@Resource ⽀持更多的参数设置 循环依赖问题 问题定义 循环依赖（Circular Dependency）是指两个或多个模块、类、组件之间相互依赖，形成一个闭环。简而言之，模块A依赖于模块B，而模块B又依赖于模块A，这会导致依赖链的循环，无法确定加载或初始化的顺序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Service public class A { @Autowired private B b; } @Service public class B { @Autowired private A a; } //或者自己依赖自己 @Service public class A { @Autowired private A a; } 解决方案 在 Spring 中，只有同时满足以下两点才能解决循环依赖的问题：\n依赖的 Bean 必须都是单例 依赖注入的方式，必须 不全是 构造器注入，且 beanName 字母序在前的不能是构造器注入 如果全是构造器注入，比如A(B b)，那表明在 new 的时候，就需要得到 B，此时需要 new B ，但是 B 也是要在构造的时候注入 A ，即B(A a)，这时候 B 需要找到不完整的 A ，但是找不到。因为 A 还没 new 完呢，所以找不到完整的 A 关键就是 提前暴露未完全创建完毕的 Bean 。\n在 Spring 中主要是使用 三级缓存 来解决了循环依赖：\n一级缓存（Singleton Objects Map）: 用于存储完全初始化完成的单例Bean。 二级缓存（Early Singleton Objects Map）: 用于存储尚未完全初始化，但已实例化的Bean，用于提前暴露对象，避免循环依赖问题。 三级缓存（Singleton Factories Map）: 用于存储对象工厂，当需要时，可以通过工厂创建早期Bean（特别是为了支持AOP代理对象的创建）。 工作流程：\nSpring 首先创建 Bean 实例，并将其加入三级缓存中（Factory）。 当一个 Bean 依赖另一个未初始化的 Bean 时，Spring 会从三级缓存中获取 Bean 的工厂，并生成该 Bean 的代理对象。 代理对象存入二级缓存，同时删除三级缓存中的对象，解决循环依赖。 一旦所有依赖 Bean 被完全初始化，Bean 将转移到一级缓存中。 三级缓存的必要性 Spring 之所以需要 三级缓存 而不是简单的二级缓存，主要原因在于 AOP代理 和 Bean的早期引用问题 。\n二级缓存虽然可以解决循环依赖的问题，但在涉及到 动态代理（AOP） 时，直接使用二级缓存不做任何处理会导致 拿到的 Bean 是未代理的原始对象 。如果二级缓存内存放的都是代理对象，则违反了 Bean 的生命周期。\n第二层缓存的作用 如果没有二级缓存，Spring 无法在未完成初始化的情况下暴露 Bean。会导致代理 Bean 的循环依赖问题，因为某些代理逻辑无法在三级缓存中提前暴露。最终可能抛出 BeanCurrentlyInCreationException。\n","date":"2024-11-03T15:06:44+08:00","permalink":"https://Tyritic.github.io/p/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACioc%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5di/","title":"控制反转（IOC)和依赖注入（DI）"},{"content":"String类型是不可变的 不可变的实现方式 String类本身被 final 修饰表示该类不允许被继承 从JDK1.9开始String类底层已经不再使用 char[] 存储而是使用 byte[] 加上并一个字段 coder 来指示编码方式，同时这个 byte[] 数组被 private final 修饰，保证初始化后不再被更改 不可变性的体现 当对字符串重新赋值的时候，需要重新指定内存区域赋值，不能使用原来的内存区域 String 类是线程安全的 当对现有字符串进行修改的时候，需要重新指定内存区域赋值，不能使用原来的内存区域 String的底层实现 在 JDK 9 之前，String 类是基于 char[] 实现的，内部采用 UTF-16 编码，每个字符占用两个字节。但是，如果当前的字符仅需一个字节的空间，这就造成了浪费。例如一些 Latin-1 字符用一个字节即可表示。 JDK 9 做了优化采用 byte[] 数组来实现，ASCII 字符串（单字节字符）通过 byte[] 存储，仅需 1 字节，减小了内存占用。并引入了 coder 变量来标识编码方式（Latin-1 或 UTF-16）。如果字符串中只包含 Latin-1 范围内的字符（如 ASCII），则使用单字节编码，否则使用 UTF-16。这种机制在保持兼容性的同时，又减少了内存占用。 String对象的创建方式 通过构造函数创建（new+构造器） 构造函数 public String() ：创建空白字符串 public String(String input) ：根据输入字符串input创建字符串 public String(char[] input) ：根据输入**char** 数组 input 创建字符串 public String(byte[] input) ：根据输入 byte 数组 input 创建字符串 底层实现 使用构造函数创建 String 对象的时候，先在堆区中创建一个新的 String 对象（引用常量池中的字面量），同时在字符串常量池中保存其字面量，在栈中保存字符串对象的引用。若常量池中存在相同的字面值则只会在堆区中创建新的 String 对象\n参考补充材料\n在堆区中创建一个新的 String 对象 若常量池中不存在所需的字面量则在常量池中创建新的字面量并将堆区中的对象指向常量池中的字面量 若存在则将堆区中的对象指向常量池中的字面量 通过字面量创建 语法格式 1 String s=\u0026#34;abc\u0026#34; 底层实现 使用字面量创建 String 对象的时候，会将在常量池中创建字面量。而不会在堆区创建String对象。若使用了相同的字面值则直接复用常量池中的字面量\nJVM检查该字符串的字面是否存在于常量池中 若不存在则在常量池中创建新的字面量 若存在则复用常量池中的字面量 两者创建方式的比较 使用字面量创建 String 对象不会在堆区创建对象 使用构造函数创建 String 对象会在堆区创建对象 示例比较 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class StringExercise01 { public static void main(String[] args) { //字面量创建对象 String s1 = \u0026#34;abc\u0026#34;; String s2 = \u0026#34;abc\u0026#34;; //通过new+构造器的方式: 此时s3,s4保存的地址值，是数据在堆空间中开辟以后对应的地址值 String s3 = new String(\u0026#34;abc\u0026#34;); String s4 = new String(\u0026#34;abc\u0026#34;); //s1 首先看常量池有没有abc //s2 首先看常量池有没有abc 有，就将b直接指向abc //所以地址值是一样的 System.out.println(s1==s2);//true //s1在常量池中，s3和s4在堆区中，指向地址不同 System.out.println(s1==s3);//false System.out.println(s1==s4);//false //s3和s4在堆区中，但是两个对象指向地址不同 System.out.println(s3==s4);//false } } String对象的拼接操作 常量与常量的拼接结果在常量池，且常量池中不会存在相同内容的常量 只要其中有一个结果是变量，结果就在堆中 如果拼接的结果调用 intern() 方法，返回值就在常量池中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 String s1 = \u0026#34;Java\u0026#34;; String s2 = \u0026#34;Android\u0026#34;; String ss =\u0026#34;JavaAndroid\u0026#34;; String s3 = \u0026#34;Java\u0026#34;+\u0026#34;Android\u0026#34;; String s4 = s1 + \u0026#34;Android\u0026#34;; String s5 = \u0026#34;Java\u0026#34; + s2; String s6 = s1 + s2; System.out.println(ss==s3);//true System.out.println(ss==s4); //false System.out.println(ss==s5);//false System.out.println(ss==s6);//false System.out.println(s4==s5);//false String s7=s4.intern(); System.out.println(ss==s7);//true String的常见操作 字符串查找 查找字符串中的字符 charAt(int index) 方法：用于返回字符串指定位置的字符，返回值为 char 类型，参数为 int 类型\n1 2 3 4 String str = new String(\u0026#34;Hello World\u0026#34;); for (int i = 0; i \u0026lt; str.length(); i++) { System.out.println(\u0026#34;下标为\u0026#34; + i + \u0026#34;的元素为：\u0026#34; + str.charAt(i));//打印的是每个字母 } 查找字符串中下标 int indexOf(int ch)\t用于返回当前字符串中参数 ch 指定的字符第一次出现的下标 int indexOf(int ch, int fromIndex)\t用于从 fromIndex(包含) 位置开始查找ch指定的字符 int indexOf(String str)\t在字符串中检索 str 返回其第一次出现的位置，若找不到返回-1 int indexOf(String str, int fromIndex)\t表示从字符串的 fromIndex(包含) 位置开始检索str第一次出现的位置 int lastIndexOf(int ch)\t用于返回参数 ch 指定的字符最后一次出现的下标 int lastIndexOf(int ch, int fromIndex)\t用于从 fromIndex(包含) 位置开始反向查找 ch 指定字符出现的下标，若找不到返回-1 int lastIndexOf(String str)\t返回 str 指定字符串最后一次出现的下标 int lastIndexOf(String str, int fromIndex)\t用于从 fromIndex(包含) 位置开始反向搜索的第一次出现的下标 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 String str = \u0026#34;Good Good Study, Day Day Up!\u0026#34;; System.out.println(str.indexOf(\u0026#39;g\u0026#39;)); // -1 代表查找失败 System.out.println(str.indexOf(\u0026#39;G\u0026#39;)); // 0 该字符第一次出现的索引位置 System.out.println(str.indexOf(\u0026#39;G\u0026#39;, 0)); // 0 System.out.println(str.indexOf(\u0026#39;G\u0026#39;, 1)); // 5 // 查找字符串 System.out.println(str.indexOf(\u0026#34;day\u0026#34;)); // -1 System.out.println(str.indexOf(\u0026#34;Day\u0026#34;)); // 17 字符串中第一个字符的下标 System.out.println(str.indexOf(\u0026#34;Day\u0026#34;, 17)); // 17 字符串中第一个字符的下标 System.out.println(str.indexOf(\u0026#34;Day\u0026#34;, 18)); // 21 字符串中第一个字符的下标 // 字符串内容的反向查找 System.out.println(str.lastIndexOf(\u0026#34;Day\u0026#34;)); // 21 System.out.println(str.lastIndexOf(\u0026#34;Day\u0026#34;, 21)); // 21 System.out.println(str.lastIndexOf(\u0026#34;Day\u0026#34;, 20)); // 17 System.out.println(str.lastIndexOf(\u0026#34;Day\u0026#34;, 15)); // -1 字符串截取 substring(int beginIndex, int endIndex) 方法：返回字符串中从下标 beginIndex(包括) 开始到 endIndex(不包括) 结束的子字符串，返回值为 String 类型，参数为 int 类型 substring(int beginIndex) 方法：返回字符串中从下标 beginIndex(包括) 开始到字符串结尾的子字符串，返回值为 String 类型，参数为 int 类型 字符串比较 判定是否相等 equals(Object anObject) 方法：比较字符串内容是否相等并返回，返回值为 boolean 类型 equalsIgnoreCase(String anotherString) 方法：比较字符串内容是否相等并返回，返回值为 boolean 类型，不考虑大小写， 如：\u0026lsquo;A’和’a’是相等 比较大小 compareTo(String anotherString) 方法：比较调用对象和参数对象的大小关系，返回值为 int 类型 compareToIgnoreCase(String str) 方法：比较调用对象和参数对象的大小关系，返回值为 int 类型，不考虑大小写，也就是’a’和’A’是相等的关系 比较方法\n方法调用者的字符依次与方法参数的字符作比较，即用 A 的 ASCII码减去 B 的ASCII码；结果有三种：负整数、正整数、零。负整数即按字典顺序 A 在 B 之前，正整数即 A 在 B 之后，零则为字符串相等。注意：比较出大小就不往后进行，即从第一个字符串开始比较，相同则比较下一个，直到比较出大小或比较到最后一个字符。\n判定前缀/后缀 startsWith(String prefix) 方法：判断字符串是否以参数字符串开头，返回值为 boolean 类型，参数为 String 类型 startsWith(String prefix, int toffset) 方法：从指定位置开始是否以参数字符串开头，返回值为 boolean 类型，参数 prefix 为 String 类型，toffset 为 int 类型 endsWith(String suffix) 方法：判断字符串是否以参数字符串结尾，返回值为 boolean 类型，参 数为 String 类型 示例代码\n1 2 3 4 5 6 String str = \u0026#34;Give you some color to see see\u0026#34;; System.out.println(str.startsWith(\u0026#34;G\u0026#34;));//true System.out.println(str.startsWith(\u0026#34; \u0026#34;));//false System.out.println(str.startsWith(\u0026#34;you\u0026#34;, 5));//true System.out.println(str.endsWith(\u0026#34; \u0026#34;));//false System.out.println(str.endsWith(\u0026#34;see\u0026#34;));//true 判定子串 contains(CharSequence s) 方法：判断当前字符串是否包含参数指定的内容，返回值为 boolean 类型\n1 2 3 String str = \u0026#34;Give you some color to see see\u0026#34;; System.out.println(str.contains(\u0026#34;some\u0026#34;));//true System.out.println(str.contains(\u0026#34;Some\u0026#34;));//false 字符串替换 replace(char oldChar, char newChar) 方法：使用参数newChar替换此字符串中出现的所有参数oldChar，返回值为 String 类型，参数为 char 类型 replace(CharSequence target, CharSequence replacement) 方法：用新字符串replacement替换所有的旧字符串target，返回值为 String 类型，参数为 CharSequence 接口 字符串拆分 split(String regex) ：根据给定的正则表达式分割此字符串，并返回一个String数组。 split(String regex,int limit) ：根据给定的正则表达式分割此字符串分割成limit组，并返回一个String数组。 字符串与其他类型的相互转换 数字和字符串之间相互转换 数字转字符串：String.valueOf(var var_name) 字符串转数字 Integer.valueOf(String var) Integer.parseInt(String var) 字符串和char数组的相互转换 字符串转字符数组：char[] toCharArray() 方法： 字符串转byte数组 byte[] getBytes()\n","date":"2024-11-03T14:22:08+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84string%E7%B1%BB/","title":"Java中的String类"},{"content":"Scanner类 java.utils包中用于获取输入的类，用于解析基本类型和字符串类型的输入。它可以从控制台、文件、字符串等不同的数据源读取数据，并将其解析为适当的类型。\n基本构造函数 Scanner可以接收控制台的键盘输入（标准输入流），文件和字符串\n从控制台输入读取\n1 Scanner scanner = new Scanner(System.in); 从文件输入读取\n1 2 File file = new File(\u0026#34;input.txt\u0026#34;); Scanner scanner = new Scanner(file); 从字符串中读取\n1 2 String input = \u0026#34;Hello World!\u0026#34;; Scanner scanner = new Scanner(input); 基本用法 读取基本类型 nextInt()：读取int类型 nextShort()：读取short类型 nextLong()：读取long类型 nextFloat()：读取float类型 nextDouble()：读取double类型 读取字符串 next() ：读取下一个字符串，遇到空白符（如空格、制表符、换行符等）停止 nextLine()：读取下一行文本，遇到回车停止 提示\nnext() 和 nextLine() 的区别\nnext()\n一定要读取到有效字符后才可以结束输入。 对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。 只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 next() 不能得到带有空格的字符串。 nextLine()\n以Enter为结束符,也就是说 nextLine() 方法返回的是输入回车之前的所有字符。 可以获得空白。 先使用 nextLine() 再使用 next()、nextInt() 等没问题，但是先使用 next() 和 nextInt() 等之后就不可以再紧跟 nextLine() 使用。\n原因：因为 next() 等这些方法读取结束后会紧跟一个回车符，而 nextLine() 会直接读取到这个回车符，这就导致出现我们还没有来得及输入我们想要输入的数据，nextLine() 就以为我们已经输入完了\n解决方法：我们直接在 next() 使用后加两个 nextLine() 即可了，这样第一个 nextLine() 就会当一个‘替死鬼’读取前一个 next() 遗留的空白符，第二个 nextLine() 就可以输入自己想要输入的数据啦！\n检验输入 hasNext()方法会检查输入中是否还有下一个单词，即是否存在非空白字符。这意味着，只要输入中还有非空白字符，无论是在当前行还是在下一行，hasNext()都会返回true。通常配合 next() 使用 hasNextLine()方法则会检查输入中是否还有下一行。如果输入中存在换行符，或者如果输入中至少还有一个字符（即使这个字符是空白字符），hasNextLine()都会返回true。但是如果输入已经到达结尾，或者输入中的下一个字符是输入流的结尾，hasNextLine()就会返回阻塞。 设置分隔符 Scanner类默认使用空白字符（空格、制表符、换行符等）作为分隔符，但可以自定义分隔符。\ndelimiter()用于查看当前分隔符\nuseDelimiter()方法用于修改分隔符\n示例代码 1 2 3 4 5 6 7 Scanner scanner = new Scanner(System.in); scanner.useDelimiter(\u0026#34;,\u0026#34;); // 使用逗号作为分隔符 System.out.print(\u0026#34;Enter comma-separated values: \u0026#34;); while (scanner.hasNext()) { String value = scanner.next(); System.out.println(\u0026#34;Value: \u0026#34; + value); } 关闭扫描器 使用完Scanner后，一定要记得将它关闭！因为使用Scanner本质上是打开了一个IO流，如果不关闭的话，它将会一直占用系统资源。\nclose()方法\n","date":"2024-11-03T12:09:48+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/","title":"Java中的标准输入操作"},{"content":"Math类的简介 Java在Math类中封装了相关的数学函数，位于Java.lang包中\n构造方法是 private 的，且所有方法都是静态方法，可以不依赖实例进行调用\n静态常量 自然对数$e$：Math.E（double数据类型）\n圆周率$π$：Math.PI（double数据类型）\n三角函数 Math.toRadians()：角度 \u0026ndash;\u0026gt; 弧度 Math.toDegrees()：弧度 \u0026ndash;\u0026gt; 弧度 正切值：Math.sin() 余弦值：Math.cos() 反正弦值：Math.asin() 反余弦值：Math.acos() 正切值：Math.tan() 反正切值：Math.atan() 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* 三角函数 */ // 角度 --\u0026gt; 弧度 toRadians() double x = 45; // 45° 45° --\u0026gt; PI / 4 System.out.println(\u0026#34;45°转换为弧度：\u0026#34; + Math.toRadians(x)); System.out.println(Math.PI / 4); double y = 180; System.out.println(\u0026#34;180°转换为弧度：\u0026#34; + Math.toRadians(y)); System.out.println(Math.PI); // 弧度 --\u0026gt; 弧度 toDegrees() double z = 0.7853981633974483; // PI / 4 --\u0026gt; 45° System.out.println(\u0026#34;0.7853981633974483转换为角度\u0026#34; + Math.toDegrees(z)); // 正弦函数sin() double degrees = 45.0; double radians = Math.toRadians(degrees); System.out.println(\u0026#34;45° 的正弦值: \u0026#34; + Math.sin(radians)); // 余弦函数cos() System.out.println(\u0026#34;45° 的余弦值: \u0026#34; + Math.cos(radians)); // 反正弦值asin() System.out.println(\u0026#34;45° 的反正弦值: \u0026#34; + Math.asin(radians)); // 反余弦值acos() System.out.println(\u0026#34;45° 的反余弦值: \u0026#34; + Math.acos(radians)); // 正切值tan() System.out.println(\u0026#34;45° 的正切值: \u0026#34; + Math.tan(radians)); // 反正切值atan() atan2() double m = 45; double n = 30; System.out.println(\u0026#34;45° 的反正切值1: \u0026#34; + Math.atan(radians)); // atan() System.out.println(\u0026#34;反正弦值2: \u0026#34; + Math.atan2(m, n)); // atan2() 坐标系表示角的反正切值 指数函数 Math.exp()：自然对数e的幂函数 Math.pow()：幂函数 Math.sqrt()：平方根 Math.cbrt()：立方根 Math.log()：ln函数 Math.log 10()：log_10函数 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* 指数函数 */ double p = 8; double q = 3; // exp() System.out.println(\u0026#34;e的6次幂: \u0026#34; + Math.exp(p)); // e^8 // pow() System.out.println(\u0026#34;8的3次幂: \u0026#34; + Math.pow(p, q)); // 8^3 // sqrt() System.out.println(\u0026#34;8的平方根: \u0026#34; + Math.sqrt(p)); // cbrt() System.out.println(\u0026#34;8的立方根: \u0026#34; + Math.cbrt(p)); // 2 // log() System.out.println(\u0026#34;ln(8): \u0026#34; + Math.log(p)); // ln(8) // log10() System.out.println(\u0026#34;log10(8): \u0026#34; + Math.log10(p)); // log10(8) 取整函数 Math.ceil()：上取整 Math.floor()：下取整 Math.rint()：最近的整数，0.5返回0 Math.round()：四舍五入的整数，0.5返回1 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 取整 */ double d = 100.675; double e = 100.500; // \u0026gt;=的整数 ceil() System.out.println(\u0026#34;ceil(100.675): \u0026#34; + Math.ceil(d)); // \u0026lt;=的整数 floor() System.out.println(\u0026#34;floor(100.675): \u0026#34; + Math.floor(d)); // 最近的整数 rint() System.out.println(\u0026#34;rint(100.675): \u0026#34; + Math.rint(d)); System.out.println(\u0026#34;rint(100.500): \u0026#34; + Math.rint(e)); // 四舍五入的整数 round() System.out.println(\u0026#34;round(100.675): \u0026#34; + Math.round(d)); System.out.println(\u0026#34;round(100.500): \u0026#34; + Math.round(e)); 比较函数 Math.min()：最小值 Math.max()：最大值 Math.abs()：绝对值 示例代码\n1 2 3 4 5 6 7 8 9 /* 其他 */ // min() 最小 System.out.println(\u0026#34;min(): \u0026#34; + Math.min(2, 10)); // max() 最大 System.out.println(\u0026#34;max(): \u0026#34; + Math.max(2, 10)); // abs() 绝对值 System.out.println(\u0026#34;abs(): \u0026#34; + Math.abs(-5)); 随机数生成 Math.random()：随机产生一个数 random()，随机数范围为 0.0 =\u0026lt; Math.random \u0026lt; 1.0 a+Math.random()+b生成[a,a+b)的随机数\n","date":"2024-11-03T11:35:06+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E5%AD%A6%E6%93%8D%E4%BD%9C/","title":"Java中的基本数学操作"},{"content":"一维数组的声明与创建 声明数组 1 2 ElementType[] array_name; // 一维数组 ElementType[][] array_name; // 二维数组 创建数组 除非数组被创建否则不能分配任何元素\n1 Array_name=new ElementType[size]; 初始化数组 静态初始化 指定数组内的元素而不指定数组的长度\n1 ElementType array_name={x1,x2,..xn}; 动态初始化 指定数组的长度而不指定数组的元素，系统自动赋默认值\n1 ElementType[]array_name=new ElementType[size]; 获取一维数组长度 1 int length=array_name.length; 访问一维数组元素 通过数组下标访问，数组下标从0开始\n数组元素的默认值 整型：0 浮点型：0.0 布尔：false 字符：’\\u000' 字符串：null 引用数据类型：null 一维数组的处理 遍历数组 不通过数组下标可以完成数组的遍历\n1 2 3 4 for(数据类型 引用名:数组名) { // 循环体 } 复制数组 使用for循环/for-each循环逐一复制元素\n使用system类中的静态方法arraycopy复制数组\n1 2 3 4 System.arraycopy(sourceArray,srcPos,targetArray,tarPos,length); // srcPos：源数组中的起始位置 // tarPos：目标数组的起始位置 // length：决定复制数组的元素个数 提示\n数组的复制不能简单使用赋值号，赋值号只是将引用的地址值赋值，此时两个变量指向同一个数组\n可变长参数列表 可以将类型相同但是数目可变的参数作为方法的形参\n语法形式 1 TypeName... parameterName 示例代码 1 2 3 4 5 6 // 定义一个带有可变参数的方法 public static void printAll(String... strings) { for (String s : strings) { System.out.println(s); } } 注意事项 可变参数必须是方法参数列表中的最后一个参数。 一个方法只能有一个可变参数。 当你调用一个带有可变参数的方法时，你可以直接传入逗号分隔的参数列表，也可以传入一个数组（数组会自动被拆分成单独的参数）。 在调用方法时同时传入了一个数组和一个或多个单独的参数，那么数组必须被明确地作为最后一个参数传入（即它不能被单独的可变参数分隔开） 二维数组的声明和创建 初始化二维数组 静态初始化 1 ElementType[][]array_name=new ElementType[][]{{var1,var2,..varN},{var1,var2,..varN}}; 动态初始化 1 ElementType[][]array_name=new ElementType[m][n]; m表示这个二维数组存放了多少个一维数组 n表示这个一维数组存放多少个元素 二维数组的存储方式 二维数组本质上是一个一维数组，这个一维数组的存储元素是其他一维数组的地址值\n例如\n1 int[][]arr={{11,22},{33,44}}; 其中arr的地址为0x0011\narr的元素为\narr[0]为0x0022（对应arr[0][])\narr[1]为0x0033(对应arr[1][])\n访问二维数组元素 1 array_name[m][n]; m索引指定访问哪个一维数组 n索引指定访问这个一维数组的哪个元素 获取二维数组的长度 对应二维数组array_name[m][n]\n通过array_name.length获取二维数组中包含多少个一维数组 通过array_name[0].length获取一维数组的长度 ","date":"2024-11-03T00:27:14+08:00","permalink":"https://Tyritic.github.io/p/java%E6%95%B0%E7%BB%84/","title":"Java数组"},{"content":"请求响应过程 基本流程 浏览器向SpringBoot项目中内置的Tomcat服务器发送请求 SpringBoot项目中的controller类接收浏览器发出的请求并发送响应 控制器的定义 控制器的种类 @Controller：用于定义一个传统的 Spring MVC 控制器，它处理客户端请求，返回视图名，通常用于返回 HTML 页面。 @RestController：专用于构建 RESTful API 的控制器，等同于 @Controller + @ResponseBody。返回的内容会直接作为 HTTP 响应体，通常用于返回 JSON 或 XML 格式的数据。 提示\n@ResponseBody\n@ResponseBody 注解用于将控制器方法的返回值直接写入 HTTP 响应体中，而不是返回一个视图名称。通常用于返回 JSON 或 XML 格式的数据，适用于 RESTful API。\n使用场景：\n用于返回 JSON、XML 数据，而不是传统的 HTML 页面。 RESTful 风格的接口通常使用该注解返回数据，尤其是在前后端分离的场景中。 路径参数的映射 使用 @RequestMapping 注解映射请求路径：在方法上使用 @RequestMapping 或其衍生注解（如 @GetMapping、@PostMapping 等）来映射 HTTP 请求。\n@GetMapping：专用于处理 GET 请求。 @PostMapping：专用于处理 POST 请求。 @PutMapping：专用于处理 PUT 请求。 @DeleteMapping：专用于处理 DELETE 请求。 具体实现 定义控制器类\n定义Controller：使用 @Controller 注解指定控制器，同时使用 @ResponseBody 修饰控制器方法表示控制器方法的返回值直接写入 HTTP 响应体中，而不是返回一个视图名称。\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Controller public class UserController { @GetMapping(\u0026#34;/users/{id}\u0026#34;) public String getUser(@PathVariable Long id, Model model) { // 调用业务逻辑 User user = userService.getUserById(id); // 添加模型数据 model.addAttribute(\u0026#34;user\u0026#34;, user); // 返回视图名称 return \u0026#34;userProfile\u0026#34;; } } 定义RestController：直接使用 @RestController 指定控制器\n1 2 3 4 5 6 7 8 9 @RestController @RequestMapping(\u0026#34;/api/users\u0026#34;) public class UserController { @GetMapping(\u0026#34;/{id}\u0026#34;) public User getUserById(@PathVariable Long id) { return userService.getUserById(id); // 返回的是 JSON 数据 } } 路径参数的映射：使用 @RequestMapping 注解映射请求路径：在方法上使用 @RequestMapping 或其衍生注解（如 @GetMapping、@PostMapping 等）来映射 HTTP 请求。\n请求参数的接收 简单参数 方法一：设置controller类中的函数形参名和请求的参数名相同 1 2 3 4 5 @RequsetMapping(\u0026#34;/simpleParam\u0026#34;) public String getParam(String param) { return param; } 方法二：参数名和形参名不匹配使用 @RequestParam 注解的name属性将参数名映射到形参 1 2 3 4 5 @RequestMapping(\u0026#34;/simpleParam\u0026#34;) public String getParam(@RequestParam(name=“username\u0026#34;)String param) { return param; } 提示\n@RequestParam\n作用：建立请求参数和controller形参的映射关系\n属性\nvalue/name：请求的参数名 required：参数是否必需。默认为true 实体对象参数 简单实体对象 请求参数与形参对象属性名相同\n1 2 3 4 5 @RequestMapping(\u0026#34;/objectParam\u0026#34;) public User getParam(User user) { return user; } 复杂实体对象（对象的成员变量是对象） 请求参数与形参对象属性名相同，按对象层次关系接收\n数组集合参数 数组参数 请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数\n1 2 3 4 5 @RequestMapping(\u0026#34;/arrayParam\u0026#34;) public User getParam(String[]array) { return array; } 集合参数 请求参数名与形参数组名称相同且请求参数为多个，@RequestParam 绑定参数关系\n1 2 3 4 5 @RequestMapping(\u0026#34;/listParam\u0026#34;) public User getParam(@RequestParam List\u0026lt;String\u0026gt;param) { return param; } 日期参数 使用 @DateTimeFormat 注解完成日期格式转换\n1 2 3 4 5 @RequestMapping(\u0026#34;/dateParam\u0026#34;) public String getParam(@DateTimeFormat(pattern=\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;) LocalDateTime param) { return param.toString(); } 提示\n@DateTimeFormat\npattern属性用于指定时间格式\nJson参数 JSON数据键名与形参对象属性名相同，定义pojo类型形参即可接收参数，需要使用 @RequestBody 标识\n1 2 3 4 5 @RequestMapping(\u0026#34;/jsonParam\u0026#34;) public String getParam(@RequestBody User user) { return user.toString(); } 提示\n@RequestBody\n类型：方法注解，类注解 位置：controller类/方法上 作用：将请求体中的数据直接绑定到控制器方法的参数上，如果返回值类型是 实体对象/集合，将会转换为JSON格式响应 使用场景 处理 RESTful 接口中的 JSON 数据请求。 将客户端提交的复杂数据结构（如 JSON）直接映射为 Java 对象。 路径参数 通过请求URL直接传递参数，使用{..}来标识该路径参数，需要使用 @PathVariable 获取路径参数\n1 2 3 4 5 @RequestMapping(\u0026#34;/path/{id}\u0026#34;) public String getParam(@PathVariable Integer id) { return id; } @PathVariable 是 Spring MVC 中用于从 URI 模板中提取变量值的注解。它的主要作用是在处理 HTTP 请求时，从请求的 URL 路径中捕获变量，并将其绑定到控制器方法的参数上。\n提示\n@PathVariable 和 @RequestParam 都是用于从 HTTP 请求中提取数据的注解，但它们的用法不同：\n@PathVariable：从 URL 路径中提取动态数据，常用于 RESTful URL 模式。URL 中的参数通常是路径的一部分，如 /users/{id}。 @RequestParam：从请求的查询参数中提取数据，通常用于处理表单数据或查询参数。参数在 ? 之后，格式如 /users?id=1。 请求头和Cookie @RequestHeader 注解用于提取 HTTP 请求头中的值，并将其注入到控制器方法的参数中。例如访问 Accept、Content-Type、User-Agent 等请求头信息。\n1 2 3 4 5 @GetMapping(\u0026#34;/header-info\u0026#34;) public String getHeaderInfo(@RequestHeader(\u0026#34;User-Agent\u0026#34;) String userAgent) { // 使用 userAgent 进行业务处理 return \u0026#34;headerInfoView\u0026#34;; } @CookieValue 注解用于从 HTTP 请求的 Cookie 中提取值，并将其注入到控制器方法的参数中。\n1 2 3 4 5 @GetMapping(\u0026#34;/cookie-info\u0026#34;) public String getCookieInfo(@CookieValue(\u0026#34;sessionId\u0026#34;) String sessionId) { // 使用 sessionId 进行业务处理 return \u0026#34;cookieInfoView\u0026#34;; } ","date":"2024-11-03T00:05:27+08:00","permalink":"https://Tyritic.github.io/p/%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/","title":"请求与响应"},{"content":"方法的定义 1 2 3 修饰符 返回值类型 方法名(形参列表){ // 方法体 } 修饰符 访问修饰符 Java 中的访问修饰符用于控制类、字段、方法和构造函数的访问权限。通过使用访问修饰符，可以实现封装，保护数据，并控制不同部分之间的访问范围。\npublic 定义：被 public 修饰的成员可以被外界访问\n作用域：在一个Java源文件（.java文件）中只有一个类被声明为 public ，且这个源文件的文件名要与这个公共类的类名相同\npublic 修饰类成员时可以在所有类中被访问\n在继承中 public 修饰的所有成员都被继承\nprotect 定义：受保护的，受该类所在包保护，只能被同一个包内的类或者不同包的子类访问\n作用域：被 protect 修饰的成员可以被同一个包内的所有类访问，同时也会被该类的所有子类继承\ndefault 定义：只对同一个包中的类友好，只能被同一个包中的类访问\n作用域：同一个包中的所有类可以访问，被 default 修饰的成员只能被同一个包中的子类继承\nprivate 定义：私有的，只能被同一个类中的成员访问\n作用域：同一个类\n表格整理如下\n修饰符 当前类 同一包内 子类（不同包） 其他包 public 是 是 是 是 protected 是 是 是 否 default 是 是 否 否 private 是 否 否 否 访问修饰符的选择动机 public：适用于需要被外部类广泛访问的成员。过多使用 public 可能导致封装性降低。 protected：适用于需要在继承关系中使用的成员。它提供了比 public 更严格的访问控制，但允许子类访问。 default：适用于仅在同一包内使用的类和成员。适当使用可以隐藏实现细节，减少类之间的耦合。 private：适用于内部实现细节，确保类的内部数据和方法不会被外部直接访问。最严格的访问控制，保护类的封装性。 静态修饰符 static 被 static 修饰的成员是静态方法，静态方法属于整个类，非静态方法属于单个对象\n静态方法的生命周期与类一样长，随着类的消亡而消亡\n非静态方法的生命周期与对象一样长，随着对象的消亡而消亡\n方法调用 main 方法作为程序入口先压入栈区 执行 main 方法中的代码，遇到方法后，将该方法压入栈区，执行完毕后出栈 方法重载 方法重载（Overloading） ：在同一个类中，允许有多个同名方法，只要它们的参数列表不同（参数个数、类型或顺序）。主要关注方法的签名变化，适用于在同一类中定义不同场景下的行为。\n判定依据 方法在同一个类中，且具有相同的方法名 具有不同的形参列表（满足以下其中之一即可） 形参个数不同 形参类型不同 形参顺序不同 方法的参数传递 在 Java 中，参数传递只有按值传递，不论是基本类型还是引用类型。\n方法传递基本数据类型 具体的基本数据类型见往期博客\n基本数据类型的特点 基本数据类型在栈空间中存储的是真实的数据字面值，在堆区中不开辟空间\n具体表现 方法中对参数的改变不会影响原始变量的值\n示例代码 1 2 3 4 5 6 7 8 9 10 public static void main(String [] args) { int nums=100; change(nums); //change(100) System.out.println(nums); //nums=100; } public static void change(int nums) { nums=110; } 内存解释 每个方法压入栈区中，都会有独立的栈空间，在该方法的栈空间中传入的实际上是参数值的副本（参数的字面值）来对形参进行初始化，在这个栈区中形参值发生了改变。方法执行完成后出栈，原来栈区中的变量不受影响\n方法传递引用数据类型 除基本数据类型以外的所有数据类型包括数组，字符串，类都是引用数据类型\n特点 引用数据类型在栈空间中存储的是其地址值，在堆区中开辟空间，真实的数据保存在堆区中\n具体表现 方法中对参数的改变会影响原始变量的值\n示例代码 1 2 3 4 5 6 7 8 9 10 public static void main(String [] args) { int[] nums={0,1,2}; change(nums); //change(nums) System.out.println(nums); //nums={0,3,2}; } public static void change(int[] nums) { nums[1]=3; } 内存解释 每个方法压入栈区中，都会有独立的栈空间，在该方法的栈空间中传入的实际上是参数值的副本（参数的地址值）对形参进行初始化。\n在这个栈区中形参和原始变量指向同一块内存区域，对形参的修改会通过引用影响原始变量。\n方法执行完成后出栈，原来栈区中的变量指向的内存区域已经受到影响\n总结 方法参数传递的本质是值传递（引用数据类型的值被视为地址值） 函数调用时在函数作用域创建栈区空间，再使用实参对形参进行初始化（形参作为实参的副本） 基本数据类型：形参改变不影响实参，形参在方法结束后弹出栈区 引用数据类型：形参是地址值，形参地址值的改变不影响实参地址值，此时形参和实参指向同一个地址 特殊的例子String类 具体表现 作为一个单独的数据类型，传递效果与传递基本数据类型相同\n作为对象的成员，传递效果与传递引用数据类型相同\n特点 String 对象一旦创建就不可更改（ String 是不可变类） String 类的所有方法都不会改变 String 的内容 示例代码（作为单独的数据类型） 1 2 3 4 5 6 7 8 public static void main(String[] args) { String s1=new String(\u0026#34;张三\u0026#34;); change(s1); System.out.println(s1); // s1=\u0026#34;张三\u0026#34; } public static void change(String s2){ s2=\u0026#34;李四\u0026#34;; } 解析过程 方法调用前\n首先 String s=new String(\u0026quot;张三\u0026quot;)，在堆中开辟内存放对象，变量 s1 在栈中，存放的是堆的地址 将地址0x11传入change方法复制一份用于初始化s2，此时s2放的是地址0x11 方法调用时\ns2=\u0026quot;李四\u0026quot; ；通过=赋值是直接先去常量池寻找是否存在与“李四”相同的值，有的话直接将其地址返回。否则创建一个值，再返回其地址。这里改变的是s2 ， s2 位于栈中 方法调用后\ns1和s2最终存储的地址不同\n示例代码（作为类的成员变量） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Person { String name; public Person(String name){ this.name=name; } } public static void main(String[] args) { Person p1 = new Person(\u0026#34;张三\u0026#34;); change(p1); System.out.println(p1.name); // 李四 } public static void change(Person p2){ p2.name=\u0026#34;李四\u0026#34;; } 解析过程 方法调用前\n首先 Person s=new Person(\u0026quot;张三\u0026quot;)，在堆中开辟内存放对象，变量p1在栈中，存放的是堆的地址 将地址0x11复制一份给s2用于初始化，此时s2放的是地址0x11 方法调用时\np2.name=\u0026quot;李四\u0026quot;；要知道通过=赋值是直接先去常量池寻找是否存在与“李四”相同的值，有的话直接将其地址返回。否则创建一个值，再返回其地址。与上一问题不同的是，这里我们改变的是name，而name在堆中，所以常量池中地址是复制给了name 方法调用后\np1.name和p2.name最终存储的地址相同\n","date":"2024-11-02T20:30:52+08:00","permalink":"https://Tyritic.github.io/p/java%E6%96%B9%E6%B3%95/","title":"Java方法"},{"content":"如何读懂SpringBoot项目结构 SpringBoot项目本质上是一个Maven项目，大体骨架与普通的Maven项目相同\n普通Maven项目结构\n1 2 3 4 5 6 7 8 9 10 Maven-name/ |--src（源代码） |\t|--main（项目实际资源） |\t|--java（java代码） |\t|--resource（资源文件） |\t|--test（测试代码资源） |\t|--java |\t|--resource |--pom.xml（依赖配置文件） |--target（打包后的jar包存放地） 开发者的代码都存放到src/main/java文件夹中\n代码层 根目录：src/main/java\n作用：该目录下存放 入口启动类 及程序的开发目录。在这个目录下进行业务开发、创建实体层、控制器层、数据连接层等。\n注解\n入口启动类：运行整个项目 main 方法的类\n1 2 3 4 5 6 @SpringBootApplication public class UserApplication { public static void main(String[] args) { SpringApplication.run(UserApplication.class, args); } } 其中 @SpringBootApplication 用于标识SpringBoot项目的入口类\n控制器层（controller) 根目录：src/main/java/controller\n作用：主要负责具体业务模块的流程控制，负责前后端交互，接受前端请求，调用service层，接收service层返回的数据，最后返回具体的页面和数据到客户端\n功能实现：通过实现controller类来实现\n1 2 3 4 5 6 7 @RequestMapping(\u0026#34;/user\u0026#34;) @RestController // @RestController=@RequestMapping + @ResponseBody public class UserController { @RequestMapping(\u0026#34;/映射资源\u0026#34;) public List\u0026lt;User\u0026gt; findAll(){ return userService.findAll(); } 业务逻辑层(service) 根目录：src/main/java/service\n作用：主要负责业务逻辑应用设计\n功能实现：首先设计Service接口，然后再设计其实现该接口的类(serviceImpl)\n作用目标 ：通常Service接口作用于数据库传输对象（DTO)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Service public class UserRegisterServiceImpl implements UserRegisterService { @Autowired UserMapper userMapper; @Override public void register(UserRegisterDTO userRegisterDTO) { //判断用户是否已存在 User tempUser=userMapper.getByUsername(userRegisterDTO.getUsername()); if(tempUser!=null){ log.error(\u0026#34;用户{}已存在\u0026#34;,userRegisterDTO.getUsername()); throw new UsernameHasBeenRegisteredException(\u0026#34;用户名已存在\u0026#34;); } //注册 User user=new User(); BeanUtils.copyProperties(userRegisterDTO,user); userMapper.register(user); log.info(\u0026#34;用户{}注册成功\u0026#34;,userRegisterDTO.getUsername()); } } 常量层(common) 根目录：src/main/java/common\n作用：主要存放工具类（utils)，常量类（constant），统一响应模板（result），统一异常处理（exception)\n数据库实体层(pojo) 根目录：src/main/java/pojo\n作用：存放数据库的实体类，通常一个实体类对应一张数据库表\n数据持久层（mapper) 根目录：src/main/java/mapper\n作用：访问数据库，向数据库发送sql语句，完成数据的增删改查任务\n功能实现：通过 @Mapper 注解接口来建立java方法和sql语句的映射关系\n作用对象 ：\n插入操作直接操作entity对象 更新操作可以直接操作entity对象 查询操作通常使用分页操作 删除操作通常接受主键作为查询条件 1 2 3 4 5 6 7 8 9 10 @Mapper public interface DistrictMapper { List\u0026lt;District\u0026gt;searchAll(String tname); boolean deleteDistrict(String dname); District getDistrictByName(String dname); void insertDistrict(DistrictDTO districtDTO); void updateDistrictTdid(DistrictDTO districtDTO); boolean deleteAll(Long tid); void updateDistrictDetail(DistrictDTO districtDTO); } 数据传输对象（dto） 根目录：src/main/java/dto（或者放入pojo层中）\n作用：对 entity 进行封装，不破坏实体类结构，进行层与层之间的数据传输\n提示\n​\tDTO通常用于\n控制器（Controller）与服务层（Service）之间的数据传输：控制器通过 DTO 将请求参数传递给服务层，服务层返回 DTO 对象给控制器。 服务层与持久层（Mapper）之间的数据传输：服务层通过 DTO 将实体对象转换为需要的数据结构传递给持久层，持久层返回 DTO 对象给服务层。 视图包装对象（vo） 根目录：src/main/java/vo（或者放入pojo层中）\n作用：用于封装客户端请求的数据同时不破坏原有的实体类结构\n提示\nVO在实际开发中通常作为controller类方法的返回值从而起到封装客户端请求数据的作用\n配置类（config) 根目录：src/main/java/config\n作用：以java类代替yaml文件进行Bean对象配置\n功能实现：通过 @Configuration 注解一个java类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration public class WebMvcConfiguration implements WebMvcConfigurer { @Autowired JwtTokenUserInterceptor jwtTokenUserInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { log.info(\u0026#34;开始注册拦截器\u0026#34;); log.info(\u0026#34;注册Jwt令牌拦截器：{}\u0026#34;,jwtTokenUserInterceptor); registry.addInterceptor(jwtTokenUserInterceptor) .addPathPatterns(\u0026#34;/Operator/**\u0026#34;) .excludePathPatterns(\u0026#34;/Operator/user/login\u0026#34;) .excludePathPatterns(\u0026#34;/Operator/user/register\u0026#34;); } } 参数配置类（properties） 根目录：src/main/java/properties\n作用：以java实体类代替yaml文件进行参数配置\n功能实现：通过 @ConfigurationProperties 注解一个java类\n1 2 3 4 5 6 7 8 9 10 @Data @Component @ConfigurationProperties(prefix = \u0026#34;operator.aliyun.oss\u0026#34;) public class AliyunOSSProperties { String endpoint; String accessKeyId; String accessKeySecret; String bucketName; String region; } 过滤器（filter） 根目录：src/main/java/filter\n作用：在Servlet 处理请求之前或响应之后对数据进行某些处理，实现诸如日志记录、请求数据修改、响应数据修改、权限控制等功能\n提示\n过滤器工作在 Servlet 容器容中，它拦截客户端的请求和服务器的响应。过滤器链（Filter Chain）是多个过滤器按照一定的顺序执行的集合，一个请求可以依次通过多个过滤器，然后到达目标 Servlet，响应也会按相反的顺序经过这些过滤器返回给客户端。\n生命周期管理\nServlet 容器负责过滤器的生命周期管理。过滤器的生命周期方法包括 init（初始化）、doFilter（执行过滤操作）和 destroy（销毁）。 请求处理流程\n当一个请求到达 Servlet 容器时，容器会根据部署描述符（web.xml）或注解配置，决定是否以及如何调用过滤器链。 过滤器链是多个过滤器按照一定的顺序执行的集合。容器按照这个顺序依次调用每个过滤器的 doFilter 方法。 doFilter 方法\n在 doFilter 方法中，开发者可以实现自定义的处理逻辑，比如修改请求头、记录日志等。 doFilter 方法中必须调用 FilterChain 的 doFilter 方法，这样请求才能继续传递给下一个过滤器或目标资源（如 Servlet）。如果不调用，请求处理流程将会停止。 工作机制\n过滤器可以修改请求和响应，但它们通常不会生成响应或结束请求，因为这通常是 Servlet 或其他资源的职责 参考文章：\nFilter（过滤器）和 Interceptor（拦截器）详解_过滤器和拦截器-CSDN博客 功能实现\n创建过滤器类\n实现 javax.servlet.Filter 接口。 重写 init()、doFilter() 和 destroy() 方法。 配置过滤器\n使用注解 @WebFilter 进行声明和配置。 或者在 web.xml 文件中配置。 编写过滤逻辑：\n在 **doFilter()**方法中实现具体的过滤逻辑。 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import javax.servlet.*; import javax.servlet.annotation.WebFilter; import java.io.IOException; @WebFilter(\u0026#34;/example/*\u0026#34;) // 过滤器应用于 URL 模式 \u0026#34;/example/*\u0026#34; public class ExampleFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { // 初始化代码，例如资源加载 } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { // 在请求处理之前执行的代码 System.out.println(\u0026#34;Before Servlet processing\u0026#34;); chain.doFilter(request, response); // 将请求传递给下一个过滤器或目标资源 // 在请求处理之后执行的代码 System.out.println(\u0026#34;After Servlet processing\u0026#34;); } @Override public void destroy() { // 清理代码，例如释放资源 } } 拦截器（interceptor） 根目录：src/main/java/interceptor\n作用：是 Spring MVC 框架中的一个核心组件，用于在处理 HTTP 请求的过程中进行拦截和处理。拦截器主要用于实现跨切面（cross-cutting）的逻辑，如日志记录、性能统计、安全控制、事务处理等。\n功能实现\n创建拦截器类：\n实现 **HandlerInterceptor**接口或继承 **HandlerInterceptorAdapter**类。 重写 preHandle()、postHandle() 和 afterCompletion() 方法。 注册拦截器：\n创建一个配置类，实现 WebMvcConfigurer接口。 重写 addInterceptors 方法来添加拦截器。 编写拦截逻辑：\n在 preHandle()、postHandle() 和 **afterCompletion()**方法中实现具体的拦截逻辑。 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { // 请求处理前的逻辑 return true; // 返回 true 继续流程，返回 false 中断流程 } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) { // 请求处理后的逻辑，但在视图渲染前 } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { // 请求处理完毕后的逻辑 } } @Configuration public class WebMvcConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new MyInterceptor()).addPathPatterns(\u0026#34;/**\u0026#34;); // 应用于所有路径 } } 项目配置层 根目录：src/main/resource\napplication.yml ：项目的整体配置文件\nmapper ：数据库映射文件\n","date":"2024-11-02T19:26:08+08:00","permalink":"https://Tyritic.github.io/p/springboot%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/","title":"SpringBoot项目结构"},{"content":"顺序结构 代码逐行执行，执行逻辑为线性逻辑\n选择结构 代码遇到选择结构根据关系表达式的不同计算结果执行不同的操作\nif语句 语法结构 1 2 3 if(关系表达式){ //语句体 } 执行流程 计算关系表达式 若为 true 执行语句体内的语句，若为 false 则跳过语句体内的语句 继续执行语句体外的语句 if-else语句 语法结构 1 2 3 4 5 if(关系表达式){ //语句体1 }else{ //语句体2 } 执行流程 计算关系表达式 若为 true 执行语句体1内的语句，若为 false 则执行语句体2内的语句 继续执行语句体外的语句 if-else if语句 语法结构 1 2 3 4 5 6 7 8 9 if(关系表达式 1){ //语句体1 }else if(关系表达式 2){ //语句体2 } ... else{ //语句体n+1 } 执行流程 计算关系表达式1 若为 true 执行语句体1内的语句，若为 false 则计算关系表达式2 若为 true 执行语句体2内的语句，若为 false 则计算关系表达式3 以此类推 若所有的关系表达式为 false 则执行语句体n+1 switch语句 语法结构 1 2 3 4 5 6 7 8 9 10 11 12 switch(表达式){ case 值1: 语句体1; break; case 值2: 语句体2; break; ...... default: 语句体 n+1 break; } 执行流程 计算表达式的值 依次与case后面的值比较。若有对应的值就会执行对应的语句体，在执行过程中遇到break结束整个switch语句 若与所有的case后面的值不匹配，便会执行default内的语句体 格式说明 表达式取值只能为byte，short，int，char，enum，string case后面是与关系式匹配的值，只能是字面量不能说变量且不允许重复 注意事项 default 可以放在任意位置，也可以省略不写 不写 break会发生case穿透问题，在case匹配过程中若没有break会执行下一个case的语句体，直到遇到 break/大括号 JDK12的新特性 语法格式 1 2 3 4 5 6 7 8 9 10 11 12 13 switch(表达式) case 值1 -\u0026gt; { //语句体1 } case 值2 -\u0026gt; { //语句体2 } .... default -\u0026gt;{ //语句体n+1 } 循环结构 for循环 语法格式 1 2 3 4 for(初始化语句;终止条件判断语句;条件控制语句) { //循环体结构 } 执行流程 执行初始化语句 执行条件判断语句，检验其结果 若为 false，循环结束 若为 true，执行循环体语句 执行条件控制语句 单次循环结束后继续执行条件判断语句 while循环 语法格式 1 2 3 4 5 6 // 初始化语句 while(条件判断语句) { // 循环体语句 // 条件控制语句 } 执行流程 执行初始化语句 执行条件判断语句，检验其结果 若为 false，循环结束 若为 true，执行循环体语句 执行条件控制语句 单次循环结束后继续执行条件判断语句 提示\nfor和while的对比\n相同点：运行规则相同\n不同点\nfor循环中控制循环的变量在循环结束后无法被访问，while循环中可以继续使用 for循环限定循环次数和范围，while循环不知道循环次数 do-while循环 语法结构 1 2 3 4 5 // 初始化语句 do{ // 循环体语句 // 条件控制语句 }while(条件判断语句) 执行流程 执行初始化语句 先执行条件判断语句 执行条件控制语句 单次循环结束后继续执行条件判断语句 若为 false，循环结束 若为 true，执行循环体语句 循环控制语句 break：立即终止当前所在的循环\ncontinue：跳过当前循环的剩余部分，直接进入下一次循环\n在嵌套循环中，break 和 continue 仅影响它所在的最近一层循环\n","date":"2024-11-02T15:41:14+08:00","permalink":"https://Tyritic.github.io/p/java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%84/","title":"Java程序运行结构"},{"content":"算术运算符 一般运算符 $+$：加法 $-$：减法 $*$：乘法 $/$：除法 %：取余数 注意事项 整数之间相除只会得到结果的整数部分 小数直接参与运算结果可能不准确 至少有一个操作数需要是浮点类型才能得到浮点数结果 字符串的拼接操作 使用$+$让字符串前后拼接，拼接操作从左向右连续执行\n字符的加法 字符和字符的加法以及字符和整型的加法是通过将字符转换成ASCII码来进行的加法\n自增自减运算符 符号 作用 等效语句 ++ 变量加一 $a++ \\iff a=a+1$ - - 变量减一 $a- - \\iff a=a-1$ 前置与后置的区别 单独使用时没有区别： $$ var++ \\iff ++var \\iff var=var+1 \\\\ var-- \\iff --var \\iff var=var-1 $$ 参与计算是有区别\n后置时先使用变量的原始值计算，然后对变量加一\n1 2 3 4 5 6 int a=10; int b=a++; //结果 //a：10 //b：11 前置时先对变量加一，再使用变量的新值进行计算\n1 2 3 4 5 6 int a=10; int b=++a; //结果 //a：11 //b：11 赋值运算符 分类 符号 作用 说明 = 直接赋值 int a=10; 将10赋值给变量a += 加后赋值 a+=b; 将a+b赋值给变量a -= 减后赋值 a-=b; 将a-b赋值给变量a *= 乘后赋值 a*=b; 将a*b赋值给变量a /= 除后赋值 a/=b; 将a/b赋值给变量a %= 余后赋值 a%=b; 将a%b赋值给变量a 注意事项 底层实现中包含了强制类型转换 在表达式中所有其他运算符完成后再进行计算 关系运算符 分类 $\u0026gt;$ 大于 $\u0026lt;$ 小于 $\\leq$ 小于等于 $\\geq$ 大于等于 $==$ 等于 $!=$ 不等于 运算结果为 boolean\n逻辑运算符 一般逻辑运算符 \u0026amp; 逻辑与 全真为真 | 逻辑或 一真为真 ! 逻辑非 取反 ^ 逻辑异或 相同为假，不同为真 短路逻辑运算符 \u0026amp;\u0026amp; 逻辑与 结果与\u0026amp;相同但是具有短路效果 || 逻辑或 结果与|相同但是具有短路效果 短路效果指的是当左边的表达式可以确定最终结果那么就不会执行右边的表达式\n三元运算符 语法格式 1 (关系表达式)?(表达式1):(表达式2) 计算规则 计算关系表达式的值 判断关系表达式的运算结果 若为 true 执行表达式1 若为 false 执行表达式2 ","date":"2024-11-02T12:23:34+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6/","title":"Java的运算符"},{"content":"字面量 数据在程序中的运行格式\n字面量类型 整数类型：不带小数点的数字 浮点数类型：带小数点的数字 字符串类型：用双引号括起来的多个字符 字符类型：用单引号括起来的单个字符 布尔类型：true/false 空类型：null 基本数据类型 整型\n整型 取值范围 内存占用 byte $-2^7 到 2^7-1 $ 1 short $-2^{15} 到 2^{15}-1 $ 2 int $-2^{31} 到 2^{31}-1 $ 4 long（字面量之后加上大写L） $-2^{63} 到 2^{63}-1 $ 8 浮点数\n浮点数 取值范围 内存占用 float（字面量之后加上大写F） 4 double 8 字符\n字符 取值范围 内存占用 char 2 布尔\n布尔 取值范围 内存占用 boolean 拓展知识 基本数据类型的特性 大小固定：每种基本类型在不同的操作系统和平台上占用的内存大小是固定的，保证了跨平台的一致性。 不支持 null：基本类型不能为 null，它们在声明时会有默认值，例如 int 的默认值是 0，boolean 的默认值是 false 。 性能更高：基本类型直接存储在栈内存中，操作效率高于包装类型（如 Integer 、Double ）。 基本数据类型的默认值 byte、short、int、long 的默认值是 0 。 float、double 的默认值是 0.0 。 char 的默认值是 '\\u0000' 。 boolean 的默认值是 false 。 提示\nboolean 的存储：\n虽然 boolean 类型在逻辑上只占用 1 位，但 Java 的虚拟机对 boolean 的存储通常会根据系统架构分配 1 字节或更多位数的空间。这是因为 CPU 通常按字节操作内存，而非按位。\n数据类型转换 数据类型不同不能直接参与运算，需要进行类型转换后再进行运算\n隐式类型转换 将取值范围小的数据赋值给取值范围大的数据类型时，程序自动进行类型转换\n提升规则 取值范围小的数据类型和取值范围大的数据类型大的进行运算，取值范围小的数据类型先提升为取值范围大的数据类型大的再进行运算 byte，short，char 在运算时直接提升为int再运算 显式类型转换 不允许直接将取值范围大的数据赋值给取值范围小的数据类型，需要开发者进行强制类型转换\n语法格式 1 目标格式 变量名 = (目标格式) 被强制类型转换的变量名 注意事项 将 double/float 强制转为 int 时会截断小数部分 Java具有常量优化机制，编译器在编译过程中，将能够在编译期确定的常量表达式直接计算并替换成结果 ","date":"2024-11-02T11:20:03+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E5%AD%97%E9%9D%A2%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","title":"Java的字面量和基本数据类型"},{"content":"执行过程 开发者编写Java源代码（ .java 文件） 编译源代码（.java文件）使用javac命令编译器将源代码转化成字节码（.class文件） 在虚拟机（JVM）上运行字节码（.class 文件），将字节码解释成机器码 在程序运行时，JVM 会监控哪些字节码被频繁调用（热点代码）。一旦识别出热点代码，JVM 会将这些代码交给 JIT 编译器进行编译，并缓存编译后的机器码。 字节码中不经常调用的部分（非热点代码）用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的 提示\n解释执行比编译执行效率差\n解释执行：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢。（类比每次给你英语让你翻译阅读）\n编译执行：在程序执行之前，整个源代码会被编译成机器码或者字节码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性较差。（类比直接给你看中文）\nJava同时具有解释性和编译性\n编译性 字节码的编译：Java源代码首先被编译成字节码，JIT 会把编译过的机器码保存起来,以备下次使用。 即时编译：JVM 加载并执行 Java 字节码文件，在执行过程中，JVM 会发现一些高频次执行的代码（热点代码），然后将这些字节码交给 JIT 编译器进行编译，生成平台相关的机器码。这样，Java 程序的性能就能得到优化，因为热点代码被 JIT 编译成了机器码，可以直接运行，而不需要每次都解释执行。 解释性：字节码中非热点部分（不经常调用的部分）用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的 跨平台性 Java程序具有在任意操作系统平台上运行\n实现原理 在运行Java程序程序的操作系统上安装一个与操作系统对应的Java虚拟机。源代码会被编译成相同的字节码，然后虚拟机根据操作系统将字节码解释成不同的机器码\nJava的运行环境 JVM（Java虚拟机） Java虚拟机用于解释Java源代码，加载Java程序。针对不同的操作系统设计有不同的Java虚拟机\nJRE（Java运行时环境） JRE全称 （Java Runtime Environment） 是Java运行时环境，包含了 JVM , Java核心类库和其他支持Java程序的文件，但是不包含任何开发工具\n组成部分 JVM（Java Virtual Machine）：执行由源代码编译后得到的Java字节码，提供了Java程序的运行环境 核心类库：标准的类库（java.lang,java.utils）供Java程序使用 其他文件：配置文件，库文件，支持JVM的运行 JDK（Java开发包） JDK全称 （Java Development Kit） 是一组独立程序构成的集合，是用于开发Java 程序的完整开发环境，它包含了JRE ，以及用于开发、调试和监控 Java 应用程序的工具。\n组成部分 JRE：JDK包含了完整的JRE，可以运行java程序 开发工具：包含编译器（javac），打包工具（jar） 附加库和文件：支持开发，文档生成 常见开发工具 javac ：Java 编译器，用于将 Java 源代码（.java 文件）编译成字节码（.class 文件）。 java ：Java 应用程序启动器，用于运行 Java 应用程序。 javadoc：文档生成器，用于从 Java 源代码中提取注释并生成 HTML 格式的 API 文档。 jar ：归档工具，用于创建和管理 JAR（Java Archive）文件。 jdb：Java 调试器，用于调试 Java 程序。 jps：Java 进程状态工具，用于列出当前所有的 Java 进程。 jstat：JVM 统计监视工具，用于监视 JVM 统计信息。 jstatd：JVM 统计监视守护进程，用于在远程监视 JVM 统计信息。 jmap：内存映射工具，用于生成堆转储（heap dump）、查看内存使用情况。 jhat：堆分析工具，用于分析堆转储文件。 jstack：线程栈追踪工具，用于打印 Java 线程的栈追踪信息。 javap：类文件反汇编器，用于反汇编和查看 Java 类文件。 jdeps：Java 类依赖分析工具，用于分析类文件或 JAR 文件的依赖关系 其他工具的介绍参见博客\n相互关系 JDK JRE JVM 核心类库 开发工具 ","date":"2024-11-02T10:46:06+08:00","permalink":"https://Tyritic.github.io/p/java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/","title":"Java程序的编译执行过程"},{"content":"文章存储位置 本博客的所有文章都存放在E/MyBlog/content/post文件夹中\n如何添加文章 在 content/tags/文章名 下新建文件 index.md\n命令行操作 在MyBlog主文件夹的cmd中运行以下命令\n1 hugo new content post/\u0026lt;FileName\u0026gt;/index.md 参数解释 post：所有文章保存的文件路径\nFileName为当前文章所在的文件夹名\nindex.md为当前文章的markdown文件\nindex.en.md：英文文章 index.zh-cn.md：中文文章 文章内修改 插入照片 将需要的图片放入文章的文件夹中即可\n头文字参数 data：创建时间\ndraft：是否草稿\ntitle：文章标题\nimage：博客网站的开头图片\ncategories：文章的分类\ntags：文章的标签\ndescription：文章的描述\n短代码 文章引用 在markdown文件中插入以下短代码，使用时将{}改为{{}}\n1 2 3 {\u0026lt; quote author=\u0026#34;作者\u0026#34; url=\u0026#34;作品的来源（可不填）\u0026#34; source=\u0026#34;作品名\u0026#34; \u0026gt;} 引用内容 {\u0026lt; /quote \u0026gt;} 插入B站视频 在markdown文件中插入以下短代码，使用时将{}改为{{}}\n1 {\u0026lt; bilibili VIDEO_ID PART_NUMBER \u0026gt;} 可以在B站视频的url中找到Video_ID``https://www.bilibili.com/video/BV1BPSdYHEbj/?spm_id_from=333.1007.tianma.1-2-2.click\u0026amp;vd_source=7db50a55b19a59c42ee778836913c04f\n其中VIDEO_ID：BV1BPSdYHEbj\n插入hugo notice hugo notice有以下几个类别\ntip：提示 info：引言 warning：警告 note：注解 创建方法为在markdown文件中插入短代码，使用时将{}改为{{}}\n创建Tip 1 2 3 {\u0026lt; notice tip \u0026gt;} This is a very good tip. {\u0026lt; /notice \u0026gt;} 提示\nThis is a very good tip.\n创建Info 1 2 3 {\u0026lt; notice info \u0026gt;} This is a very good info. {\u0026lt; /notice \u0026gt;} 引言\nThis is a very good info.\n创建Warning 1 2 3 {\u0026lt; notice warning \u0026gt;} This is a very bad warning. {\u0026lt; /notice \u0026gt;} 警告\nThis is a very bad warning.\n创建Note 1 2 3 {\u0026lt; notice note \u0026gt;} This is a very good note. {\u0026lt; /notice \u0026gt;} 注解\nThis is a very bad note.\n插入参考博客 直接将参考博客的网址复制到markdown文件中\nTyritic的个人博客\n创建分组（categories） 在 content/categories/分类名 下新建文件 _index.md\n可以使用命令行工具\n1 hugo new content categories/\u0026lt;分组名\u0026gt;/_index.md 参数解释 categories：所有分组的所在目录 _index.md：分组的配置文件 _ndex.en.md：英文分组 _index.zh-cn.md：中文分组 创建标签（Tags) 在 content/tags/分类名 下新建文件 _index.md\n可以使用命令行工具\n1 hugo new content tags/\u0026lt;标签名\u0026gt;/_index.md 参数解释 tags：所有标签所在的目录 _index.md：分组的配置文件 index.en.md：英文标签 index.zh-cn.md：中文标签 创建友情链接（Links) 在 content/page/links 下修改文件 _index.md，创建与GitHub同级的元素\n参数列表 title：博客显示该网站的名字 description：博客对该网站的描述 website：网站链接 image：网站的icon ","date":"2024-11-01T15:28:47+08:00","permalink":"https://Tyritic.github.io/p/%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"博客使用指南"},{"content":"Maven的作用 依赖管理：方便快捷地管理依赖\n统一项目结构：提供标准的项目结构\n项目构建：提供了标准的跨平台项目构建方式\nMaven项目的结构 1 2 3 4 5 6 7 8 9 10 Maven-name/ |--src（源代码） |\t|--main（项目实际资源） |\t|--java（java代码） |\t|--resource（资源文件） |\t|--test（测试代码资源） |\t|--java |\t|--resource |--pom.xml（依赖配置文件） |--target（打包后的jar包存放地） Maven项目模型 仓库：用于存储资源以及各种JAR包\n本地仓库：计算机上的目录 中央仓库：由Maven团队维护的仓库 私服：公司团队搭建的私有仓库 依赖管理 什么是依赖 依赖就是项目所需要的jar包\nMaven坐标 ​\tMaven坐标是依赖资源的唯一标识，可以唯一定位资源的位置，使用Maven坐标可以引入项目依赖\n组成结构 groupId：项目所属的组织名 artifactId：项目名称/模块名称 version：版本号 依赖配置 配置方法 在pom.xml文件中使用标签\u0026lt; dependencies \u0026gt; 单个依赖在\u0026lt; dependencies \u0026gt;中被\u0026lt; dependency \u0026gt; 包围 定义依赖的坐标 刷新Maven文件 提示\n若本地仓库不存在依赖则会连接私服或者中央仓库进行下载\n依赖传递 ​\t依赖具有传递性\n​\t直接依赖：在当前项目中通过依赖配置建立的依赖关系\n​\t间接依赖:被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源\n​\t依赖的传递关系可能出现冲突\n路径优先：当依赖中出现相同的资源时：层级越深优先级越低 声明优先：当资源在相同的层级被依赖，配置靠前的覆盖配置靠后的 特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的 依赖排除 ​\t依赖可以被开发者手动排除\n​\t实现形式\n在pom.xml文件中使用标签\u0026lt; exclusions \u0026gt;包围\n对于要排除的单个依赖使用标签\u0026lt; exclusion \u0026gt;包围\n提示\n排除依赖的时候无须指定版本号\n依赖范围 ​\t依赖的jar包，默认情况下，可以在任何地方使用。但是可以通过\u0026lt; scope \u0026gt; 手动指定其使用范围\n作用范围 主程序范围有效。(main文件夹范围内) 测试程序范围有效。(test文件夹范围内) 是否参与打包运行。(package指令范围内) \u0026lt;scope\u0026gt;标签的取值 scope的取值 主程序 测试程序 打包运行 举例 compile(默认) Y Y Y log4j（日志框架） test X Y X junit（单元测试） provided Y Y X servlet（三大组件） runtime X Y Y jdbc（数据库连接依赖） 生命周期 ​\tMaven中有三套独立的生命周期\nclean：清理工作 default：核心工作包括（编译，测试，打包，变更，部署） site：生成报告，发布站点 生命周期的阶段 ​\n​\t提示\n​\t同一套生命周期，后面的阶段要依托前面的阶段来执行\n​\n重要阶段 clean:移除上一次构建生成的文件 compile:编译项目源代码 test:使用合适的单元测试框架运行测试(junit) package:将编译后的文件打包，如:jar、war等 install:安装项目到本地仓库 ","date":"2024-11-01T15:28:45+08:00","permalink":"https://Tyritic.github.io/p/maven%E5%9F%BA%E7%A1%80/","title":"Maven基础"},{"content":"Spring框架的基本认识 Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。\nSpring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发\nSpring框架的基本特性 控制反转IOC和依赖注入DI Spring通过控制反转实现了对象的创建和对象间的依赖关系管理。开发者只需要定义好Bean及其依赖关系，Spring容器负责创建和组装这些对象。实现了通过配置文件或注解来管理对象之间的依赖关系,降低了耦合度，提高了代码的可维护性和可测试性。\n而依赖注入则是控制反转的实现方式\n面向切面编程AOP 面向切面编程，允许开发者定义横切关注点，例如事务管理、安全控制等，独立于业务逻辑的代码。将那些与核心业务逻辑无关，但是对多个对象产生影响的公共行为封装起来，如日志记录、性能统计、事务等。通过AOP，可以将这些关注点模块化，提高代码的可维护性和可重用性。\n事务管理 Spring提供了一致的事务管理接口，支持声明式和编程式事务。开发者可以轻松地进行事务管理，而无需关心具体的事务API。\nSpring框架的模块架构 Spring 框架是分模块存在，除了最核心的 Spring Core Container 是必要模块之外，其他模块都是可选的\n核心模块 Core Container Spring Core：提供了依赖注入（Dependency Injection, DI）和控制反转（Inversion of Control, IoC）的实现，所有其他Spring模块的基础，别的模块都会依赖此模块。 Spring Beans：负责管理Bean的定义和生命周期。通过IoC容器完成Bean的创建、依赖注入、初始化、销毁等操作。 Spring Context：基于Core和Beans的高级容器，提供了类似JNDI的上下文功能，还包含了国际化、事件传播、资源访问等功能。 Spring Expression Language（SpEL）：一个强大的表达式语言，用于在运行时查询和操作对象的值。 面向切面编程模块 AOP Spring AOP：提供面向切面编程的功能，可以在方法执行前后或抛出异常时动态插入额外的逻辑，比如日志记录、权限验证、事务管理等。 spring-aspects：该模块为与 AspectJ 的集成提供支持。 spring-instrument：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文件，就像这些文件是被类加载器加载的一样。 数据访问/集成模块 Spring JDBC：简化了原生JDBC的操作，提供模板方法来管理连接、资源的释放和异常处理。 Spring ORM：支持与主流ORM框架（如Hibernate、JPA、MyBatis等）集成，简化持久层开发。 Spring Transaction（事务管理）：提供声明式和编程式的事务管理机制，与数据库操作密切结合。 Web模块 Spring Web：提供基础的Web开发支持，包括Servlet API的集成，适用于构建MVC架构。 Spring MVC：实现了Model-View-Controller（MVC）模式的框架，用于构建基于HTTP请求的Web应用。它是一个常用的模块，支持注解驱动的Web开发。 Spring WebFlux：提供基于Reactive Streams的响应式编程模型，专为高并发的异步非阻塞请求设计。 提示\nSpring，SpringBoot，SpringMVC的关系和区别\nSpring 是基础框架，用来管理Bean对象，提供核心功能，如 IOC、AOP、事务管理等，同时方便整合各种框架。 Spring MVC 是 Spring 的 Web 组件，是spring对web框架的解决方案，主要用于构建基于 MVC 模式的 Web 应用。 Spring Boot 进一步简化了 Spring 和 Spring MVC 的使用，提供自动配置、嵌入式服务器、简化依赖管理，适用于快速开发 Web 和微服务应用。 Spring的常用注解 Web开发 @Controller：用于标注控制层组件。\n@RestController：是@Controller 和 @ResponseBody 的结合体，返回 JSON 数据时使用。 @RequestMapping：用于映射请求 URL 到具体的方法上，还可以细分为：\n@GetMapping：只能用于处理 GET 请求\n@PostMapping：只能用于处理 POST 请求\n@DeleteMapping：只能用于处理 DELETE 请求\n@ResponseBody：直接将返回的数据放入 HTTP 响应正文中，一般用于返回 JSON 数据。\n@RequestBody：表示一个方法参数应该绑定到 Web 请求体。\n@PathVariable：用于接收路径参数，比如 @RequestMapping(“/hello/{name}”)，这里的 name 就是路径参数。\n@RequestParam：用于接收请求参数。比如 @RequestParam(name = \u0026quot;key\u0026quot;) String key，这里的 key 就是请求参数。\n容器类 @Component：标识一个类为 Spring 组件，使其能够被 Spring 容器自动扫描和管理。 @Service：标识一个业务逻辑组件（服务层）。比如 @Service(\u0026quot;userService\u0026quot;)，这里的 userService 就是 Bean 的名称。 @Repository：标识一个数据访问组件（持久层）。 @Autowired：按类型自动注入依赖。 @Configuration：用于定义配置类，可替换 XML 配置文件。 @Value：用于将 Spring Boot 中 application.properties 配置的属性值赋值给变量。 AOP @Aspect 用于声明一个切面，可以配合其他注解一起使用，比如： @After：在方法执行之后执行。 @Before：在方法执行之前执行。 @Around：方法前后均执行。 @PointCut：定义切点，指定需要拦截的方法。 Spring中的设计模式 工厂模式 Spring 使用工厂模式可以通过 BeanFactory 或 ApplicationContext 创建 bean 对象。\nBeanFactory：延迟注入（使用到某个 bean 的时候才会注入），相比于ApplicationContext 来说会占用更少的内存，程序启动速度更快。 ApplicationContext：容器启动的时候，一次性创建所有 bean 。BeanFactory 仅提供了最基本的依赖注入支持，ApplicationContext 扩展了 BeanFactory ,除了有BeanFactory的功能还有额外更多功能，所以一般开发人员使用ApplicationContext会更多。 ApplicationContext 的三个实现类：\nClassPathXmlApplication：把上下文文件当成类路径资源。 FileSystemXmlApplication：从文件系统中的 XML 文件载入上下文定义信息。 XmlWebApplicationContext：从 Web 系统中的 XML 文件载入上下文定义信息。 1 2 ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); MyBean myBean = context.getBean(MyBean.class); 单例模式 在Bean对象的创建中使用了单例模式。Spring 中 bean 的默认作用域就是 singleton(单例)的\nSpring中实现单例模式的核心代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 通过 ConcurrentHashMap（线程安全） 实现单例注册表 private final Map\u0026lt;String, Object\u0026gt; singletonObjects = new ConcurrentHashMap\u0026lt;String, Object\u0026gt;(64); public Object getSingleton(String beanName, ObjectFactory\u0026lt;?\u0026gt; singletonFactory) { Assert.notNull(beanName, \u0026#34;\u0026#39;beanName\u0026#39; must not be null\u0026#34;); synchronized (this.singletonObjects) { // 检查缓存中是否存在实例 Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) { //...省略了很多代码 try { singletonObject = singletonFactory.getObject(); } //...省略了很多代码 // 如果实例对象在不存在，我们注册到单例注册表中。 addSingleton(beanName, singletonObject); } return (singletonObject != NULL_OBJECT ? singletonObject : null); } } //将对象添加到单例注册表 protected void addSingleton(String beanName, Object singletonObject) { synchronized (this.singletonObjects) { this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT)); } } } Spring中的单例模式属于 \u0026ldquo;注册式单例\u0026rdquo; ，广泛用于 Spring 容器的单例 Bean 管理。它的优势是：\n线程安全 支持懒加载 支持多个单例对象的管理 代理模式 Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy 去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 Cglib 生成一个被代理对象的子类来作为代理\n适配器模式 在 Spring MVC 中，DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。解析到对应的 Handler（也就是 Controller 控制器）后，开始由HandlerAdapter 适配器处理。HandlerAdapter 作为期望接口，具体的适配器实现类用于对目标类进行适配，Controller 作为需要适配的类。\nSpring中的基本概念 Bean对象 定义 任何通过 Spring 容器实例化、组装和管理的 Java 对象都是 Bean对象 。Bean 可以在 Spring 容器中被定义并且通过依赖注入来与其他 Bean 进行互相依赖。\n生命周期 实例化：当 Spring 容器启动时，根据配置文件或注解，Spring 会首先实例化 Bean。 依赖注入：在实例化之后，Spring 容器会通过构造器、setter 方法或注解将其他 Bean 的依赖注入进来。 初始化：如果 Bean 实现了 InitializingBean 接口或者使用了 @PostConstruct 注解，Spring 会在依赖注入完成后调用相应的初始化方法。 销毁：如果 Bean 实现了 DisposableBean 接口或使用了 @PreDestroy 注解，Spring 会在容器关闭时调用销毁方法。 IOC容器 定义 IOC（Inversion of Control，控制反转） 容器是 Spring 框架的核心，用于管理 Java 对象（Bean）的创建、初始化、配置、依赖注入和生命周期管理。\nIOC 容器是 Spring 提供的一个工厂，专门负责创建和管理对象（Bean），并自动将它们的依赖关系组装起来。开发者无需手动创建对象，而是由 Spring 容器自动注入所需的对象。\n","date":"2024-11-01T14:58:53+08:00","permalink":"https://Tyritic.github.io/p/spring%E6%A1%86%E6%9E%B6%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AE%A4%E8%AF%86/","title":"Spring框架的基础认识"},{"content":"概念辨析 面向对象编程(Object Oriented Programming，OOP)是一种对象为中心的编程范式或者说编程风格。把类或对象作为基本单元来组织代码，并且运用提炼出的：封装、继承和多态来作为代码设计指导。\n面向过程编程是一种以过程或函数为中心的编程范式或者说编程风格，以过程作为基本单元来组织代码。过程其实就是动作，对应到代码中来就是函数，面向过程中函数和数据是分离的，数据就是成员变量。\n总结来看：面向对象编程注重对象之间的交互和模块化设计，而面向过程编程注重逻辑的分步实现。\n与面向过程编程主要区别 数据与行为的关系：\n面向对象：数据和行为封装在对象内部，数据操作由对象方法进行管理。 面向过程：数据和函数是分离的，函数对数据进行操作。 可扩展性和复用性：\n面向对象：通过继承、接口、多态等机制支持代码的高复用性和扩展性。 面向过程：复用性较低，扩展需要修改已有代码，影响整体稳定性。 优缺点 面向对象的优缺点：\n优点：高复用性、扩展性、维护性强，适合复杂系统的开发。 缺点：开发和理解成本较高，对于简单项目可能显得繁琐。 面向过程的优缺点：\n优点：开发简单，代码执行速度快，适合小型项目。 缺点：可维护性差，代码复用性低，扩展性差。 ","date":"2024-11-01T10:59:01+08:00","permalink":"https://Tyritic.github.io/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/","title":"面向对象编程和面向过程编程的区别"},{"content":"跨平台 Java 是跨平台的，通过 JVM 实现“一次编写，到处运行”。\nJava 源代码首先编译成字节码（.class 文件），然后由 JVM 将字节码转换成平台特定的机器码。只要在不同平台上安装相应的 JVM，字节码文件就能执行。\nJava 程序通过 JVM 这个“中间层”实现跨平台运行，编译生成的字节码文件是相同的，但不同平台的 JVM 会将其翻译成不同的机器码。尽管 Java 程序是跨平台的，但 JVM 本身是平台特定的，因此需要在每个平台上安装对应版本的 JVM 来支持执行。\nJVM 是跨平台的关键，它将字节码转换为机器码，因此 Java 程序能在不同平台上运行。即使将 Java 程序打包成可执行文件（.exe），仍然需要 JVM 的支持。\n提示\n解释执行比编译执行效率差\n解释执行：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢。（类比每次给你英语让你翻译阅读）\n编译执行：在程序执行之前，整个源代码会被编译成机器码或者字节码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性较差。（类比直接给你看中文）\nJava同时具有解释性和编译性\n编译性 Java 源代码首先被编译成字节码，JIT 会把编译过的机器码保存起来，以备下次使用。 JVM 加载并执行 Java 字节码文件，在执行过程中，JVM 会发现一些高频次执行的代码（热点代码），然后将这些字节码交给 JIT 编译器进行编译，生成平台相关的机器码。这样，Java 程序的性能就能得到优化，因为热点代码被 JIT 编译成了机器码，可以直接运行，而不需要每次都解释执行。 解释性：字节码中非热点部分（不经常调用的部分）用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的 垃圾回收 Java 还提供垃圾自动回收功能，虽说手动管理内存意味着白由、精细化地掌控，但是很容易出错。 在内存较充裕的当下，将内存的管理交给 GC 来做，减轻了程序员编程的负担，提升了开发效率，更加划算!\n生态 Java 生态圈完善，丰富的第三方类库、企业级框架、各种中间件。\n面向对象 Java 是一种严格的面向对象编程语言，具有清晰的类、对象、继承、接口等概念，支持封装、继承、多态等 OOP 特性，有助于代码的可维护性和可扩展性。\n","date":"2024-11-01T10:53:37+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E7%89%B9%E7%82%B9/","title":"Java的优势与特点"},{"content":"排序算法的相关概念 内部排序和外部排序 内部排序 ：在排序期间元素全部存放在内存中的排序 外部排序 ：排序期间元素无法全部放在内存中，必须在排序的过程中不断进行内外存的数据交换 稳定排序和非稳定排序 稳定排序 ：对于相同的键，不会重新排列它的相对顺序 非稳定排序 ：对于相同的键，会重新排序它的相对顺序 基于比较的排序和基于桶的排序 基于比较的排序 ：通过比较来决定元素间的相对次序，适用于各种规模的数据，也不在乎数据的分布，都能进行排序 基于桶的排序 ：不通过比较来决定元素间的相对次序，而是通过确定每个元素之前，应该有多少个元素来排序。非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。 基于比较的排序 冒泡排序 它重复地遍历要排序的序列，依次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历序列的工作直到没有再需要交换为止，此时说明该序列已经排序完成。此时元素会像泡泡一样，冒泡到数组的适当位置\n算法步骤 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数 针对所有的元素重复以上的步骤，直到排序完成。 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static void bubbleSort(int[] a) { int n=a.length; // 遍历n-1次 for(int i=0;i\u0026lt;n-1;i++){ // 标志位,如果一次遍历中没有发生交换,说明数组已经有序,直接退出 boolean flag=true; // 每次遍历都会找到一个最大值,因此第i次遍历时只需要遍历n-i-1个元素 for(int j=0;j\u0026lt;n-i-1;j++){ if(a[j]\u0026gt;a[j+1]){ int temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; flag=false; } } if(flag){ break; } } } 算法分析 稳定性：稳定 时间复杂度 最佳：$O(n)$ （当输入数组为已经排序好的数据） 最差：$O(n^2)$：（当输入数组为倒序排列的） 平均：$O(n^2)$ 空间复杂度：$O(1)$ 选择排序 选择排序无论接收什么数据进去都是 $O(n^2)$ 的时间复杂度。所以用到它的时候，数据规模越小越好。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n算法步骤 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第 2 步，直到所有元素均排序完毕。 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public static void selectionSort(int[] a) { int n=a.length; // 遍历n-1次 for(int i=0;i\u0026lt;n-1;i++){ // 每次遍历都会找到一个最小值,因此第i次遍历时只需要遍历n-i-1个元素 int minIndex=i; for(int j=i+1;j\u0026lt;n;j++){ if(a[j]\u0026lt;a[minIndex]){ minIndex=j; } } if(minIndex!=i){ int temp=a[i]; a[i]=a[minIndex]; a[minIndex]=temp; } } } 算法分析 稳定性：不稳定 时间复杂度 最佳：$O(n^2)$ 最差：$O(n^2)$ 平均：$O(n^2)$ 空间复杂度：$O(1)$ 插入排序 插入排序的原理类似于洗牌。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\n算法步骤 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤 2~5。 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static void insertionSort(int[] a) { int n=a.length; // 遍历n-1次 for(int i=1;i\u0026lt;n;i++){ // 从第i个元素开始,将当前元素插入到前面已经排好序的数组中 int preIndex=i-1; System.out.println(\u0026#34;preIndex: \u0026#34;+preIndex); int current=a[i]; System.out.println(\u0026#34;current: \u0026#34;+current); // 从后往前遍历,将大于current的元素后移一位 while(preIndex\u0026gt;=0\u0026amp;\u0026amp;current\u0026lt;a[preIndex]){ a[preIndex+1]=a[preIndex]; preIndex--; } a[preIndex+1]=current; } } 算法分析 稳定性 ：稳定 时间复杂度 ： 最佳：$O(n)$ （输入数组本身为有序） 最差：$O(n^2)$ （输入数组本身为倒序） 平均：$O(n^2)$ 空间复杂度 ：$O(1)$ 希尔排序 希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录 “基本有序” 时，再对全体记录进行依次直接插入排序。\n算法步骤 选择一个增量序列 $\\lbrace t_1, t_2, \\dots, t_k \\rbrace$，其中 $t_i \\gt t_j, i \\lt j, t_k = 1，t_1=length/2$； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 $t$，将待排序列分割成若干长度为 $m$ 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static void shellSort(int []a) { int n=a.length; // gap为增量,每次将数组分为gap个子数组,对每个子数组进行插入排序 for(int gap=n/2;gap\u0026gt;0;gap/=2) { for(int i=gap;i\u0026lt;n;i++) { int current=a[i]; int preIndex=i-gap; while(preIndex\u0026gt;=0 \u0026amp;\u0026amp; a[preIndex]\u0026gt;current) { a[preIndex+gap]=a[preIndex]; preIndex-=gap; } a[preIndex+gap]=current; } } } } 算法分析 稳定性：不稳定 时间复杂度 最佳：$O(nlogn)$， 最差：$O(n^2)$ 平均：$O(nlogn)$ 空间复杂度：$O(1)$ 归并排序 归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。归并排序的性能不受输入数据的影响，因为始终都是 $O(nlogn)$ 的时间复杂度。代价是需要额外的内存空间。\n算法步骤 归并排序算法是一个递归过程，边界条件为当输入序列仅有一个元素时，直接返回，具体过程如下： 如果输入内只有一个元素，则直接返回，否则将长度为 $n$ 的输入序列分成两个长度为 $n/2$ 的子序列； 分别对这两个子序列进行归并排序，使子序列变为有序状态； 设定两个指针，分别指向两个已经排序子序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间（用于存放排序结果），并移动指针到下一位置； 重复步骤 3 ~ 4 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public static int[] mergeSort(int []a) { // 递归结束条件 if (a.length \u0026lt;= 1) { return a; } // 将数组分为两部分 int middle = a.length / 2; int[] arr_1 = Arrays.copyOfRange(a, 0, middle); int[] arr_2 = Arrays.copyOfRange(a, middle, a.length); // 递归调用 return merge(mergeSort(arr_1), mergeSort(arr_2)); } public static int[] merge(int[] arr_1, int[] arr_2){ int[] sorted = new int[arr_1.length + arr_2.length]; int index=0; int index_1=0; int index_2=0; while(index_1\u0026lt;arr_1.length \u0026amp;\u0026amp; index_2\u0026lt;arr_2.length){ if(arr_1[index_1]\u0026lt;arr_2[index_2]){ sorted[index++]=arr_1[index_1++]; } else{ sorted[index++]=arr_2[index_2++]; } } if(index_1\u0026lt;arr_1.length){ for(int i=index_1;i\u0026lt;arr_1.length;i++){ sorted[index++]=arr_1[i]; } } if(index_2\u0026lt;arr_2.length){ for(int i=index_2;i\u0026lt;arr_2.length;i++){ sorted[index++]=arr_2[i]; } } return sorted; } 算法分析 稳定性：稳定\n时间复杂度\n最佳：$O(nlogn)$ 最差：$O(nlogn)$ 平均：$O(nlogn)$ 空间复杂度：$O(n)$\n快速排序 快速排序的基本思想：通过一趟排序将待排序列分隔成独立的两部分，其中一部分记录的元素均比另一部分的元素小，则可分别对这两部分子序列继续进行排序，以达到整个序列有序。\n算法步骤 从序列中挑出一个元素，做为 “基准”(pivot)； 重新排列序列，将所有比基准值小的元素摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个操作结束之后，该基准就处于数列的中间位置。 递归地把小于基准值元素的子序列和大于基准值元素的子序列进行快速排序 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public static void quickSort(int []a,int low,int high) { if(low\u0026lt;high) { int pi=partition(a,low,high); quickSort(a,low,pi-1); quickSort(a,pi+1,high); } } public static int partition(int []a,int low,int high) { int pivot=a[low]; int i=low; int j=high; while(i\u0026lt;j) { while(pivot\u0026lt;=a[j] \u0026amp;\u0026amp; i\u0026lt;j) { j--; } while(pivot\u0026gt;=a[i] \u0026amp;\u0026amp; i\u0026lt;j) { i++; } if(i\u0026lt;j) { int temp=a[i]; a[i]=a[j]; a[j]=temp; } } a[low]=a[i]; a[i]=pivot; return j; } 堆排序 算法步骤 将初始待排序列 $(R_1, R_2, \\dots, R_n)$ 构建成大顶堆，此堆为初始的无序区； 将堆顶元素 $R_1$ 与最后一个元素 $R_n$ 交换，此时得到新的无序区 $(R_1, R_2, \\dots, R_{n-1})$ 和新的有序区 $R_n$, 且满足 $R_i \\leqslant R_n (i \\in 1, 2,\\dots, n-1)$； 由于交换后新的堆顶 $R_1$ 可能违反堆的性质，因此需要对当前无序区 $(R_1, R_2, \\dots, R_{n-1})$ 调整为新堆，然后再次将 $R_1$ 与无序区最后一个元素交换，得到新的无序区 $(R_1, R_2, \\dots, R_{n-2})$ 和新的有序区 $(R_{n-1}, R_n)$。不断重复此过程直到有序区的元素个数为 $n-1$，则整个排序过程完成。 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public void shiftDown(int index,int heapSize){ while(getLeft(index)\u0026lt;heapSize){ int max=index; int left=getLeft(index); int right=getRight(index); if(left\u0026lt;heapSize\u0026amp;\u0026amp;heap.get(left)\u0026gt;heap.get(max)){ max=left; } if(right\u0026lt;heapSize\u0026amp;\u0026amp;heap.get(right)\u0026gt;heap.get(max)){ max=right; } if(max==index){ break; } swap(index,max); index=max; } } public void heapSort(){ buildHeap(); int size=heap.size(); for(int i=heap.size()-1;i\u0026gt;=0;i--){ swap(0,i); size--; shiftDown(0,size); } } 算法分析 稳定性：不稳定 时间复杂度 最佳：$O(nlogn)$ 最差：$O(nlogn)$ 平均：$O(nlogn)$ 空间复杂度：$O(1)$ ","date":"2024-10-21T10:05:19+08:00","permalink":"https://Tyritic.github.io/p/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","title":"排序算法"},{"content":"树的定义 树是是n（n≥0）结点的有限集合。n=0时，称为 空树 。任何一颗非空树只有一个根节点。\n树具有以下特点：\n一棵树中的任意两个结点有且仅有唯一的一条路径连通。 一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。 一棵树不包含回路。 树的常见概念 节点相关 节点 ：树中的每个元素都可以统称为节点。 根节点 ：顶层节点或者说没有父节点的节点。 父节点 ：若一个节点含有子节点，则这个节点称为其子节点的父节点。 子节点 ：一个节点含有的子树的根节点称为该节点的子节点。 兄弟节点 ：具有相同父节点的节点互称为兄弟节点。 叶子节点：没有子节点的节点。 深度和高度 节点的高度 ：该节点到叶子节点的最长路径所包含的边数 节点的深度 ：根节点到该节点的路径所包含的边数，根节点的深度默认为0 树的高度 ：树的高度等于根节点的高度，即根节点到叶子节点包含的边数 树的深度 ：树的深度等于叶子节点的深度，即根节点到叶子节点包含的边数，所有树的深度等于树的高度 二叉树 定义 每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构\n1 2 3 4 5 6 7 8 static class TreeNode{ int val; TreeNode left; TreeNode right; public TreeNode(int val){ this.val=val; } } 深度为k的二叉树的节点数为$[2^d,2^{d+1}-1]$\n最多节点（满二叉树）：$N=2^0+2^1+\u0026hellip;2^d=2^{d+1}-1$ 最少节点（最后一层只有一个节点）：$N=2^0+2^1+..2^{d-1}+1=2^d$ 分类 满二叉树 一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 满二叉树 。也就是说，如果一个二叉树的层数为 K，且结点总数是$2^k -1 $，则它就是 满二叉树 。\n完全二叉树 除最后一层外，若其余层都是满的，并且最后一层是满的或者是在右边缺少连续若干节点，则这个二叉树就是 完全二叉树 。\n二叉搜索树 对于每个节点X，它的左子树的所有项的值均小于X的元素值，右子树的所有项均大于X的元素值\n若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值 平衡二叉树 平衡二叉树 是一棵二叉搜索树，且具有以下性质：\n可以是一棵空树 如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。 树的基本操作 遍历元素 前序遍历 二叉树的前序遍历，就是先输出根结点，再遍历左子树，最后遍历右子树，遍历左子树和右子树的时候，同样遵循先序遍历的规则。通常通过递归实现前序遍历。\n1 2 3 4 5 6 7 8 public void preOrder(TreeNode root){ if(root == null){ return; } system.out.println(root.data); preOrder(root.left); preOrder(root.right); } 中序遍历 二叉树的中序遍历，就是先递归中序遍历左子树，再输出根结点的值，再递归中序遍历右子树\n1 2 3 4 5 6 7 8 public void inOrder(TreeNode root){ if(root == null){ return; } inOrder(root.left); system.out.println(root.data); inOrder(root.right); } 后序遍历 二叉树的后序遍历，就是先递归后序遍历左子树，再递归后序遍历右子树，最后输出根结点的值\n1 2 3 4 5 6 7 8 public void postOrder(TreeNode root){ if(root == null){ return; } postOrder(root.left); postOrder(root.right); system.out.println(root.data); } 层序遍历 层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。通常使用队列实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public void solver(TreeNode node) { if (node == null) return; Queue\u0026lt;TreeNode\u0026gt; que = new LinkedList\u0026lt;TreeNode\u0026gt;(); que.offer(node); while (!que.isEmpty()) { List\u0026lt;Integer\u0026gt; itemList = new ArrayList\u0026lt;Integer\u0026gt;(); int len = que.size(); while (len \u0026gt; 0) { TreeNode tmpNode = que.poll(); itemList.add(tmpNode.val); if (tmpNode.left != null) que.offer(tmpNode.left); if (tmpNode.right != null) que.offer(tmpNode.right); len--; } resList.add(itemList); } } 插入元素 通常插入元素的时间复杂度为$O(h)$\n对于二叉搜索树 最坏情况：此时二叉搜索树退化为链表，时间复杂度为$O(n)$ 最好情况：此时二叉搜索树是平衡的，时间复杂度为$O(logn)$ 因此可以通过二叉树的平衡操作来减少二叉树的深度\n删除元素 删除节点有以下几种情况\n左右孩子都为空（叶子节点） ：直接删除节点， 返回NULL为根节点 删除节点的左孩子为空，右孩子不为空 ：删除节点，右孩子补位，返回右孩子为根节点 删除节点的右孩子为空，左孩子不为空 ：删除节点，左孩子补位，返回左孩子为根节点 左右孩子节点都不为空 ：将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public TreeNode deleteNode(TreeNode root, int key) { if(root==null) return null; if(root.val==key) { if(root.left==null) return root.right; else if(root.right==null) return root.left; else { TreeNode curr=root.right; while(curr.left!=null) curr=curr.left; curr.left=root.left; root=root.right; return root; } } if(root.val\u0026gt;key) root.left=deleteNode(root.left,key); else root.right=deleteNode(root.right,key); return root; } B树 定义 B 树是一种 自平衡的多路搜索树（multi-way search tree）\nB树单一节点拥有的最多子节点数量，称为B树的 阶 。一个m阶的B树，树的节点具有以下特征\n子节点个数和元素个数\n根节点\n元素的个数：$[1,m-1]$ 子节点的个数：$[2,m]$ 中间节点\n元素个数：$[\\lceil m/2 \\rceil-1,m-1]$ 子节点的个数：$[\\lceil m/2 \\rceil,m]$ 每个节点的子节点个数和元素个数满足关系$子节点个数=元素个数+1$\n所有的叶子节点都位于同一层。\n每个节点中的元素从小到大排列，非叶子节点存储数据和索引\n插入操作 定位：找出插入该关键字的最低层中某个非叶结点（在B树中查找key时，会找到表示查找失败的叶节点，这样就确定了最底层非叶结点的插入位置。注意：插入位置一定是最底层中的某个非叶结点）。 插入。在B树中，每个非失败结点的关键字个数都在区间内。插入后的结点关键字个数小于m，可以直接插入；插入后检查被插入结点内关键字的个数，当插入后的结点关键字个数大于m-1时，必须对结点进行分裂。 分裂的方法：取一个新结点，在插入key后的原结点，从中间位置$\\lceil m/2 \\rceil$将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放在新结点中，中间位置$\\lceil m/2 \\rceil$的结点插入原结点的父结点。若此时导致父结点的关键字个数也超过上限，则继续进行这种分裂操作，直至这个过程传到根节点为止，进而导致B树的高度增1。 删除操作 B树中的删除操作与插入操作类似，但是只需讨论删除终端结点（最底层非叶结点）中关键字的情形，因为当被删关键字k不在终端结点可以转换为在终端节点的情况\n直接删除：若被删除关键字所在结点的关键字个数$≥\\lceil m/2 \\rceil$，说明删除该关键字后仍满足B树的定义，则直接删去该关键字 兄弟够借：若被删除关键字在你所在结点删除前的关键字个数为$\\lceil m/2 \\rceil-1$，且与此结点相连的右（或左）兄弟结点的关键字个数$≥\\lceil m/2 \\rceil$，则需要调整该结点、右（或左）兄弟结点及其双亲结点父子交换，以达到新的平衡。 兄弟不够借。若被删除关键字所在结点删除前的关键字个数为$\\lceil m/2 \\rceil-1$，且此时与该结点相邻的左、右兄弟结点的关键字个数均为$\\lceil m/2 \\rceil-1$，则将关键字删除后与左或者右兄弟结点进行合并 B+树 定义 每个分支结点最多有m棵子树（孩子结点）\n非叶根节点至少有两棵子树，其他每个分支结点至少有$\\lceil m/2 \\rceil$棵子树。\n在B+树中，每个结点（非根内部结点）的关键字个数n的范围$[\\lceil m/2 \\rceil,m]$；\n在B树中，每个结点（非根内部结点）的关键字个数n的范围是$[\\lceil m/2 \\rceil-1,m-1]$。\n结点的子树个数与关键字个数相等。\n所有叶结点包含全部关键字及指向对应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序互联链接起来。\n所有分支结点（可视为索引的索引）中仅仅包含它的各个子结点（即下一级的索引块）中关键字的最大值及指向子结点的指针。\n堆 定义 堆的本质是一个二叉树。与二叉树的区别在于：对于这颗二叉树而言，任何一个子树 根节点上的数据和孩子节点上的数据之间是存在大小关系。\n大顶堆 ：根节点上的数据 大于或者等于 左右两个孩子 小顶堆 ：根节点上的数据 小于或者等于 左右两个孩子 相关操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 List\u0026lt;Integer\u0026gt;heap; MyHeap(){ this.heap=new ArrayList\u0026lt;\u0026gt;(); } MyHeap(ArrayList\u0026lt;Integer\u0026gt;heap){ this.heap=heap; } public int getLeft(int index){ return 2*index+1; } public int getRight(int index){ return 2*index+2; } public int getParent(int index){ return (index-1)/2; } public void swap(int left,int right){ int temp=heap.get(right); heap.set(right,heap.get(left)); heap.set(left,temp); } 插入操作 以大顶堆为例，需要对堆的叶子节点进行向上调整，使得堆符合定义。\n将元素插入到数组尾部中 对数组尾部的元素进行向上调整 比较插入节点和它的父亲节点，如果插入节点比其父亲节点大则交换位置 继续迭代往上判断，直到 父节点比它大或者到达树的顶部 1 2 3 4 5 6 7 8 9 10 public void shiftUp(int index){ while(index\u0026gt;0\u0026amp;\u0026amp;heap.get(index)\u0026gt;heap.get(getParent(index))){ swap(index,getParent(index)); index=getParent(index); } } public void push(int val){ heap.add(val); shiftUp(heap.size()-1); } 删除操作 堆的删除只会删除堆顶的元素，因此需要对堆的根节点进行向下调整使得堆满足定义。对大顶堆来说\n将数组尾部的元素放入数组顶部并删除数组顶部 对数组头部进行向下调整 选取空穴的左右子节点中比较小的节点，与空穴进行交换 继续迭代向下判断，直到空穴位于叶子节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public void shiftDown(int index,int heapSize){ while(getLeft(index)\u0026lt;heapSize){ int max=index; int left=getLeft(index); int right=getRight(index); if(left\u0026lt;heapSize\u0026amp;\u0026amp;heap.get(left)\u0026gt;heap.get(max)){ max=left; } if(right\u0026lt;heapSize\u0026amp;\u0026amp;heap.get(right)\u0026gt;heap.get(max)){ max=right; } if(max==index){ break; } swap(index,max); index=max; } } public int pop(){ if(heap.isEmpty()){ return Integer.MIN_VALUE; } int res=heap.get(0); int last=heap.remove(heap.size()-1); if(!heap.isEmpty()){ heap.set(0,last); shiftDown(0,heap.size()); } return res; } 建立堆 向下调整建立堆 时间复杂度为$O(nlogn)$\n找到最后一个父节点，将该父节点进行向下调整 依次对所有的父节点进行向下调整 1 2 3 4 5 6 public void buildHeap(){ int n=heap.size(); for(int i=(n-2)/2;i\u0026gt;=0;i--){ shiftDown(i,heap.size()); } } 堆排序和Top K问题 升序使用大顶堆，降序使用小顶堆，时间复杂度为$O(nlogn)$\n堆排序的过程如下（以升序排序为例）\n提取大顶堆的堆顶元素 将当前最大的元素与末尾元素进行交换 重新调整剩余元素形成新的堆 循环往复直到堆中没有元素 1 2 3 4 5 6 7 8 9 public void heapSort(){ buildHeap(); int size=heap.size(); for(int i=heap.size()-1;i\u0026gt;=0;i--){ swap(0,i); size--; shiftDown(0,size); } } TOP K问题：比如说现在有10亿个数据，要选出其中最大的K个数，应该怎么选？\n我们可以建一个容量为K的小根堆，然后先把前K个数据丢到堆里，之后依次遍历剩余的数据，将比堆顶大的数据代替堆顶进堆。\n","date":"2024-10-20T17:33:36+08:00","permalink":"https://Tyritic.github.io/p/%E6%A0%91/","title":"树"},{"content":"顺序表 数组 定义 数组由相同类型的元素（element）组成，并且是使用一块连续的内存来存储。直接可以利用元素的索引（index）可以计算出该元素对应的存储地址。\n特点\n提供随机访问 ：可以利用元素的索引访问元素 容量固定 插入和删除元素较慢 基本操作 访问特定元素：$O(1)$ 插入元素：$O(n)$ 最好情况：在表尾插入元素，时间复杂度为 $O(1)$ 最坏情况：发生在插入发生在数组的首部，此时需要移动所有元素，时间复杂度为$O(n)$ 删除元素：$O(n)$ 最好情况：在表尾删除元素，时间复杂度为 $O(1)$ 最坏情况：发生在删除发生在数组的首部，此时需要移动所有元素，时间复杂度为$O(n)$ 单链表 定义 **单链表 ** 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。单链表只有一个方向，结点只有一个后继指针 next 指向后面的节点，通过连续的节点组成，但是节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上。链表通常有一个不保存任何值的 head 节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null。\n1 2 3 4 5 6 7 static class ListNode{ int val; ListNode next; public ListNode(int val){ this.val=val; } } 特点\n不提供随机访问 ：每次访问元素需要遍历链表 容量不固定 插入和删除元素速度快 基本操作 访问特定元素：$O(n)$ 插入元素：$O(1)$ 找到要插入位置的前驱节点 pre 和后驱节点 temp=pre.next 前驱节点 pre 指向目标节点 target ：pre.next=target 目标节点指向后驱节点 temp ：target.next=temp 删除元素：$O(1)$ 找到要删除位置的前驱节点 pre 将前驱节点 pre 指向目标节点的后驱节点：pre.next=pre.next.next 双向链表 定义 基本定义与单链表一致，但是 双向链表 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。因此双向链表支持反向遍历\n基本操作 访问元素 插入元素：$O(1)$ 找到要插入位置的前驱节点 pre 和后驱节点 temp=pre.next 前驱节点 pre 和目标节点 target 建立双向链接 pre.next=target target.prev=pre 目标节点 target 和后驱节点 temp 建立双向链接 target.next=temp temp.prev=target 删除元素：$O(1)$ 找到要删除位置的前驱节点 pre 将前驱节点 pre 指向目标节点的后驱节点 temp 建立双向联系 pre.next=temp temp.prev=pre 数组和链表的区别 访问效率 数组可以通过索引直接访问任何位置的元素，访问效率高，时间复杂度为$O(1)$， 链表需要从头节点开始遍历到目标位置，访问效率较低，时间复杂度为$O(n)$。 插入和删除效率 数组插入和删除操作需要移动其他元素，时间复杂度为$O(n)$ 链表只需要修改指针指向，时间复杂度为$O(1)$。 缓存命中率 数组元素在内存中连续存储，可以提高CPU缓存的命中率 链表节点不连续存储，可能导致CPU缓存的命中率较低，频繁的缓存失效会影响性能。 应用场景 数组适合静态大小、频繁访问元素的场景 链表适合动态大小、频繁插入、删除操作的场景 栈 定义 栈 (Stack) 只允许在有序的线性数据集合的一端（栈顶）进行加入数据（入栈）和移除数据（出栈）。因而按照 后进先出（LIFO, Last In First Out） 的原理运作。在栈中，push 和 pop 的操作都发生在栈顶。 在Java中栈一般由Stack类实现，而且栈顶一般为数组末端\n基本操作 访问元素 ：需要遍历元素，时间复杂度为$O(n)$ 入栈和出栈 ：只对栈顶的元素进行操作，时间复杂度为$O(1)$ 常见应用场景 浏览器的回退和前进 可以使用两个栈来实现浏览器的回退和前进。一个栈Stack1用于保存当前浏览的界面，另一个栈Stack2用于回退的页面。\n前进页面：将页面从 Stack2 弹出，然后压入到 Stack1 中 回退页面：把页面从 Stack1 弹出，然后压入 Stack2 中。 队列 定义 队列（Queue） 是 先进先出 (FIFO，First In, First Out) 的线性表。队列只允许在后端（队尾）进行插入操作（入队），在前端（队头）进行删除操作（出队）。在Java中队列由Queue的实现类来实现，队尾为数组后端，队头为数组前端\n基本操作 访问元素 ：需要遍历元素，时间复杂度为$O(n)$ 入队和出队 ：只对队头和队尾的元素进行操作，时间复杂度为$O(1)$ 栈和队列的相互转换 栈实现队列 使用两个栈，一个栈为输入栈，另一个栈为输出栈。\n入队：将元素压入输入栈。 出队：先判断输出栈是否为空，如果不为空，则直接弹出栈顶元素；如果为空，则将输入栈中的所有元素依次弹出并压入输出栈中，然后再从输出栈中弹出栈顶元素作为出队元素。 查询队首元素时，同样需要先将输入栈中的元素转移到输出栈中，然后取出的输出栈顶元素但不弹出。 队列实现栈 使用一个栈可以实现队列。\n入栈：先入队然后将队列中的元素（除了最后一个）依次出队再入队（相当于反转一次） 出栈：直接出队 查询栈顶元素：直接返回队首元素 ","date":"2024-10-19T15:57:38+08:00","permalink":"https://Tyritic.github.io/p/%E7%BA%BF%E6%80%A7%E8%A1%A8/","title":"线性表"},{"content":"传输层的作用 主要职责 ：负责不同主机的进程间通信\n功能\n拥塞控制 ：防止整个网络因负载过大而崩溃 流量控制 ：协调发送速率和接受速率 提供端到端服务 ：不同主机之间的进程通信 常见协议\nTCP ：面向连接的可靠传输服务 UDP ：非面向连接的不可靠传输服务 多路复用和多路分解 多路分解 ：在接收端，传输层检测报文的字段，识别出接受端的socket，进而将报文段定向并正确交付到对应的socket中 多路复用 ：源主机从不同的socket收集数据块，并将数据报封装首部信息，从而生成报文段。然后将报文段交付到网络层 无连接的多路复用和多路分解 通过UDP套接字分配特定端口\nUDP套接字的格式（目的IP，目的端口号）\n有连接的多路复用和多路分解 通过TCP套接字分配端口\nTCP套接字的格式（源IP，源端口号，目的IP，目的端口号）\n面向连接的可靠传输—TCP协议 TCP是一个传输层协议，提供可靠传输，支持全双工，是一个连接导向的协议。数据任何时候都可以双向传输。\nTCP的主要特点 面向连接 ：双方传输数据之前，必须先建立一条通道 可靠传输 ：TCP提供可靠的传输服务。传送的数据无差错、不丢失、不重复、按序到达，通过确认（ACK）、重传机制以及序列号，TCP 能够保证数据在不可靠的 IP 网络上可靠传输。 面向字节流 ：虽然应用程序与TCP交互是一次一个大小不等的数据块，但TCP把这些数据看成一连串无结构的字节流，它不保证接收方收到的数据块和发送方发送的数据块具有对应大小关系， 差错检测 ：发现差错会重发报文段 拥塞控制 ：TCP 通过拥塞避免算法（如慢启动、拥塞避免、快速重传和快速恢复）来防止网络过载，协调整个网络的流量，使得每条TCP连接共享带宽 流量控制 ：TCP 通过滑动窗口机制调节发送方的数据发送速率，防止接收方因为处理能力有限而被数据流淹没。 TCP报文格式 报文段 = 首部 + 数据\n首部 ：最小长度 20 字节\n源端口号和目的端口号 ：对应用层数据进行多路复用和多路分解\n序列号 seq ：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就累加一次该「数据字节数」的大小。用来解决网络包乱序问题。\n确认号 ack ：指下一次期望收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。\n控制位\nACK：该位为 1 时，确认应答的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。 RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。 端口未监听：当主机接收到一个发往没有在监听的端口的 TCP 数据包时，会回复一个 RST 报文来告知发送方该端口不可用。 连接异常关闭后：如果一方出现崩溃、强制退出或被其他因素干扰导致连接中断，TCP 会使用 RST 报文来通知对方连接已无法继续。（例如服务端断电重启后，客户端再次通过之前的连接请求，就会被返回一个 RST）。 数据包冲突：当某一方接收到的序列号不在预期范围内时，可能会发送 RST 报文以重置连接。 重置无效的连接请求：当主机收到与当前连接状态不符的请求时，例如在未建立连接时收到 FIN 报文，会发送 RST 报文表示无效。 SYN：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。 FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。 窗口：滑动窗口大小，用来告知发送端接收端缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。\n校验和：奇偶校验，此校验和是对整个的TCP报文段（包括TCP头部和TCP数据），以16位进行计算所得，由发送端计算和存储，接收端进行验证。\n数据\nTCP粘包，拆包 现象描述 粘包 ：在 TCP 传输中，发送方的多个数据包在接收方被合并成一个包接收，导致多条消息数据粘在一起，接收方无法正确区分这些消息的边界。 拆包 ：发送方的一个数据包在接收方被分成了多个包接收，导致一条完整的消息被拆成多个部分，接收方无法一次性接收到完整的数据。 出现原因 粘包 ：TCP是面向字节流的协议，把上层应用层的数据看成字节流，所以它发送的不是固定大小的数据包，TCP协议也没有字段说明发送数据包的大小。数据在发送方可能被一次性发送，接收方在读取时可能会将多个消息拼接在一起。 拆包 ：由于网络传输中的 MTU（最大传输单元）限制或发送缓冲区大小限制，一个大包被分成了多个小包传输。 解决方案 消息定长 ：每个发送的数据包大小固定，不足的部分用空格补充，接受方取数据的时候根据这个长度来读取数据 消息末尾增加换行符来表示一条完整的消息 ：接收方读取的时候根据换行符来判断是否是一条完整的消息，如果消息的内容也包含换行符，那么这种方式就不合适了。 使用消息头 ：在消息的头部添加一个长度字段，指示消息的长度，接收方根据这个长度来读取相应长度的数据。（UDP的设计方法） TCP连接的基本认识 TCP 为每个数据流初始化并维护的某些状态信息（这些信息包括 socket、序列号和窗口大小），称为连接。\n建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识。\nSocket：由 IP 地址和端口号组成，是通信的端点 序列号：用来解决乱序问题，帮助于接收方按顺序重组数据包，并检测丢包情况 窗口大小：用来做流量控制 TCP连接的唯一确定 TCP 四元组可以唯一标识一个连接\n源地址 源端口 目的地址 目的端口 提示\nTCP 三元组\n三元组指的是 IP 地址和端口号的组合，即 IP 地址 + 端口号 + 协议类型。例如，192.168.1.1:8080 (TCP) 就是一个三元组。在一个机器上，这样的组合唯一标识了一个网络服务或应用程序。\nTCP连接的建立—三次握手 握手过程 握手前\n客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端口，处于 LISTEN 状态 第一次握手\n客户端向服务端发送特殊的TCP报文段（SYN报文段），该报文段被封装到IP数据报中，客户端处于 SYN-SENT 状态，表示向服务端发起连接，并告知服务器自己的初始序列号\nSYN 报文段结构\n客户端随机初始化序号（client_isn），设为x，填入序列号\nSYN 字段置为1\n报文段不包含数据\n第二次握手\n服务端接收到 SYN 报文段，为TCP连接分配TCP缓存和变量，并向客户端发送允许连接的报文段 (SYN + ACK) ，服务端处于 SYN-RCVD 状态，表示的连接请求被接受了，并通知客户端自己的初始序列号。 SYN+ACK 报文段结构 服务端随机初始化自己的序号（ server_isn ）设为y，填入序列号 将确认应答号 ack 置为 client_isn + 1 SYN和ACK字段置为1 不携带数据 ​\t提示\n第二次握手为什么要传回ACK和SYN\nACK：是第一次握手的确认报文，告知客户端从客户端到服务端的通信是正常的，服务端正确接收到客户端的信息 SYN：建立并确认从服务端到客户端的通信 ​\n第三次握手 客户端收到服务端报文后，为TCP连接分配缓存和变量，客户端向服务端发送确认连接的报文（ACK报文），客户端处于 ESTABLISHED 状态。服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态 ACK报文结构 将确认应答号 ack 置为 server_isn + 1 将 ACK 字段置为1 报文可以携带数据 三次握手的必要性 三次握手才可以阻止重复历史连接的初始化（主要原因） 一个「旧 SYN 报文」比「最新的 SYN」 报文早到达了服务端，那么此时服务端就会回一个 SYN + ACK 报文给客户端，此报文中的确认号是 旧的SYN报文中的ISN+1 。（第二次挥手） 客户端收到后，发现自己期望收到的确认号应该是 新的SYN报文中的ISN+1 ，于是就会回 RST 报文。（第三次握手） 服务端收到 RST 报文后，就会释放连接。 后续最新的 SYN 抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。 三次握手才可以同步双方的初始序列号 当客户端发送携带初始序列号的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收。 当服务端发送初始序列号给客户端的时候，依然也要得到客户端的应答回应 三次握手只是将服务端的ACK报文和SYN报文合为一步 三次握手可以避免资源浪费 如果没有第三次握手，服务端不清楚客户端是否收到了自己回复的 ACK 报文 。如果客户端发送的 SYN 报文在网络中阻塞了，重复发送多次 SYN 报文，那么服务端在收到请求后就会 建立多个冗余的无效链接，造成不必要的资源浪费。 提示\nTCP连接为什么不设计成两次握手\n两次握手的形式\n客户端 → SYN → 服务器。 服务器 → ACK → 客户端。 不设计为两次握手的原因\n两次握手无法阻止重复历史连接的初始化\n在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费。 服务端在收到 SYN 报文后，就进入 ESTABLISHED 状态，意味着这时可以给对方发送数据，但是客户端此时还没有进入 ESTABLISHED 状态。 假设这次是历史连接，客户端判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而服务端在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接。 服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，浪费了服务端的资源。 两次握手无法保持序列化的同步，只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。\n服务端确认了客户端的初始序列号但是客户端无法确认服务端的序列化。后续数据传输可能因序列号不同步而混乱。 两次握手无法无法确认双向通信\n服务器发送 ACK 后，认为连接已建立，但客户端可能未收到 ACK（例如网络丢包）。 客户端无法确认服务器的接收能力，服务器也无法确认客户端是否收到 ACK。 两次握手无法识别历史连接\n如果握手只有两次，那么接收方应对发送方的请求只能拒绝或者接受，但是它无法识别当前的请求是旧的请求还是新的请求。由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 ACK 报文，所以服务端每收到一个 SYN 就只能先主动建立一个连接。 如果客户端发送的 SYN 报文在网络中阻塞了，重复发送多次 SYN 报文，那么服务端在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。 初始序列号ISN 作用\n为了防止历史报文被下一个相同四元组的连接接收 当客户端和服务端中出现连接中断，若客户端又与服务端建立了与上一个连接相同四元组的连接，上一个连接中被网络阻塞的数据包正好抵达了服务端，刚好该数据包的序列号正好是在服务端的接收窗口内，所以该数据包会被服务端正常接收，就会造成数据错乱。 为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收 生成过程\n初始序列号 ISN 是以时间戳为基础生成的。\n握手丢失 第一次握手丢失（客户端发送SYN报文丢失）：客户端触发超时重传机制 服务端：不会进行任何的动作 客户端：发完SYN报文后处于 SYN_SENT 状态。由于一段时间内没有收到服务端发来的确认报文，等待一段时间后会重新发送 SYN 报文（ 重传的 SYN 报文的序列号都是一样的 ），如果仍然没有回应，会重复这个过程，直到发送次数超过最大重传次数限制，就会返回连接建立失败。 第二次握手丢失（服务端发送SYN+ACK报文丢失）：客户端和服务端均触发超时重传机制 客户端：第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是 客户端就会触发超时重传机制，重传 SYN 报文（第一次握手） 。 服务端：第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是 服务端这边会触发超时重传机制，重传 SYN-ACK 报文（第二次握手） 。 第三次握手丢失（客户端发送的ACK报文丢失）：服务端触发超时重传机制 客户端：发完SYN报文后处于 ESTABLISHED 状态 服务端：第三次握手的 ACK 报文是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。 TCP半连接 TCP 半连接指的是在 TCP 三次握手过程中，服务器接收到了客户端的 SYN 包，但还没有完成第三次握手，此时的连接处于一种未完全建立的状态。\n半连接队列和全连接队列\nTCP 进入三次握手前，服务端会从 CLOSED 状态变为 LISTEN 状态, 同时在内部创建了两个队列：半连接队列（SYN 队列）和全连接队列（ACCEPT 队列）。\n半连接队列存放的是三次握手未完成的连接，全连接队列存放的是完成三次握手的连接\n客户端发送 SYN 到服务端，服务端收到之后，便回复 ACK 和 SYN，状态由 LISTEN 变为 SYN_RCVD，此时这个连接就被推入了 SYN 队列，即半连接队列。 当客户端回复 ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入 ACCEPT 队列，即全连接队列。 SYN洪泛攻击 实现原理\nSYN 洪泛 是一种拒绝服务攻击（DoS）。攻击者伪造不存在的 IP 地址, 向服务器发送大量 SYN 报文。当服务器回复 SYN+ACK 报文后，不会收到 ACK 回应报文，那么 SYN 队列里的连接旧不会出对队，久⽽久之就会占满服务端的 SYN 接收队列（半连接队列），使得服务器不能为正常⽤户服务。\n应对策略\nsyn cookie：在收到 SYN 包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个 cookie 值作为自己的 SYNACK 包的序列号，回复 SYN+ACK 后，服务器并不立即分配资源进行处理，等收到发送方的 ACK 包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。 SYN Proxy 防火墙：服务器防火墙会对收到的每一个 SYN 报文进行代理和回应，并保持半连接。等发送方将 ACK 包返回后，再重新构造 SYN 包发到服务器，建立真正的 TCP 连接。 TCP连接的断开—四次挥手 挥手过程 第一次挥手 客户端主动关闭连接，发送 FIN 包。服务器收到 FIN 后，表示不再接收数据，但仍可能继续发送数据。 客户端进入 FIN_WAIT_1 状态 第二次挥手 服务器发送 ACK 包，确认已收到 FIN。在收到 FIN 报文的时候，TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，服务端应用程序可以通过 read 调用来感知这个 FIN 包，这个 EOF 会被放在已排队等候的其他已接收的数据之后，所以必须要得继续 read 接收缓冲区已接收的数据； 双方状态 服务器进入 CLOSE_WAIT 状态 客户端进入 FIN_WAIT_2 状态。 第三次挥手 服务器完成所有数据传输后，发送 FIN 包。客户端收到 FIN 后，准备关闭连接。 服务端进入 LAST_ACK 状态 第四次挥手 客户端发送最后一个 ACK 包，并等待可能迟到的 FIN 包。服务器收到 ACK 后，关闭连接。客户端在 TIME_WAIT 计时结束后（2MSL），正式关闭连接。 双方状态 服务端进入 CLOSED 状态 客户端进入 TIME_WAIT 状态 四次挥手的必要性 主要是为了确保数据完整性。\nTCP 是一个全双工协议，也就是说双方都要关闭，每一方都向对方发送 FIN 和回应 ACK。\n客户端发起连接断开，代表客户端没数据要发送的，但是服务端可能还有数据没有返回给客户端。\n所以一个 FIN + ACK 代表一方结束数据的传输，因此需要两对 FIN + ACK，加起来就是四次通信。\n提示\n四次挥手变成三次挥手的情况\n如果客户端发送 FIN 给服务端的时候服务端已经没数据发送给客户端了并且开启了 TCP 延迟确认机制，那么服务端就可以将 ACK （第二次挥手）和它的 FIN（第三次挥手） 合并传输 一起发给客户端，这样一来就变成三次挥手\nTCP延迟确认机制\n当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。 为了解决 ACK 传输效率低问题，所以就衍生出了 TCP 延迟确认。 TCP 延迟确认的策略：\n当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方 当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送 如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK 挥手丢失 第一次挥手丢失 客户端：迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制 重传 FIN 报文（第一次握手），重发次数由 tcp_orphan_retries 参数控制。 当客户端重传 FIN 报文的次数超过 tcp_orphan_retries 后，就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍） 服务端：不会有任何动作 第二次挥手丢失 客户端：就会触发超时重传机制 重传 FIN 报文（第一次报文），直到收到服务端的第二次挥手，或者达到最大的重传次数。 已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK 报文），那么客户端就会断开连接。 服务端：不会有任何动作 第三次挥手丢失 服务端：触发重传机制 重发 FIN 报文，重发次数仍然由 tcp_orphan_retries 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。 当服务端重传第三次挥手报文的次数达到了 3 次后，由于 tcp_orphan_retries 为 3，达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK报文），那么服务端就会断开连接。 客户端：处于 FIN_WAIT_2 状态是有时长限制的，如果 tcp_fin_timeout 时间内还是没能收到服务端的第三次挥手（FIN 报文），那么客户端就会断开连接 第四次挥手丢失 服务端：触发重传机制 当服务端重传第三次挥手报文达到 2 时，由于 tcp_orphan_retries 为 2， 达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。 客户端：进入 TIME_WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。 TIME_WAIT状态 作用\n保证被动关闭连接的一方，能被正确的关闭： TIME_WAIT 状态中，客户端可以重新发送 ACK 确保对方正常关闭连接。 在 TCP 四次挥手过程中，主动关闭连接的一方在发送最后一个 ACK 确认包后进入 TIME_WAIT 状态。 如果这个 ACK 丢失了，另一方（被动关闭连接的一方）没有收到确认包，会重发 FIN 报文。主动关闭的一方需要在 TIME_WAIT 状态下保持一段时间，以便能够重发 ACK，确保连接能被正确地关闭。 防止历史连接中的数据，被后面相同四元组的连接错误的接收：在 TIME_WAIT 持续的 2MSL 时间后，确保旧数据包完全消失，避免它们干扰未来建立的新连接。 TCP 连接在关闭后，可能会有一些延迟的或者已经失效的报文还在网络中传输。如果立即重新使用相同的 IP 地址和端口建立新的连接，可能会受到这些旧报文的干扰。 TIME_WAIT 状态可以确保在旧连接的所有报文都超时失效后，才允许新的连接使用相同的 IP 地址和端口，从而避免数据混乱。 提示\n为什么 TIME_WAIT 等待时间为2MSL\nMSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。\n网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以 一来一回需要等待 2 倍的时间。\nTIME_WAIT状态过多的危害\n占用系统资源：比如文件描述符、内存资源、CPU 资源、线程资源等； 占用端口资源：端口资源也是有限的 原因\nHTTP 没有使用长连接 大量HTTP 长连接超时 单条HTTP 长连接的请求数量达到上限 解决方案\n打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项：复用处于 TIME_WAIT 的 socket 为新的连接所用。 net.ipv4.tcp_max_tw_buckets：当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置 程序中使用 SO_LINGER ，应用强制使用 RST 关闭。 CLOSE_WAIT状态 CLOSE_WAIT状态的作用\n支持半关闭状态：TCP 是全双工协议，发送和接收通道独立。 允许服务器在收到 FIN 后继续发送剩余数据。 半关闭状态确保服务器能优雅地完成任务。 确保被动方控制关闭时机 给服务器缓冲时间，应用程序决定何时发送 FIN。 避免数据丢失，保证关闭的可靠性。 防止数据丢失 服务器在 CLOSE_WAIT 期间处理剩余数据并发送。 确保数据传输完整性。 连接的强制断开 RST（Reset）标志： 使用 TCP RST 标志可以强制立即终止连接。发送方可以直接发送带有 RST 标志的 TCP 报文，通知对方立即断开连接。 超时（Timeout）： 如果连接一段时间内没有任何数据包传输，连接双方可以依据设定的超时时间自动断开连接。 TCP的可靠传输原理 检验和 TCP 报文段包括一个校验和字段，用于检测报文段在传输过程中的变化。如果接收方检测到校验和错误，就会丢弃这个报文段\n重传机制和序列号确认机制 序列号/确认机制：TCP 将数据分成多个小段，每段数据都有唯一的序列号，以确保数据包的顺序传输和完整性。同时，发送方如果没有收到接收方的确认应答，会重传数据。\n重传机制 ：用于防止数据包的丢失。\n超时重传：发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据 发生条件 数据包丢失：发送方重新发送数据包 确认应答丢失：发送方重新发送数据包 快速重传：发送方连续收到三次相同 ACK，会在定时器过期之前，重传丢失的报文段。 SACK方法 ：带选择确认的重传\n传统的 TCP 使用累计确认（Cumulative ACK）机制，只能确认到达的连续数据段，无法有效告知发送方中间某些数据段的丢失或乱序情况。结果是发送方只能依赖超时或重复 ACK 来重传数据，这可能导致不必要的重传，浪费带宽，降低效率。\nSACK可以将已收到的数据的信息发送给「发送方」，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。\n通过 ACK 告知我接下来要 5500 开始的数据，并一直更新 SACK，6000-6500 收到了，6000-7000的数据收到了，6000-7500的数据我收到了，发送方很明确的知道，5500-5999 的那一波数据应该是丢了，于是重传。\n滑动窗口机制 TCP 滑动窗口机制的主要作用是实现流量控制（Flow Control），即协调发送方和接收方的数据传输速率，确保发送方不会发送超出接收方处理能力的数据量，防止接收端缓冲区溢出。\n滑动窗口允许发送方在未收到前一个数据包的确认（ACK）前继续发送多个数据包，从而提高网络吞吐量，减少等待时间，实现高效的数据流传输。\n累计确认机制：图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。\n拥塞控制 慢启动： 发送方在连接建立初期，缓慢地增加数据发送速率。初始的拥塞窗口（cwnd）通常为一个 MSS（最大报文段大小），然后在每次收到 ACK 后成倍增加 cwnd，直到达到慢启动阈值（ssthresh）或检测到网络拥塞。 拥塞避免 当 cwnd 达到 ssthresh 后，TCP 进入拥塞避免阶段，拥塞窗口的增长速度从指数变为线性增长，即每个 RTT（往返时间）增加一个 MSS。这一阶段旨在避免激烈的拥塞反应，保持网络稳定性。 拥塞发生 当网络出现拥塞，也就是会发生数据包重传 超时重传 ssthresh 设为 cwnd/2， cwnd 重置为 1 （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1） 快速重传 cwnd = cwnd/2 ，也就是设置为原来的一半; ssthresh = cwnd; 快速恢复（Fast Recovery） 在快速重传后，TCP 不进入慢启动，而是减小 cwnd 到当前的一半，并设置 ssthresh 为当前新的 cwnd 的值，然后开始线性增加 cwnd，以快速恢复到丢包前的传输速率。 保活机制 如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。 如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。 如果对端主机宕机（注意不是进程崩溃，进程崩溃后操作系统在回收进程资源的时候，会发送 FIN 报文，而主机宕机则是无法感知的，所以需要 TCP 保活机制来探测对方是不是发生了主机宕机），或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。 提示\nHTTP Keep-Alive 和 TCP Keep-Alive\nHTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由 应用程序 实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。 TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由 内核 实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。 非面向连接的不可靠传输-UDP协议 UDP的主要特点 非面向连接 ：进程之间通信之前没有握手过程，而是将带有目的地址的报文放入线路 不可靠服务 ：不确保报文段按序交付，不保证报文的完整性 不提供拥塞控制和流量控制 使用场景：实时通讯、语音、视频、游戏等高性能要求应用 面向报文段 UDP报文结构 报文段结构：数据字段 + 首部字段\n首部 源端口：这个字段占据 UDP 报文头的前 16 位，通常包含发送数据报的应用程序所使用的 UDP 端口，接收端的应用程序利用这个字段的值作为发送响应的目的地址，这个字段是可选的，所以发送端的应用程序不一定会把自己的端口号写入该字段中，如果不写入端口号，则把这个字段设置为 0，这样，接收端的应用程序就不能发送响应了。 目的端口：接收端计算机上 UDP 软件使用的端口，占据 16 位。 长度：该字段占据 16 位，表示 UDP 数据报长度，包含 UDP 报文头和 UDP 数据长度，因为 UDP 报文头长度是 8 个字节，所以这个值最小为 8。 校验值：该字段占据 16 位，可以检验数据在传输过程中是否被损坏。 数据部分 ","date":"2024-06-12T20:58:45+08:00","permalink":"https://Tyritic.github.io/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/","title":"传输层协议"},{"content":"网络应用程序的常见架构 客户端—服务器结构（CS结构） 设置一台或多台高性能计算机（服务器集群）作为服务端，接受其他主机（客户端）的请求 服务端总是打开，并具有固定的地址 客户端之间 不能直接通信 需要安装特定的客户端软件，该客户端需要承担部分业务逻辑 浏览器—服务器结构（BS结构） 客户端仅使用浏览器（Browser）作为访问入口，完成不需要安装额外的软件。 所有的业务逻辑和数据处理都在服务器端（Server） 点对点结构（P2P结构） P2P（Peer-to-Peer）架构是一种去中心化的网络架构，每个节点（Peer）既可以作为客户端（请求资源），也可以作为服务器（提供资源），节点之间可以直接通信、共享资源，而无需依赖中央服务器。\n对服务器具有最小依赖 具有自拓展性 ：网络能够随着节点（Peer）数量的增加，自主扩展计算能力、存储容量和带宽，而不依赖中央服务器。每个对等节点都由于接受请求产生工作负荷，但是每个对等节点向其他对等节点分发文件也为系统增加服务能力 进程与网络之间的接口（Socket） Socket（套接字） 是计算机网络中用于 进程间通信（IPC, Inter-Process Communication） 的一种机制，它可以让不同计算机上的进程通过网络进行通信。Socket 提供了一种标准化的接口，使应用程序能够发送和接收数据，而不需要关心底层网络协议的实现细节。\n超文本传输协议（HTTP） HTTP（超文本传输协议，HyperText Transfer Protocol） 是一种 无状态、基于请求-响应模式 的 应用层协议 ，用于在 Web 浏览器和服务器之间 传输数据，如 HTML 页面、图片、视频等。\nHTTP 是 互联网的基础协议，它构建在 TCP/IP 协议 之上，使得客户端（如浏览器）和服务器可以相互通信。默认端口为 80\nURI和URL URI(Uniform Resource Identifier) 全称是统一资源标志符，可以唯一标识一个资源。 URL(Uniform Resource Locator) 全称是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。 基本工作模型 基于 请求—响应 模型进行工作，客户端向服务器发送 HTTP Request（请求），服务器响应请求并返回 HTTP Response（响应）\nHTTP客户端先建立与服务端的TCP连接\n浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。 服务器接收来自浏览器的 TCP 连接。 客户端进程和服务器进程通过 Socket 访问网络连接\n客户端从 Socket 发出请求并接受响应 服务端从 Socket 接受请求并发送响应 协议特点 无状态协议 ：HTTP 协议是 无状态 的协议，它无法记录客户端用户的状态，一般我们都是通过 Session 来记录客户端用户的状态。 明文传输 ：默认情况下数据不加密，容易被监听（可用 HTTPS 加密）。 基于请求—响应机制 ：客户端发送请求，服务器返回响应。 可靠传输 ：HTTP 通过 TCP协议（三次握手） 确保可靠传输。 HTTP状态码 状态码由 3 位数字组成，第一位定义 响应的类别\n1xx: 信息响应\n100 Continue：服务器已接收请求的初步部分，客户端应继续请求。\n101 Switching Protocols：服务器同意切换协议，如从 HTTP 切换到 WebSocket。\n2xx: 成功\n200 OK：请求成功，服务器返回所请求的资源或数据。\n201 Created：请求成功并创建了新的资源，常用于 POST 请求。\n204 No Content：请求成功但服务器不返回任何内容，常用于删除操作。\n206 Partial Content ：应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。\n3xx: 重定向\n301 Moved Permanently：资源已永久移动到新的 URL，客户端应使用新 URL 访问。\n302 Found：资源临时移动到新的 URL，客户端应继续使用原来的 URL。搜索引擎会抓取新的内容而保存旧的网址并认为新的网址只是暂时的。\n304 Not Modified：资源未修改，客户端可以使用缓存版本。\n4xx: 客户端错误\n400 Bad Request：请求无效或语法错误，服务器无法处理。\n401 Unauthorized：请求需要身份验证，客户端未提供有效的凭证。\n403 Forbidden：服务器理解请求但拒绝执行，通常是权限问题。\n404 Not Found：请求的资源在服务器上未找到。\n5xx: 服务器错误\n500 Internal Server Error：服务器内部错误，无法完成请求。\n501 Not Implemented ：客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。\n502 Bad Gateway：服务器作为网关或代理，从上游服务器接收到无效响应。\n503 Service Unavailable：服务器暂时无法处理请求，通常是因为过载或维护。\n提示\n重定向机制的区别 301 Moved Permanently ：用于临时重定向，不会更新书签。 302 Found ：用于永久重定向，通常会更新客户端的书签 HTTP请求方法 GET ：用于请求获取指定资源，通常用于获取数据。 GET 请求的参数位置一般是写在 URL 中，但是浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。 POST ：用于向服务器提交数据，通常用于提交表单数据或进行资源的创建。 POST 请求携带数据的位置一般是写在报文请求体 body 中，请求体中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对请求体大小做限制。 PUT ：用于向服务器更新指定资源，通常用于更新已存在的资源。 DELETE ：用于请求服务器删除指定资源。 HEAD ：类似于GET请求，但只返回资源的头部信息，用于获取资源的元数据而不获取实际内容。 提示\nGET 和 POST 的区别\n定义 GET：用于获取资源，通常用于请求数据而不改变服务器状态。 POST：用于提交数据到服务器，通常会改变服务器的状态或产生副作用（如创建或更新资源）。 参数传递方式 GET：参数通过 URL 拼接传递，暴露在请求 URL 中，具有可见性，长度有限（取决于浏览器和服务器）。 POST：参数放在请求体中，通常不可见且长度理论上没有限制，更适合传递大量数据或敏感信息（但是注意，POST 也可以在 URL 上放参数！）。 安全性 数据安全性 GET：参数可见，数据容易暴露在浏览器历史记录、日志和缓存中，不适合传递敏感信息。 POST：数据放在请求体中，相对安全，但需要 HTTPS 才能保证数据加密传输。 HTTP定义：在 HTTP 协议里，所谓的 安全 是指请求方法不会 破坏 服务器上的资源。 GET ：是 只读 操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。 POST ：是 新增或提交数据 的操作，会修改服务器上的资源 幂等性：多次执行相同的操作，结果都是相同的 GET ：GET 具有幂等性，GET 是 只读 操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。（重复请求不会改变服务器状态）。 POST ：POST 具有非幂等，POST 是 新增或提交数据 的操作，会修改服务器上的资源（多次请求可能导致重复创建资源或执行多次相同操作） 缓存机制 GET ：可以对 GET 请求的数据做缓存，当请求同一个 URL 时可以直接返回缓存内容，减少服务器负载。适用于不频繁变动的资源，比如图片、静态页面。 缓存可以做到浏览器本身上（彻底避免浏览器发请求） 缓存可以做到代理上，而且在浏览器中 GET 请求可以保存为书签。 POST ：POST 请求默认不缓存，大部分浏览器和缓存服务器不缓存 POST 请求，主要因为 POST 请求通常会对服务器数据产生影响（如创建、修改数据），需要确保请求每次都传递到服务器。 HTTP报文格式 请求报文 HTTP 请求报文由三个部分组成(请求行+请求头+请求体)\n请求行 （红色部分） ：请求报文的第一行 请求方法（如GET、POST ） 请求的资源路径 URI HTTP协议版本（如HTTP/1.1）。 请求头（深黄色部分）：以键值对的形式表现，用于传递客户端环境、请求内容、认证信息等。 实体头部 ：描述请求体的头部 Content-Length ：表明本次请求的数据长度。用于服务端进行拆包 当客户端发送一个HTTP请求时，会在请求头中添加 Content-Length 字段，该字段的值表示请求正文的字节数。服务器在接收到请求后，会根据 Content-Length 字段的值来确定请求的长度，并从请求中读取相应数量的字节，直到读取完整个请求内容。这种基于 Content-Length 字段的拆包机制可以确保服务器正确接收到完整的请求，避免了请求的丢失或截断问题。 Content-Type ：请求体的多媒体类型（用于 POST 和 PUT 请求中） 通用头部：适用于请求和响应 Cache-Control ：用来指定在这次的请求/响应链中的所有缓存机制都必须 遵守的指令 Connection ：该浏览器想要优先使用的连接类型（持久连接还是非持久连接） 请求头部：特定于请求的头部 Host ：客户端发送请求时，用来指定服务器的域名。 User-Agent ：浏览器的浏览器身份标识字符串 Accept ：能够接受的回应内容类型（Content-Types）。 Accept-Encoding ：能够接受的编码方式列表 Accept-Language ：能够接受的回应内容的自然语言列表。 Cookie ：服务器通过 Set-Cookie发送的一个超文本传输协议 Cookie Authorization ：用于超文本传输协议的认证的认证信息 空行：用于分隔请求头和请求体。 请求体：仅在POST、PUT等方法中存在，包含需要发送到服务器的数据。 表单数据（Form Data）：application/x-www-form-urlencoded，用于提交表单数据。 多部分数据（Multipart Data）：multipart/form-data，用于上传文件或复杂表单数据。 JSON数据：application/json ，用于提交JSON格式的数据。 XML数据：application/xml ，用于提交XML格式的数据。 文本数据：text/plain ，用于提交纯文本数据。 请求解析过程\n请求行解析：根据 HTTP 请求的第一行（请求行），服务器首先解析出请求方法、请求 URI 和协议版本。 请求头解析：请求头的格式为 key: value，可以通过换行符来分隔每一行的头部信息。头部信息指示了客户端的行为、首选内容类型、缓存控制等。 请求体解析：对于包含请求体的请求（如 POST 或 PUT），服务器需要解析请求体的内容。通常，内容类型会告知服务器如何解析请求体。 请求路由与处理：HTTP 请求中的 URI 部分会被用来进行路由匹配，决定请求应该被哪个资源或处理程序处理。 生成 HTTP 响应：服务器处理请求后，会生成一个 HTTP 响应 发送 HTTP 响应：服务器将构造好的 HTTP 响应通过 TCP 连接返回给客户端。客户端接收到响应后，会根据状态码和响应头判断如何处理响应体 响应报文 HTTP响应报文由三个部分组成(响应行,响应头,响应体)\n响应行（红色部分）：响应报文的第一行 HTTP协议版本 状态码：用于描述响应结果 描述 响应头（黄色部分）：以键值对形式表现 Set-Cookie ：服务端可以设置客户端的cookie Connection ：该浏览器想要优先使用的连接类型 响应体（绿色部分）：存放响应数据 HTTP缓存技术 对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对请求-响应的数据都缓存在本地，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，由此HTTP/1.1 的性能会提升不少。\n强制缓存 强制缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存。由浏览器决定是否使用缓存的主动性。\n实现方式\n强制缓存是利用HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：\nCache-Control ：是一个相对时间 Expires ：是一个绝对时间 工作流程\n当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在请求头部加上 Cache-Control ，Cache-Control 中设置了过期时间大小； 浏览器再次请求访问服务器中的该资源时，会先 通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期 ，如果没有，则使用该缓存，否则重新请求服务器； 服务器再次收到请求后，会再次更新请求头的 Cache-Control。 协商缓存 通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。\n实现方式\n响应头部中 Etag ：唯一标识响应资源 请求头部中的 If-None-Match ：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304（允许使用本地缓存），如果资源变化了返回 200。 工作流程\n当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在请求头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的 当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期： 如果没有过期，则直接使用本地缓存； 如果缓存过期了，会在请求头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识； 服务器再次收到请求后，会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较 如果值相等代表服务器中的资源未被修改，则返回 304 Not Modified，不会返回资源 如果不相等代表服务器中的资源被修改，则返回 200 状态码和返回资源，并在请求头部加上新的 ETag 唯一标识； 如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。 HTTP版本 HTTP1.0版本 无状态协议：HTTP 1.0 是无状态的，每个请求之间相互独立，服务器不保存任何请求的状态信息。 非持久连接：默认情况下，每个 HTTP 请求/响应对之后，连接会被关闭，属于短连接。这意味着对于同一个网站的每个资源请求，如 HTML 页面上的图片和脚本，都需要建立一个新的 TCP 连接。可以设置 Connection: keep-alive 强制开启长连接。 HTTP1.1版本 新增特性\n默认使用长连接即 keep—alive ，允许持久连接。只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。\n支持 pipeline，在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以 减少整体的响应时间。 但是服务器必须按照接收请求的顺序发送对这些管道化请求的响应（队尾堵塞）。 所以，HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞。\n允许响应数据分块（chunked)，即响应的时候不标明 Content-Length ，客户端就无法断开连接，直到收到服务端的 EOF ，利于传输大文件。\n新增缓存的控制和管理。\n请求头中加入了 Host 字段：解决了域名系统（DNS）允许多个主机名绑定到同一个 IP 地址上，而请求报文无法指出所请求的主机名的问题\n范围请求：HTTP/1.1 引入了范围请求（range request）机制，以避免带宽的浪费。当客户端想请求一个文件的一部分，或者需要继续下载一个已经下载了部分但被终止的文件，HTTP/1.1 可以在请求中加入 Range 头部，以请求（并只能请求字节型数据）数据的一部分。\n性能瓶颈\n头部冗余：请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分，发送冗长的首部。每次互相发送相同的首部造成的浪费较多 请求队头阻塞：服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据 没有请求优先级控制 请求只能从客户端开始，服务器只能被动响应。 优化思路\n避免发送HTTP请求 实现方案：采用缓存技术，对于一些具有重复性的 HTTP 请求，可以把这对请求-响应的数据都缓存在本地，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了 减少HTTP响应数据大小 实现方案 无损压缩（适合用在文本文件、程序可执行文件、程序源代码）、 有损压缩（压缩多媒体数据） 减少 HTTP 请求的次数 实现方案 减少重定向请求：将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数 合并请求：将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输，再来减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗 HTTP2.0版本 新增特性\n二进制帧：相较于HTTP/1.1 则使用文本格式的报文，HTTP 2.0 使用二进制而不是文本格式来传输数据，解析更加高效。 多路复用：一个 TCP 连接上可以同时进行多个 HTTP 请求/响应，解决了 HTTP 1.x 的响应队头阻塞问题。 头部压缩：HTTP 协议不带状态，所以每次请求都必须附上所有信息。HTTP 2.0 引入了头部压缩机制，可以使用 gzip 或 compress 压缩后再发送，减少了冗余头部信息的带宽消耗。 服务端推送：服务器可以主动向客户端推送资源，而不需要客户端明确请求。 优先级设置 ：HTTP2.0支持优先级设置，允许按 权重和依赖关系 优先传输关键资源，优化用户体验。 底层实现\nStream ：一个TCP连接中包含多条 Stream ，一个 Stream中包含一对请求响应报文 Message ：请求或响应报文 Frame ：Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体） 在 HTTP/2 连接上，不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ），因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，而同一 Stream 内部的帧必须是严格有序的。\n客户端和服务器双方都可以建立 Stream ，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。\nHTTP/2 还可以对每个 Stream 设置不同 优先级\nHTTP3.0版本 HTTP2.0的问题\n队头阻塞：HTTP/2 多个请求是跑在一个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。 网络连接迁移：一个 TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，这意味着如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手，这不利于移动设备切换网络的场景 HTTP3.0的改进\n将传输层协议改为UDP，并且基于UDP实现了应用层的QUIC协议\nQUIC协议的特点\n传输协议 ：HTTP/2.0 是基于 TCP 协议实现的，HTTP/3.0 新增了 QUIC（Quick UDP Internet Connections） 协议来实现可靠的传输，提供与 TLS/SSL 相当的安全性，具有较低的连接和传输延迟。可以将 QUIC 看作是 UDP 的升级版本，在其基础上新增了很多功能比如加密、重传等等 连接建立快：对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、OpenSSL 库实现的表示层。 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS 1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。 无队头阻塞：HTTP/2.0 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。由于 QUIC 协议的特性，HTTP/3.0 在一定程度上解决了队头阻塞问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。 连接迁移：HTTP/3.0 支持连接迁移，因为 QUIC 使用 64 位 ID 标识连接，只要 ID 不变就不会中断，网络环境改变时（如从 Wi-Fi 切换到移动数据）也能保持连接。而 TCP 连接是由（源 IP，源端口，目的 IP，目的端口）组成，这个四元组中一旦有一项值发生改变，这个连接也就不能用了。 安全性：在 HTTP/2.0 中，TLS 用于加密和认证整个 HTTP 会话，包括所有的 HTTP 头部和数据负载。TLS 的工作是在 TCP 层之上，它加密的是在 TCP 连接中传输的应用层的数据，并不会对 TCP 头部以及 TLS 记录层头部进行加密，所以在传输的过程中 TCP 头部可能会被攻击者篡改来干扰通信。而 HTTP/3.0 的 QUIC 对整个数据包（包括报文头和报文体）进行了加密与认证处理，保障安全性。 HTTPS协议 HTTP 是明文传输的，存在数据窃听、数据篡改和身份伪造等问题。而 HTTPS 通过引入 SSL/TLS 解决安全性问题，HTTPS 默认端口号是 443\n信息加密：交互信息无法被窃取。 校验机制：无法篡改通信内容，篡改了就不能正常显示。 身份证书：证明身份。 加密机制 混合加密 HTTPS 采用的是对称加密和非对称加密结合的混合加密方式实现消息的机密性，保证消息不被窃听\n在通信建立前（TLS四次握手）采用非对称加密的方式交换会话秘钥，后续就不再使用非对称加密。 在通信过程（后续加密通信）中全部使用对称加密的会话秘钥的方式加密明文数据。 提示\n非对称加密和对称加密\n对称加密：双方用会话密钥加密通信内容。 非对称加密：服务器向客户端发送公钥，然后客户端用公钥加密自己的随机密钥，也就是会话密钥，发送给服务器，服务器用私钥解密，得到会话密钥。 密钥类型 公钥：负责加密 私钥：负责解密 用公钥加密过的密文只有私钥才能解密，用私钥加密过的密文只有公钥才能解密 公钥加密，私钥解密 ：这个目的是为了保证内容传输的安全，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容； 私钥加密，公钥解密 ：这个目的是为了保证消息不会被冒充，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。 相较于对称加密，非对称加密的速度慢 数字签名和摘要算法 HTTPS 采用的是 数字签名 和 摘要算法 实现消息的完整性，保证消息不被篡改\n摘要算法 用于保证消息的 完整性\n计算机里会 用摘要算法（哈希函数）来计算出内容的哈希值 ，也就是内容的摘要，这个哈希值是唯一的，且无法通过哈希值推导出内容，然后将内容和哈希值一同发送。对方收到后，先是对内容也计算出一个摘要，然后跟发送方发送的摘要做一个比较，如果摘要相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。\n数字签名 用于保证消息保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）\n数字签名算法利用非对称加密的机制，服务器用私钥对内容的哈希值进行加密，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。\n数字证书 由于客户端的公钥可以被替换或者伪造，导致在通信时攻击者可以使用与自己私钥配对的公钥替换客户端的公钥然后与客户端进行通信\n数字证书 用于保证公钥无法被伪造或者替换\n服务器将自己的公钥注册到数字证书认证机构（CA）\nCA 使用自己的私钥将服务器的公钥进行加密，生成数字证书\nCA 会把持有者的公钥、⽤途、颁发者、有效时间等信息打成⼀个包，然后对这些信息进⾏ Hash 计算，得到⼀个 Hash 值； CA 会使⽤⾃⼰的私钥将该 Hash 值加密，⽣成 Certificate Signature； 最后将 Certificate Signature 添加在⽂件证书上，形成数字证书。 客户端拿到服务器的数字证书后，使用CA的公钥确认服务器的数字证书的真实性\n客户端从数字证书获取服务器公钥后，使用已被验证的公钥进行加密后发送\n服务器用私钥对报文解密\n生活例子解释 你想向老师请假，一般来说是要求由家长写一份请假理由并签名，老师才能允许你请假\n这里的老师对应于客户端，家长对应服务端，你对应一名攻击者。\n为什么需要数字签名？\n假设你有模仿家长字迹的能力，你用家长的字迹写了一份请假条然后签上你爸爸的名字，老师一看到这个请假条，查看字迹和签名，就误以为是家长写的，就会允许你请假。\n引入了数字签名算法后，你就无法模仿家长的字迹来请假了，家长手上持有着私钥，老师持有着公钥。\n其中请假条中的签名对于数字签名，字迹对应内容\n这样只有用家长手上的私钥才对请假条进行签名，老师通过公钥看能不能解出这个签名，如果能解出并且确认内容的完整性，就能证明是由家长发起的请假条，这样老师才允许你请假，否则老师就不认。\n为什么需要数字证书？\n虽然家长持有私钥，老师通过是否能用公钥解密来确认这个请假条是不是来源你父亲的。但是我们还可以自己伪造出一对公私钥啊！\n你找了个夜晚，偷偷把老师桌面上和你爸爸配对的公钥，换成了你的公钥，那么下次你在请假的时候，你继续模仿你爸爸的字迹写了个请假条，然后用你的私钥做个了数字签名。\n但是老师并不知道自己的公钥被你替换过了，所以他还是按照往常一样用公钥解密，由于这个公钥和你的私钥是配对的，老师当然能用这个被替换的公钥解密出来，并且确认了内容的完整性，于是老师就会以为是家长写的请假条，又允许你请假了。\n通信过程 第一阶段是TLS四次握手，这一阶段主要是利用非对称加密的特性各种交换信息，最后得到一个\u0026quot;会话秘钥\u0026quot;。\n第二阶段是则是在第一阶段的\u0026quot;会话秘钥\u0026ldquo;基础上，进行对称加密通信。\n第一次握手：由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。 客户端支持的 TLS 协议版本，如 TLS 1.2 版本。 客户端生产的随机数 （Client Random） ，后面用于生成「会话秘钥」条件之一。 客户端支持的密码套件列表，如 RSA 加密算法。 第二次握手：服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello 响应 确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。 服务器生产的随机数 （Server Random） ，也是后面用于生产会话秘钥条件之一。 确认的密码套件列表，如 RSA 加密算法。 服务器的数字证书，包含被CA私钥加密过的服务器公钥。 第三次握手：通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。同时生成会话密钥： 客户端使用客户端随机数，服务器随机数和 pre_master_key 这三个随机数进行计算得到一个 会话秘钥 。客户端会 从数字证书中取出服务器的公钥 ，然后使用它加密报文的 pre-master key ，向服务器发送如下信息： 一个随机数 （pre-master key） ：该随机数由客户端生成，并被服务器公钥加密。 加密通信算法改变通知：表示随后的信息都将用会话秘钥加密通信。 内容摘要：客户端会把迄今为止的通信数据内容生成一个摘要，用 会话秘钥 加密，发给服务器做校验，此时客户端这边的握手流程就结束了，因此也叫 Finished报文 。 第四次握手：服务器收到客户端的第三个随机数 （pre-master key） 之后通过服务器私钥进行解密获得原文，通过与客户端协商的加密算法，计算出本次通信的 会话秘钥 。 加密通信算法改变通知，表示随后的信息都将用会话秘钥加密通信。 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。 DNS（域名解析协议） DNS的全称是Domain Name System（域名系统），它是互联网中用于将域名转换为对应IP地址的分布式数据库系统。\nDNS 是应用层协议，基于 UDP 协议之上，端口为 53 。\nDNS服务器 根 DNS 服务器：根 DNS 服务器提供 TLD 服务器的 IP 地址。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。 顶级域 DNS 服务器（TLD 服务器）：顶级域是指域名的后缀，如com、org、net和edu等。国家也有自己的顶级域，如uk、fr和ca。TLD 服务器提供了权威 DNS 服务器的 IP 地址。 权威 DNS 服务器：在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。 本地 DNS 服务器：每个 ISP（互联网服务提供商）都有一个自己的本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 层次结构中。严格说来，不属于 DNS 层级结构 域名解析过程 域名解析请求：用户在浏览器中输入一个域名，浏览器首先检查本地缓存（如果有的话）是否存有该域名的 IP 地址。 本地DNS解析：如果本地缓存中没有所需的 IP 地址，浏览器会向配置的 本地 DNS 服务器 发送请求。若存在则直接返回 根DNS解析 ：如果 本地DNS服务器 中没有所需的 IP 地址，本地 DNS 服务器 向 根DNS服务器 发出请求，查询 根DNS 以获取 顶级域（TLD）的 DNS 地址。 根DNS 负责将 顶级域DNS 的IP地址发回到 本地DNS 。 顶级域DNS解析 ：本地DNS 向 顶级域DNS 发出请求，查询 顶级域DNS 以获取 权威DNS 地址。 顶级域DNS 负责将 权威DNS 的IP地址发回到 本地DNS 。 权威DNS解析 ：本地DNS 向 权威DNS 发出请求，查询 权威DNS 以获取 域名对应的IP地址 。 权威DNS 负责将 域名对应的IP地址 发回到 本地DNS 。 浏览器缓存该 IP 地址以供后续请求使用，并通过 IP 地址连接到目标服务器以访问网站内容 RPC（远程过程调用） RPC（Remote Procedure Call），又叫做远程过程调用。它本身并不是一个具体的协议，而是一种调用方式。\n服务发现 在 HTTP 中，你知道服务的域名，就可以通过 DNS 服务去解析得到它背后的 IP 地址，默认 80 端口。\n而 RPC 的话，就有些区别，一般会有专门的中间服务去保存服务名和IP信息，比如 Consul 或者 Etcd，甚至是 Redis。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 DNS 也是服务发现的一种，所以也有基于 DNS 去做服务发现的组件，比如CoreDNS。\n底层连接形式 主流的 HTTP/1.1 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（Keep Alive），之后的请求和响应都会复用这条连接。\n而 RPC 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个连接池，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。\nWebSocket WebSocket 适用于需要实时通信和双向数据流的场景，而 HTTP 更适合于传统的客户端与服务器之间的短时请求响应场景。\nWebSocket 是一种基于 TCP 连接的全双工通信协议，即客户端和服务器可以同时发送和接收数据。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。\n提示\n全双工和半双工的概念\n全双工 ：同一时间里，双方都可以主动向对方发送数据。 半双工 ：同一时间里，客户端和服务器只能有一方主动发数据 与HTTP的区别 WebSocket 是一种双向实时通信协议，客户端和服务器建立持久连接后，双方可以随时发送消息，直到主动关闭连接 HTTP 是一种单向通信协议。HTTP 协议基于请求/响应模型，下的通信只能由客户端发起，服务器无法主动通知客户端 HTTP轮询和长轮询 为了实现类似服务器主动发送消息给客户端的场景，有HTTP轮询和长轮询两种实现方案\nHTTP轮询 网页的前端代码里不断定时发 HTTP 请求到服务器，服务器收到请求后给客户端响应消息。。这是一种伪实现。本质上并不是服务器主动发消息到客户端，而是客户端自己不断偷偷请求服务器，只是用户无感知而已。\n缺点\n消耗带宽，同时也会增加下游服务器的负担。 使用体验上会出现 明显的卡顿 ，用户需要等个 1~2 秒，正好才触发下一次 HTTP 请求 长轮询 将HTTP 请求的 超时时间设置的很大 ，比如 30 秒，在这 30 秒内只要服务器收到了请求，就立马返回给客户端。如果超时，那就立马发起下一次请求。\n这样就减少了 HTTP 请求的个数，并且由于大部分情况下，响应也是及时的。\nWebSocket握手过程 客户端向服务器发送一个 HTTP 请求，请求头中包含 Upgrade: websocket 和 Sec-WebSocket-Key 等字段，表示要求升级协议为 WebSocket ； Upgrade: websocket ：请求升级协议到 WebSocket Sec-WebSocket-Key ：随机生成的 base64 码 服务器收到这个请求后，会进行升级协议的操作，如果支持 WebSocket，它将回复一个 HTTP 101 状态码，响应头中包含 ，Connection: Upgrade 和 Sec-WebSocket-Accept: xxx 等字段、表示成功升级到 WebSocket 协议。 Connection: Upgrade ：支持协议切换 Sec-WebSocket-Accept ：根据客户端生成的 Sec-WebSocket-Key ，用 公开的 算法变成另一段字符串 客户端也用同样的公开算法将 Sec-WebSocket-Key 转成另一段字符串，如果这段字符串跟服务器传回来的 Sec-WebSocket-Accept 一致，那验证通过。客户端和服务器之间建立了一个 WebSocket 连接，可以进行双向的数据传输。 数据以帧（frames）的形式进行传送，WebSocket 的每条消息可能会被切分成多个数据帧（最小单位）。发送端会将消息切割成多个帧发送给接收端，接收端接收消息帧，并将关联的帧重新组装成完整的消息。 客户端或服务器可以主动发送一个关闭帧，表示要断开连接。另一方收到后，也会回复一个关闭帧，然后双方关闭 TCP 连接。 Tomcat服务器 基本使用 启动Tomcat服务器：双击Tomcat服务器目录下的bin\\startup.bat\n关闭Tomcat服务器\nCTRL+C：正常关闭 直接关闭运行窗口：强制关闭 双击Tomcat服务器目录下的bin\\shutdown.bat：正常关闭 部署项目：将应用放入webapps目录下\nTomcat服务器的目录结构 1 2 3 4 5 6 7 8 Tomcat/ |--bin（可执行文件） |--conf（配置文件） |--lib（Tomcat依赖的jar包） |--logs（日志文件） |--temp（测试代码资源） |--webapps（应用发布目录） |--resource（工作目录） ","date":"2024-06-09T10:51:40+08:00","permalink":"https://Tyritic.github.io/p/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/","title":"应用层协议"},{"content":"网络中的常见设备 主机（host） 主机（Host） 是指连接到网络并能够发送或接收数据的设备。\n常见的主机类型 个人计算机（PC）\n普通用户使用的台式机或笔记本电脑。\n通过有线（以太网）或无线（Wi-Fi）方式连接到网络。\n服务器（Server）\n提供网络服务的计算机，如Web服务器、数据库服务器、云服务器等。\n运行稳定性和计算能力较强，可同时为多个客户端提供服务。\n常见操作系统：Windows Server、Linux（Ubuntu、CentOS等）。\n物联网设备（IoT Devices）\n连接到互联网的智能设备，如智能家居、传感器、工业控制系统等。\n资源有限，通常使用轻量级协议（如MQTT、CoAP）进行通信。\n移动设备（Mobile Devices）\n智能手机、平板电脑等设备，也可以作为主机接入网络。\n主要通过Wi-Fi或蜂窝网络（4G/5G）访问互联网。\n交换机（Switch） 交换机（Switch） 是一种二层（数据链路层）或三层（网络层）网络设备，用于在局域网（LAN）中连接多个设备，并根据MAC地址或IP地址高效地转发数据。交换机没有MAC地址\n主要功能 数据转发：接收数据帧，并根据目标MAC地址决定将其发送到哪个端口，而不是像集线器（Hub）那样广播给所有设备。 流量管理：通过 全双工通信 ，同时支持数据的发送和接收，减少网络冲突，提高带宽利用率。 地址学习（MAC表）：存储设备的MAC地址和端口映射关系，智能决定数据流向。 常见交换机类型 二层交换机（L2 Switch）：依据MAC地址转发数据，不具备IP路由功能，适用于小型局域网 三层交换机（L3 Switch）：结合路由功能，能根据IP地址转发数据包，适用于大型网络。 路由器（Router） 路由器（Router） 是一种 网络层（第三层）设备 ，用于连接不同的网络，并根据 IP地址 确定数据包的最佳传输路径。它是互联网通信的核心设备，负责数据的转发和寻址。\n主要功能 IP地址转发：根据数据包的目标IP地址，选择最佳路径进行转发。 网络隔离：不同的网络（如家庭网络和外部互联网）通过路由器进行连接和隔离。 NAT（网络地址转换）：允许多个设备共享一个公网IP上网。 DHCP（动态主机配置协议）：自动分配IP地址，简化网络配置。 集线器（Hub） 集线器（Hub） 是一种 物理层（第一层） 的网络设备，用于在局域网（LAN）内连接多个设备。它的主要作用是广播（Broadcast）数据，即收到数据后，会将其发送到所有端口，而不进行智能转发或流量管理。作为接收方的主机发现Mac地址不是自己会忽略该数据包\n主要功能 信号复制：收到数据后，将其广播到所有端口。 物理连接：提供多个端口，用于连接计算机、打印机等设备。 放大信号（部分型号）：用于延长网络传输距离（称为中继器集线器） 分组交换技术 分组交换（Packet Switching） 是一种将数据拆分成多个小数据包，并独立传输到目标地址的通信方式。它不需要建立固定的通信路径，而是根据网络的实时状态选择最优路径，从而提高资源利用率和网络可靠性。\n存储转发机制 交换机或路由器开始向链路传输该分组的第一个比特之前必须接受整个分组\n工作流程 数据拆分：将大数据拆分为多个小的数据包（Packet）。 数据打包：每个数据包包含源地址、目标地址和序列号，确保数据按顺序重组。 动态路由：每个数据包独立选择路径，可能走不同的路。 数据包重组：接收端根据序列号重新组装数据，恢复原始信息。 优缺点 优点\n无建立时延 ：通信前无须建立间接，用户可以随时发送分组 线路利用率高 ：分组在哪段链路上传送时才占用这段链路的通信资源。相比采用电路交换传送突发式的计算机数据，分组交换的通信线路利用率大大提高。 简化了存储管理（相对于报文交换）：因为分组的长度固定，相应缓冲区的大小也固定，在交换结点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易。 加速传输 ：分组是逐个传输的，可以使后一个分组的存储操作与前一个分组的转发操作并行，这种流水线方式减少了报文的传输时间。此外，传输一个分组比传输一次报文所需的缓冲区小得多，这样，因缓冲区不足而等待发送的概率及时间必然也少得多。 减小了出错概率和重发数据量 ：因为分组较短，其出错概率必然减小，所以每次重发的数据量也就大大减少，这样不仅提高了可靠性，而且减小了传输时延。 缺点\n存在存储转发时延 ：尽管分组交换比报文交换的传输时延小，但相对于电路交换仍存在存储转发时延，且其结点交换机必须具有更强的处理能力。 需要传输额外的信息量 ：每个小数据段都要加上控制信息以构成分组，这使得传送的信息量增大，进而使得控制复杂，降低了通信效率，增大了处理的时延。 当分组交换网采用数据报服务时，可能出现失序、丢失或重复分组的情况 ：分组到达目的结点时，要对分组按编号进行排序等工作， 应用场景 互联网通信（如网页浏览、电子邮件、社交网络） VoIP（网络电话） 视频流（如YouTube、Netflix） 无线通信（4G/5G） 电路交换技术 电路交换（Circuit Switching） 是指在通信开始前，必须建立一个固定的端到端通信路径（电路），预留好了通信所需资源，并在整个通信过程中保持该路径。\n复用技术 在电路交换中，复用指的是将多个用户或通信流的信号合并到一个物理路径上，并根据需要将其分开进行通信。在通信过程中，虽然多个通信流共享同一条物理线路，但每个用户都能获得一个独占的虚拟通道，在会话期间保持通道的占用。\n常见的复用技术\n时分复用（TDM, Time Division Multiplexing） 时分复用技术将一个物理信道按时间划分为多个时隙，每个通信会话在不同的时隙内传输数据。这样，多个用户或信号可以交替使用同一通道，但每个用户在其专有的时间段内使用该通道。 频分复用（FDM, Frequency Division Multiplexing） 频分复用技术将可用的传输带宽划分为多个频带，每个通信会话被分配到一个独立的频带上进行传输。每个频带相当于一个独立的虚拟信道，每个用户在自己分配的频带内进行通信。 工作流程 建立连接（拨号和呼叫建立阶段）：系统为通信双方预留一条专用电路。 数据传输（通信阶段）：数据沿固定路径传输，保证稳定性。 释放连接（挂断阶段）：通话结束后，释放电路资源。 优缺点 优点\n通信质量稳定：由于通话期间通道被独占，不会有其他用户占用带宽。 延迟低：不需要数据包排序或重组，数据按固定路径流动，时延较小。 适用于实时通信：如传统电话、专线通信等。 缺点\n资源利用率低，即使通话双方没有发送数据，通信通道仍然被占用 通信时延 节点总时延=节点处理时延+排队时延+传输时延+传播时延\n节点处理时延 检查分组首部以及决定分组导向何处所需时间\n排队时延 分组在链路上等待传输所需的时间\n传输时延 将所有分组推向链路的时延\n传播时延 从链路的起点到交换机所需的时间\nOSI七层协议模型 协议：定义了在两个或多个通信实体之间交换的报文格式和顺序，以及报文发送或接受报文或其他事件所采取的动作\n计算机网络的协议采用分层架构。每一层都依赖于上层提供的服务并向下层提供服务。（通常以物理层为第一层，作为最下层）\n当数据从设备发出时，数据从应用层逐层向下传递，每一层会对数据进行封装，增加自己的头部信息，以便下一层能够正确地识别、处理和传输数据。\n当数据到达目标设备时，数据从物理层逐层向上传递，每一层会进行 解封装，提取出属于该层的数据部分，并将其传递给上一层，直到最终到达应用层。\n每一层分工明确\n应用层 ：为计算机用户提供服务，给应用程序提供统一的接口 表示层 ：数据处理(编解码、加密解密、压缩解压缩)，使得通信的应用程序能够解释交换数据的含义 会话层 ：管理（建立、维护、重连）表示层实体之间的会话 传输层 ：负责端到端的数据传输，为两台主机进程之间的通信提供通用的数据传输服务 网络层 ：负责数据的路由、转发、分片，决定数据在网络的游走路径 数据链路层 ：负责数据的封帧和差错检测，以及 MAC 寻址 物理层 ：负责在物理网络中传输数据帧，透明地传送比特流传输 提示\n网络模型为什么要采用分层模型\n各层之间相互独立：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）。这个和我们对开发时系统进行分层是一个道理。 提高了灵活性和可替换性：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。并且，每一层都可以根据需要进行修改或替换，而不会影响到整个网络的结构。这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。 问题分解：分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 这个和平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。 应用层 应用层 是OSI模型的最高层，它为用户提供直接的网络服务。它是应用程序与网络之间的接口，它定义了信息交换的格式，消息会交给下一层传输层来传输，是应用程序以及应用层协议存在的地方，负责用户与计算机的交互。\n应用层是不用去关心数据是如何传输的，而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。\n应用层的信息分组称为 报文\n常用协议 常见的应用层协议\nHTTP（Hypertext Transfer Protocol，超文本传输协议）：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载 SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）：基于 TCP 协议，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。 FTP（File Transfer Protocol，文件传输协议）：基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。 SSH（Secure Shell Protocol，安全的网络传输协议）：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务 DNS（Domain Name System，域名管理系统）: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。 表示层 表示层 负责数据格式的转换，确保不同系统之间的数据能够互相理解。它通常包括数据的编码、加密、解密和压缩功能。\n例如：Linux 给 WIndows 发包，不同系统语法不一致，如 exe 不能在 Linux 下执行，shell 不能在 Windows 不能直接运行。因此需要表示层。解决不同系统之间通信语法问题\n会话层 会话层 负责建立、管理和终止会话，它提供了在应用程序之间的会话管理功能，保证数据的同步、恢复以及多次通信的管理。它确保数据传输的秩序性，如恢复中断的连接。\n常见的协议有 ADSP、RPC 等\n传输层 传输层 负责在通信的两端提供 端到端的可靠性（不同主机上不同进程的通信） ，它确保数据的可靠传输和流量控制。它将数据从应用层交给网络层，然后将接收到的数据传递给应用层。传输层还负责错误检测与修正。\n报文段 传输层的数据分组称为 报文段\n常用协议 在传输层会有两个传输协议，分别是 TCP 和 UDP。\nTCP 的全称叫传输控制协议（Transmission Control Protocol），具有以下功能\n流量控制 超时重传 拥塞控制等 通过提供面向连接的服务保证报文段可靠地传输给对方\nUDP 相对来说就很简单，提供无连接服务，只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。\n当设备作为接收方时，传输层则要负责把报文段传给应用进程，但是一台设备上可能会有很多应用进程在接收或者传输数据，因此需要用一个 端口号 将应用进程区分开来。\n网络层 随着网络节点的不断增加，点对点通讯需要通过多个节点，如何找到目标节点，如何选择最佳路径成为首要需求。\n网络层主要功能是将 网络地址转化为对应的物理地址（寻址） ，并 决定如何将数据从发送方路由到接收方（路由选择） 。\n数据报 位于网络层的数据分组称为 数据报\n网络层最常使用的是 IP 协议（Internet Protocol），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会再次进行分片，得到一个即将发送到网络的 IP 报文。\nIP地址 IP地址 用于区分不同的物理设备\n网络号：负责标识该 IP 地址是属于哪个「子网」的； 主机号：负责标识同一「子网」下的不同主机； 子网掩码 ：用于计算网络号和主机号\n将 子网掩码 和 IP地址 进行按位与操作即可计算出网络号\n将 子网掩码 取反后与 IP地址 进行进行按位与运算，就可以得到主机号\n常见协议 IP（Internet Protocol，网际协议）：TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。 ARP（Address Resolution Protocol，地址解析协议）：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。 ICMP（Internet Control Message Protocol，互联网控制报文协议）：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除 NAT（Network Address Translation，网络地址转换协议）：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。 RIP(Routing Information Protocol，路由信息协议）：一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。 数据链路层 在物理连接中提供可靠的传输（ 点到点的传输 ），负责建立和维护两个相邻节点间的链路。包括数据帧的封装与解封装，以及错误检测与校正。它还负责处理物理地址（MAC地址），管理局域网的访问控制。\n链路层中的数据分组为 帧\n物理层 物理层是OSI模型的最底层，负责将数据以电气信号、光信号或无线信号的形式传输到物理媒介上。它定义了硬件设备的接口、传输媒介的电气特性、连接器的标准等。\n网卡工作在这层\nTCP/IP模型 TCP/IP 四层模型 是目前被广泛采用的一种模型,可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：\n应用层 传输层 网络层 网络接口层 网络接口层 网络接口层（Network Access Layer）：可以把网络接口层看作是数据链路层和物理层的合体。负责将数字信号在物理通道（网线）中准确传输，定义了如何在单一网络链路上传输数据，如何处理数据帧的发送和接收，包括物理地址（MAC 地址）的解析。\nMAC地址 Mac地址 是一个全球唯一的物理地址，由设备制造商在生产时烧录到网卡的固件中。MAC 地址用于局域网（LAN）中的设备识别和通信。\nIP 网络使用 IP 地址 进行通信，但在局域网内，设备最终依靠 MAC 地址 进行数据传输。\nARP（Address Resolution Protocol） 负责将 IP 地址转换为 MAC 地址。\n数据封装过程 网页显示过程 工作流程 浏览器解析 URL：浏览器会解析 URL 并根据解析结果和缓存分析获得传输协议和资源路径，并试图从缓存获得IP地址 浏览器分析 URL 所需要使用的传输协议和请求的资源路径。 如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。 如果没有问题，浏览器会检查 URL 中是否出现了非法字符，则对非法字符进行转义后在进行下一过程。 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里且没有失效，那么就直接使用，否则向服务器发起新的请求。 浏览器通过 DNS 做域名解析从而获取域名对应的IP地址：请求需要知晓服务器域名对应的 IP 地址才能通信，浏览器会检查本地缓存、操作系统缓存，甚至路由器缓存。如果未命中缓存，浏览器向配置的 DNS 服务器发送查询请求，DNS 服务器递归查询 最终返回 IP 地址。 通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈。 浏览器会调用 Socket 库委托协议栈工作，并得到了封装了 HTTP 数据的 TCP 数据包, TCP协议指定了指定源端口号和目的端口号，然后下发给网络层 在 TCP 数据包的基础上，再封装源地址 IP 和前面 DNS 解析出来目标地址 IP 等信息，得到网络包。并多个网络节点中确定数据包的传输路径，最终能找到目标服务器。然后将下发给数据链路层 数据链路层的发送需要封装通信双方的 MAC 地址。 本机的 MAC 地址作为源 MAC 地址。 接收方目标 MAC 地址的获取方式是通过将 IP 地址与本机的子网掩码相结合，可以判断是否与请求主机在同一个子网里 如果在同一个子网里，可以使用 ARP 协议获取到目的主机的 MAC 地址 如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。 网卡驱动获取网络包之后，会将其复制到网卡内的缓存区中。网卡会将包转为电信号，通过网线发送出去 建立TCP连接：主机将使用目标 IP地址和目标MAC地址发送一个TCP SYN包，请求建立一个TCP连接，然后交给路由器或者交换机 交换机：它会根据数据包中的 MAC 头来查找MAC表来找到另一个设备连接在交换机的哪个端口，然后传输。 路由器：路由器进行跨子网的转发，通过查找路由表中IP地址和端口的映射关系来决定从路由器的哪个端口发出 发送HTTP请求：连接建立后，浏览器会向服务器发送HTTP请求。请求中包含了用户需要获取的资源的信息，例如网页的URL、请求方法（GET、POST等）等。 服务器处理请求并返回响应：服务器收到请求后，会根据请求的内容进行相应的处理。例如，如果是请求网页，服务器会读取相应的网页文件，并生成HTTP响应。 数据封装过程 数据包传递过程 路由器1的路由表\n目的地址 下一跳 端口 192.168.0.0/24 0 192.168.0.254/32 0 192.168.1.0/24 1 192.168.1.254/32 1 192.168.2.0/24 192.168.100.5 2 192.168.100.0/24 2 192.168.100.4/32 2 以主机A发送给主机F数据包为例\nA （192.168.0.1） 通过子网掩码 （255.255.255.0） 计算出自己与 F （192.168.2.2） 并不在同一个子网内，于是决定发送给默认网关 （192.168.0.254） A 通过 ARP 找到 默认网关 192.168.0.254 的 MAC 地址 （ABAB） 。 A 封装数据包 数据链路层头部 源 MAC 地址设置为A的MAC地址 （AAAA） 目标MAC地址为网关 MAC 地址 （ABAB） 网络层头部 源 IP 地址设置为A的IP地址 （192.168.0.1） 目的 IP 地址设置为F的IP地址 （192.168.2.2）（从始至终这个数据包的两个 IP 地址都是不变的，只有 MAC 地址在不断变化） 交换机 1 收到数据包后，查询MAC地址表，目标 MAC 地址是 ABAB ，从MAC地址表的指定端口转发给路由器1 数据包来到了路由器 1，发现其目标 IP 地址是 192.168.2.2 ，查看其路由表，发现了下一跳的地址是 192.168.100.5 ，从映射端口发出数据包到路由器2 源MAC设置为路由器1的映射端口的MAC地址 （D1D1） 目标MAC设置为下一跳的MAC地址 （D2D2） 此时路由器 2 收到了数据包，看到其目标IP地址是 192.168.2.2 ，查询其路由表，准备从映射端口把数据包送出去。 但此时路由器 2 需要知道 192.168.2.2 的 MAC 地址了，于是查看其 arp 缓存，找到其 MAC 地址为 FFFF ，将其封装在数据链路层头部，并从映射端口把包发出去。 源MAC设置为路由器2的映射端口的MAC地址 （EFEF） 目标MAC设置为F的MAC地址 （FFFF） 交换机 3 收到了数据包，发现目的 MAC 地址为 FFFF ，查询其 MAC 地址表，从映射端口把数据包发出去。 F 最终收到了数据包并且发现目的 MAC 地址就是自己，于是收下了这个包 ","date":"2024-06-06T21:09:15+08:00","permalink":"https://Tyritic.github.io/p/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/","title":"网络分层模型"}]