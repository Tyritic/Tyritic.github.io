[{"content":"MyBatis-Plus对MyBatis的改进 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 具体使用 引入依赖（参见官方文档 ），MyBatisPlus官方提供了starter，其中集成了Mybatis和MybatisPlus的所有功能，并且实现了自动装配效果。因此我们可以用MybatisPlus的starter代替Mybatis的starter:\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-spring-boot3-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 定义Mapper：自定义Mapper继承MyBatis-P;us提供的接口BaseMapper\n1 2 3 public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt;{ } 默认配置 MyBatis-Plus通过扫描实体类，利用反射机制获取实体类的信息作为数据库表的信息\n类名驼峰转下划线作为表名 名为id的字段作为主键 变量名驼峰转下划线作为表的字段名 1 2 3 public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt;{ } 1 2 3 4 5 6 7 8 9 10 11 public class User{ private Long id; private String username; private string password; private String phone; private string info; private Integer status; private Integer balance; private LocalDateTime createTime; //对应表的字段 create_time private LocalDateTime updateTime; //对应表的字段 update_time } 自定义配置 如果不符合Mybatis-Plus的约定就要使用自定义配置。\n基于注解的配置 @TableName：用来指定表名（该注解用于指定实体类对应的数据库表名。当实体类名与数据库表名不一致，或者实体类名不是数据库表名的驼峰写法时，您需要使用这个注解来明确指定表名。） @TableId：用来指定表中的主键字段信息 value：对应数据库表中的主键字段名 type：主键策略 AUTO：数据库自增长 INPUT：通过set方法自行输入 ASSIGN_ID：分配id @TableField ：用来指定表中的普通字段信息 使用场景 成员变量名与数据库字段名不一致 成员变量名以is开头，且是布尔值(经过反射处理，它会将is去掉作为数据库字段名) 成员变量名与数据库关键字冲突 成员变量名不是数据库字段(数据库中不存在该字段) 具体注解参考官方文档\n基于yml的注解 在SpringBoot项目中可以通过修改application.yml来配置\n1 2 3 4 5 6 7 8 9 10 11 mybatis-plus: type-aliases-package: com.gty.mp.domain.po #注册后，在 Mapper 对应的 XML 文件中可以直接使用类名，无需使用全限定类名。 mapper-locations: \u0026#34;classpath*:/mapper/**/*.xml\u0026#34; #mapper.xml文件地址, 默认值 configuration: map-underscore-to-camel-case: true #是否开启下划线和驼峰的映射 cache-enabled: true #是否开启二级映射 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl #开启mybatis打印日志 global-config: db-config: id-type: assign_id #id为雪花算法生成,注解配置大于全局配置 update-strategy: not_null # 更新策略:只更新非空字段 具体详细配置参考官方文档\n条件构造器（Wrapper） MyBatis-Plus 提供了一套强大的条件构造器（Wrapper），用于构建复杂的数据库查询条件。（BaseMapper实现简单的单表查询）\nWrapper 类允许开发者以链式调用的方式构造查询条件，无需编写繁琐的 SQL 语句，从而提高开发效率并减少 SQL 注入的风险。\n通常作为mapper方法（自定义在mapper接口或者MyBatis-Plus已经实现的）的参数在service层使用\n类的继承结构 AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件\nQueryWrapper ： Query条件封装 UpdateWrapper ： Update条件封装 AbstractLambdaWrapper ： 使用Lambda语法 LambdaQueryWrapper ：基于Lambda语法使用的查询Wrapper LambdaUpdateWrapper ： 基于Lambda语法使用的更新Wrapper QueryWrapper和LambdaQueryWrapper通常用来构建select、delete、update的where条件部分\nUpdateWrapper和LambdaUpdateWrapper通常只有在set语句比较特殊才使用\n具体使用 创建Wrapper对象 Wrappers静态方法： public static \u0026lt;T\u0026gt; QueryWrapper\u0026lt;T\u0026gt; query() 通过QueryWrapper对象的构造方法： public QueryWrapper() 通过lambda方法可以将普通Wrapper转换成lambdaWrapper 基于复杂条件构建wrapper，使用链式编程 示例方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package com.dfbz; import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.baomidou.mybatisplus.core.toolkit.Wrappers; import com.dfbz.entity.User; import com.dfbz.mapper.UserMapper; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import java.util.List; /** * @author lscl * @version 1.0 * @intro: */ @SpringBootTest(classes = MyBatisPlusApplication.class) @RunWith(SpringRunner.class) public class Demo06_LambdaQueryMapper { @Autowired private UserMapper userMapper; /** * 使用QueryWrapper * @throws Exception */ @Test public void test1() throws Exception { QueryWrapper\u0026lt;User\u0026gt; wrapper = Wrappers.query(); wrapper.eq(\u0026#34;id\u0026#34;,\u0026#34;1\u0026#34;); List\u0026lt;User\u0026gt; userList = userMapper.selectList(wrapper); for (User user : userList) { System.out.println(user); } } /** * 使用LambdaQueryWrapper * @throws Exception */ @Test public void test2() throws Exception { LambdaQueryWrapper\u0026lt;User\u0026gt; wrapper = Wrappers.lambdaQuery(); // id=1 // wrapper.eq(User::getId,1); // select id,name,age from user where id in (1,2,3) and name like \u0026#34;%a%\u0026#34; wrapper.in(User::getId,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;) .like(User::getName,\u0026#34;a\u0026#34;) .select(User::getId,User::getName,User::getAge); List\u0026lt;User\u0026gt; userList = userMapper.selectList(wrapper); for (User user : userList) { System.out.println(user); } } } 条件方法 方法名 解释 示例 eq 等于 = eq(“name”, “老王”)**---\u0026gt;** name = ‘老王’ ne 不等于 \u0026lt;\u0026gt; ne(“name”, “老王”)**---\u0026gt;** name \u0026lt;\u0026gt; ‘老王’ gt 大于 \u0026gt; gt(“age”, 18)**---\u0026gt;** age \u0026gt; 18 ge 大于等于 \u0026gt;= ge(“age”, 18)**---\u0026gt;** age \u0026gt;= 18 lt 小于 \u0026lt; lt(“age”, 18)**---\u0026gt;** age \u0026lt; 18 le 小于等于 \u0026lt;= le(“age”, 18)**---\u0026gt;** age \u0026lt;= 18 between between 值1 and 值2 between(“age”, 18, 30)**---\u0026gt;** age between 18 and 30 notBetween not between 值1 and 值2 notBetween(“age”, 18, 30)**---\u0026gt;** age not between 18 and 30 like LIKE ‘%值%’ like(“name”, “王”)**---\u0026gt;** name like ‘%王%’ notLike NOT LIKE ‘%值%’ notLike(“name”, “王”)**---\u0026gt;** name not like ‘%王%’ likeLeft LIKE ‘%值’ likeLeft(“name”, “王”)**---\u0026gt;** name like ‘%王’ likeRight LIKE ‘值%’ likeRight(“name”, “王”)**---\u0026gt;** name like ‘王%’ isNull 字段 IS NULL isNull(“name”)**---\u0026gt;** name is null isNotNull 字段 IS NOT NULL isNotNull(“name”)**---\u0026gt;** name is not null in 字段 IN (v0, v1, …) in(“age”, 1, 2, 3)**---\u0026gt;** age in (1,2,3) notIn 字段 NOT IN (v0, v1, …) notIn(“age”, 1, 2, 3)**---\u0026gt;** age not in (1,2,3) inSql 字段 IN ( sql语句 ) inSql(“id”, “select id from table where id \u0026lt; 3”)**---\u0026gt;** id in (select id from table where id \u0026lt; 3) notInSql 字段 NOT IN ( sql语句 ) notInSql(“id”, “select id from table where id \u0026lt; 3”)**---\u0026gt;** id not in (select id from table where id \u0026lt; 3) groupBy 分组：GROUP BY 字段, … groupBy(“id”, “name”)**---\u0026gt;** group by id,name orderByAsc 排序：ORDER BY 字段, … ASC orderByAsc(“id”, “name”)**---\u0026gt;** order by id ASC,name ASC orderByDesc 排序：ORDER BY 字段, … DESC orderByDesc(“id”, “name”)**---\u0026gt;** order by id DESC,name DESC orderBy 排序：ORDER BY 字段, … orderBy(true, true, “id”, “name”)**---\u0026gt;** order by id ASC,name ASC having HAVING ( sql语句 ) 例1：having(“sum(age) \u0026gt; 10”)**---\u0026gt;** having sum(age) \u0026gt; 10 例2：having(“sum(age) \u0026gt; {0}”, 11)**---\u0026gt;** having sum(age) \u0026gt; 11 func 主要解决条件拼接 func(i -\u0026gt; if(true) {i.eq(“id”, 1)} else {i.ne(“id”, 1)}) or 拼接 OR eq(“id”,1).or().eq(“name”,“老王”)**---\u0026gt;** id = 1 or name = ‘老王’ and AND 嵌套 and(i -\u0026gt; i.eq(“name”, “李白”).ne(“status”, “活着”))**---\u0026gt;** and (name = ‘李白’ and status \u0026lt;\u0026gt; ‘活着’) nested 用于多条件拼接时 nested(i -\u0026gt; i.eq(“name”, “李白”).ne(“status”, “活着”))**---\u0026gt;** (name = ‘李白’ and status \u0026lt;\u0026gt; ‘活着’) apply 用于拼接SQL语句 例1：apply(“id = 1”)**---\u0026gt;** id = 1 例2：apply(“id = {0}”,1)**---\u0026gt;** *id = 1 例3：apply(“name like {0} and age \u0026gt; {1}”,“%J%”,18) **\\*\\*---\u0026gt;\\*\\* *name like ‘%J%’ and age \u0026gt; 18 last 无视优化规则直接拼接到 sql 的最后 *last(“limit 1”) **\\*\\*---\u0026gt;\\*\\* *在SQL语句最后面拼接：limit 1 exists 拼接 EXISTS ( sql语句 ) exists(“select id from table where age = 1”)**---\u0026gt;** exists (select id from table where age = 1) notExists 拼接 NOT EXISTS ( sql语句 ) notExists(“select id from table where age = 1”)**---\u0026gt;** not exists (select id from table where age = 1) 具体参见官方文档\n自定义SQL 可以利用MyBatis-Plus的Wrapper来构建复杂的where条件，然后自己定义SQL语句中剩下的部分。\n基于Wrapper定义复杂的Where条件\n在mapper方法参数中用@Param注解声明wrapper变量名称，名称必须为ew或者使用注解 @Param(Constants.WRAPPER) 明确指定参数为 Wrapper 对象。\n1 2 3 4 5 6 7 8 import com.baomidou.mybatisplus.core.conditions.Wrapper; import com.baomidou.mybatisplus.core.toolkit.Constants; import org.apache.ibatis.annotations.Param; public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt; { @Select(\u0026#34;SELECT * FROM user ${ew.customSqlSegment}\u0026#34;) List\u0026lt;User\u0026gt; selectByCustomSql(@Param(Constants.WRAPPER) Wrapper\u0026lt;User\u0026gt; wrapper); } 自定义SQL语句，使用${ew.customSqlSegment}来引用 Wrapper 对象生成的 SQL 片段。\n1 2 3 QueryWrapper\u0026lt;User\u0026gt; queryWrapper = new QueryWrapper\u0026lt;\u0026gt;(); queryWrapper.eq(\u0026#34;name\u0026#34;, \u0026#34;张三\u0026#34;); List\u0026lt;User\u0026gt; userList = userMapper.selectByCustomSql(queryWrapper); Service层接口IService MyBatis提供了Service层接口IService和默认实现类ServiceImpl\n使用流程 自定义Service接口继承IService接口（其中IService接口中的泛型为操纵的实体类）\n1 2 3 public interface IUserService extends IService\u0026lt;User\u0026gt;{ } 自定义Service实现类，实现自定义接口并继承Servicelmpl类（其中ServiceImpl中的泛型为对应的Mapper类和实体类）\n1 2 3 4 @Service public class UserServiceImpl extends ServiceImpl\u0026lt;UserMapper,User\u0026gt; implements IUserService{ } LambdaQuery和LambdaUpdate IService中还提供了Lambda功能来简化我们的复杂查询及更新功能。\n在Service层中可以代替Wrapper实现更加复杂的查询/更新\nlambdaQuery()和lambdaUpdate()方法直接获得一个Wrapper的子类通过链式编程简化\n在service层中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Override public List\u0026lt;User\u0026gt; queryUsers(UserQuery userQuery) { return lambdaQuery() .like(userQuery.getName() != null, User::getUsername, userQuery.getName()) .eq(userQuery.getStatus() != null, User::getStatus, userQuery.getStatus()) .ge(userQuery.getMinBalance() != null, User::getBalance, userQuery.getMinBalance()) .le(userQuery.getMaxBalance() != null, User::getBalance, userQuery.getMaxBalance()) .list(); } @Override public void deductionBalance(Long id, Integer money) { // 1.查询用户 User user = getById(id); // 2.校验用户状态 if (user == null || user.getStatus() == UserStatus.FREEZE) { throw new RuntimeException(\u0026#34;用户状态异常!\u0026#34;); } // 3.校验余额是否充足 if (user.getBalance() \u0026lt; money) { throw new RuntimeException(\u0026#34;用户余额不足\u0026#34;); } // 4.扣减余额 int remainBalance = user.getBalance() - money; lambdaUpdate() .set(User::getBalance, remainBalance) .set(remainBalance == 0, User::getStatus, UserStatus.FREEZE) .eq(User::getId, id) .eq(User::getBalance, user.getBalance()) //乐观锁 .update(); } 还需要在链式编程的最后添加一个list()，这是在告诉MP我们的调用结果需要是一个list集合。这里不仅可以用list()，可选的方法有：\n.one()：最多1个结果 .list()：返回集合结果 .count()：返回计数结果 批量插入 1 2 3 4 // 插入（批量） boolean saveBatch(Collection\u0026lt;T\u0026gt; entityList); // 插入（批量） boolean saveBatch(Collection\u0026lt;T\u0026gt; entityList, int batchSize); 效率一般：MybatisPlus的批处理是基于PrepareStatement的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。而想得到最佳性能，最好是将多条SQL合并为一条。\n提升效率的方式\nMySQL的客户端连接参数中有这样的一个参数：rewriteBatchedStatements。顾名思义，就是重写批处理的statement语句。这个参数的默认值是false，我们需要修改连接参数，将其配置为true。\n在配置文件中，在数据库连接配置中在url后面加上 rewriteBatchedStatements=true 的一个参数：\n分页插件 具体参见官方文档\n在配置类中注册MyBatis-Plus的核心插件。同时添加分页插件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Configuration @MapperScan(\u0026#34;scan.your.mapper.package\u0026#34;) public class MybatisPlusConfig { /** * 添加分页插件 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { //创建MyBatis-Plus拦截器 MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); //添加内部拦截器（插件） // 添加分页插件 PaginationInnerInterceptor paginationInnerInterceptor = new PaginationInnerInterceptor(DbType.MYSQL); //可以给分页插件添加属性 //overflow\tboolean\tfalse\t溢出总页数后是否进行处理 //maxLimit\tLong\t单页分页条数限制 //dbType\tDbType\t数据库类型 //dialect\tIDialect\t方言实现类 interceptor.addInnerInterceptor(paginationInnerInterceptor); // 如果配置多个插件, 切记分页最后添加 // 如果有多数据源可以不配具体类型, 否则都建议配上具体的 DbType return interceptor; } } 在Mapper方法使用分页相关API\n设置分页参数\n1 2 3 4 5 6 7 8 //方法一 int pageNo = 1; //页码 int pageSize = 2; //每页大小 Page\u0026lt;User\u0026gt; pageInfo = Page.of(pageNo, pageSize); Page\u0026lt;User\u0026gt;p=userMapper.page(pageInfo); //方法二 Page\u0026lt;User\u0026gt; pageInfo = new Page\u0026lt;\u0026gt;(page,pageSize); Page\u0026lt;User\u0026gt;p = userService.page(pageInfo); 进行分页查询\n1 2 Page\u0026lt;T\u0026gt; page_name=userMapper.selectPage(page, wrapper); //条件分页查询 Page\u0026lt;T\u0026gt; page_name=userMapper.page(page);//普通分页查询 使用相关API\n1 2 3 4 5 6 7 当前页数：page.getCurrent() 总页数： page.getPages() 记录数： page.getTotal() 是否有上一页： page.hasPrevious() 是否有下一页： page.hasNext() 分页数据：page.getRecords() 排序条件：page.addOrder(new OrderItem(\u0026#34;数据库字段名\u0026#34;,true)); //升序为true,降序为false ","date":"2024-11-16T10:56:19+08:00","permalink":"https://Tyritic.github.io/p/mybatis-plus/","title":"MyBatis Plus"},{"content":"一级缓存 一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问\n使一级缓存失效的四种情况: 不同的SqlSession对应不同的一级缓存 同一个SqlSession但是查询条件不同 同一个SqlSession两次查询期间执行了任何一次增删改操作 同一个SqlSession两次查询期间手动清空了缓存 二级缓存 二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存;此后若再次执行相同的查询语句，结果就会从缓存中获取。\n二级缓存开启的条件: 在核心配置文件中，设置全局配置属性cacheEnabled=\u0026ldquo;true\u0026rdquo;，默认为true，不需要设置 在mapper.xml映射文件中设置标签\u0026lt;cache \u0026gt; 二级缓存必须在SqlSession关闭或提交之后有效 查询的数据所转换的实体类类型必须实现序列化的接口 失效的情况 在两次查询之间进行任意的增删改，手动清空缓存只会清空一级缓存\n相关配置 在mapper.xml映射文件中设置标签\u0026lt;cache \u0026gt;\n相关属性参见 MyBatis官方文档\n缓存查询顺序 先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用 如果二级缓存没有命中，再查询一级缓存 如果一级缓存也没有命中，则查询数据库 Sqisession关闭之后，一级缓存中的数据会写入二级缓存 ","date":"2024-11-15T20:31:12+08:00","permalink":"https://Tyritic.github.io/p/mybatis%E7%BC%93%E5%AD%98/","title":"MyBatis缓存"},{"content":"JavaWeb的三大组件 Servlet Servlet是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容。\n狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。\n作用： 接收请求数据 处理请求 完成响应 使用方法 实现javax.servlet.Servlet接口； 继承javax.servlet.GenericServlet类； 继承javax.servlet.http.HttpServlet类； 工作原理 ​\tServlet接口定义了Servlet与servlet容器之间的契约。这个契约是：Servlet容器将Servlet类载入内存，并产生Servlet实例和调用它具体的方法。但是要注意的是，在一个应用程序中，每种Servlet类型只能有一个实例。\n​\t用户请求致使Servlet容器调用Servlet的Service（）方法，并传入一个ServletRequest对象和一个ServletResponse对象。ServletRequest对象和ServletResponse对象都是由Servlet容器（例如TomCat）封装好的，并不需要程序员去实现，程序员可以直接使用这两个对象。\nServletRequest中封装了当前的Http请求，因此，开发人员不必解析和操作原始的Http数据。ServletResponse表示当前用户的Http响应，程序员只需直接操作ServletResponse对象就能把响应轻松的发回给用户。 对于每一个应用程序，Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）的环境详情。每个应用程序只有一个ServletContext。每个Servlet对象也都有一个封装Servlet配置的ServletConfig对象。 生命周期 init( ),当Servlet第一次被请求时，Servlet容器就会开始调用这个方法来初始化一个Servlet对象出来，但是这个方法在后续请求中不会在被Servlet容器调用，就像人只能“出生”一次一样。我们可以利用init（ ）方法来执行相应的初始化工作。调用这个方法时，Servlet容器会传入一个ServletConfig对象进来从而对Servlet对象进行初始化。 service( )方法，每当请求Servlet时，Servlet容器就会调用这个方法。就像人一样，需要不停的接受老板的指令并且“工作”。第一次请求时，Servlet容器会先调用init( )方法初始化一个Servlet对象出来，然后会调用它的service( )方法进行工作，但在后续的请求中，Servlet容器只会调用service方法了。 destory,当要销毁Servlet时，Servlet容器就会调用这个方法，就如人一样，到时期了就得死亡。在卸载应用程序或者关闭Servlet容器时，就会发生这种情况，一般在这个方法中会写一些清除代码。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class MyFirstServlrt implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { System.out.println(\u0026#34;Servlet正在初始化\u0026#34;); } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { //专门向客服端提供响应的方法 System.out.println(\u0026#34;Servlet正在提供服务\u0026#34;); } @Override public String getServletInfo() { return null; } @Override public void destroy() { System.out.println(\u0026#34;Servlet正在销毁\u0026#34;); } } ServletRequest接口 Servlet容器对于接受到的每一个Http请求，都会创建一个ServletRequest对象，并把这个对象传递给Servlet的Sevice( )方法。其中，ServletRequest对象内封装了关于这个请求的许多详细信息。\n1 2 3 4 5 6 7 8 9 public interface ServletRequest { int getContentLength();//返回请求主体的字节数 String getContentType();//返回主体的MIME类型 String getParameter(String var1);//返回请求参数的值 } ServletResponse接口 javax.servlet.ServletResponse接口表示一个Servlet响应，在调用Servlet的Service( )方法前，Servlet容器会先创建一个ServletResponse对象，并把它作为第二个参数传给Service( )方法。ServletResponse隐藏了向浏览器发送响应的复杂过程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public interface ServletResponse { String getCharacterEncoding(); String getContentType(); ServletOutputStream getOutputStream() throws IOException; PrintWriter getWriter() throws IOException; void setCharacterEncoding(String var1); void setContentLength(int var1); void setContentType(String var1); //在发送任何HTML之前，应该先调用setContentType（）方法，设置响应的内容类型，并将“text/html”作为一个参数传入，这是在告诉浏览器响应的内容类型为HTML，需要以HTML的方法解释响应内容而不是普通的文本，或者也可以加上“charset=UTF-8”改变响应的编码方式以防止发生中文乱码现象。 void setBufferSize(int var1); int getBufferSize(); void flushBuffer() throws IOException; void resetBuffer(); boolean isCommitted(); void reset(); void setLocale(Locale var1); Locale getLocale(); } HttpServlet抽象类 HttpServlet抽象类是继承于GenericServlet抽象类而来的。使用HttpServlet抽象类时，还需要借助分别代表Servlet请求和Servlet响应的HttpServletRequest和HttpServletResponse对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doPut(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doDelete(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } HttpServletRequest接口 HttpServletRequest表示Http环境中的Servlet请求。它扩展于javax.servlet.ServletRequest接口，并添加了几个方法。\n获取请求的相关数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 String getContextPath();//返回请求上下文的请求URI部分 Cookie[] getCookies();//返回一个cookie对象数组 String getHeader(String var1);//返回指定HTTP标题的值 String getMethod();//返回生成这个请求HTTP的方法名称 String getQueryString();//返回请求URL中的查询字符串 HttpSession getSession();//返回与这个请求相关的会话对象 String getRequestURI(); StringBuffer getRequestURL(); String[] getParameterValues(String name); //获得如checkbox类（名字相同，但值有多个）的数据。 接收数组变量 String getParameter(String name)； //获得相应名的数据，如果有重复的参数名，则返回第一个的值 HttpServletResponse接口 在Service API中，定义了一个HttpServletResponse接口，它继承自ServletResponse接口，专门用来封装HTTP响应消息。 由于HTTP请求消息分为状态行，响应消息头，响应消息体三部分，因此，在HttpServletResponse接口中定义了向客户端发送响应状态码，响应消息头，响应消息体的方法。\n设置响应的相关数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void addCookie(Cookie var1);//给这个响应添加一个cookie void addHeader(String var1, String var2);//给这个请求添加一个响应头 void sendRedirect(String var1) throws IOException;//发送一条响应码，讲浏览器跳转到指定的位置 void setStatus(int var1);//设置响应行的状态码 void addHeader(String name, String value);//添加响应头 void addIntHeader(String name, int value) void addDateHeader(String name, long date) void setHeader(String name, String value) void setDateHeader(String name, long date) void setIntHeader(String name, int value) PrintWriter getWriter();//获得字符流，通过字符流的write(String s)方法可以将字符串设置到response 缓冲区中，随后Tomcat会将response缓冲区中的内容组装成Http响应返回给浏览器端。 ServletOutputStream getOutputStream();//获得字节流，通过该字节流的write(byte[] bytes)可以向response缓冲区中写入字节，再由Tomcat服务器将字节内容组成Http响应返回给浏览器。 Filter 参见先前博客 Filter\nListener 概述 ​\t监听器就是监听某个对象的状态变化的组件，监听web应用中某些对象、信息的创建、销毁、增加，修改，删除等动作的发生，然后作出相应的响应处理\n具体实现 实现ServletContextListener接口\n1 2 3 4 5 6 7 8 9 10 public class MyListener implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent sce){ System.out.println(\u0026#34;Servlet上下文---\u0026gt;当前web项目启动\u0026#34;); } @Override public void contextDestroyed(ServletContextEvent sce){ System.out.println(\u0026#34;当前类销毁\u0026#34;); } } 注册Listenner监听器\nSpringBoot对三大组件的集成 SpringBoot中内嵌的Servlet容器是Tomcat服务器\n嵌入式Servlet容器配置修改 方法一：通过全局配置文件Application.yml修改\n可以通过server.xxx 来进行web服务配置， 没有带服务器名称的则是通用配置,通过带了具体的服务器名称则是单独对该服务器进行设置，比如server.tomcat.xxx 就是专门针对tomcat的配置,具体配置参见SpringBoot官方文档\n1 2 3 server: port: 8080 tomcat: 方法二：通过注册一个实现 WebServerFactoryCustomizer 接口的Spring Bean\n1 2 3 4 5 6 7 8 9 10 11 12 13 import org.springframework.boot.web.server.WebServerFactoryCustomizer; import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory; import org.springframework.stereotype.Component; @Component public class MyWebServerFactoryCustomizer implements WebServerFactoryCustomizer\u0026lt;ConfigurableServletWebServerFactory\u0026gt; { @Override public void customize(ConfigurableServletWebServerFactory server) { server.setPort(9000); } } 修改server.xxx 配置的相关内容 会跟配置文件形成互补 三大组件的注册 方法一：servlet3.0规范提供的注解方式注册\n在组件的实现类使用提供的注解注册\n1 2 3 4 5 6 7 8 @WebServlet(name=\u0026#34;HelloServlet\u0026#34;,urlPatterns = \u0026#34;/HelloServlet\u0026#34;) public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { PrintWriter writer = resp.getWriter(); writer.println(\u0026#34;hello servlet!\u0026#34;); } } @WebServlet @WebListener @WebFilter 在SpringBoot启动类上添加注解@ServletComponentScan\n1 2 3 4 5 6 7 @SpringBootApplication @ServletComponentScan public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } }\t方法二：SpringBoot提供的注册方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package com.hzl.boot.config.filter; import org.springframework.boot.web.servlet.FilterRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.servlet.Filter; /** * @description * @create: 2024-09-23 22:25 **/ @Configuration public class FilterRegistrationDemo { @Bean public FilterRegistrationBean filterRegistrationBean(){ FilterRegistrationBean\u0026lt;Filter\u0026gt; registrationBean = new FilterRegistrationBean\u0026lt;\u0026gt;(); // 设置自己的过滤器 registrationBean.setFilter(new MyFilter()); // 设置自定义的拦截规则 registrationBean.addUrlPatterns(\u0026#34;/*\u0026#34;); // 设置拦截器的顺序 registrationBean.setOrder(1); return registrationBean; } } ServletRegistrationBean FilterRegistrationBean ServletListenerRegistrationBean 切换内嵌Servlet容器 SpringBoot包含了对Tomcat,Jetty（Socket)等服务器的支持\n通过修改pom.xml的依赖即可排除相关依赖即可\n","date":"2024-11-15T15:55:52+08:00","permalink":"https://Tyritic.github.io/p/springboot%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6/","title":"SpringBoot中的三大组件"},{"content":"MVC设计模式 MVC 是一种常见的软件设计模式，用于分离应用程序的不同部分以实现松散耦合和高内聚性。MVC 模式由三个核心组件组成：\n模型（Model）：表示应用程序的数据和业务逻辑。模型处理应用程序的数据，并根据控制器的指令执行相应的操作。 视图（View）：提供模型数据的用户界面。视图通常是模板、HTML 页面、XML 文件或其他格式，可以呈现模型数据给用户。 控制器（Controller）：处理用户交互并更新模型和视图。控制器负责接收来自视图的用户输入，对模型进行相应的操作，并更新视图以反映更改。 MVC 模式的优点是可以将代码分离成三个独立的组件，使得应用程序更易于维护和扩展。例如，如果要更改视图的外观，可以修改视图而不影响模型和控制器；如果要更改数据存储方式，可以修改模型而不影响视图和控制器。同时，MVC 模式还有助于降低应用程序中的耦合度，使得各组件更加独立和可重用。\nSpringMVC框架 概述： Spring MVC 是非常著名的 Web 应用框架，现在的大多数 Web 项目都采用 Spring MVC。它与 Spring 有着紧密的关系。是 Spring 框架中的模块，专注 Web 应用，能够使用 Spring 提供的强大功能，IOC、AOP等。 Spring MVC 框架底层是基于 Servlct 技术。遵循 Servlet 规范，Web 组件 Servlet 、Filter、Listener在 Spring MVC 中都能使用。同时 Spring MVC 也是基于 MVC 架构模式的，职责分离，每个组件只负责自己的功能，组件解耦。 Spring Boot 的自动配置、按约定编程极大简化，提高了 Web 应用的开发效率。 响应流程： 大体流程：请求到控制器（controller），经过业务模型（model）处理后返回响应给视图层。\n具体流程：\nDispatcherServlet 首先收到请求，将请求映射到对应的处理器（controller）上，映射到controller的时候会触发拦截器 处理器处理完后封装数据模型，交给视图解析器将数据模型解析为对应的视图返回给前端。 SpringMVC组件 控制器controller 控制器是一种由 Spring 管理的 Bean 对象，赋予角色是“控制器”。\n作用：处理请求，接收浏览器发送过来的参数，将数据或视图应答给浏览器或者客户端 App等。\n具体实现：一个Java类，使用@Controller或@RestController\n提示\n@Controller 和 @RestController 注解的区别：\n@RestController 包含了 @Controller 的功能，同时加入了 @ResponseBody 的注解。 表示当前控制器类中的方法，都会默认加入 @ResponseBody 的功能。方法的返回值是数据可以通过 HttpServletResponse 输出给浏览器。 接收请求\n@RequestMapping ：用于将 Web 请求映射到控制器类的方法。此方法处理请求。可用作在类上或方法上。在类上和方法上同时使用。\n1 2 3 @RequestMapping(value = \u0026#34;/updateProduct\u0026#34;,method = RequestMethod.POST) public Result\u0026lt;String\u0026gt; updateProduct(@RequestParam MultipartFile file, @RequestParam String dname, @RequestParam String tname, @RequestParam String content,@RequestParam String olddname) Value：别名 path 表示请求的 URI，在类和方法上同时使用 value，方法上的继承类上的 value。 method：请求方式，支持 GET、POST、HEAD、OPTIONS、PUT、PATCH、DELETE、TRACE。值为：RequestMethod[] method()，RquestMethod 是 enum 类型。 快捷注解：\n@GetMapping: 表示 get 请求方式的@RequestMapping @PostMapping:表示 post 请求方式的@RequestMapping @PutMapping：表示 put 请求方式的@RequestMapping @DeleteMapping: 表示 delete 请求方式的@RequestMapping 接收请求参数\n@RequestParam：把请求中的指定名称的参数传递给控制器中的形参赋值\nvalue属性值指定请求中的参数 required 属性指定请求中的参数是否必须，默认为 true ，如果加上 required=false，没对应上则不会报错，而是获取值为 null。 如果参数前不写@RequestParam(xxx)的话，那么就前端可以有可以没有对应的参数名字都行，如果有参数名的话，那么就会自动匹配；没有的话，请求也能正确发送。 HttpServletRequest对象 使用 HttpServletRequest 对象接收参数，request.getParameter(\u0026quot;XXX\u0026quot;)获取对应的值，这是原始的 JavaWeb 中的方式 @RequestBody：主要用来接收前端传递给后端的json字符串中的数据的(通常json字符串放在请求体中)\nGET方式无请求体，所以使用@RequestBody接收数据时，前端不能使用GET方式提交数据，而是用POST方式进行提交。 在后端的同一个接收方法里，@RequestBody与@RequestParam()可以同时使用，@RequestBody最多只能有一个，而@RequestParam()可以有多个。 如果后端参数是一个对象，且该参数前是以@RequestBody修饰的，那么前端传递json参数时，必须满足以下要求：后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类(即：@RequestBody后面的类)时，会根据json字符串中的key来匹配对应实体类的属性，如果匹配一致且json中的该key对应的值符合(或可转换为)实体类的对应属性的类型要求时，会调用实体类的setter方法将值赋给该属性 @RequestHeader：从请求头中获取某些值\n1 2 3 4 5 6 7 8 9 10 11 12 import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestHeader; import org.springframework.web.bind.annotation.RestController; @RestController public class MyController { @GetMapping(\u0026#34;/greet\u0026#34;) public String greet(@RequestHeader(\u0026#34;User-Agent\u0026#34;) String userAgent) { return \u0026#34;Hello! You are using \u0026#34; + userAgent; } } 返回值\n不使用 @ResponseBody的 String 返回值，返回的是一个页面视图 使用 @ResponseBody的 String 返回值，返回的是一个JSON数据 返回ModelAndView ，返回的是一个视图其中包含数据。（最后数据都是放到 Request 中的） 返回自定义的对像，默认的返回格式是json字符串（有jackson工具） 返回 Map，默认的返回格式是json字符串（有jackson工具） 返回ResponseEntity：包含数据和自定义的HttpStatus Code。（默认转为json格式的字符串） 模型 Model 在许多实际项目需求中，后台要从控制层直接返回前端所需要的数据，这时 Model 大家族就派上用场了。 Model Spring MVC 中的 ”M“，是用来传输数据的。从控制层直接返回数据给前端。内置的 JSP，模板技术能够展现 Model 中存储的数据。 Model 可以是承载数据的，也可以是处理具体业务的类，这些都是指 Spring MVC 中的Model。 视图 View Spring MVC 中的 View（视图）用于展示数据的，视图技术的使用是可插拔的。无论选择使用 thymleaf、jsp 还是其他技术，classpath 有 jar 就能使用视图了。开发者主要就是更改配置。SpringBoot3 不推荐使用 FreeMarker、JSP 这些了。建议使用 Thymeleaf。 SpringBoot框架中对SpringMVC框架的集成 自动配置：SpringBoot会自动配置一个嵌入式的Servlet容器（如Tomcat），并为我们提供默认的SpringMVC配置。这样我们无需手动配置Servlet容器和SpringMVC，只需添加相应的依赖即可快速搭建一个Web应用。 视图解析器：SpringBoot默认使用Thymeleaf作为视图解析器，如果需要更换其他视图解析器，可以在pom.xml中修改对应的依赖。 静态资源处理：SpringBoot默认会处理静态资源（如HTML、CSS、JavaScript等），并将其放在项目的/static或/public目录下。如果需要自定义静态资源的处理方式，可以通过编写一个类实现WebMvcConfigurer接口，并重写addResourceHandlers方法来实现。 拦截器：SpringBoot支持自定义拦截器，可以通过实现HandlerInterceptor接口来创建拦截器，同时编写一个类实现WebMvcConfigurer接口，并重写addInterceptors方法来实现。 异常处理：SpringBoot默认使用WhitelabelErrorView来处理异常，如果需要自定义异常处理方式，可以通过编写一个类实现ErrorController接口，并重写errorHtml方法来实现。 参数绑定：SpringBoot支持多种参数绑定方式，如@RequestParam、@PathVariable、@RequestBody等。如果需要自定义参数绑定方式，可以通过编写一个类实现MethodArgumentResolver接口，并重写resolveArgument方法来实现。 跨域支持：SpringBoot默认支持CORS跨域请求，如果需要自定义跨域配置，可以通过编写一个类实现WebMvcConfigurer接口，并重写addCorsMappings方法来实现。 Spring Boot中配置Spring MVC 配置方法 因为Spring Boot自动装配机制的存在，一般来说我们不需要对Spring MVC进行配置，如果要进行特别定制化的配置，Spring Boot也支持配置文件或者编写代码的两种方式来进行配置。\n方法一：修改application.xml 可以通过修改application.xml的spring.mvc属性来修改SpringBoot对SpringMVC的默认配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 spring: mvc: # 启用Spring MVC enabled: true # 配置静态资源路径 static-path-pattern: /static/** static-locations: classpath:/static/ # 配置视图解析器 view.prefix: /WEB-INF/views/ view.suffix: .jsp # 配置拦截器 interceptor: exclude-path-patterns: /login,/logout include-path-patterns: /admin/** # 配置HTTP缓存 resources: cache: period: 3600 servlet: # 配置文件上传 multipart: max-file-size: 10MB max-request-size: 10MB # 配置会话管理 session: timeout: 1800 cookie.max-age: 1800 # 配置JSON序列化 jackson: serialization: indent_output: true date-format: yyyy-MM-dd HH:mm:ss # 配置异常处理 error: whitelabel: enabled: false 方法二：编写一个被注解@WebMvcConfiguration修饰的Java配置类 WebMvcConfigurer接口是Spring提供的一个用于自定义Spring MVC配置的接口，主要提供了WebMvcConfigurer接口是Spring提供的一个用于自定义Spring MVC配置的接口，主要提供了多个回调方法，包括添加或修改Spring MVC的配置，如添加拦截器，自定义消息转换器等。具体来说，WebMvcConfigurer接口的主要方法包括：\nconfigurePathMatch（S）：此方法用于配置路由请求规则。 configureContentNegotiation（S）：该方法用于内容协商配置。 configureAsyncSupport（S）：该方法用于异步支持配置。 configureDefaultServletHandling（S）：该方法用于配置默认静态资源处理器。 addFormatters（S）：此方法用于注册自定义转化器。 addInterceptors（S）：此方法用于拦截器配置。 addResourceHandlers（S）：此方法用于资源处理。 addCorsMappings（S）：此方法用于CORS配置。 在使用时，只需要实现WebMvcConfigurer接口，重写上述的方法即可完成自定义配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @Configuration public class MyWebMvcConfig implements WebMvcConfigurer { // 配置视图解析器 @Override public void configureViewResolvers(ViewResolverRegistry registry) { InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix(\u0026#34;/WEB-INF/views/\u0026#34;); resolver.setSuffix(\u0026#34;.jsp\u0026#34;); registry.viewResolver(resolver); } // 配置静态资源 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\u0026#34;/static/**\u0026#34;).addResourceLocations(\u0026#34;/static/\u0026#34;); } // 配置拦截器 @Autowired private MyInterceptor myInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(myInterceptor).addPathPatterns(\u0026#34;/**\u0026#34;); } // 配置消息转换器 @Override public void configureMessageConverters(List\u0026lt;HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converters) { MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter(); List\u0026lt;MediaType\u0026gt; supportedMediaTypes = new ArrayList\u0026lt;MediaType\u0026gt;(); supportedMediaTypes.add(MediaType.APPLICATION_JSON); converter.setSupportedMediaTypes(supportedMediaTypes); converters.add(converter); } // 配置异常处理器 @ControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(value = Exception.class) public ModelAndView handleException(HttpServletRequest req, Exception e) { ModelAndView mav = new ModelAndView(); mav.addObject(\u0026#34;exception\u0026#34;, e); mav.addObject(\u0026#34;url\u0026#34;, req.getRequestURL()); mav.setViewName(\u0026#34;error\u0026#34;); return mav; } } // 配置全局跨域资源共享（CORS） @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\u0026#34;/user/*\u0026#34;) // 映射服务器中那些http接口运行跨域访问 .allowedOrigins(\u0026#34;http://localhost:8081\u0026#34;) // 配置哪些来源有权限跨域 .allowedMethods(\u0026#34;GET\u0026#34;,\u0026#34;POST\u0026#34;,\u0026#34;DELETE\u0026#34;,\u0026#34;PUT\u0026#34;); // 配置运行跨域访问的请求方法 } // 配置文件上传 @Bean public MultipartResolver multipartResolver() { CommonsMultipartResolver resolver = new CommonsMultipartResolver(); resolver.setMaxUploadSize(10485760); resolver.setMaxInMemorySize(4096); return resolver; } // 配置请求缓存 @Bean public KeyGenerator keyGenerator() { return new DefaultKeyGenerator(); } @Bean public RequestCache requestCache() { return new HttpSessionRequestCache(); } // 配置视图控制器 @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\u0026#34;/\u0026#34;).setViewName(\u0026#34;index\u0026#34;); registry.addViewController(\u0026#34;/login\u0026#34;).setViewName(\u0026#34;login\u0026#34;); } } 提示\n使用Springboot框架对SpringMVC的默认设置：直接编写控制器逻辑\n手动设置SpringMVC的部分功能，定义MVC的底层组件：@Configuration+配置WebMvcConfiguration，不要使用@EnableWebMvc\n手动设置SpringMVC的所有功能：@Configuration+配置WebMvcConfiguration+@EnableMvc\n使用 @EnableWebMvc 会完全覆盖 SpringBoot 对 SpringMVC 的自动配置，因此如果使用了 @EnableWebMvc，就需要自己配置 Spring MVC 的全部内容，包括视图解析器、资源处理、异常处理等。通常情况下，只有在需要非常精细的控制 Spring MVC 配置时才会使用 @EnableWebMvc。\n","date":"2024-11-14T16:21:47+08:00","permalink":"https://Tyritic.github.io/p/springmvc/","title":"SpringMVC"},{"content":"简介 Springdoc-OpenApi是一个规范且完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。\nSpringdoc-OpenApi 的目标是对 REST API 定义一个标准且和语言无关的接口，可以让人和计算机拥有无须访问源码、文档或网络流量监测就可以发现和理解服务的能力。\n具体使用 引入具体依赖springfox\n1 2 3 4 5 6 \u0026lt;!-- 导入相关依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springdoc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springdoc-openapi-starter-webmvc-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 添加配置类用于Api文档的基本配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package org.example.user.config; import io.swagger.v3.oas.models.OpenAPI; import io.swagger.v3.oas.models.info.Contact; import io.swagger.v3.oas.models.info.Info; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class SpringDocConfig { // OpenAPI类用于定制全局文档信息 @Bean public OpenAPI customOpenAPI() { return new OpenAPI() // 定制文档基本信息 .info(new Info() //关于文档信息 .title(\u0026#34;API 文档标题\u0026#34;) .description(\u0026#34;API 文档描述\u0026#34;) .version(\u0026#34;1.0.0\u0026#34;) .termsOfService(\u0026#34;https://example.com/terms\u0026#34;) //关于开发者 .contact(new Contact() .name(\u0026#34;开发者姓名\u0026#34;) .url(\u0026#34;开发者网址\u0026#34;) .email(\u0026#34;开发者邮箱\u0026#34;)) //关于许可证 .license(new License() .name(\u0026#34;许可证名称\u0026#34;) .url(\u0026#34;许可证文件\u0026#34;))) //配置服务器信息（可选） .servers(List.of( new Server().url(\u0026#34;服务器url\u0026#34;).description(\u0026#34;服务器描述\u0026#34;), new Server().url(\u0026#34;https://api.example.com\u0026#34;).description(\u0026#34;生产服务器\u0026#34;))) //配置外部文档信息（可选） .externalDocs(new ExternalDocumentation() .description(\u0026#34;外部文档描述\u0026#34;) .url(\u0026#34;外部文档url\u0026#34;)); } } 修改application.yml配置文件\n1 2 3 4 5 springdoc: api-docs: enable: true swagger-ui: enable: true 其余属性参见官方文档 SpringDoc-OpenApi官方文档\n提示\n1 2 3 4 5 6 7 8 springdoc: group-configs: #进行文档分组每个组配置对应的请求路径以及区分所在包 - group: \u0026#39;user\u0026#39; paths-to-match: \u0026#39;/api/users/**\u0026#39; packages-to-scan: com.toher.springdoc.user - group: \u0026#39;product\u0026#39; paths-to-match: \u0026#39;/api/product/**\u0026#39; packages-to-scan: com.toher.springdoc.product 可以在微服务架构中进行分组\n查看接口文档\nSwagger-UI接口文档：http://localhost:8080/swagger-ui/index.html Json形式接口文档：localhost:8080/v3/api-docs 使用注解编写接口文档\n常用注解 对实体类的描述 @Schema：用于描述类或字段的数据结构和属性，支持OpenAPI 3规范中的各种特性，如类型、格式、默认值等。\n1 2 3 4 5 6 7 8 9 10 11 12 @Data @NoArgsConstructor @AllArgsConstructor @Builder public class User { @Schema(description = \u0026#34;用户ID\u0026#34;, example = \u0026#34;1\u0026#34;) private int id; @Schema(description = \u0026#34;用户姓名\u0026#34;, example = \u0026#34;张三\u0026#34;) private String name; @Schema(description = \u0026#34;用户年龄\u0026#34;, example = \u0026#34;18\u0026#34;) private int age; } 对方法的描述 @Operation：用于方法级别，提供对API操作的详细描述，包括摘要、描述、响应、参数等信息。\nsummary：操作的简要描述。 description：操作的详细描述。 tags：与操作相关的标签。 operationId：操作的唯一标识符。 parameters：操作的参数列表。 responses：操作的响应列表。 1 2 3 4 5 6 7 8 9 10 @Operation( summary = \u0026#34;获取用户信息\u0026#34;, description = \u0026#34;根据用户ID获取用户详细信息\u0026#34;, tags = {\u0026#34;用户操作\u0026#34;}, operationId = \u0026#34;getUserById\u0026#34; ) @RequestMapping(\u0026#34;/users\u0026#34;) public User getUserById(@PathVariable Long id) { // 实现逻辑 } @ApiResponses是一个容器注解，用于收集多个@ApiResponse，描述方法可能返回的各种响应情况。\n@ApiResponse描述了API操作的一个特定响应，包括响应的状态码、描述、内容类型等。\nresponseCode：响应代码。 description：响应描述。 content：响应内容。 1 2 3 4 5 6 7 8 9 10 11 12 13 @RequestMapping(value=\u0026#34;/{id}\u0026#34;, method = RequestMethod.GET) @Operation(summary = \u0026#34;findById方法\u0026#34;, description = \u0026#34;根据id查询用户\u0026#34;) @Parameter(name = \u0026#34;id\u0026#34;, description = \u0026#34;用户id\u0026#34;, required = true, in = ParameterIn.PATH) @ApiResponses(value = { @ApiResponse(responseCode = \u0026#34;200\u0026#34;, description = \u0026#34;查询成功\u0026#34;,content={@Content(mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = Result.class))}), @ApiResponse(responseCode = \u0026#34;500\u0026#34;, description = \u0026#34;查询失败\u0026#34;,content={@Content(mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = Result.class))}) }) public Result\u0026lt;User\u0026gt; findById(@PathVariable Integer id) { return Result.success(\u0026#34;查询成功\u0026#34;, new User(id, \u0026#34;张三\u0026#34;, 20)); } @Parameters是一个容器注解，用于收集多个@Parameter注解，描述方法的多个请求参数。\n@Parameter：用于描述单个请求参数，可以是查询参数、路径参数、请求头等。\nname：参数名。 description：参数描述。 required：是否必需参数。 in：参数所在位置（query、header、path、cookie）。 1 2 3 4 5 6 7 8 @Parameters(value = { @Parameter(name = \u0026#34;name\u0026#34;, description = \u0026#34;姓名\u0026#34;, in = ParameterIn.PATH), @Parameter(name = \u0026#34;age\u0026#34;, description = \u0026#34;年龄\u0026#34;, in = ParameterIn.QUERY) }) @GetMapping(\u0026#34;/{name}\u0026#34;) public List\u0026lt;Programmer\u0026gt; getProgrammers(@PathVariable(\u0026#34;name\u0026#34;) String name, @RequestParam(\u0026#34;age\u0026#34;) Integer age) { ... } 对类的描述 @Tag：用于标记API控制器或方法属于哪一个功能分类或标签，有助于组织和分类API文档中的不同部分\n1 2 3 4 5 6 @Tag(name = \u0026#34;程序员\u0026#34;, description = \u0026#34;程序员乐园\u0026#34;) @RestController @RequestMapping(\u0026#34;/api/programmer\u0026#34;) public class ProgrammerController { ... } ","date":"2024-11-12T10:01:20+08:00","permalink":"https://Tyritic.github.io/p/springboot%E6%95%B4%E5%90%88springdoc-openapi%E7%94%9F%E6%88%90%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/","title":"SpringBoot整合Springdoc-OpenApi生成接口文档"},{"content":"Restful服务 Restful是目前流行的互联网软件服务架构设计风格\n服务特点 每一个URL代表一种资源 客户端使用GET、POST、PUT、DELETE四种表示操作方式的动词对服务端资源进行操作：GET用于获取资源，POST用于新建资源（也可以用于更新资源），PUT用于更新资源，DELETE用于删除资源。 通过操作资源的表现形式来实现服务端请求操作。 资源的表现形式是JSON或者HTML。 客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都包含必需的信息。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @RestController public class UserController{ @ApiOperation(\u0026#34;获取用户\u0026#34;) @GetMapping(\u0026#34;/user/{id}\u0026#34;) public String getUserById(@PathVariable int id){ System.out.println(id); return \u0026#34;根据ID获取用户信息\u0026#34;; } @PostMapping(\u0026#34;/user\u0026#34;) public String save(User user){ return \u0026#34;添加用户\u0026#34;; } @PutMapping(\u0026#34;/user\u0026#34;) public String update(User user){ return \u0026#34;更新用户\u0026#34;; } @DeleteMapping(\u0026#34;/user/{id}\u0026#34;) public String deleteById(@PathVariable int id){ System.out.println(id); return \u0026#34;根据ID删除用户\u0026#34;; } } 最佳实现 接口设计 URL的组成 网络协议 服务器地址 接口名称 ？参数列表（GET方法） 响应设计 Content-body用来存放数据 用于描述数据的msg和code放入Content-header中 RestTemplate 简介 RestTemplate是Spring提供的用于访问Rest服务的，RestTemplate提供了多种便捷访问远程Http服务的方法，传统情况下在java代码里访问restfuI服务，一般使用Apache的HttpClient，不过此种方法使用起来太过繁琐。spring提供了一种简单便捷的模板类来进行操作，这就是RestTemplate.（常用于客户端和微服务）\n具体使用 以微服务为例\n创建一个Controller类（用@RestController修饰）\n创建一个Config类对RestTemplate进行配置和创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Configuration public class RestTemplateConfig { /** * 没有实例化RestTemplate时，初始化RestTemplate * 性能上OkHttp优于Apache的HttpClient，Apache的HttpClient优于HttpURLConnection（默认）。 * @return */ @ConditionalOnMissingBean(RestTemplate.class) @Bean public RestTemplate restTemplate(){ RestTemplate restTemplate = new RestTemplate(getClientHttpRequestFactory()); return restTemplate; } /** * 使用OkHttpClient作为底层客户端 * @return */ private ClientHttpRequestFactory getClientHttpRequestFactory(){ OkHttpClient okHttpClient = new OkHttpClient.Builder() .connectTimeout(5, TimeUnit.SECONDS) .writeTimeout(5, TimeUnit.SECONDS) .readTimeout(5, TimeUnit.SECONDS) .build(); return new OkHttp3ClientHttpRequestFactory(okHttpClient); } } 进行依赖注入并使用该Bean对象\n常见方法 GET请求 getForObject：获取请求体\n不带参数：(uri, \u0026lt;T \u0026gt;.class) 代表 请求地址、HTTP响应转换被转换成的对象类型 带参数(uri, String.class, paramMap) 代表 请求地址、HTTP响应转换被转换成的对象类型，请求参数 getForEntity：获取整个请求，除了包含响应体，还包含HTTP状态码、contentType、contentLength、Header等信息\nPOST请求 postForObject：获取请求体 postForEntity：获取整个请求，除了包含响应体，还包含HTTP状态码、contentType、contentLength、Header等信息 PUT请求 put： Delete请求 delete： 通用请求 exchange(String url, HttpMethod method,@Nullable HttpEntity\u003c?\u003e requestEntity, Class responseType, Map uriVariables) url: 请求地址； method: 请求类型(如：POST,PUT,DELETE,GET)； requestEntity: 请求实体，封装请求头，请求内容 responseType: 响应类型，根据服务接口的返回类型决定 uriVariables: url中参数变量值 ","date":"2024-11-11T18:48:31+08:00","permalink":"https://Tyritic.github.io/p/resttemplate/","title":"RestTemplate"},{"content":"devtool热部署 为了进一步提高开发效率,springboot为我们提供了全局项目热部署,日后在开发过程中修改了部分代码以及相关配置文件后,不需要每次重启使修改生效,在项目中开启springboot全局热部署之后只需要在修改之后等待几秒即可使修改生效。\n开启热部署 引入相关依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; Java的日志体系 日志门面 每一种日志框架都有自己单独的API，要使用对应的框架就要使用其对应的API，这就大大的增加应用程序代码对于日志框架的耦合性。\n为了解决这个问题，就是在日志框架和应用程序之间架设一个沟通的桥梁，对于应用程序来说，无论底层的日志框架如何变，都不需要有任何感知。只要门面服务做的足够好，随意换另外一个日志框架，应用程序不需要修改任意一行代码，就可以直接上线。总而言之，日志门面用于整合不同日志框架的日志（类似接口），不实现具体日志\n常见的日志门面 JCL（Java Common Logging）：Java自带的日志门面 SLF4J：目前最常用的日志门面 JCL 用户可以自由选择第三方的日志组件作为具体实现，像log4j，或者jdk自带的jul， common-logging会通过动态查找的机制，在程序运行时自动找出真正使用的日志库。\nJCL默认的情况下，会使用JUL日志框架做日志的记录操作。\nJCL使用原则：如果有log4j，优先使用log4j，如果没有任何第三方日志框架的时候，使用的就是JUL。\n具体实现\n导入相关依赖\n编写业务代码\n1 2 3 4 5 6 7 public class JulMain { public static void main(String[] args){ Log 1og= LogFactory.getLog(JulMain.class) log.info(\u0026#34;Hello world\u0026#34;); } } SLF4J 简单日志门面(Simple Logging Facade For Java) SLF4J主要是为了给Java日志访问提供一套标准、规范的API框架，\n主要意义：提供接口，具体的实现可以交由其他日志框架，例如log4j和logback等。\n对于一般的Java项目而言，日志框架会选择slf4j-api作为门面，配上具体的实现框架（log4j、logback等），中间使用桥接器完成桥接。所以我们可以得出SLF4J最重要的两个功能就是对于日志框架的绑定以及日志框架的桥接。\n具体使用\n引入相关依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!--slf4j 核心依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--slf4j 自带的简单日志实现 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-simple\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--具体日志框架的slf4j桥接器（可选）--\u0026gt; 编写业务代码(如果在没有任何其他日志实现框架集成的基础之上，slf4j使用的就是自带的框架slf4j-simple，slf4j-simple也必须以单独依赖的形式导入进来。)\n1 2 3 4 5 6 7 8 9 10 public class SLF4JTest01 { // 都是slf4j包下的 Logger logger = LoggerFactory.getLogger(SLF4JTest.class); logger.trace(\u0026#34;trace信息\u0026#34;); logger.debug(\u0026#34;debug信息\u0026#34;); logger.info(\u0026#34;info信息\u0026#34;); logger.warn(\u0026#34;warn信息\u0026#34;); logger.error(\u0026#34;error信息\u0026#34;); } 日志实现和对应的日志门面 日志实现 日志门面 log4j（已经淘汰） JCL/SLF4J JUL（java.utils.logging) JCL log4j2 SLF4J logback SLF4J 提示\n记录日志不能直接使用日志实现框架，必须通过日志门面来实现\n日志实现 JUL JUL全称 Java Util Logging，核心类在java.util.logging包下，它是java原生的日志框架，使用时不需要另外引用第三方的类库，相对其他的框架使用方便，学习简单，主要是使用在小型应用中。\n组件构成\nLogger：被称为记录器，应用程序通过获取Logger对象，调用其API来发布日志信息。Logger通常被认为是访问日志系统的入口程序。 Handler：处理器，每个Logger都会关联一个或者是一组Handler，Logger会将日志交给关联的Handler去做处理，由Handler负责将日志做记录。Handler具体实现了日志的输出位置，比如可以输出到控制台或者是文件中等等。 Filter：过滤器，根据需要定制哪些信息会被记录，哪些信息会被略过。 Formatter：格式化组件，它负责对日志中的数据和信息进行转换和格式化，所以它决定了我们输出日志最终的形式。 Level：日志的输出级别，每条日志消息都有一个关联的级别。我们根据输出级别的设置，用来展现最终所呈现的日志信息。根据不同的需求，去设置不同的级别。 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 日志示例 public static void test02() { /* 日志的级别，总共七级 Level.SEVERE：（最高级）错误 Level.WARNING：警告 Level.INFO：（默认级别）消息 Level.CONFIG：配置级别 Level.FINE：详细信息（少） Level.FINER：详细信息（中） Level.FINEST：（最低级）详细信息（多） 两个特殊的级别： Level.OFF；可用来关闭日志记录 Level.ALL：启用所有日志记录 */ // Logger创建方式，参数为当前类全路径字符串com.demo.logger.jul.JULTest Logger logger = Logger.getLogger(JULTest.class.getCanonicalName()); logger.severe(\u0026#34;severe信息\u0026#34;); logger.warning(\u0026#34;warning信息\u0026#34;); logger.info(\u0026#34;info信息\u0026#34;); logger.config(\u0026#34;config信息\u0026#34;); logger.fine(\u0026#34;fine信息\u0026#34;); logger.finer(\u0026#34;finer信息\u0026#34;); logger.finest(\u0026#34;finest信息\u0026#34;); /* 输出内容：我们看到，默认是输出info及比info信息级别高的信息 三月 20, 2023 9:47:27 下午 com.demo.logger.jul.JULTest test02 严重: severe信息 三月 20, 2023 9:47:27 下午 com.demo.logger.jul.JULTest test02 警告: warning信息 三月 20, 2023 9:47:27 下午 com.demo.logger.jul.JULTest test02 信息: info信息 */ } SpringBoot日志框架 SpringBoot框架底层使用slf4j+logback的方式进行日志记录同时对于其他日志实现都提供了slf4j日志门面的集成\nSpringBoot日志使用 日志级别 trace：日志追踪信息 debug：日志详细信息 info：日志的关键信息 默认打印级别 warn：日志警告信息 error：日志错误信息 只有级别大于日志核心配置文件的 rootlevel 的信息才会输出，SpringBoot默认的 rootlevel 是info\n可以在application.yml中进行 rootlevel 的修改\n1 2 3 4 5 6 7 8 9 10 #修改全局的rootlevel logging: level: root: #可以只修改某个包下日志的rootlevel #示例 logging: level: com: example: 日志记录器声明 方法一：Java语句声明\n1 2 //1.声明日志记录器 Logger logger=LoggerFactory.getLogger(全类名) 方法二：使用注解@Slf4j(这个注解基于lombok依赖)\n1 2 3 4 @Slf4j public class userController{ } ​\n日志格式 默认格式 日期和时间：毫秒精度，易于排序 日志级别：ERROR，WARN，INFO，DEBUG，或TRACE 进程ID \u0026mdash;：分离器来区分实际日志消息的开始。 线程名称:用方括号括起来(对于控制台输出可能会被截断) 记录器名称:这通常是源类名称(通常缩写)。 日志消息。 修改默认格式 可以在application.yml中修改logging.pattern.console属性来修改格式详情常见SpringBoot官方文档\n1 2 3 logging: pattern: console: SpringBoot官方文档\n日志输出 日志默认在控制台输出，可以通过修改applicaiton.yml中的logging.file.name和logging.file.path来输出日志文件\n1 2 3 4 5 6 7 8 logging: file: #只指定name属性不指定path属性则默认日志文件输出在项目的根目录中 #name属性可以同时指定输出路径和日志文件名例如D:/mylog.log name:日志文件名 #不可以指定文件名，只能指定一个物理文件夹路径，默认文件名为spring.log path:日志文件的输出路径 日志的归档和迭代 在application.yml中可以设置相关参数实现日志的归档和迭代\n名称 描述 logging.logback.rollingpolicy.file-name-pattern 归档的文件名 logging.logback.rollingpolicy.clean-history-on-start 是否在应用程序启动时进行日志归档清理。 logging.logback.rollingpolicy.max-file-size 归档前日志文件的最大大小。 logging.logback.rollingpolicy.total-size-cap 删除日志档案之前可以使用的最大大小 logging.logback.rollingpolicy.max-history 保留日志存档的天数(默认为7) 示例代码\n1 2 3 4 5 6 logging: file: name: 日志文件名 path: 日志文件的输出路径 max-file-size: 日志文件的最大大小(日志文件超出该大小则生成归档的压缩包) max-history: 日志文件保留的时间 ","date":"2024-11-09T19:20:26+08:00","permalink":"https://Tyritic.github.io/p/springboot%E7%83%AD%E9%83%A8%E7%BD%B2%E5%92%8C%E6%97%A5%E5%BF%97/","title":"SpringBoot热部署和日志"},{"content":"分模块设计与开发 将项目的不同业务功能划分为不同的Maven模块\n优点\n方便项目的维护拓展 方便模块的相互调用 继承 概念：继承描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。 作用：简化依赖配置、统一管理依赖（所有子工程共有的依赖配置在父工程中）\n所有的SpringBoot项目都继承一个统一的父工程spring-boot-starter-parent\n具体实现： 创建maven模块，该工程为父工程，设置打包方式pom(默认jar)\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.itheima\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.8-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; 在子工程的pom.xml文件中，配置继承关系。\n1 2 3 4 5 6 \u0026lt;parents \u0026lt;groupId\u0026gt;com.itheima\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;../ tlias-parent/pom,xml\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; 提示\n在子工程中，配置了继承关系之后，坐标中的groupId是可以省略的，因为会自动继承父工程的 relativePath指定父工程的pom文件的相对位置(如果不指定，将从本地仓库/远程仓库查找该工程)。 在父工程中配置各个工程共有的依赖(子工程会自动继承父工程的依赖)。 提示\n若子工程和父工程的依赖版本不同，以子工程的为准 打包方式 pom：父工程，该模块无代码只进行依赖管理 jar：内嵌Tomcat服务器 war：普通web程序，部署在在外部Tomcat服务器 版本锁定 在maven中，可以在父工程的pom文件中通过\u0026lt;dependencyManagement \u0026gt;来统一管理依赖版本。\n在父工程的pom文件中指定依赖版本后，子工程引入依赖时不需要指定依赖版本，变更依赖版本时在父工程的pom文件中统一更改\n示例\n1 2 3 4 5 6 7 8 9 10 11 #父工程 \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--JWT令牌--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 1 2 3 4 5 6 7 #子工程 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 提示\n\u0026lt; dependencies \u0026gt;和\u0026lt; dependencyManage \u0026gt;的区别\n\u0026lt; dependencies \u0026gt;是直接依赖，子工程的pom无须引入 \u0026lt; dependencyManage \u0026gt;是版本管理，子工程的pom依然需要引入 自定义属性/引用属性 可以在pom文件中使用标签\u0026lt;properties\u0026gt;标签来自定义属性\n1 2 3 4 \u0026lt;properties\u0026gt; \u0026lt;lombok.versiqn\u0026gt;1.18.24\u0026lt;/lombok.version\u0026gt; \u0026lt;jjwt.version\u0026gt;8.9.0\u0026lt;/jjwt.version\u0026gt; \u0026lt;/properties\u0026gt; 然后使用${}来引用自定义属性\n1 2 3 4 5 6 7 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 聚合 概述：将多个模块组织成一个整体，同时进行项目的构建。 聚合工程：一个不具有业务功能的“空”工程(有且仅有一个pom文件)通常是继承中的父工程 具体实现：在父工程中使用标签\u0026lt;module\u0026gt;指定子模块\n1 2 3 4 5 \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;../tlias-pojo\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;,./tlias-utils\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../tlias-web-management\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; 提示\n聚合工程中所包含的模块，在构建时，会自动根据模块间的依赖关系设置构建顺序，与聚合工程中模块的配置书写位置无关。\n继承和聚合的区别 作用\n聚合用于快速构建项目 继承用于简化依赖配置、统一管理依赖 相同点\n聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中 聚合与继承均属于设计型模块，并无实际的模块内容 不同点\n聚合是在聚合工程中配置关系，聚合可以感知到参与聚合的模块有哪些 继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己 ","date":"2024-11-09T12:27:38+08:00","permalink":"https://Tyritic.github.io/p/maven%E9%AB%98%E7%BA%A7/","title":"Maven高级"},{"content":"起步依赖 原理：SpringBoot框架提供的起步依赖通过Maven的依赖传递集成了开发中常见的依赖\n自动配置 概念 当spring容器启动后，一些配置类、bean对象就自动存入到了I0C容器中，不需要手动去声明，从而简化了开发，省去了繁琐的配置操作。\n实现方案 方案一：@ComponentScan 组件扫描依赖 1 2 3 4 @SpringBootApplication @ComponentScan({\u0026#34;com.alibaba\u0026#34;,\u0026#34;com.google\u0026#34;,\u0026#34;org.springframework\u0026#34;,\u0026#34;org.mybatis\u0026#34;,...} public class springbootWebconfig2Application{ } 方案二：@lmport 导入 使用@lmport导入的类会被Spring加载到I0C容器中，导入形式主要有以下几种:\n导入 普通类 导入 配置类 导入 ImportSelector 接口实现类 @EnableXXX注解，封装了@Import 1 2 3 4 5 @Import({TokenParser.class,Headerconfig.class}) @SpringBootApplication public class springbootWebconfig2Application{ } 源码分析 查看启动类的注解**@SpringBootApplication**的源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //自定义组件所需的元注解 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited //表示启动类也是一个配置类 @SpringBootConfiguration //自动配置功能 @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) 提示\n问：为什么在启动类中可以声明第三方Bean对象？\n答：@SpringBootApplication中封装了@SpringBootConfiguration，表明启动类也是一个配置类\n问：为什么启动类只会扫描启动类所在包及其子包的组件\n答：@SpringBootApplication中封装了@ComponentScan的注解\n由 @SpringBootApplication 的注解源码可知自动配置由注解 @EnableAutoConfiguration 提供，查看 @EnableAutoConfiguration的注解\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import({AutoConfigurationImportSelector.class}) public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = \u0026#34;spring.boot.enableautoconfiguration\u0026#34;; Class\u0026lt;?\u0026gt;[] exclude() default {}; String[] excludeName() default {}; } 可以看出 @EnableAutoConfiguration 注解通过 @Import注解导入 ImportSelector 接口实现类来实现自动配置\n查看AutoConfigurationImportSelector.class 的源码\n1 2 3 4 5 6 7 8 public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!this.isEnabled(annotationMetadata)) { return NO_IMPORTS; } else { AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); } } selectImports方法返回要导入的Bean对象的全类名\n从 AutoConfigurationImportSelector.class 的源码可以知道返回值从 autoConfigurationEntry.getConfigurations() 获得而autoConfigurationEntry 由 AutoConfigurationImportSelector.getAutoConfigurationEntry方法获得。查看 getAutoConfigurationEntry 的源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) { if (!this.isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } else { AnnotationAttributes attributes = this.getAttributes(annotationMetadata); List\u0026lt;String\u0026gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); configurations = this.removeDuplicates(configurations); Set\u0026lt;String\u0026gt; exclusions = this.getExclusions(annotationMetadata, attributes); this.checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = this.getConfigurationClassFilter().filter(configurations); this.fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); } } 从 AutoConfigurationImportSelector.getAutoConfigurationEntry看出 configuration是一个List\u0026lt;String\u0026gt;对象，从AutoConfigurationImportSelector.getCandidateConfigurations(annotationMetadata, attributes) 中获得。查看AutoConfigurationImportSelector.getCandidateConfigurations(annotationMetadata, attributes) 的源码\n1 2 3 4 5 protected List\u0026lt;String\u0026gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List\u0026lt;String\u0026gt; configurations = ImportCandidates.load(AutoConfiguration.class, this.getBeanClassLoader()).getCandidates(); Assert.notEmpty(configurations, \u0026#34;No auto configuration classes found in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you are using a custom packaging, make sure that file is correct.\u0026#34;); return configurations; } SpringBoot框架会自动加载 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 的配置文件并封装到 configurations 这个List集合中\n实现过程 @SpringBootApplication注解封装了 @EnableAutoConfiguration 来实现自动配置\n@EnableAutoConfiguration 封装了 @Import 注解，该注解以引入 ImportSelector接口的实现类AutoConfigurationImportSelector 来完成自动装配\nAutoConfigurationImportSelector 获取 AutoConfigurationEntry 对象，该对象具有成员变量Configurations用于存储Bean对象的全类名\nAutoConfigurationEntry 使用 getCandidateConfigurations方法，SpringBoot框架会自动加载 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 配置文件并封装到 configurations 这个List集合中\nMETA-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 中封装了Bean对象的声明\n条件配置 @Conditional 作用：按照一定的条件进行判断，在满足给定条件后才会注册对应的bean对象到SpringIOC容器中。\n位置：方法、类\n@Conditional 本身是一个父注解，派生出大量的子注解:\n@Conditional0nClass：判断环境中是否有对应字节码文件，才注册bean到IOC容器。 @ConditionalOnMissingBean：判断环境中没有对应的bean(类型或名称)，才注册bean到IOC容器。 @ConditionalOnProperty：判断配置文件中有对应属性和值，才注册bean到IOC容器。 ","date":"2024-11-08T18:47:12+08:00","permalink":"https://Tyritic.github.io/p/springboot%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","title":"SpringBoot底层原理"},{"content":"Bean对象的获取 默认情况下，Spring项目启动时，会把bean都创建好放在IOC容器中\n提示\n上述所说的【Spring项目启动时，会把其中的bean都创建好】还会受到作用域及延迟初始化影响，这里主要针对于默认的单例非延迟加载的bean而言。\n但可以主动获取Bean对象\n具体实现\n注入IOC容器对象：ApplicationContext 1 2 3 根据name获取bean: Object getBean(String name) 根据类型获取bean：\u0026lt;T\u0026gt;T getBean(class\u0026lt;T\u0026gt; requiredType) 根据name获取bean(带类型转换)：\u0026lt;T\u0026gt;T getBean(String name,Class\u0026lt;T\u0026gt;requiredType) Bean对象的作用域 Spring支持五种作用域，后三种在web环境才生效\n作用域 说明 singleton 容器内同 名称 的 bean 只有一个实例(单例)(默认) prototype 每次使用该 bean 时会创建新的实例(非单例) request 每个请求范围内会创建新的实例(web环境中，了解) session 每个会话范围内会创建新的实例(web环境中，了解) application 每个应用范围内会创建新的实例(web环境中，了解) 使用@Scope注解来指定作用域\n1 2 3 4 5 @Scope(\u0026#34;prototype\u0026#34;) @RestController @RequestMapping(\u0026#34;/depts\u0026#34;) public class DeptController { } 警告\n注意事项\n默认singleton的bean，在容器启动时被创建，可以使用@Lazy注解来延迟初始化(延迟到第一次使用时)prototype的bean，每一次使用该bean的时候都会创建一个新的实例。 实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性。 第三方Bean对象 如果要管理的bean对象来自于第三方(不是自定义的)，是无法用 @Component及衍生注解声明bean的，就需要用到 @Bean注解。\n具体实现\n​\t方法一：在启动类中使用@Bean注解修饰一个返回值为Bean对象的方法（不推荐）\n1 2 3 4 5 6 @springBootApplication public class springbootWebconfig2Application { @Bean/将方法返回值交给I0C容器管理,成为IOC容器的bean对象 public SAXReader saxReader(){ return new SAXReader(); } 方法二：创建一个配置类（使用@Configuration)集中配置Bean对象\n1 2 3 4 5 6 @Configuration public class commonconfig{ @Bean/将方法返回值交给I0C容器管理,成为IOC容器的bean对象 public SAXReader saxReader(){ return new SAXReader(); } 提示\n通过@Bean注解的name或value属性可以声明bean的名称，如果不指定，默认bean的名称就是方法名 如果第三方bean需要依赖其它bean对象，直接在bean定义方法中设置形参即可，容器会根据类型自动装配。 ","date":"2024-11-08T17:05:51+08:00","permalink":"https://Tyritic.github.io/p/bean%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%AE%A1%E7%90%86/","title":"Bean对象的管理"},{"content":"配置方式 文件配置 properties文件 yml文件 yaml文件 Java系统属性 设置方法 执行maven打包指令package\n执行java指令，运行jar包，在执行java命令时添加参数\n参数格式\n1 -Dxxx=xxx 命令行参数 执行maven打包指令package\n执行java指令，运行jar包，在执行java命令时添加参数\n参数格式\n1 --xxx=xxx 配置优先级 优先级从低到高\napplication.yam](忽略) application.yml application.properties java系统属性(-Dxxx=xxx) 命令行参数(\u0026ndash;xxx=xxx) ","date":"2024-11-08T16:37:30+08:00","permalink":"https://Tyritic.github.io/p/springboot%E9%85%8D%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7/","title":"SpringBoot配置优先级"},{"content":"概述 AOP就是是Aspect Oriented Programming(面向切面编程、面向方面编程)，其实就是面向特定方法编程\n底层实现：动态代理是面向切面编程最主流的实现。而SpringAOP是Spring框架的高级技术，旨在管理bean对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程。\n应用场景\n记录操作日志 权限控制 事务管理 具体实现 导入相关依赖\n编写AOP程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Component @Aspect public class TimeAspect { @Around(\u0026#34;execution()”) public Object recordTime(ProceedingJoinPoint proceedingJoinPoint)throws Throwable { long begin=System.currentTimeMillis(); 0bject object=proceedingJoinPoint.proceed();//调用原始方法运行 long end=System.currentTimeMillis(); log.info(proceeding]oinPoint.getsignature()+\u0026#34;执行耗时:{}ms\u0026#34;,end - begin); return object; } } AOP核心概念 连接点（JoinPoint）：可以被AOP控制的方法(暗含方法执行时的相关信息)\n通知（Advice）：指哪些重复的逻辑，也就是共性功能\n体现为被@Around()修饰的方法 切入点（PointCut）：匹配连接点的条件，通知仅会在切入点方法执行时被应用\n相关注解：@Around(\u0026ldquo;execution()”) 切面（Aspect）：描述通知与切入点的对应关系(通知+切入点)\n相关注解：@Aspect用于修饰类 目标对象（Target）：通知所应用的对象\nAOP执行流程 底层为目标对象生成代理对象 在代理对象中使用通知对目标对象的连接点做功能增强 在依赖注入时注入代理对象 AOP通知 通知类型 @Around:环绕通知，此注解标注的通知方法在目标方法前、后都被执行 @Before:前置通知，此注解标注的通知方法在目标方法前披执行 @After :后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行 @AfterReturning: 返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行 @AfterThrowing: 异常后通知，此注解标注的通知方法发生异常后执行 提示\n@Around环绕通知需要自己调用 ProceedingJoinPoint.proceed()来让原始方法执行，其他通知不需要考虑目标方法 执行@Around环绕通知方法的返回值，必须指定为Object，来接收原始方法的返回值。 通知顺序 当有多个切面的切入点都匹配到了目标方法，目标方法运行时，多个通知方法都会被执行\n不同切面类的通知顺序 目标方法前的通知方法：字母排名靠前的先执行 目标方法后的通知方法：字母排名靠前的后执行 用注解@Order(数字) 加在切面类上来控制顺序 目标方法前的通知方法:数字小的先执行 目标方法后的通知方法:数字小的后执行 同一个切面类的通知顺序 Around-Before Before Around-after after 切入点表达式 切入点表达式：描述切入点方法的一种表达式 作用：主要用来决定项目中的哪些方法需要加入通知\nexecution(….)根据方法的签名来匹配 execution 主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配\n语法：execution(访问修饰符? 返回值 包名.类名.?方法名(方法参数)throws 异常?)\n带?的部分可以省略\n访问修饰符:可省略(比如:public、protected) 包名.类名: 可省略 throws 异常:可省略(注意是方法上声明抛出的异常，不是实际抛出的异常) 通配符\n*：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分\n1 execution(* com.*.service.*.update*(*)) :：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数\n1 execution(* com.itheima..Deptservice.*(..)) @annotation(.):根据注解匹配 @annotation切入点表达式，用于匹配标识有特定注解的方法\n语法：@annotation(全类名)\n1 2 3 4 @Before(\u0026#34;@annotation(com.itheima.anno.Log)\u0026#34;) public void before(){ log.info(\u0026#34;before ....\u0026#34;); } 提示\n@PointCut 该注解的作用是将公共的切点表达式抽取出来，需要用到时引用该切点表达式即可\n1 2 3 4 5 6 @Pointcut(\u0026#34;execution()\u0026#34;) public void pt(){) @Around(\u0026#34;pt()\u0026#34;) public Object recordrime(ProceedingjoinPoint joinPoint) throws Throwable { } 注意事项\nprivate:仅能在当前切面类中引用该表达式 public:在其他外部的切面类中也可以引用该表达式 连接点 在Spring中用JoinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等。\n对于 @Around 通知，获取连接点信息只能使用ProceedingJoinPoint\n对于其他四种通知，获取连接点信息只能使用JoinPoint，它是ProceedingJoinPoint 的父类型\n相关方法\n1 2 3 4 5 6 7 8 9 @Around(\u0026#34;execution()\u0026#34;) public object around(Proceeding)oinPoint joinPoint)throws Throwable { String className=joinPoint.getTarget().getc1ass().getName(); //获取目标类名 Signature signature=joinPoint.getsignature();//获取目标方法签名 String methodName= joinPoint.getsignature().getName();//获取目标方法名 0bject[]args = joinPoint.getArgs();//获取目标方法运行参数 0bject res= joinPoine.proceed();/执行原始方法,获取返回值(环绕通知) return res; } 1 2 3 4 5 6 7 8 @Before(\u0026#34;execution(\u0026#34;\u0026#34;)) public void befored(JoinPoint joinPoint) { String className=joinPoint.getTarget().getclass().getName();//获取目标类名 Signature signature=joinPoint.getsignature();//获取目标方法签名 String methodName =joinPoint.getsignature().getName();//获取目标方法名 0bject[]args= joinPoint.getArgs();//获取目标方法运行参数 } ","date":"2024-11-07T18:38:05+08:00","permalink":"https://Tyritic.github.io/p/aop/","title":"AOP"},{"content":"数据库中的事务 概念：事务是一组操作的集合，它是一个不可分割的工作单位，这些操作 要么同时成功，要么同时失败。\n操作\n开启事务(一组操作开始前，开启事务)\n1 start transaction; 提交事务(这组操作全部成功后，提交事务)\n1 commit; 回滚事务(中间任何一个操作出现异常，回滚事务)\n1 rollback; Spring中的事务管理 @Transactional 注解\n位置：service层的方法，类，接口上\n修饰方法\n1 2 3 4 5 6 @Transactional @Override public void delete(Integer id){ deptMapper.delete(id); empMapper.deleteByDeptId(id); } 修饰类\n1 2 3 4 @Transactional @Service public class DeptServiceImpl implements DeptService{ } 修饰接口\n1 2 3 4 @Transactional public interface DeptService { } 作用：将当前方法交给spring进行事务管理\n方法执行前，开启事务; 成功执行完毕，提交事务; 出现异常，回滚事务 事务属性 回滚 默认情况下，只有出现 RuntimeException 才回滚异常。rollbackFor 属性用于控制出现何种异常类型，回滚事务。\n示例代码\n1 2 3 4 5 6 @Transactional(rollbackFor=Exception.class) @Override public void delete(Integer id)throws Exception { deptMapper.deleteById(id); empMapper.deleteByDeptId(id); } 传播行为 传播行为：指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制。\n常见的传播行为属性\n属性值 含义 REQUIRED 【默认值】需要事务，有则加入，无则创建新事务 REQUIRES_NEW 需要新事务，无论有无，总是创建新事务 SUPPORTS 支持事务，有则加入，无则在无事务状态中运行 NOT_SUPPORTED 不支持事务，在无事务状态下运行,如果当前存在已有事务,则挂起当前事务 MANDATORY 必须有事务，否则抛异常 NEVER 必须没事务，否则抛异常 使用场景\nREQUIRED：大部分情况下都是用该传播行为即可。 REOUIRES NEW：当我们不希望事务之间相互影响时，可以使用该传播行为。比如:下订单前需要记录日志，不论订单保存成功与 否，都需要保证日志记录能够记录成功。 ","date":"2024-11-07T16:51:41+08:00","permalink":"https://Tyritic.github.io/p/springboot%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/","title":"SpringBoot事务管理"},{"content":"项目开发过程中会遇到异常问题\n全局异常处理器 @RestControllerAdvice：用于修饰类表示全局异常处理器\n@ExceptionHandler：用于修饰异常处理方法\n示例代码\n1 2 3 4 5 6 @RestControllerAdvice puhlic class GlobalExceptionHandler { @ExceptionHandler(Exception.class) public Result ex(Exception ex){ex.printstackTrace(); return Result.error(”对不起,操作失败,请联系管理员\u0026#34;); } 全局异常 在common包下定义基本异常BaseException，其余的异常为这个类的子类\n示例代码\n1 2 3 4 5 6 7 8 9 10 public class BaseException extends RuntimeException { public BaseException() { } public BaseException(String msg) { super(msg); } } ","date":"2024-11-07T16:33:35+08:00","permalink":"https://Tyritic.github.io/p/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","title":"异常处理"},{"content":"简介 Spring框架中提供的，用来动态拦截控制器方法的执行。 作用:拦截请求，在指定的方法调用前后，根据业务需要执行预先设定的代码。\n具体实现 定义Interceptor类，实现HandlerInterceptor接口并重写方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Component public class LoginCheckInterceptor implements HandlerInterceptor { @0verride //目标资源方法执行前执行，放回true:放行，返回false:不放行 public boolean prehandle(HttpServletRequest reg, HttpServletResponse resp, object handler) throws Exception { System.out.println(\u0026#34;preHandle ...\u0026#34;); return true; } @Override //目标资源方法执行后执行 public void postHandle(HttpservletRequest req, HttpServletResponse resp, object handler, ModelAndview modelAndview){ System.out.println(\u0026#34;postHandle..\u0026#34;); } @0verride //视图渲染完毕后执行，最后执行 public void afterCompletion (HttSservietReguest reg, HttpServletResponse resp, Object handler, Exception ex) { System.out.println(\u0026#34;aftercompletion ...\u0026#34;); } } 注册拦截器\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class webConfig implements WebMvcConfigurer { @Autowired private LoginCheckInterceptor logincheckInterceptor; @Override public void addInterceptors(InterceptorRegistry registry){ registry.addInterceptor (logincheckInterceptor) .addPathPatterns(\u0026#34;拦截路径\u0026#34;) .excludePathPatterns(\u0026#34;放行路径\u0026#34;) } } 拦截路径 拦截器可以根据需求，配置不同的拦截路径:\n拦截路径 含义 示例 /* 所有的一级路径 /depts /** 任意级路径 /depts，/depts/1 /depts/* /depts下的一级路径 /depts/1 /depts/** /depts下的任意级路径 /depts/emp/1 执行流程 请求先进入过滤器还未进入Spring容器中 经过过滤器的校验后进入DispatcherServlet 请求到达拦截器进行校验 提示\n接口规范不同: 过滤器需要实现Filter接口 拦截器需要实现Handlerinterceptor接口。 拦截范围不同: Filter会拦截所有的资源 Interceptor只会拦截Spring环境中的资源。 ","date":"2024-11-07T15:49:32+08:00","permalink":"https://Tyritic.github.io/p/interceptor/","title":"Interceptor"},{"content":"概述 Filter 过滤器是JavaWeb 三大组件(Servlet、Filter、Listener)之一。\n作用：过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。\n使用场景：过滤器一般完成一些通用的操作，比如:登录校验、统一编码处理、敏感字符处理等。\n具体实现 定义Filter类：实现 Filter接口，并重写其所有方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @WebFilter(urlPatterns =\u0026#34;/*\u0026#34;) public class DemoFilter implements Filter { //初始化方法,Web服务器启动,创建Filter时调用，只调用一次 public void init (Filterconfig filterconfig)throws ServletException { Filter.super.init(filterConfig); } ///拦截到请求时,调用该方法,可调用多次 public void doFilter (ServletRequest request, servletResponse response, Filterchain chain){ System.out.println(\u0026#34;拦截方法执行，拦截到了请求...\u0026#34;); System.out.println(\u0026#34;执行放行前的逻辑...\u0026#34;); chain.doFilter(request,response);// 放行请求 System.out.println(\u0026#34;执行放行后的逻辑...\u0026#34;); } //销毁方法，服务器关闭时调用，只调用一次 public void destroy(){ Filter.super.destroy(); } } 配置Filter：使用@WebFilter注解，配置拦截资源的路径。\n引导类上加 @ServletComponentScan 开启Servlet组件支持。\n1 2 3 4 5 @ServletComponentScan @SpringBootApplication public class TliasWebManagementApplication{public static void main(stringl] args){ SpringApplication.run(TliasWebManagementApplication.class, args); } 执行流程 过滤器拦截到请求 过滤器执行doFilter()之前的部分作为放行前的逻辑 过滤器执行doFilter()放行请求 过滤器执行doFilter()之后的部分作为放行后的逻辑 提示\n放行后访问对应资源，资源访问完成后，还会回到Filter中 回到Filter中执行放行后的逻辑 拦截路径 Filter 可以根据需求，配置不同的拦截资源路径\n拦截路径 urlPattern 含义 拦截具体路径 /login 只有访问/login才被拦截 目录拦截 /emp/* 访问emp目录下的资源都被拦截 拦截所有 /* 访问所有资源都被拦截 过滤器链 一个web应用中，可以配置多个过滤器，这多个过滤器就形成了一个过滤器链\n顺序：注解配置的Filter，优先级是按照过滤器类名(字符串)的自然排序\n","date":"2024-11-07T14:50:40+08:00","permalink":"https://Tyritic.github.io/p/filter/","title":"Filter"},{"content":"登录功能实现的基本思路 登录标记 用户登录成功之后，每一次请求中，都可以获取到该标记，\n常见技术\n会话技术 登录校验 对接收到的请求进行统一拦截\n常见技术\n过滤器（Filter） 拦截器（Interceptor） 登录标记 会话技术 用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。\n会话跟踪 一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。\n会话跟踪方案\n客户端会话跟踪技术:Cookie 服务端会话跟踪技术:Session 令牌技术 Cookies 基本流程\n浏览器第一次向服务端发出请求时服务端设置Cookies 服务端给浏览器响应并设置响应头的Set-Cookie 浏览器解析Cookie值并保存在浏览器本地 后续的每次请求中浏览器会将Cookis数据放入请求头中 优点：HTTP协议支持的技术\n缺点\n移动端APP不支持cookie 不安全，用户可以自己禁用Cookie Cookies不能跨域 提示\n跨域被分为三个维度：协议，IP，端口，三者有一个不同就是跨域\nSession 基本流程\n浏览器第一次向服务器端发出请求，此时服务器端没有Session对象 服务器端生成Session对象并将Session对象放入响应的响应头（Set-Cookies） 浏览器保存Session对象并在此后的每次请求中以请求头的Cookies数据附带Session对象 服务器会寻找到请求Cookies中的Session对象从而实现数据共享 优点：存储在服务器端安全\n缺点\n服务器集群中无法直接使用Session技术 Session技术基于Cookies技术，继承了Cookies的全部缺点 令牌技术 基本流程\n浏览器发出请求后，服务端生成令牌作为身份凭证放入响应 此后的每一次请求浏览器的请求携带会携带令牌 服务端则会校验令牌 优点:\n支持PC端、移动端 解决集群环境下的认证问题 减轻服务器端存储压力 JWT令牌技术 简介：全称:jSON Web Token(https://jwt.io/) 定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。\n令牌结构 第一部分:Header(头)，记录令牌类型、签名算法等。 第二部分:Payload(有效载荷)，携带一些自定义信息、默认信息等。 第三部分:Signature(签名)，防止Token被篡改、确保安全性。将header、payload，并加入指定秘钥，通过指定签名算法计算而来。 使用场景：登录认证 登录成功后服务端生成令牌，通过响应返回给客户端 此后每个请求都要携带JWT令牌，服务端每次处理请求前都要校验令牌，校验通过后再处理 具体实现 引入JWT相关依赖 将JWT数字签名的相关部分放入Properties文件中以备引用 书写JWT工具类的生成方法和解析方法 生成JWT令牌 具体思路\n指定签名算法 使用令牌持续时间来计算令牌的过期时间 生成JWT令牌函数Jwts.builder() 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * 创建jwt * 加密算法：HS256 * 私钥使用jwtProperties中的userSecretKey * @param claims 载荷 * @return jwt */ public String createJwt(Map\u0026lt;String, Object\u0026gt;claims) { String userSecretKey = jwtProperties.getUserSecretKey(); //自定义密钥 long userTtl = jwtProperties.getUserTtl(); //令牌持续时间 SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; //指定签名算法 long nowMillis = System.currentTimeMillis(); Date exp = new Date(nowMillis + userTtl); //令牌过期时间 JwtBuilder builder = Jwts.builder() //生成JWT令牌 .setClaims(claims) //设置载荷 .signWith(signatureAlgorithm, userSecretKey.getBytes()) //设置数字签名（签名算法，过期时间） .setExpiration(exp); //设置过期时间 return builder.compact(); } 解析JWT令牌 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * 解密jwt * @param token jwt * @return jwt中的数据 */ public Claims parseJwt(String token) { //获取jwtProperties中的userSecretKey String userSecretKey = jwtProperties.getUserSecretKey(); return Jwts.parser() .setSigningKey(userSecretKey.getBytes(StandardCharsets.UTF_8)) .parseClaimsJws(token) .getBody(); } 登录校验 过滤器（Filter） 参见博客Filter\n拦截器（interceptor） 参见博客Interceptor\n","date":"2024-11-07T13:11:16+08:00","permalink":"https://Tyritic.github.io/p/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/","title":"登录功能"},{"content":"配置文件的种类 SpringBoot提供了多种属性配置方式\napplication.properties\n1 2 server.port=8080 server.address=127.0.0.1 application.yml\n1 2 3 server: port:8080 address:127.0.0.1 application.yaml\n1 2 3 server: port:8080 address:127.0.0.1 配置文件优先级 优先级从高到低：properties\u0026gt;yml\u0026gt;yaml\n外部配置文件的优先级（从低到高）\nclasspath（resource文件夹） classpath根config 项目根目录（对于存在继承/聚合关系的maven项目项目根目录是父工程的根目录） 项目根目录/config 直接子目录/config 多配置文件的加载 Profile意思是配置，不同环境可能需要不同的配置需要\nSpringBoot框架提供了多profile的管理功能，我们可以使用profile文件来区分不同环境的配置\n基本语法 如果需要创建自定义的yml文件时，可以用application-{profile}.yml的命名方式\n切换不同环境的yml文件时在application.yml中配置\n1 2 3 spring: profiles: active: profile yml文件语法 基本语法 大小写敏感 数值前边必须有空格，作为分隔符 使用缩进表示层级关系，缩进时，不允许使用Tab键，只能用空格(idea中会自动将Tab转换为空格) 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 #表示注释，从这个字符一直到行尾，都会被解析器忽略 数据格式 对象/Map集合\n1 2 3 4 user: name: zhangsan age: 18 password:123456 数组/List集合\n1 2 3 4 hobby: -java -game -sport 参数配置化 利用注解进行参数配置化 @Value 注解通常用于外部配置的属性注入，具体用法为: @Value(\u0026quot;${配置文件中的key}\u0026quot;)\n示例代码\n1 2 3 4 aliyun.oss.endpoint=https://oss-cn-hangzhou.aliyuncs.com aliyun.oss.accessKeyId=LTAI4GCHlvX6DKqJWxdбnEuW aliyun.oss.accessKeySecret=yBshYweHOpqDuhCArrVHwIiBKPYqSL aliyun.oss.bucketName=web-tlias 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Component pubiic class AliossUti1s{ @Value(\u0026#34;${aliyun.oss.endpoint}\u0026#34;) private string endpoint; @Value(\u0026#34;${aliyun.oss.accessKeyId}\u0026#34;) private string accesskeyId; @Value(\u0026#34;${aliyun.oss.accessKeySecret}\u0026#34;) private String accessKeySecret; @Value (\u0026#34;${aliyun.oss.bucketName } \u0026#34;) private String bucketName } 使用自定义配置类进行参数配置化 自定义properties文件使用@Component注册为Bean对象，使用 @ConfigurationProperties 注解批量的将yml配置文件的属性和Bean对象属性绑定，@ConfigurationProperties 的prefix属性指定application.yml的子节点，该节点中的子节点将自动和属性进行绑定\n示例代码\n1 2 3 4 5 6 7 8 9 10 @Data @Component @ConfigurationProperties(prefix = \u0026#34;operator.aliyun.oss\u0026#34;) public class AliyunOSSProperties { String endpoint; String accessKeyId; String accessKeySecret; String bucketName; String region; } @ConfigurationProperties 支持jsr-300数据校验使用 @Validate\n提示\n​\tjsr-300数据校验\n@Null：被注释的元素必须为 null @NotNull：被注释的元素必须不为nu11 @AssertTrue：被注释的元素必须为true @AssertFalse：被注释的元素必须为false @Min(value)：被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value)：被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value)：被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value)：被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max，min)：被注释的元素的大小必须在指定的范围内 @Digits (integer,fraction)：被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past：被注释的元素必须是一个过去的日期 @Future：被注释的元素必须是一个未来的日期 ","date":"2024-11-07T10:19:39+08:00","permalink":"https://Tyritic.github.io/p/springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","title":"SpringBoot配置文件"},{"content":"简介 文件上传，是指将本地图片、视频、音频等文件上传到服务器，供其他用户浏览或下载的过程。\n实现要点 前端页面 表单项 type=“file” 表单提交方式 post 表单的enctype属性 multipart/form-data 后端controller类 使用MultipartFile接收文件 实现方式 上传到本地 常见方法\n1 2 3 4 5 - String getOriginalFilename(); //获取原始文件名 - void transferTo(File dest); //将接牧的文件转存到磁盘文件中 - long getSize(); //获取文件的大小，单位:字节 - byte[] getBytes();//获取文件内容的字节数组 - InputStream getinputStream(); //获取接收到的文件内容的输入流 具体实现\n1 2 3 4 5 6 7 8 9 10 11 12 @RestController public class UploadController { @PostMapping(\u0026#34;/upload\u0026#34;) public Result upload(MultipartFile image) throws IOException //获取原始文件名 String originalFilename =image.getOriginalFilename(): //构建新的文件名 String newfileName = UUID.,randomUUID.toString()+originalFilename.substring(originalFilename.lastindexOf(\u0026#34;.\u0026#34;)); //将文件保存在服务器端 E:/images目景下 image.transferTo(new File(\u0026#34;E:/images/\u0026#34;+newFileName)): return Result,success(); } 提示\n在SpringBoot中，文件上传，默认单个文件允许最大大小为1M。如果需要上传大文件，可以进行在application.yml如下配置:\n1 2 3 4 spring: servlet: multipart.max-file-size=10MB #配置单个文件最大上传大小 max-request-size=100MB #配置单个请求最大上传大小(一次请求可以上传多个文件) 阿里云OSS存储 基本概念\nBucket：存储空间是用户用于存储对象(0bject，就是文件)的容器，所有的对象都必须隶属于某个存储空间。 SDK:Software Development Kit 的缩写，软件开发工具包，包括辅助软件开发的依赖(jar包)、代码示例等，都可以叫做SDK。 具体实现\n创建bucket并获取AccessKey\n在pom.xml中引入相关依赖\n将aliyunOSS服务所需的相关参数写入配置文件application.yml中，并专门建立一个properties配置文件\n将相关方法写入工具类中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 public String upload(MultipartFile file) throws ClientException { if(file==null||file.isEmpty()){ return null; } String endpoint = aliyunOSSProperties.getEndpoint(); String bucketName = aliyunOSSProperties.getBucketName(); String region = aliyunOSSProperties.getRegion(); String accessKeyId = aliyunOSSProperties.getAccessKeyId(); String accessKeySecret = aliyunOSSProperties.getAccessKeySecret(); // 创建OSSClient实例 ClientBuilderConfiguration clientBuilderConfiguration = new ClientBuilderConfiguration(); CredentialsProvider defaultCredentialProvider = new DefaultCredentialProvider(accessKeyId, accessKeySecret); OSS ossClient= OSSClientBuilder.create() .endpoint(endpoint) .credentialsProvider(defaultCredentialProvider) .clientConfiguration(clientBuilderConfiguration) .region(region) .build(); String originalFilename = file.getOriginalFilename(); String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(\u0026#34;.\u0026#34;)); try { InputStream fileInputStream = file.getInputStream(); ossClient.putObject(bucketName, fileName, fileInputStream); String url=endpoint.split(\u0026#34;//\u0026#34;)[0]+\u0026#34;/\u0026#34;+bucketName+\u0026#34;.\u0026#34;+endpoint.split(\u0026#34;//\u0026#34;)[1]+\u0026#34;/\u0026#34;+fileName; return url; } catch (Exception e) { log.error(\u0026#34;上传文件失败\u0026#34;, e); throw new ClientException(\u0026#34;上传文件失败\u0026#34;); } finally { ossClient.shutdown(); } } public void deleteExhibitImage(String d_url) { String endpoint = aliyunOSSProperties.getEndpoint(); String bucketName = aliyunOSSProperties.getBucketName(); String region = aliyunOSSProperties.getRegion(); String accessKeyId = aliyunOSSProperties.getAccessKeyId(); String accessKeySecret = aliyunOSSProperties.getAccessKeySecret(); String fileName=d_url.substring(d_url.lastIndexOf(\u0026#34;/\u0026#34;)+1);//从url中获取bucket中的文件名 // 创建OSSClient实例 ClientBuilderConfiguration clientBuilderConfiguration = new ClientBuilderConfiguration(); CredentialsProvider defaultCredentialProvider = new DefaultCredentialProvider(accessKeyId, accessKeySecret); OSS ossClient= OSSClientBuilder.create() .endpoint(endpoint) .credentialsProvider(defaultCredentialProvider) .clientConfiguration(clientBuilderConfiguration) .region(region) .build(); try { ossClient.deleteObject(bucketName, fileName); } catch (Exception e) { log.error(\u0026#34;删除文件失败\u0026#34;, e); } finally { ossClient.shutdown(); } } ","date":"2024-11-07T09:52:26+08:00","permalink":"https://Tyritic.github.io/p/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","title":"文件上传"},{"content":"在Mapper接口中基于注解书写sql语句 设置动态参数 1 #{参数名} 如果mapper接口中的方法参数名和mapper.xml中sql语句中的字段名一致，spring会自动进行封装\n设置mappper接口方法参数名和mapper.xml中的sql语句中的字段一致 如果mapper接口中的方法参数名和mapper.xml中sql语句中的字段名不一致，需要通过注解@Param来指定对应关系\n1 @Param(Sql语句中的字段名) 方法参数名 示例\n1 User selectUser(@param(“name”)String personName); 1 2 3 \u0026lt;select id=\u0026#34; selectUser\u0026#34; resultMap=\u0026#34;BaseResultMap\u0026#34;\u0026gt; select * from user where user_name = #{name} \u0026lt;/select\u0026gt; 删除操作 sql语句 1 delete from emp where id=#{id} 接口方法 1 2 3 4 5 @Mapper public interface EmpMapper //根据ID删除数据 @Delete(\u0026#34;delete from emp where id=#{id}\u0026#34;) public void delete(Integer id): 添加操作 sql语句 1 2 insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) values(#{username), #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptld}, #{createTime}, #{updateTime} 接口方法 1 2 3 4 5 @Mapper public interface EmpMapper //根据ID添加数据 @Insert(\u0026#34;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time)\u0026#34; +\u0026#34;values(#{username), #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptld}, #{createTime}, #{updateTime}\u0026#34;) public void insert(Emp emp); 主键返回 描述：在数据添加成功后，需要获取插入数据库数据的主键。\n实现：在@Insert上添加注解 @Options(keyProperty = \u0026ldquo;id\u0026rdquo;, useGeneratedKeys = true) 会自动将生成的主键值赋给id属性\n更新操作 sql语句 1 update emp set username=#{username),name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_Id=#{deptld}, create_time=#{createTime}, update_time=#{updateTime} where id=#{id} 接口方法 1 2 3 4 @Mapper public interface EmpMapper @Update(\u0026#34;update emp set username=#{username), name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_Id=#{deptld}, create_time=#{createTime}, update_time=#{updateTime} where id=#{id}\u0026#34;) public void update(Emp emp); 提示\n数据封装\n实体类属性名和数据库表查询返回的字段名一致，mybatis会自动封装。 如果实体类属性名 和 数据库表查询返回的字段名不一致，不能自动封装。 解决方案\n方案一：给字段起别名与实体类属性名相同\n方案二：使用@Results注解手动指定映射，@Result封装映射\ncolumn属性指定数据库字段 property属性指定实体类属性 1 2 3 @Results({ @Result(column=\u0026#34;数据库字段\u0026#34;,property=\u0026#34;实体类属性\u0026#34;) }) 查询操作 sql语句 1 2 3 select * from emp where name like \u0026#39;%李%\u0026#39; 接口方法 1 2 3 4 @Mapper public interface EmpMapper @Select(\u0026#34;select * from emp where name like \u0026#39;%#{name}%\u0026#39;\u0026#34;) public List\u0026lt;User\u0026gt; list(String name) 警告\n在模糊匹配中%#{name}%不建议使用（不是预编译sql语句）\n可以使用concat(‘%\u0026rsquo;,\u0026rsquo;#{name}\u0026rsquo;,\u0026rsquo;%')\n在Mapper.xml中基于映射文件属性sql语句 使用规范 XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下(同包同名)。\nXML映射文件的namespace属性为Mapper接口全限定名一致。\nXML映射文件中sql语句的id与Mapper 接口中的方法名一致，并保持返回类型一致。\n编写sql语句的格式\n1 2 3 \u0026lt;操作名 id=\u0026#34;函数名\u0026#34; resultType=\u0026#34;单条记录的实体类全类名\u0026#34;\u0026gt; sql语句 \u0026lt;/操作名\u0026gt; 提示\n只有select操作需要resultType\n动态SQL语句 \u0026lt; if \u0026gt;标签 ​\t描述：用于判断条件是否成立。使用test属性进行条件判断，如果条件为true，则拼接SQL\n​\t示例代码\n1 2 3 4 5 6 7 8 \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.itheima.pojo.Emp\u0026#34;\u0026gt; select * from omp where \u0026lt;if test=\u0026#34;name !=null\u0026#34;\u0026gt; name like concat(\u0026#34;%\u0026#34;,#{name},\u0026#34;%\u0026#34;) \u0026lt;/if\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;where\u0026gt;标签 ​\t描述：动态生成where子句，若子标签的条件都不满足则不会生成where子句，同时会删除子句开头的条件运算符\n​\t示例代码\n1 2 3 4 5 6 7 8 9 \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.itheima.pojo.Emp\u0026#34;\u0026gt; select * from emp \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name !=null\u0026#34;\u0026gt; name like concat(\u0026#34;%\u0026#34;,#{name},\u0026#34;%\u0026#34;) \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;set\u0026gt;标签 描述：动态生成set子句\n示例代码\n1 2 3 4 5 6 7 8 9 \u0026lt;update id=\u0026#34;update\u0026#34;\u0026gt; update emp \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;name !=null\u0026#34;\u0026gt; name=#{name} \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id=#{id} \u0026lt;/update\u0026gt; \u0026lt;foreach\u0026gt;标签 描述：用于遍历元素\n属性\ncollection：遍历的集合 item：集合中的元素 separator：分隔符 open：遍历开始前的SQL语句 close：遍历结束后的SQL语句 示例代码\n1 2 3 4 5 6 \u0026lt;delete id=\u0026#34;delete\u0026#34;\u0026gt; delete from emp where id in \u0026lt;foreach collection=\u0026#34;遍历的集合\u0026#34;,item=\u0026#34;集合中的元素\u0026#34;,separator=\u0026#34;分隔符\u0026#34;,open=\u0026#34;(\u0026#34;,close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; \u0026lt;sql\u0026gt;标签和\u0026lt;include\u0026gt;标签 \u0026lt;sql\u0026gt;:定义可重用的 SQL片段。 \u0026lt;include\u0026gt;:通过属性refid，指定包含的sql片段。 示例代码\n1 2 3 4 5 6 7 8 9 10 \u0026lt;sql id=\u0026#34;commonSelect\u0026#34;\u0026gt; select id, username from emp \u0026lt;/sql\u0026gt; \u0026lt;select id=\u0026#34;getById\u0026#34; resultTypea\u0026#34;com.itheima.pojo.Emp\u0026#34;\u0026gt; \u0026lt;include refid=\u0026#34;commonselect\u0026#34;/\u0026gt; where id = #{id} \u0026lt;/select\u0026gt; \u0026lt; trim \u0026gt;标签 prefix：将trim标签中内容前面添加指定内容 suffix：将trim标签中内容前面添加指定内容 prefixOverride：将trim标签中内容前面去除指定内容 suffixOverride：将trim标签中内容后面去除指定内容 \u0026lt;choose\u0026gt;,\u0026lt;when\u0026gt;,\u0026lt;otherwise\u0026gt; 相当于switch，if，else\n1 2 3 4 5 6 \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;满足的条件\u0026#34;\u0026gt; \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; 字段名和属性名的映射关系 通常情况下当数据表中的字段名和实体类的属性名对应相等时，MyBatis会将查询出的字段数据自动赋值给实体类\n当字段名和属性名不一致时 在sql语句中给字段名起别名使得字段名与属性名相同\n通过resultMap解决，其他的sql语句设置resultMap属性来确定映射关系\n1 2 3 4 \u0026lt;resultMap id=\u0026#34;resultMap_name\u0026#34;,type=\u0026#34;实体类\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;属性名\u0026#34;,column=\u0026#34;主键字段名\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;属性名\u0026#34;,column=\u0026#34;其他字段名\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultMap\u0026gt; 多对一的映射关系 示例：查询员工及其对应部门信息时，将员工的did和dname合并为一个dept对象，作为emp对象的成员变量\n通过resultMap中的级联属性解决，其他的sql语句设置resultMap属性来确定映射关系\nresultMap使用级联属性对应成员对象名\n1 2 3 4 5 6 7 8 9 \u0026lt;resultMap id=\u0026#34;empAndDeptResultMapone\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34;column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;dept.did\u0026#34; column=\u0026#34;did\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;dept.deptName\u0026#34; column=\u0026#34;dept_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultMap\u0026gt; 通过resultMap中的association标签解决，其他的sql语句设置resultMap属性来确定映射关系\nassociation具有两个属性，property对应实体类中的成员对象名，javaType对应该成员对象的java类型\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;resultMap id=\u0026#34;empAndDeptResultMapone\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34;column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;association property=\u0026#34;dept\u0026#34; javaType=\u0026#34;Dept\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;did\u0026#34; column=\u0026#34;did\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;dept.deptName\u0026#34; column=\u0026#34;dept_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; 一对多的映射方式 示例：查询部门及其下属员工时，一个部门作为实体类具有一个员工对象的集合作为成员变量\n通过resultMap的collection标签解决，其他的sql语句设置resultMap属性来确定映射关系\ncollection具有两个属性，property对应实体类中的成员对象名，ofType对应该成员对象的java类型\n1 2 3 4 5 6 7 8 9 \u0026lt;resultMap id=\u0026#34;empAndDeptResultMapone\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;collection property=\u0026#34;成员变量名\u0026#34; ofType=\u0026#34;集合内的泛型\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34;column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; ","date":"2024-11-06T17:26:14+08:00","permalink":"https://Tyritic.github.io/p/mybatis%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","title":"MyBatis基本使用"},{"content":"Lombok简介 Lombok是一个实用的java类库，能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法 并可以自动化生成日志变量，简化iava开发\n常见注解 注解 作用 @Getter/@Setter 为所有的属性提供get/set方法 @ToString 会给类自动生成易阅读的toString 方法 @EqualsAndHashCode 根据类所拥有的非静态字段自动重写 equals方法和 hashcode 方法 @Data 提供了更综合的生成代码功能(@Getter+@Setter+@ToString+@EqualsAndHashCode) @NoArgsConstructor 为实体类生成无参的构造器方法 @AllArgsConstructor 为实体类生成除了static修饰的字段之外带有各参数的构造器方法 ","date":"2024-11-06T17:19:27+08:00","permalink":"https://Tyritic.github.io/p/lombok/","title":"Lombok"},{"content":"什么是MyBatis MyBatis是一款优秀的 持久层框架，用于简化JDBC的开发。 MyBatis本是 Apache的一个开源项目iBatis,2010年这个项目由apache迁移到了google code，并且改名为MyBatis。2013年11月迁移到Github。 官网:https://mybatis.org/mybatis-3/zh/index.html MyBatis的配置 在pom.xml中配置相关依赖\n在application.yml中的spring.database属性下配置相关数据库连接信息\n指定驱动类名称：driver-class-name 数据库连接的url：url 连接数据库的用户名 连接数据库的密码 编写sql语句\n在mapper文件夹下编写接口，用@Mapper修饰\n在每一个函数上根据操作名使用对应的注解修饰sql语句\n1 2 3 4 5 @Mapper public interface UserMapper{ @Select(\u0026#34;select * from user\u0026#34;) public List\u0026lt;User\u0026gt;list(); } 或者在resource文件夹下创建和接口全名（包名.接口名）一致的xml，在xml文件中根据具体的接口函数编写对应的sql语句\n1 2 3 4 5 6 7 8 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34; \u0026gt; \u0026lt;mapper namespace=\u0026#34;org.example.operator.mapper.userMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;list\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 数据库连接池 什么是数据连接池 数据库连接池是个容器，负责分配、管理数据库连接(Connection) 它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个 释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏 优势 资源重用 提升系统响应速度 避免数据库连接遗漏 常见产品 C3PO DBCP Druid Hikari(springboat默认) ","date":"2024-11-06T16:50:26+08:00","permalink":"https://Tyritic.github.io/p/mybatis%E7%AE%80%E4%BB%8B/","title":"MyBatis简介"},{"content":"基本概念 索引(index)：帮助数据库 高效获取数据的数据结构\n优点\n提高数据查询的效率，降低数据库的I0成本， 通过索引列对数据进行排序，降低数据排序的成本，降低CPU消耗。 缺点\n索引会占用存储空间。 索引大大提高了查询效率，同时却也降低了insert、 update、delete的效率。 索引结构 MySQL数据库支持的索引结构有很多，如:Hash索引、B+Tree索引、Full-Text索引等。我们平常所说的索引，如果没有特别指明，都是指默认的 B+Tree 结构组织的索引。\n索引操作 创建索引\n1 create [unique] index index_name on table_name(字段名,...) 查看索引\n1 show index from table_name 删除索引\n1 drop index index_name on table_name 提示\n主键字段，在建表时，会自动创建主键索引。 添加唯一约束时，数据库实际上会添加唯一索引。 ","date":"2024-11-04T19:18:04+08:00","permalink":"https://Tyritic.github.io/p/mysql%E7%B4%A2%E5%BC%95/","title":"MySQL索引"},{"content":"概念 事务是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作 要么同时成功，要么同时失败。\n提示\nMySQL会立即隐式的提交事务。默认MySQL的事务是自动提交的，\n事务控制语句 开启事务\n1 start transaction； 提交事务\n1 commit; 回滚事务\n1 rollback; 四大特性 原子性（Atomicity）：事务是不可分割的最小单元，要么全部成功，要么全部失败 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态 隔离性（lsolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的 ","date":"2024-11-04T19:06:51+08:00","permalink":"https://Tyritic.github.io/p/mysql%E4%BA%8B%E5%8A%A1/","title":"MySQL事务"},{"content":"基本查询 基本语法\n1 2 3 4 5 6 7 8 9 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from table_name where condition #条件列表 #以下均为可选选项 group by 聚合函数（字段列表） having 对分组条件的过滤操作 order by 对字段列表的排序 #（ASC升序，DESC降序） limit 分页参数 (起始索引，查询记录数) #索引从0开始，起始索引=（查询页码-1)*每页记录数 条件查询 常见条件运算符 比较运算符 功能 \u0026gt; 大于 \u0026gt;= 大于等于 \u0026lt; 小于 \u0026lt;= 小于等于 \u0026lt;\u0026gt;或!= 不等于 between \u0026hellip; and \u0026hellip; 在某个区间范围内（含最大值和最小值） in(\u0026hellip;) 在in中的列表的值，多选一 like 占位符 模糊匹配（_匹配单个字符，\u0026amp;匹配任意字符 is null 是null 常见逻辑运算符 逻辑运算符 功能 and 或 \u0026amp;\u0026amp; 与 or 或 || 或 not 或 | 非 分组查询 聚合函数 函数 功能 sum 求和 avg 平均值 count 计数 max 最大值 min 最小值 提示\nnull不参与聚合函数的运算\nhaving和where的区别 执行时机不同:where是分组之前进行过滤，不满足where条件，不参与分组;而having是分组之后对结果进行过滤。 判断条件不同:where不能对聚合函数进行判断，而having可以。 查询的执行顺序 where \u0026gt;聚合函数 \u0026gt;having\n注意事项 提示\nselect 子句中的字段一般为用于分组的字段和聚合函数（保证出现在select子句中但是没有被聚集的属性只能出现在group by子句中 在默认情况下，系统按照group by子句中指定的列升序排列，但是可以使用order by子句指定新的排列顺序。 任何出现在having子句中但没有被聚集的属性只能出现在group by子句中 多表查询 连接查询 笛卡尔积：A表和B表元组的所有组合情况\n示例代码：\n1 table a,table b 内连接：查询A表和B表相交的部分\n语法：\n1 2 3 4 5 6 7 8 9 #隐式内连接 select 字段列表 from table a,table b where condition #显式内连接 select 字段列表 from table a join table b on 连接条件 外连接：查询只存在A表或B表的部分\n1 2 3 4 5 6 7 8 9 #左外连接 select 字段列表 from table a left join table b on 连接条件 #右外连接 select 字段列表 from table a right join table b on 连接条件 子查询 子查询：SQL语句中嵌套select语句\n类别\n标量子查询:子查询返回的结果为单个值 列子查询:子查询返回的结果为一列 行子查询:子查询返回的结果为一行 表子查询:子查询返回的结果为多行多列 子查询的位置\nselect后面：标量子查询 from后面：表子查询 where/having：标量/列/行子查询 ","date":"2024-11-04T15:07:25+08:00","permalink":"https://Tyritic.github.io/p/mysql%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C/","title":"MySQL表数据查询操作"},{"content":"插入元组 指定字段添加元组\n1 insert into table_name (字段1,子段2,...子段n) values(值1,..值n); 全部字段添加元组\n1 insert into table_name values(值1,值2,...值n); 批量添加指定子段的元组\n1 insert into table_name (子段1,子段2,...子段n) values(值1,...值n),..(值1,...值n); 全部数据批量添加\n1 insert into table_name values(值1,...值n),..(值1,...值n); 更新元组 更新符合指定条件的元组\n1 update table_name set 字段1=v值1,..字段n=值n [where condition] 删除元组 1 delete from table_name [where condition] ","date":"2024-11-04T14:57:14+08:00","permalink":"https://Tyritic.github.io/p/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/","title":"MySQL数据库表数据操作"},{"content":"创建表结构 代码结构 1 2 3 4 5 create table table_name( 字段1 字段类型[约束] [comment \u0026#39;关于字段的描述\u0026#39;], ... 字段n 字段类型[约束] [comment \u0026#39;关于字段的描述\u0026#39;] )[comment 关于表的描述] 约束 概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据\n目的：保证数据库中数据的正确性、有效性和完整性。\n常见约束参考\n约束 描述 关键字 非空约束 限制该字段不能为null not null 唯一约束 保证该字段的所有数据都是唯一，不存在重复 unique 主键约束 主键是一个元组的唯一标识，要求非空且唯一 primary key 默认约束 保存数据时要是未指定该字段值则存入默认值 default 外键约束 通过外键建立两张表的联系，保证数据的一致性和完整性 foreign key 示例代码\n1 2 3 4 5 6 7 8 create table student (ID varchar (5) comment[\u0026#39;唯一标识符\u0026#39;], name varchar (20) not null, dept_name varchar (20), tot_cred numeric (3,0) check (tot_cred \u0026gt;= 0), primary key (ID), #主键约束 foreign key (dept_name) references department(dept_name) on delete set null); #外键约束 数据类型 数值类型 类型 大小（byte) 有符号范围 无符号范围 描述 备注 tinyint 1 (-128,127) (0,255) 小整数 smallint 2 (-32768,32767) (0,65535) 大整数 mediumint 3 (-8388608,8388607) (0,1677215) 大整数 int 4 (-2^31 ,2^31-1) (0,2^32-1) 大整数 bigint 8 (-2^63 ,2^63-1) (0,2^64-1) 极大整数 float 4 单精度浮点值 float(5,2)，其中5为数字长度，2为小数位数 double 8 双精度浮点值 double(5,2)，其中5为数字长度，2为小数位数 decimal 小数值（精度最高） 字符类型 类型 大小（byte） 描述 备注 char 0~255 定长字符串 char(10),最多只能存10个字符，不足10个字符也占有10个字符空间 varchar 0~63315 变长字符串 varchar(10),最多只能存10个字符，不足10个字符按实际长度存储 tinyblob 0~255 不超过255个字符的二进制数据 tinytext 0~255 短文本字符串 blob 0~65535 二进制形式长文本数据 text 0~65535 长文本数据 mediumblob 0~16777215 二进制形式中等长文本数据 mediumtext 0~16777215 中等长度文本数据 longblob 0~4294967295 二进制形式的极大文本数据 longtext 0~4294967295 极大文本数据 日期类型 类型 大小（byte） 格式 范围 描述 date 3 YYYY-MM-DD 1000-01-01到 9999-12-31 日期值 time 3 HH:MM:SS -838:59:59 到 838:59:59 时间值或持续时间 year 1 YYYY 1901到2155 年份值 datetime 8 YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00到 9999-12-31 23:59:59 混合日期和时间值 timestamp 4 YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00到 9999-12-31 23:59:59 混合日期和时间值，时间戳 查询表结构 查询当前数据库的所有表\n1 show tables 查询指定表的表结构\n1 desc table_name 查询建表语句\n1 show create table table_name 修改表结构 添加字段\n1 2 alter table table_name add 字段名 字段类型（长度） [comment \u0026#39;关于字段的描述\u0026#39;] [约束]; 修改字段类型\n1 2 alter table table_name modify 字段名 新字段类型（长度）; 修改字段名和字段类型\n1 2 alter table table_name change 旧字段名 新字段名 新类型（长度）[comment \u0026#39;关于字段的描述\u0026#39;] [约束]; 删除字段\n1 2 alter table table_name drop column 字段名; 修改表名\n1 rename table 旧表名 to 新表名; 删除表结构 1 drop table 表名; ","date":"2024-11-03T18:46:17+08:00","permalink":"https://Tyritic.github.io/p/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C/","title":"MySQL数据库表结构操作"},{"content":"切换数据库 1 use database_name; 创建数据库 1 create database[if not exists] database_name; 查询数据库 查询所有的数据库\n1 show databases; 查询当前正在使用的数据库\n1 select database(); 删除数据库 1 drop database [if exist] database_name ","date":"2024-11-03T18:26:36+08:00","permalink":"https://Tyritic.github.io/p/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/","title":"MySQL数据库操作"},{"content":"MySQL配置使用 启动服务：\n1 net start mysql 停止服务：\n1 net stop mysql 登录MySQL\n1 mysql -u[用户名] -p[密码] [-h 数据库服务器IP -p 端口号] 退出MySQL\n1 exit MySQL数据模型 关系型数据库(RDBMS)：建立在关系模型基础上，由多张相互连接的二维表组成的数据库\n特点\n使用表存储数据，格式统一，便于维护 使用SQL语言操作，标准统一，使用方便，可用于复杂查询 SQL简介 SQL：一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准。\n通用语法 SOL语句可以单行或多行书写，以分号结尾。 SOL语句可以使用空格/缩进来增强语句的可读性。 MySQL数据库的SQL语句不区分大小写。 注释 单行注释：\u0026ndash;注释内容或者#注释内容**（MySQL特有）** 多行注释：/* 注释内容 */ 分类 分类 全称 说明 DDL Data Definition Language 数据定义语言，用来定义数据库对象(数据库，表，字段) DML Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改 DQL Data Query Lanquage 数据查询语言，用来查询数据库中表的记录 DCL Data Control Language 数据控制语言，用来创建数据库用户、控制数据库的访问权限 ","date":"2024-11-03T17:02:26+08:00","permalink":"https://Tyritic.github.io/p/mysql%E7%AE%80%E4%BB%8B/","title":"MySQL简介"},{"content":"什么是控制反转（IOC) IOC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。以右图为例\nIOC容器作为中间位置“第三方”，也就是，使得A、B、C、D这四个对象没有了耦合关系，齿轮之间的传动全部依靠IOC容器，全部对象的控制权上交给IOC容器，所以IOC容器成了整个系统的关键核心，它起到一个“粘合剂”的作用，把系统中所有对象粘合在一起发挥作用。\nIOC的关键点 谁控制谁： 传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象； 而IOC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建； 控制了什么 那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 什么是反转： 传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转； 而反转则是由容器来帮忙创建及注入依赖对象 为什么是反转：因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象。 哪些方面反转了：依赖对象的获取被反转了。 IOC的过程 所有的类都会在Spring容器中登记，告诉spring你是个什么东西，你需要什么东西， 然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。 所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。 对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。 Bean对象的声明 注解 说明 位置 @Component 声明Bean对象的基本注解 不属于以下三类时使用该注解 @Service @Component的衍生注解 标注在ServiceImpl类上 @Controller @Component的衍生注解 标注在Controller类上 @Repository @Component的衍生注解 标注在数据访问类上（现在有mybatis，使用评论少） 注意事项\n声明bean的时候，可以通过value属性指定bean的名字，如果没有指定，默认为类名首字母小写 使用以上四个注解都可以声明bean，但是在springboot集成web开发中，声明控制器bean只能用@Controller. Bean组件扫描 声明bean的四大注解，要想生效，还需要被组件扫描注解 @ComponentScan 扫描。 @ComponentScan 注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解 @SpringBootApplication 中，默认扫描的范围是启动类所在包及其子包。\n","date":"2024-11-03T15:06:44+08:00","permalink":"https://Tyritic.github.io/p/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/","title":"控制反转"},{"content":"什么是依赖注入（DI） 组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。\n关键点分析 谁依赖于谁：当然是应用程序依赖于IoC容器； 为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源； 谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象； 注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据） Bean注入方式 @Autowired注入 使用@Autowired注解修饰要注入的对象\n1 2 @Autowired userMapper mapper; 注意事项 @Autowired注解默认按Bean对象的类型进行自动装配，若存在多个相同类型的Bean对象会报错 可以使用注解@Primary指定Bean对象的优先级，对优先级高的Bean对象使用 @Primary 注解 可以使用注解@Qualifier和@Autowired配合使用，@Qualifier的value属性用于按名字指定Bean对象 提示\nBean对象的默认名称是类名首字母小写\n@Resource ​\t使用 @Resource 注解修饰要注入的对象,@Resource 注解按照Bean对象名注入对象\n1 2 @Resource(name=\u0026#34;Bean_name\u0026#34;) userMapper mapper; 提示\n@Resource 和 @Autowired 的区别\n@Autowired 是Spring框架提供的注解，而 @Resource 是IDK提供的注解 @Autowired 默认是按照类型注入，而 @Resource 默认是按照名称注入。 ","date":"2024-11-03T13:37:35+08:00","permalink":"https://Tyritic.github.io/p/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/","title":"依赖注入"},{"content":"请求响应过程 基本流程 浏览器向SpringBoot项目中内置的Tomcat服务器发送请求 SpringBoot项目中的controller类接收浏览器发出的请求并发送响应 请求参数的接收 简单参数 方法一：设置controller类中的函数形参名和请求的参数名相同 1 2 3 4 5 @RequsetMapping(\u0026#34;/simpleParam\u0026#34;) public String getParam(String param) { return param; } 方法二：参数名和形参名不匹配使用@RequestParam注解的name属性将参数名映射到形参 1 2 3 4 5 @RequestMapping(\u0026#34;/simpleParam\u0026#34;) public String getParam(@RequestParam(name=“username\u0026#34;)String param) { return param; } 提示\n@RequestParam\n作用：建立请求参数和controller形参的映射关系\n属性\nvalue/name：请求的参数名 required：参数是否必需。默认为true 实体对象参数 简单实体对象 请求参数与形参对象属性名相同\n1 2 3 4 5 @RequestMapping(\u0026#34;/objectParam\u0026#34;) public User getParam(User user) { return user; } 复杂实体对象（对象的成员变量是对象） 请求参数与形参对象属性名相同，按对象层次关系接收\n数组集合参数 数组参数 请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数\n1 2 3 4 5 @RequestMapping(\u0026#34;/arrayParam\u0026#34;) public User getParam(String[]array) { return array; } 集合参数 请求参数名与形参数组名称相同且请求参数为多个，@RequestParam绑定参数关系\n1 2 3 4 5 @RequestMapping(\u0026#34;/listParam\u0026#34;) public User getParam(@RequestParam List\u0026lt;String\u0026gt;param) { return param; } 日期参数 使用**@DateTimeFormat**注解完成日期格式转换\n1 2 3 4 5 @RequestMapping(\u0026#34;/dateParam\u0026#34;) public String getParam(@DateTimeFormat(pattern=\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;) LocalDateTime param) { return param.toString(); } 提示\n@DateTimeFormat\npattern属性用于指定时间格式\nJson参数 JSON数据键名与形参对象属性名相同，定义pojo类型形参即可接收参数，需要使用 @RequestBody标识\n1 2 3 4 5 @RequestMapping(\u0026#34;/jsonParam\u0026#34;) public String getParam(@RequestBody User user) { return user.toString(); } 路径参数 通过请求URL直接传递参数，使用{..}来标识该路径参数，需要使用 @PathVariable 获取路径参数\n1 2 3 4 5 @RequestMapping(\u0026#34;/path/{id}\u0026#34;) public String getParam(@PathVariable Integer id) { return id; } 响应报文的回写 @RequestBody 类型：方法注解，类注解 位置：controller类/方法上 作用：将方法返回值直接响应，如果返回值类型是 实体对象/集合，将会转换为JSON格式响应 说明：@RequestController=@RequestBody+@Controller ","date":"2024-11-03T00:05:27+08:00","permalink":"https://Tyritic.github.io/p/%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/","title":"请求与响应"},{"content":"如何读懂SpringBoot项目结构 SpringBoot项目本质上是一个Maven项目，大体骨架与普通的Maven项目相同\n普通Maven项目结构\n1 2 3 4 5 6 7 8 9 10 Maven-name/ |--src（源代码） |\t|--main（项目实际资源） |\t|--java（java代码） |\t|--resource（资源文件） |\t|--test（测试代码资源） |\t|--java |\t|--resource |--pom.xml（依赖配置文件） |--target（打包后的jar包存放地） 开发者的代码都存放到src/main/java文件夹中\n代码层 根目录：src/main/java\n作用：该目录下存放入口启动类及程序的开发目录。在这个目录下进行业务开发、创建实体层、控制器层、数据连接层等。\n注解\n入口启动类：运行整个项目main方法的类\n1 2 3 4 5 6 @SpringBootApplication public class UserApplication { public static void main(String[] args) { SpringApplication.run(UserApplication.class, args); } } 其中@SpringBootApplication用于标识SpringBoot项目的入口类\n控制器层（controller) 根目录：src/main/java/controller\n作用：主要负责具体业务模块的流程控制，负责前后端交互，接受前端请求，调用service层，接收service层返回的数据，最后返回具体的页面和数据到客户端\n功能实现：通过实现controller类来实现\n1 2 3 4 5 6 7 @RequestMapping(\u0026#34;/user\u0026#34;) @RestController // @RestController=@RequestMapping + @ResponseBody public class UserController { @RequestMapping(\u0026#34;/映射资源\u0026#34;) public List\u0026lt;User\u0026gt; findAll(){ return userService.findAll(); } 业务逻辑层(service) 根目录：src/main/java/service\n作用：主要负责业务逻辑应用设计\n功能实现：首先设计service接口，然后再设计其实现该接口的类(serviceImpl)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Service public class UserRegisterServiceImpl implements UserRegisterService { @Autowired UserMapper userMapper; @Override public void register(UserRegisterDTO userRegisterDTO) { //判断用户是否已存在 User tempUser=userMapper.getByUsername(userRegisterDTO.getUsername()); if(tempUser!=null){ log.error(\u0026#34;用户{}已存在\u0026#34;,userRegisterDTO.getUsername()); throw new UsernameHasBeenRegisteredException(\u0026#34;用户名已存在\u0026#34;); } //注册 User user=new User(); BeanUtils.copyProperties(userRegisterDTO,user); userMapper.register(user); log.info(\u0026#34;用户{}注册成功\u0026#34;,userRegisterDTO.getUsername()); } } 常量层(common) 根目录：src/main/java/common\n作用：主要存放工具类（utils)，常量类（constant），统一响应模板（result），统一异常处理（exception)\n数据库实体层(pojo) 根目录：src/main/java/pojo\n作用：存放数据库的实体类，通常一个实体类对应一张数据库表\n数据持久层（mapper) 根目录：src/main/java/mapper\n作用：访问数据库，向数据库发送sql语句，完成数据的增删改查任务\n功能实现：通过@Mapper注解接口来建立java方法和sql语句的映射关系\n1 2 3 4 5 6 7 8 9 10 @Mapper public interface DistrictMapper { List\u0026lt;District\u0026gt;searchAll(String tname); boolean deleteDistrict(String dname); District getDistrictByName(String dname); void insertDistrict(DistrictDTO districtDTO); void updateDistrictTdid(DistrictDTO districtDTO); boolean deleteAll(Long tid); void updateDistrictDetail(DistrictDTO districtDTO); } 数据传输对象（dto） 根目录：src/main/java/dto（或者放入pojo层中）\n作用：对entity进行封装，不破坏实体类结构，进行层与层之间的数据传输\n提示\n​\tDTO通常用于\n控制器（Controller）与服务层（Service）之间的数据传输：控制器通过 DTO 将请求参数传递给服务层，服务层返回 DTO 对象给控制器。 服务层与持久层（Mapper）之间的数据传输：服务层通过 DTO 将实体对象转换为需要的数据结构传递给持久层，持久层返回 DTO 对象给服务层。 视图包装对象（vo） 根目录：src/main/java/vo（或者放入pojo层中）\n作用：用于封装客户端请求的数据同时不破坏原有的实体类结构\n提示\nVO在实际开发中通常作为controller类方法的形参从而起到封装客户端请求数据的作用\n配置类（config) 根目录：src/main/java/config\n作用：以java类代替yaml文件进行Bean对象配置\n功能实现：通过**@Configuration**注解一个java类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration public class WebMvcConfiguration implements WebMvcConfigurer { @Autowired JwtTokenUserInterceptor jwtTokenUserInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { log.info(\u0026#34;开始注册拦截器\u0026#34;); log.info(\u0026#34;注册Jwt令牌拦截器：{}\u0026#34;,jwtTokenUserInterceptor); registry.addInterceptor(jwtTokenUserInterceptor) .addPathPatterns(\u0026#34;/Operator/**\u0026#34;) .excludePathPatterns(\u0026#34;/Operator/user/login\u0026#34;) .excludePathPatterns(\u0026#34;/Operator/user/register\u0026#34;); } } 参数配置类（properties） 根目录：src/main/java/properties\n作用：以java实体类代替yaml文件进行参数配置\n功能实现：通过**@ConfigurationProperties**注解一个java类\n1 2 3 4 5 6 7 8 9 10 @Data @Component @ConfigurationProperties(prefix = \u0026#34;operator.aliyun.oss\u0026#34;) public class AliyunOSSProperties { String endpoint; String accessKeyId; String accessKeySecret; String bucketName; String region; } 过滤器（filter） 根目录：src/main/java/filter\n作用：在Servlet 处理请求之前或响应之后对数据进行某些处理，实现诸如日志记录、请求数据修改、响应数据修改、权限控制等功能\n提示\n过滤器工作在 Servlet 容器容中，它拦截客户端的请求和服务器的响应。过滤器链（Filter Chain）是多个过滤器按照一定的顺序执行的集合，一个请求可以依次通过多个过滤器，然后到达目标 Servlet，响应也会按相反的顺序经过这些过滤器返回给客户端。\n生命周期管理\nServlet 容器负责过滤器的生命周期管理。过滤器的生命周期方法包括 init（初始化）、doFilter（执行过滤操作）和 destroy（销毁）。 请求处理流程\n当一个请求到达 Servlet 容器时，容器会根据部署描述符（web.xml）或注解配置，决定是否以及如何调用过滤器链。 过滤器链是多个过滤器按照一定的顺序执行的集合。容器按照这个顺序依次调用每个过滤器的 doFilter 方法。 doFilter 方法\n在 doFilter 方法中，开发者可以实现自定义的处理逻辑，比如修改请求头、记录日志等。 doFilter 方法中必须调用 FilterChain 的 doFilter 方法，这样请求才能继续传递给下一个过滤器或目标资源（如 Servlet）。如果不调用，请求处理流程将会停止。 工作机制\n过滤器可以修改请求和响应，但它们通常不会生成响应或结束请求，因为这通常是 Servlet 或其他资源的职责 参考文章：\nFilter（过滤器）和 Interceptor（拦截器）详解_过滤器和拦截器-CSDN博客 功能实现\n创建过滤器类\n实现 javax.servlet.Filter 接口。 重写 init、doFilter 和 destroy 方法。 配置过滤器\n使用注解 @WebFilter 进行声明和配置。 或者在 web.xml 文件中配置。 编写过滤逻辑：\n在 doFilter方法中实现具体的过滤逻辑。 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import javax.servlet.*; import javax.servlet.annotation.WebFilter; import java.io.IOException; @WebFilter(\u0026#34;/example/*\u0026#34;) // 过滤器应用于 URL 模式 \u0026#34;/example/*\u0026#34; public class ExampleFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { // 初始化代码，例如资源加载 } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { // 在请求处理之前执行的代码 System.out.println(\u0026#34;Before Servlet processing\u0026#34;); chain.doFilter(request, response); // 将请求传递给下一个过滤器或目标资源 // 在请求处理之后执行的代码 System.out.println(\u0026#34;After Servlet processing\u0026#34;); } @Override public void destroy() { // 清理代码，例如释放资源 } } 拦截器（interceptor） 根目录：src/main/java/interceptor\n作用：是 Spring MVC 框架中的一个核心组件，用于在处理 HTTP 请求的过程中进行拦截和处理。拦截器主要用于实现跨切面（cross-cutting）的逻辑，如日志记录、性能统计、安全控制、事务处理等。\n功能实现\n创建拦截器类：\n实现 HandlerInterceptor接口或继承 HandlerInterceptorAdapter类。 重写 preHandle、postHandle 和 afterCompletion 方法。 注册拦截器：\n创建一个配置类，实现 WebMvcConfigurer接口。 重写 addInterceptors 方法来添加拦截器。 编写拦截逻辑：\n在 preHandle、postHandle 和 afterCompletion方法中实现具体的拦截逻辑。 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { // 请求处理前的逻辑 return true; // 返回 true 继续流程，返回 false 中断流程 } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) { // 请求处理后的逻辑，但在视图渲染前 } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { // 请求处理完毕后的逻辑 } } @Configuration public class WebMvcConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new MyInterceptor()).addPathPatterns(\u0026#34;/**\u0026#34;); // 应用于所有路径 } } 项目配置层 根目录：src/main/resource\napplication.yml：项目的整体配置文件\nmapper：数据库映射文件\n","date":"2024-11-02T19:26:08+08:00","permalink":"https://Tyritic.github.io/p/springboot%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/","title":"SpringBoot项目结构"},{"content":"什么是HTTP协议 ​\tHTTP协议（Hyper Text Transfer Protocol，超文本传输协议）：规定了浏览器和服务器之间数据传输的规则。\n特点 在传输层上基于TCP协议\n提示\nTCP协议是面向连接的，安全性好。\n基于请求-响应机制\n无状态协议，对于事务的处理没有记忆，每次请求-响应都是独立的\n优点：速度快 缺点：多次请求之间不能共享数据 HTTP请求协议 请求报文结构 请求行（红色部分）：请求数据的第一行（请求方式/资源路径/协议版本）\n注解\n常见的请求方式有\nGET：请求指定页面的信息 POST：向指定资源提交数据进行处理请求，数据被包含在请求体 DELETE：请求服务器删除指定的页面 PUT：从客户端向服务端传输的数据取代指定的页面，向指定的位置上传最新的内容 请求头（深黄色部分）：以键值对的形式表现\n请求体（浅黄色部分）：在POST请求中存放请求参数\n提示\nGET请求没有请求体\n请求参数\nGET：请求参数在请求行中，且GET请求没有请求体，GET请求大小有限制 POST:请求参数在请求体中，POST请求大小没有限制 HTTP响应协议 响应报文结构 ​\t响应行（红色部分）：响应报文的第一行（协议版本，状态码，描述）\n注解\nhttp状态码用于描述响应结果\n分为以下几类\n1XX（临时响应信息提示）：这些状态代码表示临时的响应。客户端在收到常规响应之前，应准备接收一个或多个1xx 100（继续） ：请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101（切换协议） ： 服务器将遵从客户的请求转换到另外一种协议 2XX（成功） 200（成功）：服务器已成功处理了请求。 201（已创建）：请求成功并且服务器创建了新的资源。 202（已接受）：服务器已接受请求，但尚未处理。 3XX（重定向）：表示要完成请求，需要进一步操作。客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同的页面，或通过代理服务器重复该请求。 建议在每次请求中使用重定向不要超过 5次。 300（多种选择）：针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301（永久移动）：请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置 4XX（请求错误）：这些状态码表示请求可能出错，客户端似乎有问题。 400（错误请求）：服务器不理解请求的语法。 401（未授权）：请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。 403（禁止）：服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码(您可以在 Google网站管理员工具诊断下的网络抓取页面上看到此信息)，可能是您的服务器或主机拒绝了 Googlebot 访问。 404（未找到）：服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。 5XX（服务器错误）：服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错 500 （服务器内部错误） ：服务器遇到错误，无法完成请求。 响应头（黄色部分）：以键值对形式表现\n响应体（绿色部分）：存放响应数据\nHTTP协议解析 ​\tWeb服务器：一个软件程序，对HTTP协议进行封装，使得开发者不必直接面对HTTP协议进行开发\nTomcat服务器 基本使用 启动Tomcat服务器：双击Tomcat服务器目录下的bin\\startup.bat\n关闭Tomcat服务器\nCTRL+C：正常关闭 直接关闭运行窗口：强制关闭 双击Tomcat服务器目录下的bin\\shutdown.bat：正常关闭 部署项目：将应用放入webapps目录下\nTomcat服务器的目录结构 1 2 3 4 5 6 7 8 Tomcat/ |--bin（可执行文件） |--conf（配置文件） |--lib（Tomcat依赖的jar包） |--logs（日志文件） |--temp（测试代码资源） |--webapps（应用发布目录） |--resource（工作目录） ","date":"2024-11-02T16:04:47+08:00","permalink":"https://Tyritic.github.io/p/http%E5%8D%8F%E8%AE%AE/","title":"HTTP协议"},{"content":"文章存储位置 本博客的所有文章都存放在E/MyBlog/content/post文件夹中\n如何添加文章 在 content/tags/文章名 下新建文件 index.md\n命令行操作 在MyBlog主文件夹的cmd中运行以下命令\n1 hugo new content post\\\u0026lt;FileName\u0026gt;/index.md 参数解释 post：所有文章保存的文件路径\nFileName为当前文章所在的文件夹名\nindex.md为当前文章的markdown文件\nindex.en.md：英文文章 index.zh-cn.md：中文文章 文章内修改 插入照片 将需要的图片放入文章的文件夹中即可\n头文字参数 data：创建时间\ndraft：是否草稿\ntitle：文章标题\nimage：博客网站的开头图片\ncategories：文章的分类\ntags：文章的标签\ndescription：文章的描述\n短代码 文章引用 在markdown文件中插入以下短代码，使用时将{}改为{{}}\n1 2 3 {\u0026lt; quote author=\u0026#34;作者\u0026#34; url=\u0026#34;作品的来源（可不填）\u0026#34; source=\u0026#34;作品名\u0026#34; \u0026gt;} 引用内容 {\u0026lt; /quote \u0026gt;} 插入B站视频 在markdown文件中插入以下短代码，使用时将{}改为{{}}\n1 {\u0026lt; bilibili VIDEO_ID PART_NUMBER \u0026gt;} 可以在B站视频的url中找到Video_ID``https://www.bilibili.com/video/BV1BPSdYHEbj/?spm_id_from=333.1007.tianma.1-2-2.click\u0026amp;vd_source=7db50a55b19a59c42ee778836913c04f\n其中VIDEO_ID：BV1BPSdYHEbj\n插入hugo notice hugo notice有以下几个类别\ntip：提示 info：引言 warning：警告 note：注解 创建方法为在markdown文件中插入短代码，使用时将{}改为{{}}\n创建Tip 1 2 3 {\u0026lt; notice tip \u0026gt;} This is a very good tip. {\u0026lt; /notice \u0026gt;} 提示\nThis is a very good tip.\n创建Info 1 2 3 {\u0026lt; notice info \u0026gt;} This is a very good info. {\u0026lt; /notice \u0026gt;} 引言\nThis is a very good info.\n创建Warning 1 2 3 {\u0026lt; notice warning \u0026gt;} This is a very bad warning. {\u0026lt; /notice \u0026gt;} 警告\nThis is a very bad warning.\n创建Note 1 2 3 {\u0026lt; notice note \u0026gt;} This is a very good note. {\u0026lt; /notice \u0026gt;} 注解\nThis is a very bad note.\n插入参考博客 直接将参考博客的网址复制到markdown文件中\nTyritic的个人博客\n创建分组（categories） 在 content/categories/分类名 下新建文件 _index.md\n可以使用命令行工具\n1 hugo new content categories/\u0026lt;分组名\u0026gt;/_index.md 参数解释 categories：所有分组的所在目录 _index.md：分组的配置文件 _ndex.en.md：英文分组 _index.zh-cn.md：中文分组 创建标签（Tags) 在 content/tags/分类名 下新建文件 _index.md\n可以使用命令行工具\n1 hugo new content tags/\u0026lt;标签名\u0026gt;/_index.md 参数解释 tags：所有标签所在的目录 _index.md：分组的配置文件 index.en.md：英文标签 index.zh-cn.md：中文标签 创建友情链接（Links) 在 content/page/links 下修改文件 _index.md，创建与GitHub同级的元素\n参数列表 title：博客显示该网站的名字 description：博客对该网站的描述 website：网站链接 image：网站的icon ","date":"2024-11-01T15:28:47+08:00","permalink":"https://Tyritic.github.io/p/%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"博客使用指南"},{"content":"Maven的作用 依赖管理：方便快捷地管理依赖\n统一项目结构：提供标准的项目结构\n项目构建：提供了标准的跨平台项目构建方式\nMaven项目的结构 1 2 3 4 5 6 7 8 9 10 Maven-name/ |--src（源代码） |\t|--main（项目实际资源） |\t|--java（java代码） |\t|--resource（资源文件） |\t|--test（测试代码资源） |\t|--java |\t|--resource |--pom.xml（依赖配置文件） |--target（打包后的jar包存放地） Maven项目模型 仓库：用于存储资源以及各种JAR包\n本地仓库：计算机上的目录 中央仓库：由Maven团队维护的仓库 私服：公司团队搭建的私有仓库 依赖管理 什么是依赖 依赖就是项目所需要的jar包\nMaven坐标 ​\tMaven坐标是依赖资源的唯一标识，可以唯一定位资源的位置，使用Maven坐标可以引入项目依赖\n组成结构 groupId：项目所属的组织名 artifactId：项目名称/模块名称 version：版本号 依赖配置 配置方法 在pom.xml文件中使用标签\u0026lt; dependencies \u0026gt; 单个依赖在\u0026lt; dependencies \u0026gt;中被\u0026lt; dependency \u0026gt; 包围 定义依赖的坐标 刷新Maven文件 提示\n若本地仓库不存在依赖则会连接私服或者中央仓库进行下载\n依赖传递 ​\t依赖具有传递性\n​\t直接依赖：在当前项目中通过依赖配置建立的依赖关系\n​\t间接依赖:被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源\n​\t依赖的传递关系可能出现冲突\n路径优先：当依赖中出现相同的资源时：层级越深优先级越低 声明优先：当资源在相同的层级被依赖，配置靠前的覆盖配置靠后的 特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的 依赖排除 ​\t依赖可以被开发者手动排除\n​\t实现形式\n在pom.xml文件中使用标签\u0026lt; exclusions \u0026gt;包围\n对于要排除的单个依赖使用标签\u0026lt; exclusion \u0026gt;包围\n提示\n排除依赖的时候无须指定版本号\n依赖范围 ​\t依赖的jar包，默认情况下，可以在任何地方使用。但是可以通过\u0026lt; scope \u0026gt; 手动指定其使用范围\n作用范围 主程序范围有效。(main文件夹范围内) 测试程序范围有效。(test文件夹范围内) 是否参与打包运行。(package指令范围内) \u0026lt;scope\u0026gt;标签的取值 scope的取值 主程序 测试程序 打包运行 举例 compile(默认) Y Y Y log4j（日志框架） test X Y X junit（单元测试） provided Y Y X servlet（三大组件） runtime X Y Y jdbc（数据库连接依赖） 生命周期 ​\tMaven中有三套独立的生命周期\nclean：清理工作 default：核心工作包括（编译，测试，打包，变更，部署） site：生成报告，发布站点 生命周期的阶段 ​\n​\t提示\n​\t同一套生命周期，后面的阶段要依托前面的阶段来执行\n​\n重要阶段 clean:移除上一次构建生成的文件 compile:编译项目源代码 test:使用合适的单元测试框架运行测试(junit) package:将编译后的文件打包，如:jar、war等 install:安装项目到本地仓库 ","date":"2024-11-01T15:28:45+08:00","permalink":"https://Tyritic.github.io/p/maven%E5%9F%BA%E7%A1%80/","title":"Maven基础"}]