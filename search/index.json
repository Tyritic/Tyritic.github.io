[{"content":"为什么要异步调用？ 实际项目中，一个接口可能需要同时获取多种不同的数据，然后再汇总返回\n如果是串行（按顺序依次执行每个任务）执行的话，接口的响应速度会非常慢。考虑到这些任务之间有大部分都是 无前后顺序关联 的，可以 并行执行 。通过并行执行多个任务的方式，接口的响应速度会得到大幅优化。\nFuture接口 核心思想 ：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用等待耗时任务执行完成。等我们的事情干完后，我们再通过 Future 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // V 代表了Future执行的任务返回值的类型 public interface Future\u0026lt;V\u0026gt; { // 取消任务执行 // 成功取消返回 true，否则返回 false boolean cancel(boolean mayInterruptIfRunning); // 判断任务是否被取消 boolean isCancelled(); // 判断任务是否已经执行完成 boolean isDone(); // 获取任务执行结果 V get() throws InterruptedException, ExecutionException; // 指定时间内没有返回计算结果就抛出 TimeOutException 异常 V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutExceptio } FutureTask 提供了 Future 接口的基本实现，常用来封装 Callable 和 Runnable，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。\nFutureTask 有两个构造函数，可传入 Callable 或者 Runnable 对象。实际上，传入 Runnable 对象也会在方法内部转换为**Callable** 对象。\nFutureTask 相当于对 Callable 进行了封装，管理着任务执行的情况，存储了 Callable 的 call 方法的任务执行结果。\nCompletableFuture 类 CompletableFuture 是 Java 8 引入的一个强大的异步编程工具。允许非阻塞地处理异步任务，并且可以通过链式调用组合多个异步操作。\n核心特性\n异步执行：使用 runAsync() 或 supplyAsync() 方法，可以非阻塞地执行任务。 任务的组合：可以使用 thenApply() 、thenAccept() 等方法在任务完成后进行后续操作，支持链式调用。 异常处理：提供 exceptionally()、handle() 等方法来处理异步任务中的异常。 并行任务：支持多个异步任务的组合，如 thenCombine()、allOf() 等方法，可以在多个任务完成后进行操作。 非阻塞获取结果：相比 Future，CompletableFuture 支持通过回调函数获取结果，而不需要显式的阻塞等待。 创建操作 使用构造方法 CompletableFuture\u0026lt;T\u0026gt; future = new CompletableFuture\u0026lt;\u0026gt;(); 使用静态工厂方法 创建异步任务并返回结果 static \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; supplyAsync(Supplier\u0026lt;U\u0026gt; supplier) ：// 使用自定义线程池(推荐) static \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; supplyAsync(Supplier\u0026lt;U\u0026gt; supplier, Executor executor) 创建异步任务，不返回结果 static CompletableFuture\u0026lt;Void\u0026gt; runAsync(Runnable runnable) ：// 使用自定义线程池(推荐) static CompletableFuture\u0026lt;Void\u0026gt; runAsync(Runnable runnable, Executor executor) 获取异步调用的结果 V get() throws InterruptedException, ExecutionException ：阻塞 调用，等待异步任务完成并返回结果。\nget() 会抛出 InterruptedException 或 ExecutionException V getNow(V valueIfAbsent) ：非阻塞 调用。如果任务已完成，返回计算结果；否则，返回默认值 valueIfAbsent 。\npublic T join() ：获取 CompletableFuture 计算的结果，如果任务 尚未完成，它会 阻塞 直到结果可用。\n如果 CompletableFuture 执行失败，join() 不会抛出 CheckedException，而是抛出 CompletionException（运行时异常）。 处理异步调用的结果 \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; thenApply(Function\u0026lt;? super T,? extends U\u0026gt; fn) ：接受一个 Function 实例，用它来修改任务返回值，并返回新的 CompletableFuture\u0026lt;U\u0026gt; ，支持 链式调用\n适合需要 基于前一个任务的结果进行计算或转换 的场景。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; import java.util.function.Function; public class ThenApplyAnonymousClassExample { public static void main(String[] args) throws ExecutionException, InterruptedException { // 创建 CompletableFuture CompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(new java.util.concurrent.Callable\u0026lt;Integer\u0026gt;() { @Override public Integer call() { return 10; } }).thenApply(new Function\u0026lt;Integer, String\u0026gt;() { @Override public String apply(Integer number) { return \u0026#34;Result: \u0026#34; + (number * 2); } }); // 获取结果 System.out.println(future.get()); // 输出: Result: 20 } } CompletableFuture\u0026lt;Void\u0026gt; thenAccept(Consumer\u0026lt;? super T\u0026gt; action) ：接受一个 Comsumer 实例（该任务访问之前异步任务的结果），并基于结果做无返回值的操作，返回新的 CompletableFuture\u0026lt;Void\u0026gt; ，支持 链式调用 ，但不返回新结果\n适用于 消费 上一个异步操作的结果，但 不需要修改结果，例如打印日志、存储数据等。 1 2 3 4 5 6 7 8 9 10 11 import java.util.concurrent.CompletableFuture; public class ThenAcceptExample { public static void main(String[] args) throws Exception { CompletableFuture\u0026lt;Void\u0026gt; future = CompletableFuture .supplyAsync(() -\u0026gt; \u0026#34;Hello, World\u0026#34;) .thenAccept(result -\u0026gt; System.out.println(\u0026#34;Received: \u0026#34; + result)); future.get(); // 等待执行完成 } } CompletableFuture\u0026lt;Void\u0026gt; thenRun(Runnable action) ：接受一个 不接收参数 且 无返回值 的 Runnable 任务（该任务不访问之前异步任务的结果），并返回新的 CompletableFuture\u0026lt;Void\u0026gt; ，支持 链式调用 ，不返回新结果\n适用于在异步任务完成后执行 不依赖于结果的 动作时。 1 2 3 4 5 6 7 8 9 10 11 import java.util.concurrent.CompletableFuture; public class ThenRunExample { public static void main(String[] args) throws Exception { CompletableFuture\u0026lt;Void\u0026gt; future = CompletableFuture .supplyAsync(() -\u0026gt; \u0026#34;Task Completed\u0026#34;) .thenRun(() -\u0026gt; System.out.println(\u0026#34;Logging: Task finished!\u0026#34;)); future.get(); // 等待任务完成 } } CompletableFuture\u0026lt;T\u0026gt; whenComplete(BiConsumer\u0026lt;? super T, ? super Throwable\u0026gt; action) ：不改变异步任务的结果，但是保存下异步任务的结果\nBiConsumer\u0026lt;? super T, ? super Throwable\u0026gt; action ： T：前一个 CompletableFuture 成功 计算的结果（可能为 null）。 Throwable ：异常信息（若任务成功则为 null） 用于 无论任务成功或失败时 都要执行某些操作，且 不修改原始结果 的场景。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; public class WhenCompleteExample { public static void main(String[] args) throws ExecutionException, InterruptedException { CompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(() -\u0026gt; { if (Math.random() \u0026gt; 0.5) { throw new RuntimeException(\u0026#34;Computation failed!\u0026#34;); } return \u0026#34;Success!\u0026#34;; }).whenComplete((result, error) -\u0026gt; { if (error != null) { System.out.println(\u0026#34;Error: \u0026#34; + error.getMessage()); } else { System.out.println(\u0026#34;Result: \u0026#34; + result); } }); // 获取最终结果（可能抛出异常） System.out.println(\u0026#34;Final result: \u0026#34; + future.get()); } } 异常处理 CompletableFuture\u0026lt;U\u0026gt; handle(BiFunction\u0026lt;? super T, Throwable, ? extends U\u0026gt; fn) ：\n如果 任务成功，则 fn 会接收到前一个任务的结果和 null 作为异常，返回一个新的结果。 如果 任务失败，则 fn 会接收到前一个任务的异常和 null 作为结果，返回一个新的结果（默认值）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import java.util.concurrent.CompletableFuture; public class HandleExample { public static void main(String[] args) { CompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(() -\u0026gt; { // 随机决定是否抛出异常 if (Math.random() \u0026gt; 0.5) { throw new RuntimeException(\u0026#34;Task failed!\u0026#34;); } return \u0026#34;Task completed successfully!\u0026#34;; }).handle((result, error) -\u0026gt; { if (error != null) { // 任务失败时，返回一个默认值 return \u0026#34;Recovered from error: \u0026#34; + error.getMessage(); } else { // 任务成功时，返回结果的修改 return \u0026#34;Handled result: \u0026#34; + result; } }); // 输出结果 System.out.println(future.join()); } } 组合处理 public \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; thenCompose(Function\u0026lt;? super T, ? extends CompletionStage\u0026lt;U\u0026gt;\u0026gt; fn)\n适用场景\n适用于 前后依赖的异步任务（即一个任务的结果作为下一个任务的输入）。 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 CompletableFuture\u0026lt;String\u0026gt; future1 = CompletableFuture.supplyAsync(new Supplier\u0026lt;String\u0026gt;() { @Override public String get() { return \u0026#34;Hello\u0026#34;; } }).thenCompose((String s)-\u0026gt; { return CompletableFuture.supplyAsync(new Supplier\u0026lt;String\u0026gt;() { @Override public String get() { return s + \u0026#34; World\u0026#34;; } }); }); public \u0026lt;U, V\u0026gt; CompletableFuture\u0026lt;V\u0026gt; thenCombine( CompletionStage\u0026lt;? extends U\u0026gt; other, BiFunction\u0026lt;? super T, ? super U, ? extends V\u0026gt; fn)\n适用场景\nthenCombine() 会在 两个任务都完成 后，使用提供的函数 合并它们的结果。两个任务之间没有前后依赖 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 CompletableFuture\u0026lt;Integer\u0026gt; future2=CompletableFuture.supplyAsync(new Supplier\u0026lt;Integer\u0026gt;() { @Override public Integer get() { return 100; } }); CompletableFuture\u0026lt;Integer\u0026gt; future3=CompletableFuture.supplyAsync(new Supplier\u0026lt;Integer\u0026gt;() { @Override public Integer get() { return 200; } }); CompletableFuture\u0026lt;Integer\u0026gt; future4=future2.thenCombine(future3, new BiFunction\u0026lt;Integer, Integer, Integer\u0026gt;() { @Override public Integer apply(Integer integer, Integer integer2) { return integer+integer2; } }); 并行处理 static CompletableFuture\u0026lt;Void\u0026gt; allOf(CompletableFuture\u0026lt;?\u0026gt;... cfs)\n适用场景\n适用于 多个异步任务并行执行，并在 所有任务完成后继续执行 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.util.concurrent.CompletableFuture; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class AllOfExample { public static void main(String[] args) { CompletableFuture\u0026lt;String\u0026gt; future1 = CompletableFuture.supplyAsync(() -\u0026gt; \u0026#34;Task 1\u0026#34;); CompletableFuture\u0026lt;String\u0026gt; future2 = CompletableFuture.supplyAsync(() -\u0026gt; \u0026#34;Task 2\u0026#34;); CompletableFuture\u0026lt;String\u0026gt; future3 = CompletableFuture.supplyAsync(() -\u0026gt; \u0026#34;Task 3\u0026#34;); CompletableFuture\u0026lt;Void\u0026gt; allOf = CompletableFuture.allOf(future1, future2, future3); // 等待所有任务完成后，获取每个任务的结果 List\u0026lt;String\u0026gt; results = Arrays.asList(future1, future2, future3) .stream() .map(CompletableFuture::join) .collect(Collectors.toList()); System.out.println(results); // 输出: [Task 1, Task 2, Task 3] } } static CompletableFuture\u0026lt;Object\u0026gt; anyOf(CompletableFuture\u0026lt;?\u0026gt;... cfs)\n适用场景\n适用于 多个任务竞争，只关心 最先完成 的任务结果。 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import java.util.concurrent.CompletableFuture; public class AnyOfExample { public static void main(String[] args) { CompletableFuture\u0026lt;String\u0026gt; future1 = CompletableFuture.supplyAsync(() -\u0026gt; { try { Thread.sleep(1000); } catch (InterruptedException e) {} return \u0026#34;Task 1\u0026#34;; }); CompletableFuture\u0026lt;String\u0026gt; future2 = CompletableFuture.supplyAsync(() -\u0026gt; { try { Thread.sleep(500); } catch (InterruptedException e) {} return \u0026#34;Task 2\u0026#34;; }); CompletableFuture\u0026lt;Object\u0026gt; anyOf = CompletableFuture.anyOf(future1, future2); System.out.println(anyOf.join()); // 输出: Task 2 （因为 Task 2 更快） } } ","date":"2025-02-08T10:24:08+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/","title":"Java中的异步调用"},{"content":"什么是阻塞队列 阻塞队列代表的是线程安全的队列，不仅可以由多个线程并发访问，还添加了等待/通知机制，以便在队列为空时阻塞获取元素的线程，直到队列变得可用，或者在队列满时阻塞插入元素的线程，直到队列变得可用。\n常见操作 由于 BlockingQueue 继承了 Queue 接口，因此，BlockingQueue 也具有 Queue 接口的基本操作，如下所示：\n插入元素 boolean add(E e) ：将元素添加到队列尾部，如果队列满了，则抛出异常 IllegalStateException 。 boolean offer(E e) ：将元素添加到队列尾部，如果队列满了，则返回 false。 删除元素 boolean remove(Object o) ：从队列中删除元素，成功返回 true，失败返回 false E poll() ：检索并删除此队列的头部，如果此队列为空，则返回 null。 查找元素 E element() ：检索但不删除此队列的头部，如果队列为空时则抛出 NoSuchElementException 异常； peek() ：检索但不删除此队列的头部，如果此队列为空，则返回 null . 特定方法 void put(E e) ：将元素添加到队列尾部，如果队列满了，则线程将阻塞直到有空间。 offer(E e, long timeout, TimeUnit unit) ：将指定的元素插入此队列中，如果队列满了，则等待指定的时间，直到队列可用。 take() ：检索并删除此队列的头部，如有必要，则等待直到队列可用； poll(long timeout, TimeUnit unit) ：检索并删除此队列的头部，如果需要元素变得可用，则等待指定的等待时间。 ArrayBlockingQueue ArrayBlockingQueue 它是一个基于数组的有界阻塞队列\n特点 有界：ArrayBlockingQueue 的大小是在构造时就确定了，并且在之后不能更改。这个界限提供了流量控制，有助于资源的合理使用。 FIFO：队列操作符合先进先出的原则。 当队列容量满时，尝试将元素放入队列将导致阻塞；尝试从一个空的队列取出元素也会阻塞 实现原理 ArrayBlockingQueue 一旦创建，容量不能改变。其并发控制采用可重入锁 ReentrantLock ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻，尝试从一个空队列中取一个元素也会同样阻塞。\nArrayBlockingQueue 默认情况下不能保证线程访问队列的公平性但是可以在构造方法中将第二个 Boolean 类型参数设置为 true\nLinkedBlockingQueue LinkedBlockingQueue 是一个底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，同样满足 FIFO 的特性。\n特点 可以在队列头部和尾部进行高效的插入和删除操作。 当队列为空时，取操作会被阻塞，直到队列中有新的元素可用。当队列已满时，插入操作会被阻塞，直到队列有可用空间。 可以在构造时指定最大容量。如果不指定，默认为 Integer.MAX_VALUE，这意味着队列的大小受限于可用内存。 实现原理 LinkedBlockingQueue 使用两个锁（putLock 和 takeLock），一个用于放入操作，另一个用于取出操作。锁分离\nPriorityBlockingQueue PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。\nPriorityBlockingQueue 并发控制采用的是可重入锁 ReentrantLock，队列为无界队列（ ArrayBlockingQueue 是有界队列，LinkedBlockingQueue 也可以通过在构造函数中传入 capacity 指定队列最大的容量，但是 PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容）。\n","date":"2025-02-07T21:27:50+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/","title":"Java的阻塞队列"},{"content":"什么是线程池 线程池其实是一种池化的技术实现，池化技术的核心思想就是实现资源的复用，避免资源的重复创建和销毁带来的性能开销。线程池可以管理一堆线程，让线程执行完任务之后不进行销毁，而是继续去处理其它线程已经提交的任务。\n线程池的优点\n降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 Executor 框架 Executor 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor 框架让并发编程变得更加简单。\n框架的组成部分 任务(Runnable /Callable)：执行任务需要实现的 Runnable 接口 或 Callable接口。Runnable 接口或 Callable 接口 实现类都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。 任务的执行器(Executor)：任务执行机制的核心接口 Executor ，以及继承自 Executor 接口的 ExecutorService 接口。ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 这两个关键类实现了 ExecutorService 接口。 异步计算的结果(Future)：Future 接口以及 Future 接口的实现类 FutureTask 类都可以代表异步计算的结果。 使用流程 主线程首先要创建实现 Runnable 或者 Callable 接口的任务对象。\n提交任务\n把创建完成的实现 Runnable/Callable 接口的 对象直接交给 ExecutorService 执行: ExecutorService.execute（Runnable command） 把 Runnable 对象或 Callable 对象提交给 ExecutorService 执行 ExecutorService.submit（Runnable task） ExecutorService.submit（Callable \u0026lt;T\u0026gt; task） 执行 ExecutorService.submit（…），ExecutorService 将返回一个实现 Future 接口的对象\n最后，主线程可以执行 FutureTask.get() 方法来等待任务执行完成。\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // 提交Runnable任务 class Task implements Runnable { @Override public void run() { // 线程执行的代码 } } public static void main(String[] args) { ExecutorService executor = Executors.newFixedThreadPool(10); // 创建固定大小的线程池 for (int i = 0; i \u0026lt; 10; i++) { executor.submit(new Task()); // 提交任务到线程池执行 } executor.shutdown(); // 关闭线程池 } //提交Callable任务 import java.util.concurrent.*; class Task implements Callable\u0026lt;String\u0026gt; { @Override public String call() { return \u0026#34;Task executed by \u0026#34; + Thread.currentThread().getName(); } } public class CallableExample { public static void main(String[] args) { ExecutorService executor = Executors.newFixedThreadPool(10); // 创建固定大小的线程池 Future\u0026lt;String\u0026gt;[] results = new Future[10]; // 存储任务的返回结果 for (int i = 0; i \u0026lt; 10; i++) { results[i] = executor.submit(new Task()); // 提交 Callable 任务 } // 获取任务的返回结果 for (Future\u0026lt;String\u0026gt; result : results) { try { System.out.println(result.get()); // get() 方法会阻塞直到结果可用 } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } } executor.shutdown(); // 关闭线程池 } } 创建线程池的方法 使用 ThreadPoolExecutor 直接创建线程池 常见构造函数\n1 2 3 4 5 6 7 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize ：核心线程数，线程池会始终保持这个数量的线程，即使它们处于空闲状态。\nmaximumPoolSize ：最大线程数，当任务队列已满且核心线程已满时，线程池会创建新线程，最多创建到 maximumPoolSize 。\nkeepAliveTime ：当线程池中的线程数量超过 corePoolSize 时，空闲线程的存活时间，超过该时间的空闲线程会被回收。\nunit ：keepAliveTime 的时间单位，例如 TimeUnit.SECONDS 。\nworkQueue ：任务队列，用于存放待执行的任务，常见的选择包括：\nArrayBlockingQueue\u0026lt;Runnable\u0026gt;(capacity) ：有界队列，适用于任务数可预测的情况。\nLinkedBlockingQueue\u0026lt;Runnable\u0026gt;() ：无界队列，适用于任务数量不确定但不希望拒绝任务的情况（可能导致线程数不会超过 corePoolSize）。\nSynchronousQueue\u0026lt;Runnable\u0026gt;() ：不存储任务的队列，每个任务必须有可用线程立即执行，否则会创建新线程（可能导致线程数迅速增长）。\nthreadFactory ：用于创建线程的工厂，可以自定义线程名称、优先级等，常用 Executors.defaultThreadFactory() 作为默认实现。\nhandler ：拒绝策略，当任务队列满且线程数量已达到 maximumPoolSize 时，会触发拒绝策略，常见的策略包括：\nAbortPolicy（默认）：直接抛出 RejectedExecutionException，拒绝任务。 CallerRunsPolicy ：让提交任务的线程自己执行任务，避免任务丢失。 DiscardPolicy ：丢弃任务，不做任何处理。 DiscardOldestPolicy ：丢弃队列中最老的任务，并尝试再次提交新任务。 使用 Executors 工厂类 通过 Executor 框架的工具类 Executors 来创建内置线程池。\n1 2 3 4 5 ExecutorService fixedThreadPool = Executors.newFixedThreadPool(4); // 固定大小线程池 ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); // 可伸缩线程池 ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); // 单线程池 ExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(2); // 定时任务线程池 ExecutorService pool = Executors.newWorkStealingPool(); //任务窃取线程池 FixedThreadPool ：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。适合负载稳定的场景，任务数量确定且不需要动态调整线程数。 SingleThreadExecutor ： 只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。适用于需要保证任务按顺序执行的场景，或者不需要并发处理任务的情况。 CachedThreadPool ： 可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。适合短期大量并发任务的场景，任务执行时间短且线程数需求变化较大。 ScheduledThreadPool ：给定的延迟后运行任务或者定期执行任务的线程池。适用于需要周期性任务执行的场景，如定时任务调度器。 WorkStealingPool ：基于任务窃取算法的线程池。线程池中的每个线程维护一个双端队列（deque），线程可以从自己的队列中取任务执行。如果线程的任务队列为空，它可以从其他线程的队列中“窃取”任务来执行，达到负载均衡的效果。适合大量小任务并行执行，特别是递归算法或大任务分解成小任务的场景。 线程池的核心参数 corePoolSize ：线程池中用来工作的核心线程数量。 maximumPoolSize ：最大线程数，线程池允许创建的最大线程数。 keepAliveTime ：超出 corePoolSize 后创建的线程存活时间或者是所有线程最大存活时间，取决于配置。 unit ：keepAliveTime 的时间单位。 workQueue ：任务队列，是一个阻塞队列，当线程数达到核心线程数后，会将任务存储在阻塞队列中。 threadFactory ：线程池内部创建线程所用的工厂。 handler ：拒绝策略；当队列已满并且线程数量达到最大线程数量时，会调用该方法处理任务。 线程池的工作流程 提交任务 检查线程池是否运行 若线程池不再运行则放弃任务 检测当前线程池的线程数是否小于核心线程数 若小于核心线程数则创建一个工作线程并执行任务 若大于核心线程数检测阻塞队列是否已经满 若阻塞队列未满了，就会添加任务到阻塞队列中，等待工作线程获取执行 若阻塞队列已经满了就会检测当前线程池的线程数 若线程数小于最大线程数则会创建非核心线程 若线程数大于最大线程数则会拒绝任务 线程池的拒绝策略 Java中提供了四种拒绝策略用于任务被拒绝时执行该策略同时支持自定义拒绝策略\nThreadPoolExecutor.AbortPolicy ：抛出 RejectedExecutionException 来拒绝新任务的处理。 ThreadPoolExecutor.CallerRunsPolicy ：调用执行者自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果你的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。 ThreadPoolExecutor.DiscardPolicy ：不处理新任务，直接丢弃掉。 ThreadPoolExecutor.DiscardOldestPolicy ：此策略将丢弃最早的未处理的任务请求。 自定义拒绝策略\n可以自己实现 RejectedExecutionHandler 接口\n1 2 3 4 5 6 7 public class CustomRejectedExecutionHandler implements RejectedExecutionHandler { @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) { System.out.println(r.toString() + \u0026#34; rejected\u0026#34;); // 可以在这里实现日志记录或其他逻辑 } } 警告\nThreadPoolExecutor.CallerRunsPolicy 策略具有一定风险\n如果被 CallerRunsPolicy 的拒绝的任务是个非常耗时的任务，且处理提交任务的线程是主线程，可能会导致主线程阻塞，影响程序的正常运行。\n解决策略\n在内存允许的情况下，我们可以增加阻塞队列 BlockingQueue 的大小并调整堆内存以容纳更多的任务，确保任务能够被准确执行。 为了充分利用 CPU，我们还可以调整线程池的 maximumPoolSize （最大线程数）参数，这样可以提高任务处理速度，避免累计在 BlockingQueue 的任务过多导致内存用完。 线程池常用的阻塞队列 ArrayBlockingQueue：一个有界队列，底层基于数组实现。需要在初始化时指定队列的大小，队列满时，生产者会被阻塞，队列空时，消费者会被阻塞。 LinkedBlockingQueue：基于链表的阻塞队列，允许可选的界限（有界或无界）。无界模式下可以不断添加元素，直到耗尽系统资源。有界模式则类似于 ArrayBlockingQueue，但吞吐量通常较高。 PriorityBlockingQueue：一个无界的优先级队列，元素按照自然顺序或者指定的比较器顺序进行排序。与其他阻塞队列不同的是，PriorityBlockingQueue 不保证元素的 FIFO 顺序。 DelayQueue：一个无界队列，队列中的元素必须实现 Delayed 接口，只有当元素的延迟时间到期时，才能被取出。常用于延迟任务调度。 SynchronousQueue：一个没有内部容量的队列，每个插入操作必须等待对应的移除操作，反之亦然。常用于在线程之间的直接传递任务，而不是存储任务。 参见往期博客\n核心线程的执行策略 核心线程数量可以为0 当核心线程数为0的时候，会创建一个非核心线程进行执行。\n核心线程回收问题 ThreadPoolExecutor 默认不会回收核心线程，即使它们已经空闲了。这是为了减少创建线程的开销，因为核心线程通常是要长期保持活跃的。\n但是，如果线程池是被用于周期性使用的场景，且频率不高（周期之间有明显的空闲时间）可以考虑回收核心线程。在负载高峰时临时增加核心线程数，低负载时通过回收空闲线程释放资源\nallowCoreThreadTimeOut(true) 可以允许核心线程在空闲时被回收，从而释放系统资源。\n核心线程数在运行过程可以动态修改 使用 ThreadPoolExecutor.setCorePoolSize(int corePoolSize) 方法可以动态修改核心线程数。\ncorePoolSize 参数代表线程池中的核心线程数。\n当池中线程数量少于核心线程数时，会创建新的线程来处理任务。这个修改可以在线程池运行的过程中进行，立即生效。\n注意事项\n核心线程数的修改不会中断现有任务，新的核心线程数会在新任务到来时生效。 setCorePoolSize() 方法可以减少核心线程数，但如果当前线程池中的线程数量超过了新的核心线程数，多余的线程不会立即被销毁，直到这些线程空闲后被回收。 提示\n线程池中的核心参数支持动态调整\nsetCorePoolSize(int corePoolSize) ：修改 核心线程数 setMaximumPoolSize(int maximumPoolSize) ：修改 最大线程数 setKeepAliveTime(long time, TimeUnit unit) ：修改 线程存活时间 setRejectedExecutionHandler(RejectedExecutionHandler handler) ：修改 拒绝策略 线程池的状态 RUNNING ：线程池创建时就是这个状态，能够接收新任务，以及对已添加的任务进行处理。 SHUTDOWN ：调用 shutdown 方法，线程池就会转换成 SHUTDOWN 状态，此时线程池不再接收新任务，但能继续处理已添加的任务到队列中。 STOP ：调用 shutdownNow 方法，线程池就会转换成 STOP 状态，不接收新任务，也不能继续处理已添加的任务到队列中任务，并且会尝试中断正在处理的任务的线程。 TIDYING：所有的任务已经运行终止，记录的任务数量为 0。 SHUTDOWN 状态下，任务数为 0， 其他所有任务已终止，线程池会变为 TIDYING 状态 线程池在 SHUTDOWN 状态，任务队列为空且执行中任务为空，线程池会变为 TIDYING 状态 线程池在 STOP 状态，线程池中执行中任务为空时，线程池会变为 TIDYING 状态。 TERMINATED ：线程池彻底终止。线程池在 TIDYING 状态执行完 terminated() 方法就会转变为 TERMINATED 状态。 线程池的任务提交 提交不需要返回值的任务 execute() 用于提交不需要返回值的任务\n方法签名 void execute(Runnable command)\n代码示例 1 2 3 4 threadsPool.execute(new Runnable() { @Override public void run() { // TODO Auto-generated method stub } }); 异常处理 当任务通过 execute() 提交到线程池并在执行过程中抛出异常时，如果这个异常没有在任务内被捕获，那么该异常会导致当前线程终止，并且异常会被打印到控制台或日志文件中。线程池会检测到这种线程终止，并创建一个新线程来替换它，从而保持配置的线程数不变。\n提交需要返回值的任务 submit() 方法用于提交需要返回值的任务。线程池会返回一个 future 类型的对象，通过这个 future 对象可以判断任务是否执行成功，并且可以通过 future 的 get() 方法来获取返回值\n方法签名 \u0026lt;T\u0026gt; Future\u0026lt;T\u0026gt; submit(Runnable task, T result) ：无返回值的任务（可以传默认值） \u0026lt;T\u0026gt; Future\u0026lt;T\u0026gt; submit(Callable\u0026lt;T\u0026gt; task) ：有返回值的任务 代码示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.util.concurrent.*; public class SubmitRunnableExample { public static void main(String[] args) throws ExecutionException, InterruptedException { ExecutorService executor = Executors.newFixedThreadPool(2); Runnable task = () -\u0026gt; { System.out.println(Thread.currentThread().getName() + \u0026#34; 执行任务\u0026#34;); }; Future\u0026lt;?\u0026gt; future = executor.submit(task); // `Runnable` 没有返回值，future.get() 只能拿到 `null` System.out.println(\u0026#34;任务执行结果: \u0026#34; + future.get()); executor.shutdown(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.util.concurrent.*; public class SubmitCallableExample { public static void main(String[] args) throws ExecutionException, InterruptedException { ExecutorService executor = Executors.newFixedThreadPool(2); Callable\u0026lt;Integer\u0026gt; task = () -\u0026gt; { System.out.println(Thread.currentThread().getName() + \u0026#34; 执行任务\u0026#34;); return 42; }; Future\u0026lt;Integer\u0026gt; future = executor.submit(task); System.out.println(\u0026#34;任务执行结果: \u0026#34; + future.get()); executor.shutdown(); } } 异常处理 对于通过 submit() 提交的任务，如果在任务执行中发生异常，这个异常不会直接打印出来。相反，异常会被封装在由 submit() 返回的 Future 对象中。当调用 Future.get() 方法时，可以捕获到一个 ExecutionException 。在这种情况下，线程不会因为异常而终止，它会继续存在于线程池中，准备执行后续的任务。\n线程池的关闭 shutdown() ：关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。 shutdownNow() ：关闭线程池，线程池的状态变为 STOP。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。 shutdown() 方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * 启动一次顺序关闭，在这次关闭中，执行器不再接受新任务，但会继续处理队列中的已存在任务。 * 当所有任务都完成后，线程池中的线程会逐渐退出。 */ public void shutdown() { final ReentrantLock mainLock = this.mainLock; // ThreadPoolExecutor的主锁 mainLock.lock(); // 加锁以确保独占访问 try { checkShutdownAccess(); // 检查是否有关闭的权限 advanceRunState(SHUTDOWN); // 将执行器的状态更新为SHUTDOWN interruptIdleWorkers(); // 中断所有闲置的工作线程 onShutdown(); // ScheduledThreadPoolExecutor中的挂钩方法，可供子类重写以进行额外操作 } finally { mainLock.unlock(); // 无论try块如何退出都要释放锁 } tryTerminate(); // 如果条件允许，尝试终止执行器 } 启动线程池的平滑关闭。它不再接受新的任务，但会继续执行已经提交的任务（包括在队列中的任务）。\n线程池会进入 SHUTDOWN 状态，所有已执行和正在执行的任务都会继续完成，只有所有任务完成后，线程池才会完全终止。\nshutdownNow() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * 尝试停止所有正在执行的任务，停止处理等待的任务， * 并返回等待处理的任务列表。 * * @return 从未开始执行的任务列表 */ public List\u0026lt;Runnable\u0026gt; shutdownNow() { List\u0026lt;Runnable\u0026gt; tasks; // 用于存储未执行的任务的列表 final ReentrantLock mainLock = this.mainLock; // ThreadPoolExecutor的主锁 mainLock.lock(); // 加锁以确保独占访问 try { checkShutdownAccess(); // 检查是否有关闭的权限 advanceRunState(STOP); // 将执行器的状态更新为STOP interruptWorkers(); // 中断所有工作线程 tasks = drainQueue(); // 清空队列并将结果放入任务列表中 } finally { mainLock.unlock(); // 无论try块如何退出都要释放锁 } tryTerminate(); // 如果条件允许，尝试终止执行器 return tasks; // 返回队列中未被执行的任务列表 } 启动线程池的强制关闭。它会尝试停止所有正在执行的任务，并返回等待执行的任务列表。它会尽力中断正在执行的任务，但不能保证所有任务都能被立即停止。\n线程池进入 STOP 状态，除了尝试中断正在执行的任务外，还会清空任务队列，返回未执行的任务列表。\n线程池的最佳实践和调优 线程池声明时 必须 使用 ThreadPoolExecutor 构造函数的方式，不允许使用 Executors 去创建 FixedThreadPool 和 SingleThreadExecutor 使用的是有界阻塞队列是 LinkedBlockingQueue ，其任务队列的最大长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。 CachedThreadPool 使用的是同步队列 SynchronousQueue , 允许创建的线程数量为 Integer.MAX_VALUE ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。 ScheduledThreadPool 和 SingleThreadScheduledExecutor 使用的无界的延迟阻塞队列 DelayedWorkQueue ，任务队列最大长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。 选择合适的线程池大小 过小的线程池可能会导致任务一直在排队 过大的线程池可能会导致大家都在竞争 CPU 资源，增加上下文切换的开销 设置策略 CPU 密集型任务 (N/N+1)： 这种任务消耗的主要是 CPU 资源，线程数应设置为 N或N+1（CPU 核心数）。由于任务主要瓶颈在于 CPU 计算能力，与核心数相等的线程数能够最大化 CPU 利用率，过多线程反而会导致竞争和上下文切换开销。 I/O 密集型任务(M * N)： 这类任务大部分时间处理 I/O 交互，线程在等待 I/O 时不占用 CPU。 为了充分利用 CPU 资源，线程数可以设置为 M * N，其中 N 是 CPU 核心数，M 是一个大于 1 的倍数，建议默认设置为 2 ，具体取值取决于 I/O 等待时间和任务特点，需要通过测试和监控找到最佳平衡点。 自定义 ThreadFactory 实现给线程命名 线程池尽量不放入耗时操作 ","date":"2025-02-07T13:17:52+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF/","title":"Java的线程池技术"},{"content":"原子操作类是什么 原子类就是具有原子性操作特征的类。\njava.util.concurrent.atomic 包中的 Atomic 原子类提供了一种线程安全的方式来操作单个变量。\n原子类的基本特性 非阻塞（无锁）：基于 CAS（Compare-And-Swap） 实现，不使用 synchronized。 高效并发：比 synchronized 或 Lock 更快，适合高并发环境。 保证原子性：不会发生竞态条件（Race Condition）。 原子操作基本数据类型 AtomicBoolean：以原子更新的方式更新 boolean AtomicInteger ：以原子更新的方式更新 Integer AtomicLong：以原子更新的方式更新 Long 常用方法（以 AtomicInteger 为例）\n1 2 3 4 5 6 7 public final int get() //获取当前的值 public final int getAndSet(int newValue)//获取当前的值，并设置新的值 public final int getAndIncrement()//获取当前的值，并自增 public final int getAndDecrement() //获取当前的值，并自减 public final int getAndAdd(int delta) //获取当前的值，并加上预期的值 boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update） public final void lazySet(int newValue)//最终设置为newValue, lazySet 提供了一种比 set 方法更弱的语义，可能导致其他线程在之后的一小段时间内还是可以读到旧的值，但可能更高效。 原子操作数组类型 AtomicIntegerArray：原子更新 int 整数数组的方法。 AtomicLongArray ：原子更新 long 型证书数组的方法。 AtomicReferenceArray ：原子更新引用类型数组的方法。 常用方法（以 AtomicIntegerArray 为例）\n1 2 3 4 5 6 7 public final int get(int i) //获取 index=i 位置元素的值 public final int getAndSet(int i, int newValue)//返回 index=i 位置的当前的值，并将其设置为新值：newValue public final int getAndIncrement(int i)//获取 index=i 位置元素的值，并让该位置的元素自增 public final int getAndDecrement(int i) //获取 index=i 位置元素的值，并让该位置的元素自减 public final int getAndAdd(int i, int delta) //获取 index=i 位置元素的值，并加上预期的值 boolean compareAndSet(int i, int expect, int update) //如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update） public final void lazySet(int i, int newValue)//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 原子操作引用类型 AtomicReference ：原子更新引用类型； AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。 AtomicMarkableReference ：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class AtomicDemo { private static AtomicReference\u0026lt;User\u0026gt; reference = new AtomicReference\u0026lt;\u0026gt;(); public static void main(String[] args) { User user1 = new User(\u0026#34;a\u0026#34;, 1); reference.set(user1); User user2 = new User(\u0026#34;b\u0026#34;,2); User user = reference.getAndSet(user2); System.out.println(user); System.out.println(reference.get()); } static class User { private String userName; private int age; public User(String userName, int age) { this.userName = userName; this.age = age; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;userName=\u0026#39;\u0026#34; + userName + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } } // 输出结果 // User{userName=\u0026#39;a\u0026#39;, age=1} // User{userName=\u0026#39;b\u0026#39;, age=2} 原子更新字段 AtomicIntegerFieldUpdater :原子更新整形字段的更新器 AtomicLongFieldUpdater ：原子更新长整形字段的更新器 AtomicReferenceFieldUpdater ：原子更新引用类型里的字段的更新器 使用步骤\n通过静态方法 newUpdater 创建一个更新器，并且设置想要更新的类和字段； 字段必须使用 public volatile 进行修饰； 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class AtomicDemo { private static AtomicIntegerFieldUpdater updater = AtomicIntegerFieldUpdater.newUpdater(User.class,\u0026#34;age\u0026#34;); public static void main(String[] args) { User user = new User(\u0026#34;a\u0026#34;, 1); int oldValue = updater.getAndAdd(user, 5); System.out.println(oldValue); System.out.println(updater.get(user)); } static class User { private String userName; public volatile int age; public User(String userName, int age) { this.userName = userName; this.age = age; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;userName=\u0026#39;\u0026#34; + userName + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } } 原子操作的实现原理 Java 中的原子类是通过使用硬件提供的原子操作指令（ CAS ，Compare-And-Swap）来确保操作的原子性，从而避免线程竞争问题。\n具体细节参见 往期博客\n","date":"2025-02-06T14:56:39+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB/","title":"Java中的原子操作类"},{"content":"为什么需要 ThreadLocal ThreadLocal 是 Java 中提供的一种用于实现线程局部变量的工具类。它允许每个线程都拥有自己的独立副本，从而实现线程隔离，用于解决多线程中共享对象的线程安全问题。\n通常，使用 synchronzed 关键字 或者 lock 来控制线程对临界区资源的同步顺序，但这种加锁的方式会让未获取到锁的线程进行阻塞，很显然，这种方式的时间效率不会特别高。\n线程安全问题的核心在于多个线程会对同一个临界区的共享资源进行访问，那如果每个线程都拥有自己的“共享资源”，各用各的，互不影响，这样就不会出现线程安全的问题\nThreadLocal 就是线程的“本地变量”，即每个线程都拥有该变量的一个副本，达到人手一份的目的，这样就可以避免共享资源的竞争。\nThreadLocal 的主要特性 每个线程都维护一份独立的变量副本：不同线程之间的值互不影响。 变量的生命周期与线程一致：线程结束后，ThreadLocal 变量会自动回收，避免内存泄漏。 适用于线程安全的场景，尤其是在无锁并发编程中使用，如 数据库连接、用户 Session、事务管理 等。 ThreadLocal 的主要方法 set(T value) 设置当前线程的变量值\nget() 获取当前线程的变量值\nremove() 删除当前线程的变量值，避免内存泄漏\nwithInitial(Supplier\u0026lt;T\u0026gt; supplier) 设置初始值\nThreadLocal 的实现原理 ThreadLocal 提供了一种线程内独享的变量机制，使每个线程都能有自己独立的变量副本。每个线程内部维护一个 ThreadLocalMap，这个 ThreadLocalMap 用于存储线程独立的变量副本。ThreadLocalMap 以 ThreadLocal 实例作为键，以线程独立的变量副本作为值。不同线程通过 ThreadLocal 获取各自的变量副本，而不会影响其他线程的数据。\nThreadLocal 可以理解为 ThreadLocalMap的封装，传递了变量值。\n每个Thread中都具备一个ThreadLocalMap，而 ThreadLocalMap 可以存储以ThreadLocal为 key ，Object 对象为 value 的键值对。\nThreadLocal 的使用场景 用于保存用户登录信息，这样在同一个线程中的任何地方都可以获取到登录信息。 用于保存数据库连接、Session 对象等，这样在同一个线程中的任何地方都可以获取到数据库连接、Session 对象等。 用于保存事务上下文，这样在同一个线程中的任何地方都可以获取到事务上下文。 用于保存线程中的变量，这样在同一个线程中的任何地方都可以获取到线程中的变量。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class UserAuthenticationService { // 创建一个ThreadLocal实例，用于保存用户登录信息 private static ThreadLocal\u0026lt;User\u0026gt; currentUser = ThreadLocal.withInitial(() -\u0026gt; null); public static void main(String[] args) { // 模拟用户登录 loginUser(new User(\u0026#34;Alice\u0026#34;, \u0026#34;password123\u0026#34;)); System.out.println(\u0026#34;User logged in: \u0026#34; + getCurrentUser().getUsername()); // 模拟另一个线程处理另一个用户 Runnable task = () -\u0026gt; { loginUser(new User(\u0026#34;Bob\u0026#34;, \u0026#34;password456\u0026#34;)); System.out.println(\u0026#34;User logged in: \u0026#34; + getCurrentUser().getUsername()); }; Thread thread = new Thread(task); thread.start(); } // 模拟用户登录方法 public static void loginUser(User user) { // 这里通常会有一些身份验证逻辑 currentUser.set(user); } // 获取当前线程关联的用户信息 public static User getCurrentUser() { return currentUser.get(); } // 用户类 public static class User { private final String username; private final String password; public User(String username, String password) { this.username = username; this.password = password; } public String getUsername() { return username; } // 其他getter和setter... } } ThreadLocal 的缺点 内存泄漏问题 ThreadLocal 的生命周期和线程的生命周期绑定，当一个线程结束时，其 ThreadLocalMap 也会随之销毁，但是 ThreadLocal 对象本身不会立即被垃圾回收，直到没有其他引用指向它为止。\n底层原因\nkey 是弱引用：ThreadLocalMap 中的 key 是 ThreadLocal 的弱引用 。 这意味着，如果 ThreadLocal 实例不再被任何强引用指向，垃圾回收器会在下次 GC 时回收该实例，导致 ThreadLocalMap 中对应的 key 变为 null value 是强引用： ThreadLocalMap 中的 value 是强引用。 即使 key 被回收（变为 null），value 仍然存在于 ThreadLocalMap 中，被强引用，不会被回收。 内存泄漏的条件\nThreadLocal 实例不再被强引用； 线程持续存活，导致 ThreadLocalMap 长期存在。 解决方法\n显式调用 remove() 方法 解决哈希冲突的策略可以优化 HashMap 是通过链表(红黑树)法来解决冲突，而 ThreadLocalMap 是通过开放寻址法来解决冲突。在哈希冲突多了，需要遍历的次数就多了\n使用建议 避免内存泄漏： ThreadLocal 中的 key 是弱引用，但 value 是强引用，因此需要在适当的时机调用 remove() 方法来清除 ThreadLocal 的值，避免内存泄漏。尤其是在使用线程池时，线程对象会被重用，若不手动清理，容易导致内存泄漏。 使用静态变量存放 ThreadLocal： 将 ThreadLocal 作为类的静态变量保存，这样可以确保同一个线程的局部变量在线程的生命周期内都可以被访问，避免对象频繁创建。 ","date":"2025-02-06T13:16:53+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84threadlocal/","title":"Java中的ThreadLocal"},{"content":"ReentrantLock类 ReentrantLock 是 Java 并发包（java.util.concurrent.locks） 提供的一个可重入锁，比 synchronized 更灵活，支持公平锁、非公平锁、可中断锁、超时获取锁等特性。\nReentrantLock类的常用方法 构造方法 public ReentrantLock() ：// 创建一个非公平锁（默认） public ReentrantLock(boolean fair) ：// 创建一个公平锁或非公平锁 获取锁 public void lock() ：阻塞式地获取锁（如果锁被占用，会一直等待）。 public boolean tryLock() ：尝试获取锁（不会阻塞，获取失败返回 false）。 public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException ：在指定时间内尝试获取锁，超时返回 false。 使用 ReentrantLock 时，锁必须在 try 代码块开始之前获取，并且加锁之前不能有异常抛出，否则在 finally 块中就无法释放锁（ReentrantLock 的锁必须在 finally 中手动释放）。\n判断锁的归属 public boolean isLocked() ：判断锁是否被任何线程持有。 public boolean isHeldByCurrentThread() ：判断锁是否被当前线程持有。 释放锁 public void unlock() ：释放锁 ReentrantLock 的实现原理 内部实现依靠一个 state 变量和两个队列：同步队列 和 等待队列。\n线程利用 CAS 修改 state 来争抢锁。\n争抢不到则入同步队列等待，同步队列是一个双向链表。\n条件 condition 不满足时候则入等待队列等待，是个单向链表。\n是否是公平锁的区别在于：线程获取锁时是加入到同步队列尾部还是直接利用 CAS 争抢锁。\n非公平锁的实现 获取非公平锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 final boolean nonfairTryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); //1. 如果该锁未被任何线程占有，该锁能被当前线程获取 if (c == 0) { if (compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } //2.若被占有，检查占有线程是否是当前线程 else if (current == getExclusiveOwnerThread()) { // 3. 再次获取，计数加一 int nextc = c + acquires; if (nextc \u0026lt; 0) // overflow throw new Error(\u0026#34;Maximum lock count exceeded\u0026#34;); setState(nextc); return true; } return false; } 如果该锁未被任何线程占有，该锁能被当前线程获取 如果该锁已经被线程占有了，会继续检查占有线程是否为当前线程 如果是的话，同步状态加 1 返回 true，表示可以再次获取成功。每次重新获取都会对同步状态进行加一的操作 释放非公平锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 protected final boolean tryRelease(int releases) { //1. 同步状态减1 int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) { //2. 只有当同步状态为0时，锁成功被释放，返回true free = true; setExclusiveOwnerThread(null); } // 3. 锁未被完全释放，返回false setState(c); return free; } 由于锁会被获取 n 次，那么只有锁在被释放同样的 n 次之后，该锁才算是完全释放成功。\n总体逻辑 CAS 方式尝试将 state 从 0 变为 1，如果成功，锁被当前线程获取。 如果失败（锁已被占用），则进入 AQS 同步队列，等待唤醒。 公平锁的实现 获取公平锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 protected final boolean tryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { if (!hasQueuedPredecessors() \u0026amp;\u0026amp; compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc \u0026lt; 0) throw new Error(\u0026#34;Maximum lock count exceeded\u0026#34;); setState(nextc); return true; } return false; } 增加了 hasQueuedPredecessors 的逻辑判断，用来判断当前节点在同步队列中是否有前驱节点的\n如果有前驱节点，说明有线程比当前线程更早的请求资源，根据公平性，当前线程请求资源失败。\n如果当前节点没有前驱节点，才有做后面逻辑判断的必要性。\n总体逻辑 如果该锁未被任何线程占有，该锁能被当前线程获取 再检查 hasQueuedPredecessors()，判断当前线程前面是否有排队的线程 如果队列为空，才允许当前线程尝试获取锁（严格遵循先来先得）。 如果队列中已有等待的线程，即使 state == 0 也不能直接获取锁。 如果该锁已经被线程占有了，会继续检查占有线程是否为当前线程 如果是的话，同步状态加 1 返回 true，表示可以再次获取成功。每次重新获取都会对同步状态进行加一的操作 ReentrantLock 和 synchronized 的区别 用法不同：synchronized 可用来修饰普通方法、静态方法和代码块，而 ReentrantLock 只能用在代码块上。 获取锁和释放锁方式不同：synchronized 会自动加锁和释放锁，当进入 synchronized 修饰的代码块之后会自动加锁，当离开 synchronized 的代码段之后会自动释放锁。而 ReentrantLock 需要手动加锁和释放锁 锁类型不同：synchronized 属于非公平锁，而 ReentrantLock 既可以是公平锁也可以是非公平锁。 响应中断不同：ReentrantLock 可以响应中断，解决死锁的问题，而 synchronized 不能响应中断。 底层实现不同：synchronized 是 JVM 层面通过监视器实现的，而 ReentrantLock 是基于 AQS 实现的。 实现多路选择通知 ：ReentrantLock 可以实现多路选择通知（可以绑定多个 Condition），而 synchronized 只能通过 wait 和 notify/notifyAll 方法唤醒一个线程或者唤醒全部线程（单路通知） ","date":"2025-02-04T20:59:16+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84reentrantlock%E7%B1%BB/","title":"Java中的ReentrantLock类"},{"content":"什么是AQS AQS 全称 Abstract Queued Synchronizer 即 抽象队列同步器\n可以从以下角度理解\n抽象：抽象类，只实现一些主要逻辑，有些方法由子类实现； 队列：使用先进先出（FIFO）的队列存储数据； 同步：实现了同步的功能。 AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的同步器\nAQS 常见的实现类有 ReentrantLock、CountDownLatch、Semaphore 等等\nAQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁 实现的，即将暂时获取不到锁的线程加入到队列中。\nAQS的底层数据结构 状态 AQS 通过一个 volatile 类型的整数 state 来表示同步状态。\n1 2 3 4 /** * The synchronization state. */ private volatile int state; 双端队列 AQS 内部使用了一个先进先出（FIFO）的双端队列。用于管理等待获取同步状态的线程。CLH队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。每个节点（Node）代表一个等待的线程，节点之间通过 next 和 prev 指针链接。\n1 2 3 4 5 6 7 8 9 10 static final class Node { static final Node SHARED = new Node(); static final Node EXCLUSIVE = null; volatile int waitStatus; volatile Node prev; volatile Node next; volatile Thread thread; // 保存等待的线程 Node nextWaiter; ..... } 资源共享模式 AQS 支持两种同步方式：\n独占模式：只有一个线程能获取同步状态，例如 ReentrantLock 。 共享模式：多个线程可以同时获取同步状态，例如 Semaphore 和 ReadWriteLock。 如果共享资源被占用，需要一种特定的阻塞等待唤醒机制来保证锁的分配，AQS 会将竞争共享资源失败的线程添加到一个 CLH 队列中。\n在 CLH 锁中，当一个线程尝试获取锁并失败时，它会将自己添加到队列的尾部并自旋，等待前一个节点的线程释放锁。\n","date":"2025-02-04T16:24:44+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84aqs/","title":"Java中的AQS"},{"content":"线程同步问题 线程同步是指在多线程环境下，为了避免多个线程对共享资源进行同时访问，从而引发数据不一致或其他问题的一种机制。它通过对关键代码段加锁，使得同一时刻只有一个线程能够访问共享资源。\n当多个线程共享同一资源（如变量、对象或文件）时，若没有同步机制，可能会导致竞态条件，即线程对共享资源的操作是非原子性的，多个线程之间可能会同时修改数据，导致结果不符合预期。\n死锁问题 线程死锁的定义：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。（ 死锁不是锁 ）\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class A { synchronized void method1(B b) { System.out.println(\u0026#34;Thread 1: Holding lock 1...\u0026#34;); try { Thread.sleep(1000); } catch (InterruptedException e) {} System.out.println(\u0026#34;Thread 1: Waiting for lock 2...\u0026#34;); b.last(); } synchronized void last() { System.out.println(\u0026#34;Thread 1: Inside method last\u0026#34;); } } class B { synchronized void method2(A a) { System.out.println(\u0026#34;Thread 2: Holding lock 2...\u0026#34;); try { Thread.sleep(1000); } catch (InterruptedException e) {} System.out.println(\u0026#34;Thread 2: Waiting for lock 1...\u0026#34;); a.last(); } synchronized void last() { System.out.println(\u0026#34;Thread 2: Inside method last\u0026#34;); } } public class DeadlockExample { public static void main(String[] args) { final A a = new A(); final B b = new B(); // Thread 1 new Thread() { public void run() { a.method1(b); } }.start(); // Thread 2 new Thread() { public void run() { b.method2(a); } }.start(); } } 死锁的必要条件 互斥条件：该资源任意一个时刻只由一个线程占用。 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。 预防和防止死锁的方法 预防死锁的方法\n破坏请求与保持条件：一次性申请所有的资源。 破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。 破坏循环等待条件 靠按序申请资源来预防 ：按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。 设置超时等待时间：为锁操作设置超时，防止线程无限期地等待锁。 锁机制的定义 锁（Lock）是一种用于控制对共享资源的访问的机制，确保多个线程在并发执行时，能够安全地访问资源，防止数据冲突和不一致的情况。锁通常用于实现线程同步，确保同一时刻只有一个线程可以访问临界区（critical section）中的共享资源。\nJava 多线程的锁都是基于对象的，Java 中的每一个对象都可以作为一个锁。\n锁存放的位置 对象头 每个 Java 对象都有一个对象头。如果是非数组类型，则用 2 个字宽来存储对象头，如果是数组，则会用 3 个字宽来存储对象头。\n对象头的内容\n长度 内容 说明 32/64bit Mark Word 存储对象的 hashCode 或锁信息等 32/64bit Class Metadata Address 存储到对象类型数据的指针 32/64bit Array length 数组的长度（如果是数组） Mark Word 锁状态 29 bit 或 61 bit 1 bit 是否是偏向锁？ 2 bit 锁标志位 无锁 0 01 偏向锁 线程 ID 1 01 轻量级锁 指向栈中锁记录的指针 此时这一位不用于标识偏向锁 00 重量级锁 指向互斥量（重量级锁）的指针 此时这一位不用于标识偏向锁 10 GC 标记 此时这一位不用于标识偏向锁 11 锁的级别 在 JDK 1.6 以前，所有的锁都是”重量级“锁，因为使用的是操作系统的互斥锁，当一个线程持有锁时，其他试图进入 synchronized 块的线程将被阻塞，直到锁被释放。涉及到了线程上下文切换和用户态与内核态的切换，因此效率较低。\n那为了减少获得锁和释放锁带来的性能消耗，JDK 1.6 引入了 “ 偏向锁 ”和“ 轻量级锁 ” 的概念\n一个对象其实有四种锁级别，它们级别由低到高依次是\n无锁状态 偏向锁状态 轻量级锁状态 重量级锁状态 无锁状态 在这个状态下，没有线程试图获取锁。没有对资源进行锁定，任何线程都可以尝试去修改它\n偏向锁 出现原因：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此可以消除同一线程的后续锁获取和释放的开销。如果同一线程再次请求锁，就无需再次同步。\n偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。也就是说，偏向锁在资源无竞争情况下消除了同步语句。\n工作原理 一个线程在第一次进入同步块时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID。 当下次该线程进入这个同步块时，会去检查锁的 Mark Word 里面是不是放的自己的线程 ID。 如果是，表明该线程已经获得了锁，以后该线程在进入和退出同步块时不需要花费 CAS 操作来加锁和解锁 如果不是，就代表有另一个新线程来竞争这个偏向锁。这个时候新线程会尝试使用 CAS 来替换 Mark Word 里面的线程 ID 为新线程的 ID 成功，表示之前的线程不存在了， Mark Word 里面的线程 ID 为新线程的 ID，锁不会升级，仍然为偏向锁； 失败，表示之前的线程仍然存在，那么暂停之前的线程，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁。 轻量级锁 多个线程在不同时段获取同一把锁 ，即不存在锁竞争的情况，也就没有线程阻塞。针对这种情况，JVM 采用轻量级锁来避免线程的阻塞与唤醒。\n当一个线程尝试获取轻量级锁时，它会在自己的栈帧中创建一个锁记录（Lock Record），然后尝试使用 CAS 操作将对象头的 Mark Word 替换为指向锁记录的指针。\n工作原理 当线程想要获取一个轻量级锁时，它会在自己的栈帧中创建一个锁记录（Lock Record）然后尝试用 CAS 将锁的 Mark Word 替换为指向锁记录的指针 如果 CAS 操作成功，即锁当前没有被任何线程持有。JVM会将锁的标志位设置为“轻量级锁”状态，并将当前线程的ID保存在对象头中。该线程会继续执行它的代码，并且无需阻塞。 如果 CAS 操作失败，即另一个线程试图获取锁。当前线程会进入自旋 状态（它会在短时间内不断地尝试访问锁的对象，而不立即挂起自己）自旋的过程会消耗一些CPU资源，但如果锁竞争不激烈，线程很可能在自旋过程中成功获取锁，而不会造成线程的阻塞。 如果自旋到一定程度（和 JVM、操作系统相关），依然没有获取到锁，那么这个线程会阻塞。同时这个锁就会升级成重量级锁。 重量级锁 重量级锁依赖于操作系统的互斥锁（mutex，用于保证任何给定时间内，只有一个线程可以执行某一段特定的代码段） 实现，而操作系统中线程间状态的转换需要相对较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗 CPU。\n锁的升级过程 无锁\u0026ndash;\u0026gt;偏向锁\u0026mdash;\u0026gt; 轻量级锁\u0026mdash;-\u0026gt;重量级锁。\n当线程A首次访问同步块时，如果此对象无锁状态且偏向锁未被禁用，JVM 会将该对象头的锁标记改为偏向锁状态，并记录下线程A的 ID。此时，对象头中的 Mark Word 中存储了持有偏向锁的线程 ID。\n当线程A再次进入这个同步块时，会去检查锁的 Mark Word 里面是不是放的自己的线程 ID。\n如果是，表明线程A已经获得了锁，以后该线程在进入和退出同步块时不需要花费 CAS 操作来加锁和解锁 如果不是，就代表有另一个线程B来竞争这个偏向锁，这个时候线程B会尝试使用 CAS 来替换 Mark Word 里面的线程 ID 为自己的 ID 成功，表示线程A已经退出同步块了， Mark Word 里面的线程 ID 为线程B的 ID，锁不会升级，仍然为偏向锁； 失败，表示线程A仍然持有偏向锁，那么JVM会 暂停线程A 撤销偏向锁 升级为轻量级锁， 线程A和线程B按照轻量级锁的方式进行竞争锁。 当线程B想要获取一个轻量级锁时，它会在自己的栈帧中创建一个锁记录（Lock Record）然后尝试用 CAS 将锁的 Mark Word 替换为指向锁记录的指针\n如果 CAS 操作成功，即锁当前没有被任何线程持有。JVM会将锁的标志位设置为“轻量级锁”状态，并将线程B的ID保存在对象头中。该线程会继续执行它的代码，并且无需阻塞。 如果 CAS 操作失败，即另一个线程（线程A）试图获取锁。线程B会进入自旋 状态（它会在短时间内不断地尝试访问锁的对象，而不立即挂起自己）自旋的过程会消耗一些CPU资源，但如果锁竞争不激烈，线程B很可能在自旋过程中成功获取锁，而不会造成线程的阻塞。 如果线程B自旋到一定程度（和 JVM、操作系统相关），依然没有获取到锁，那么这个线程会阻塞。同时这个锁就会升级成重量级锁。\nsynchronized 的优化 偏向锁：当一个线程首次获得锁时，JVM 会将锁标记为偏向这个线程，将锁的标志位设置为偏向模式，并且在对象头中记录下该线程的 ID。之后，当相同的线程再次请求这个锁时，就无需进行额外的同步。如果另一个线程尝试获取这个锁，偏向模式会被撤销，并且锁会升级为轻量级锁。 轻量级锁：多个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。针对这种情况，JVM 采用轻量级锁来避免线程的阻塞与唤醒。当一个线程尝试获取轻量级锁时，它会在自己的栈帧中创建一个锁记录（Lock Record），然后尝试使用 CAS 操作将对象头的 Mark Word 替换为指向锁记录的指针。如果成功，该线程持有锁；如果失败，表示有其他线程竞争，锁会升级为重量级锁。 自旋锁：当线程尝试获取轻量级锁失败时，它会进行自旋，即循环检查锁是否可用，以避免立即进入阻塞状态。自旋的次数不是固定的，而是根据之前在同一个锁上的自旋时间和锁的状态动态调整的。 锁粗化：如果 JVM 检测到一系列连续的锁操作实际上是在单一线程中完成的，则会将多个锁操作合并为一个更大范围的锁操作，这可以减少锁请求的次数。锁粗化主要针对循环内连续加锁解锁的情况进行优化。 提示\n自旋 和 锁自适应自旋\n自旋 ：在多线程环境下，当一个线程尝试获取锁时，如果锁已经被其他线程持有，线程并不会立即被阻塞，而是不断地访问锁对象。检查锁是否已经释放，线程在自旋过程中不会被挂起，也不会进行上下文切换，而是占用CPU继续执行循环检查。 锁自适应自旋 ：自适应自旋锁通过动态调整自旋的次数来提高性能。自适应的策略基于之前的自旋结果，假如上一次自旋很快获得了锁，下次可能会增加自旋次数；如果自旋失败，则减少自旋时间甚至直接放弃自旋。 乐观锁和悲观锁 乐观锁（Optimistic Lock） 和 悲观锁（Pessimistic Lock） 是两种不同的并发控制策略，常用于处理多线程环境下对共享资源的访问冲突。它们的核心区别在于对数据冲突的预判和处理方式不同。\n悲观锁 定义 悲观锁是一种假设会发生冲突的策略，认为在并发环境下线程之间会发生数据竞争，因此采用锁机制来确保线程之间的互斥执行，避免数据冲突。悲观锁会在操作数据之前加锁，保证同一时刻只有一个线程可以访问共享资源。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。\n特点 假设线程之间会有冲突，因此总是会对共享资源加锁。 锁的粒度较大，通常在整个操作过程中都持有锁。 当一个线程持有锁时，其他线程必须等待该锁释放才能继续执行。 缺点 性能开销大 ：高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。 线程阻塞 ：悲观锁还可能会存在死锁问题（线程获得锁的顺序不当时），影响代码的正常运行。 使用场景 悲观锁通常多用于写比较多的情况（读少写多场景，竞争激烈），这样可以避免频繁失败和重试影响性能。 需要严格保证数据一致性和完整性的场合 数据库中的行级锁防止多个事务同时修改同一行数据。 在电商平台等支付系统中，多个用户可能会同时购买同一商品，或者多个支付请求同时处理。使用悲观锁可以确保同一时间只有一个线程能够处理某个商品的支付请求，从而避免出现库存不足或重复支付的情况。 具体实现 synchronized 是最常见的悲观锁实现方式，会在方法或代码块上加锁，确保同一时刻只有一个线程能够执行该代码块或方法。 ReentrantLock 是 Java 提供的一种显式锁，比 synchronized 提供了更多的控制功能，例如尝试获取锁、定时获取锁等。 乐观锁 定义 乐观锁则是一种假设不会发生冲突的策略，认为在并发环境下线程之间发生冲突的概率较低，因此不通过加锁来进行数据保护，而是通过其他手段，如版本号、时间戳等，来验证数据在提交时是否发生变化。如果数据发生了变化，乐观锁会进行重试或者抛出异常。\n特点 假设冲突发生的概率较低，因此不会加锁。 在操作数据时，乐观锁会先执行任务并在提交时检查数据是否已经发生变化。 如果数据没有变化，则提交成功；如果数据发生了变化，则需要重新尝试或处理冲突。 缺点 实现复杂度较高，尤其是在多表或复杂事务的场景下。 冲突频繁时性能下降。 使用场景 “读多写少“的环境，避免频繁加锁影响性能 在数据库系统中，乐观锁用于保证数据在并发环境下的正确性。典型的做法是给每行数据加上一个 version 字段（或 timestamp）。在更新数据时，首先读取该行数据的版本号，然后在提交时比较版本号，如果版本号没有变化，则表示没有其他事务修改过该数据，可以进行更新；如果版本号发生变化，则回滚操作。 具体实现 版本号机制 在版本号机制中，每个数据对象（或数据库表中的记录）都会有一个与之关联的版本号或时间戳。每次读取数据时，都会获取当前的版本号。在数据修改时，首先检查版本号是否和读时一致。如果版本号没有变化，则说明在读取和写入期间没有其他事务对该数据进行修改，操作可以继续进行；否则，如果版本号发生了变化，表示数据在此期间已被其他事务修改，当前事务需要回滚或者重试。\n初始化版本号：每个数据项或记录初始化时会有一个版本号 version 读取数据时：每次读取数据时，除了获取数据内容外，还会获取该数据的版本号 version。 修改数据时： 在修改数据前，程序会检查当前数据的版本号 version。 提交更新时，检查该数据在操作期间是否有其他事务修改过。如果版本号 version 没有变化，说明没有发生冲突，可以提交更新；如果版本号 version 已发生变化，说明数据已被其他事务修改，此时需要回滚或重试。 提交操作时：如果数据没有被其他事务修改（即版本号 version 一致），则可以成功提交更新，并将版本号 version 自增。 冲突处理：如果在提交时发现版本号 version 不一致，说明发生了冲突，当前操作需要处理冲突（比如重试、提示用户、选择保留某个版本等）。 CAS算法 CAS(Compare And Swap) 是一种硬件级别的原子操作，它比较内存中的某个值是否为预期值，如果是，则更新为新值，否则不做修改。\n算法原理\n涉及的变量如下\nV：要更新的变量(var) E：预期值(expected) N：新值(new) 算法步骤如下\n比较（Compare） ：CAS 会检查内存中的某个值 V 是否与预期值 E 相等。 交换（Swap） ：如果相等，则 CAS 通过 原子 方式用新值 N 来更新 V 的值 失败重试 ：如果不相等，说明有其他线程已经修改了该值，CAS 操作失败。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。 Java中的实现和应用\n在 Java 中，实现 CAS 操作的一个关键类是 Unsafe 。Unsafe 类中的 CAS 方法是 native方法。native 关键字表明这些方法是用本地代码（通常是 C 或 C++）实现的，而不是用 Java 实现的。这些方法直接调用底层的硬件指令来实现原子操作。也就是说，Java 语言并没有直接用 Java 实现 CAS 。\nJava中的原子类都是基于 CAS 操作实现原子操作的\n原子性的保证机制\nCPU层面采取以下策略\n总线锁定：通过锁定 CPU 的总线，禁止其他 CPU 或设备访问内存。在进行操作时，CPU 发出一个 LOCK 信号，这会阻止其他处理器对内存地址进行操作，直到当前指令执行完成。 缓存锁定：当多个 CPU 操作同一块内存地址时，如果该内存地址已经被缓存到某个 CPU 的缓存中，缓存锁定机制会锁定该缓存行，防止其他 CPU 对这块内存进行修改。 存在的问题\nABA 问题：在多线程环境下，某个变量的值在一段时间内经历了从 A 到 B 再到 A 的变化，这种变化可能被线程误认为值没有变化，从而导致错误的判断和操作。 解决思路 版本号/时间戳：在每次更新一个变量时，不仅更新变量的值，还更新一个版本号。CAS 操作在比较时，除了比较值是否一致，还比较版本号是否匹配。这样，即使值回到了初始值，版本号的变化也能检测到修改。 引用标记 ：另一种类似的机制，通过在引用上标记一个布尔值，帮助区分是否发生了特定变化。 长时间自旋的CPU消耗 ：CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。 解决方案：让 JVM 支持处理器提供的pause 指令。 只能对单个变量执行操作的原子性 ：如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。 解决方案 可以考虑改用锁来保证操作的原子性 可以考虑合并多个变量，将多个变量封装成一个对象，通过 AtomicReference 来保证原子性。 可重入锁 定义 可重入锁 是指同一个线程在获取了锁之后，可以再次重复获取该锁而不会造成死锁或其他问题。当一个线程持有锁时，如果再次尝试获取该锁，就会成功获取而不会被阻塞。\n具体实现 synchronized 关键字 ReentrantLock 类 示例 同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提：锁的是同一个对象或者 class），不会因为之前已经获取过还没释放而阻塞\n1 2 3 4 5 6 7 8 9 10 public class Widget { public synchronized void doSomething() { System.out.println(\u0026#34;方法1执行...\u0026#34;); doOthers(); } public synchronized void doOthers() { System.out.println(\u0026#34;方法2执行...\u0026#34;); } } doSomething() 方法中调用了 doOthers() 方法。因为内置锁是可重入的，所以同一个线程在调用 doOthers() 时可以直接获得当前对象的锁，进入 doOthers() 进行操作。\n如果是一个不可重入锁，那么当前线程在调用doOthers()之前，需要将执行 doSomething() 时获取当前对象的锁释放掉，实际上该对象锁已经被当前线程所持有，且无法释放。所以此时会出现死锁。\n公平锁和非公平锁 公平锁 : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。\n非公平锁：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。\n一般情况下，非公平锁能提升一定的效率。但是非公平锁可能会发生线程饥饿（有一些线程长时间得不到锁）的情况。\n读写锁和排他锁 排他锁 定义 ：在同一时刻只能有一个线程获取该锁，其他线程必须等待锁释放后才能继续执行。\n如果线程 T 对数据 A 加上排它锁后，则其他线程不能再对 A 加任何类型的锁。获得排它锁的线程既能读数据又能修改数据。\n特点 ：\n写操作必须独占锁，防止数据竞争。 多个线程不能同时持有排它锁，即便是读操作也会被阻塞。 具体实现\nsynchronized 关键字 ReentrantLock 类 读写锁 定义 ：允许多个线程同时读取共享资源，而在写操作时确保只有一个线程能够进行写操作（读读操作不互斥，读写互斥、写写互斥）。\n提供两种模式\n读锁（共享锁）：允许多个线程同时获取读锁，只要没有任何线程持有写锁。适合读操作频繁而写操作较少的场景。 写锁（独占锁）：写锁是独占的，当有线程持有写锁时，其他线程既不能获取写锁，也不能获取读锁。写锁用于保证写操作的独占性，防止数据不一致。 ","date":"2025-02-03T12:54:49+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E9%94%81/","title":"Java中的锁"},{"content":"Java内存模型的定义 Java 内存模型（Java Memory Model, JMM） 是 Java 虚拟机 (JVM) 定义的一种规范，用于描述多线程程序中变量（包括实例字段、静态字段和数组元素）如何在内存中存储和传递的规则。规范了线程何时会从主内存中读取数据、何时会把数据写回主内存。\n操作系统有一套内存模型，而 Java 是跨平台实现的，因此它需要自己定义一套内存模型屏蔽各操作系统之间的差异。\nJMM 定义了 Java 源码到 CPU 指令执行一套规范，我们仅需直接使用 Java 提供的并发类（synchronized、volatile 等），知晓它定义的 happens-before 原则，即可写出并发安全的代码，无需关心底层的 CPU 指令重排、多级缓存等各种底层原理。\n常见并发模型\nJava 使用的是共享内存并发模型\n三大特性 JMM 的核心目标是确保多线程环境下的可见性、有序性和原子性，从而避免由于硬件和编译器优化带来的不一致问题。\n原子性 原子性 指的是一个操作或一系列操作要么全部执行成功，要么全部不执行，期间不会被其他线程干扰。\n原子类与锁：Java 提供了 java.util.concurrent.atomic 包中的原子类，如 AtomicInteger , AtomicLong，来保证基本类型的操作具有原子性。此外，synchronized 关键字和 Lock 接口也可以用来确保操作的原子性。 CAS（Compare-And-Swap）：Java 的原子类底层依赖于 CAS 操作来实现原子性。CAS 是一种硬件级的指令，它比较内存位置的当前值与给定的旧值，如果相等则将内存位置更新为新值，这一过程是原子的。CAS 可以避免传统锁机制带来的上下文切换开销。 可见性 可见性 指的是一个线程对共享变量的修改，能够被其他线程及时看见。\nvolatile：volatile 关键字是 Java 中用来保证可见性的轻量级同步机制。当一个变量被声明为 volatile 时，所有对该变量的读写操作都会直接从主内存中进行，从而确保变量对所有线程的可见性。 synchronized：synchronized 关键字不仅可以保证代码块的原子性，还可以保证进入和退出 synchronized 块的线程能够看到块内变量的最新值。每次线程退出 synchronized 块时，都会将修改后的变量值刷新到主内存中，进入该块的线程则会从主内存中读取最新的值。 Java Memory Model（JMM）：JMM 规定了共享变量在不同线程间的可见性和有序性规则。它定义了内存屏障的插入规则，确保在多线程环境下的代码执行顺序和内存可见性。 有序性 有序性 指的是程序执行的顺序和代码的先后顺序一致。但在多线程环境下，为了优化性能，编译器和处理器可能会对指令进行重排序。\n指令重排序：为了提高性能，处理器和编译器可能会对指令进行重排序。尽管重排序不会影响单线程中的执行结果，但在多线程环境下可能会导致严重的问题。例如，单例模式 中的 双重检查锁定（DCL） 模式在没有正确同步的情况下，由于指令重排序可能导致对象尚未完全初始化就被另一个线程访问。 happens-before 原则：JMM 定义了 happens-before 规则，用于约束操作之间的有序性。如果一个操作 A happens-before 操作 B，那么 A 的结果对于 B 是可见的，且 A 的执行顺序在 B 之前。这为开发者提供了在多线程环境中控制操作顺序的手段。 内存屏障：volatile 变量的读写操作会在指令流中插入内存屏障，阻止特定的指令重排序。 在写操作前插入一个 StoreStore 屏障，防止写操作与之前的写操作重排序、 在读操作之后插入一个 LoadLoad 屏障，防止读操作与之后的读操作重排序。 线程不安全问题 内存可见性问题 共享变量 对于每一个线程来说，栈都是私有的，而堆是共有的。\n在栈中的变量（局部变量、方法定义的参数、异常处理的参数）不会在线程之间共享，也就不会有内存可见性的问题，也不受内存模型的影响。\n而在堆中的变量是共享的，一般称之为共享变量。\nCPU缓存模型 CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。\n可以把 内存看作外存的高速缓存，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。\n工作方式：先复制一份数据到 CPU 缓存 中，当 CPU 需要用到的时候就可以直接从 CPU 缓存 中读取数据，当运算完成后，再将运算得到的数据写回 主存 中。\nCPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议（比如 MESI 协议）或者其他手段来解决。\n问题定义 问题定义如下：\nCPU 缓存一致性 ：每个 CPU 核心都可能对共享变量在本地缓存中进行修改，而不立即将修改的值写回到主存（RAM）。这意味着，一个线程对变量的修改可能只有它自己能看到，其他线程可能会看到旧的值，因为它们依然访问的是自己缓存中的旧值。 写回延迟 ：当线程修改变量时，它通常会先将修改结果写入自己的 CPU 缓存，而不立即更新到主存。这种写回延迟可能导致其他线程不能及时看到变量的更新，因为其他线程从主存读取数据时并没有得到最新的值。 缓存刷新与同步 ：由于缓存的写入并不是同步的，多个线程之间的修改没有立即同步到主存。线程 A 可能在自己的缓存中修改了变量 x，但线程 B 可能依然读取的是线程 A 修改前的值，直到缓存被刷新或被同步。 指令重排问题 问题定义 在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序\n编译器优化的重排序 ：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令级并行的重排序 ：现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。 内存系统的重排序 ：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 单线程情况下不会影响程序执行结果。多线程情况下，指令重排可能导致线程之间的数据不一致问题，影响并发的正确性。\n指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致。所以在多线程下，指令重排序可能会导致一些问题。\n示例：单例模式中的“双重检查锁定”就是为了避免指令重排的问题。在初始化单例对象时，由于编译器或 CPU 的指令重排，可能会导致另一个线程读取到未初始化完成的对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Singleton { private static volatile Singleton instance; private Singleton() {} public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); // 可能会发生指令重排 } } } return instance; } } instance = new Singleton(); 的执行步骤\n分配内存空间。 初始化对象。 将对象指向内存地址。 如果没有 volatile 关键字，编译器或处理器可能会重排步骤 2 和步骤 3，这就会导致另一个线程可能读取到一个尚未初始化完成的对象\nJava内存模型的结构 抽象的来看 JMM 会把内存分为 本地内存 和 主存 ，每个线程都有自己的私有化的 本地内存，然后还有个存储共享数据的 主存 。\n主存：所有共享变量（实例变量、静态变量）存储在 主存（也就是所有线程共享的内存区域）。\n本地内存：每个线程都有一个私有的本地内存，本地内存存储了该线程以读 / 写共享变量的 副本 。每个线程只能操作自己本地内存中的变量，无法直接访问其他线程的本地内存。 如果线程间需要通信，必须通过 主存 来进行。\n由图可知\n所有的 共享变量 都存在 主存 中。 每个线程都保存了一份该线程使用到的 共享变量 的副本。 如果线程间需要通信，必须通过 主存 来进行 当一个线程更改了本地内存中共享变量的副本后，它需要将这些更改刷新到主内存中，以确保其他线程可以看到这些更改。 当一个线程需要读取共享变量时，它可能首先从本地内存中读取。如果本地内存中的副本是过时的，线程将从主内存中重新加载共享变量的最新值到本地内存中。 提示\n为什么线程需要拥有自己的内存\n在多线程环境中，如果所有线程都直接操作主内存中的共享变量，会引发更多的内存访问竞争，这不仅影响性能，还增加了线程安全问题的复杂度。通过让每个线程使用本地内存，可以减少对主内存的直接访问和竞争，从而提高程序的并发性能。\n现代 CPU 为了优化执行效率，可能会对指令进行乱序执行（指令重排序）。使用本地内存（CPU 缓存和寄存器）可以在不影响最终执行结果的前提下，使得 CPU 有更大的自由度来乱序执行指令，从而提高执行效率。\n内存可见性的保证 volatile 关键字 写入 volatile 变量时，JMM 会强制把值刷新到主存。 读取 volatile 变量时，JMM 会强制从主存获取最新值，而不是从缓存读取。 禁止指令重排序（确保 volatile 变量的读写顺序不会被 JVM 或 CPU 乱序执行）。 synchronized 关键字 进入 synchronized 方法或代码块时，线程必须从主存读取最新变量。 退出 synchronized 方法或代码块时，线程必须把修改的变量刷新回主存。 由于同一时间只有一个线程能进入 synchronized 代码块，它可以确保变量修改对所有线程可见。 顺序一致性的保证和happens-before规则 指令重排的限制条件 在单线程环境下不能改变程序运行的结果 存在数据依赖关系的不允许重排序。 happens-before规则的定义 如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。 主要规则 程序次序规则：在一个线程中，代码的执行顺序是按照程序中的书写顺序执行的，即一个线程内，前面的操作 happens-before 后面的操作。 监视器锁规则：一个锁的解锁（ unlock ）操作 happens-before 后续对这个锁的加锁（ lock ）操作。也就是说，在释放锁之前的所有修改在加锁后对其他线程可见。 volatile 变量规则：对一个 volatile 变量的写操作 happens-before 后续对这个 volatile 变量的读操作。它保证 volatile 变量的可见性，确保一个线程修改 volatile 变量后，其他线程能立即看到最新值。 线程启动规则：线程 A 执行 Thread.start() 操作后，线程 B 中的所有操作 happens-before 线程 A 的 Thread.start() 调用。 线程终止规则：线程 A 执行 Thread.join() 操作后，线程 B 中的所有操作 happens-before 线程 A 从 Thread.join() 返回。 线程中断规则：对线程的 interrupt() 调用 happens-before 线程检测到中断事件（通过 Thread.interrupted() 或 Thread.isInterrupted()）。 对象的构造规则：对象的构造完成（即构造函数执行完毕） happens-before 该对象的 finalize() 方法调用。 ","date":"2025-02-02T20:48:21+08:00","permalink":"https://Tyritic.github.io/p/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8Bjmm/","title":"Java内存模型（JMM）"},{"content":"传统的BIO模式（同步阻塞模式） 在计算机网络中，BIO (Blocking I/O) 是一种同步的 I/O 模型。它的工作原理是：在 BIO 模式下，服务器为每个客户端连接创建一个独立的线程，每个线程负责处理一个I/O操作。线程在进行I/O操作时，如果数据未准备好，会阻塞，直到操作完成后才继续。\n例如，在Java中，使用ServerSocket和Socket进行网络通信时，accept()、read()、write()等操作都是阻塞的，直到请求或数据到来。 它通常用于基于传统 TCP/IP 协议的客户端和服务器通信。\nBIO模式的特点 阻塞模式：在进行读取或写入操作时，线程会被阻塞，直到数据准备好或操作完成。对于每个客户端请求，都会分配一个线程来处理，直到请求完成后，线程才会释放。 简单易用：因为阻塞 I/O 模型非常直观，它不需要复杂的线程管理或事件驱动机制，对于小型应用或简单的服务器来说，BIO 是一个相对简洁的选择。 性能瓶颈：由于每个连接都需要单独的线程进行处理，BIO 会消耗更多的系统资源，并且当连接数增加时，会导致性能下降。特别是在并发量很大的情况下，BIO 的效率就变得较低。 适用于低并发的应用场景：BIO 最适合用在连接数较少且并发请求量不大的应用中，比如传统的客户端-服务器模型，或者早期的网络服务。 BIO 的缺点 线程资源浪费：每个连接都需要一个单独的线程，线程管理和上下文切换会导致系统资源浪费，尤其在连接数较多时，会对系统性能产生负面影响。 不适合高并发应用：对于高并发的场景，BIO 模型的性能会大幅下降，因为线程数过多时会导致线程切换和内存消耗过大，甚至可能导致服务器崩溃。 改进后的模式——NIO模式（同步非阻塞模式） NIO (New Input/Output) 是 Java 1.4 引入的一种非阻塞式 I/O 模型，它相较于传统的 BIO (Blocking I/O) 模型，提供了更高效的 I/O 操作，特别是在处理大量并发连接时。NIO 通过支持非阻塞 I/O 操作、缓冲区、选择器等机制，N基于I/O多路复用实现的，它可以只用一个线程处理多个客户端I/O，线程不会在执行读取或写入操作时被阻塞。线程可以在等待数据时继续做其他事情，当数据准备好时，NIO 会通过回调机制告知应用程序，显著提高了系统的性能，尤其适用于高并发的网络编程。\nNIO的特点 非阻塞 I/O：NIO 中的 I/O 操作是非阻塞的。也就是说，在进行读写操作时，线程不会被阻塞，线程可以继续处理其他任务，直到数据准备好。 双向读写：channel作为I/O 操作的数据流通道，可以用于读写数据。 线程的多路复用：选择器（Selector） 使得一个线程可以同时监控多个通道，检测哪些通道可以进行 I/O 操作。允许一个线程在多个通道之间进行多路复用。 缓冲机制：NIO 中的所有数据读写操作都通过 缓冲区（Buffer） 来完成。缓冲区是一个在内存中临时存储数据的区域 NIO 的主要组成部分 选择器（Selector）： 选择器是 NIO 的核心组件之一，它允许单个线程同时监控多个 I/O 通道，检测哪些通道准备好进行读写操作。 通过选择器，NIO 可以避免为每个连接创建一个线程，而是利用单个线程同时处理多个连接，提高了并发处理能力。 缓冲区（Buffer）： 在 NIO 中，数据读写通过 缓冲区（Buffer）进行操作。缓冲区是一个内存区域，它用于在数据与通道（Channel）之间传递数据。 数据总是从通道读到缓冲区，或者从缓冲区写到通道。缓冲区是 NIO 中的一个重要概念，类似于传统 I/O 的字节流和字符流。 通道（Channel）： 通道是 NIO 中与数据源或数据目的地之间的连接通道，用于读取或写入数据。Channel 与传统的流不同，它是双向的，即既可以读，也可以写。 NIO 提供了多个具体的通道类，如 FileChannel（文件通道）、SocketChannel（套接字通道）和 ServerSocketChannel（服务器套接字通道）。 内存映射文件（Memory-mapped Files）： NIO 支持内存映射文件，可以通过 MappedByteBuffer 来将文件的部分或整个内容映射到内存中，允许程序像访问数组一样操作文件内容，提升了文件操作的效率。 SelectionKey： SelectionKey 是选择器与通道之间的桥梁，它表示通道在选择器上的注册状态，并且它指示通道准备好进行的操作（如读、写、连接等）。 NIO的工作流程 创建通道并设置为非阻塞模式：在 NIO 中，所有的数据读取和写入操作都是通过 通道（Channel） 完成的。通道是一个连接 I/O 设备（如文件、网络套接字等）的双向数据传输通道。 将通道注册到选择器（Selector）：通道需要注册到 选择器（Selector） 上。选择器是一个核心组件，它允许单个线程监控多个通道的 I/O 状态。 轮询选择器（Selector）：在应用程序中，调用选择器的 select() 方法来阻塞并等待事件的发生。当至少一个通道准备好进行指定的 I/O 操作时，选择器会返回并且唤醒线程。 处理就绪的通道：一旦选择器检测到某些通道已经准备好进行 I/O 操作，就会返回这些通道的集合。 处理IO操作：在通道准备好后，应用程序通过 ByteBuffer 来读取或写入数据。 继续轮询并处理其他通道的 I/O 事件 关闭通道与选择器 核心组件 Channel接口 是双向的，可以同时支持读取和写入（读/写），与传统的I/O流相比更灵活。传统的流只能单向，要么是输入流要么是输出流。 常用于非阻塞I/O操作，可以结合Selector来实现多路复用，从而处理多个并发连接。 种类\nSocketChannel：用于基于TCP的网络通信，可以与服务器或客户端进行连接。 ServerSocketChannel：用于监听TCP连接，类似于传统I/O中的ServerSocket。 DatagramChannel：用于基于UDP的网络通信。 FileChannel：用于从文件中读取或向文件中写入数据。 常用方法\nSelectionKey register(Selector sel, int ops) throws ClosedChannelException sel：选择器对象，通道将会注册到该选择器上。 ops：感兴趣的操作，可以是 SelectionKey.OP_READ、SelectionKey.OP_WRITE、SelectionKey.OP_CONNECT 等。 返回值：返回一个 SelectionKey，表示通道在选择器中的状态。 创建对象 public static FileChannel open(Path path, OpenOption... options) throws IOException; path: 要操作的文件路径，类型为 Path。 options: 文件打开选项，例如 StandardOpenOption.READ、StandardOpenOption.WRITE 等，可以传入多个选项。 public static SocketChannel open() throws IOException; public static ServerSocketChannel open() throws IOException; public static DatagramChannel open() throws IOException; 读取数据 int read(ByteBuffer dst) throws IOException; Selector类 Selector 是Java NIO（New I/O）中用于实现I/O多路复用的组件，它可以通过一个单独的线程同时监视多个通道（Channel）的事件。\nSelector的作用：\n管理多个Channel：通过一个Selector实例，程序可以同时监听多个通道的I/O事件（如可读、可写、连接就绪等），从而使一个线程管理多个连接变得高效。 非阻塞I/O：Selector通常与非阻塞通道（如SocketChannel）配合使用，实现高效的非阻塞I/O操作。它使得程序无需为每个连接创建一个线程，减少了线程的开销。 Selector的事件类型：\nOP_READ：表示通道中有数据可读。 OP_WRITE：表示通道可以向其中写入数据。 OP_CONNECT：表示通道完成连接操作。 OP_ACCEPT：表示通道可以接受新的连接 Selector的常见方法\nint selectNow()：不论是否有无事件发生，立即返回 int select(long timeout)：至多阻塞 timeout 时间（或被唤醒），如果提早有事件发生，提早返回 int select()：一直阻塞着，直到有事件发生（或被唤醒） 返回值就是就绪的通道数，一般判断大于 0 即可进行后续的操作。\n","date":"2025-01-20T15:22:04+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84bionioaio/","title":"Java的BIO,NIO,AIO"},{"content":"什么是注解 注解（Annotation） 是一种元数据，它为代码提供了附加的信息，注解本身不直接影响代码的逻辑执行，但可以通过工具、编译器或运行时反射等机制对代码进行处理。\n注解的定义方式 1 2 3 4 public @interface MyAnnotation { String value() default \u0026#34;default value\u0026#34;; // 带有默认值的元素 int number(); // 没有默认值的元素 } 注解的目标对象 ElementType.TYPE：类、接口（包括注解类型）或枚举。 ElementType.FIELD：字段（包括枚举常量）。 ElementType.METHOD：方法。 ElementType.PARAMETER：方法参数。 ElementType.CONSTRUCTOR：构造方法。 ElementType.LOCAL_VARIABLE：局部变量。 ElementType.ANNOTATION_TYPE：注解类型。 ElementType.PACKAGE：包。 定义在 ElementType 枚举中，使用元注解@Target指定目标对象\n注解的生命周期 RetentionPolicy.SOURCE：注解仅在源码中存在，编译时被丢弃。 RetentionPolicy.CLASS：注解存在于编译后的 .class 文件中，但运行时不可用。 RetentionPolicy.RUNTIME：注解在运行时可用，可以通过反射机制访问。 定义在 RetentionPolicy 枚举中，使用元注解@Retention指定生命周期\n示例 1 2 3 4 5 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface JsonField { public String value() default \u0026#34;\u0026#34;; } JsonField 注解的生命周期是 RUNTIME，也就是运行时有效。 JsonField 注解装饰的目标是 FIELD，也就是针对字段的。 创建注解需要用到 @interface 关键字。 JsonField 注解有一个参数，名字为 value，类型为 String，默认值为一个空字符串。 ","date":"2025-01-20T09:40:41+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86/","title":"Java的注解原理"},{"content":"动态代理的定义 动态代理（Dynamic Proxy） 是 Java 提供的一种机制，它允许在运行时创建实现指定接口的代理类，而不需要在编译时编写实现类。\n动态代理主要用途 简化代码：通过代理模式，可以减少重复代码，尤其是在横切关注点（如日志记录、事务管理、权限控制等）方面。 增强灵活性：动态代理使得代码更具灵活性和可扩展性，因为代理对象是在运行时生成的，可以动态地改变行为。 实现 AOP：动态代理是实现面向切面编程（AOP, Aspect-Oriented Programming）的基础，可以在方法调用前后插入额外的逻辑 动态代理的工作原理 接口与代理： 代理类并不是通过继承或实现接口来定义的，而是通过 Proxy 类在运行时动态创建。代理类会在运行时被创建，并会实现与原接口相同的方法。 InvocationHandler 接口： 这个接口是动态代理的核心，它定义了 invoke() 方法，当代理对象调用任何方法时，都会触发 invoke() 方法，从而可以在其中执行增强逻辑。 Proxy.newProxyInstance() 方法： 这是 Java 提供的用于创建动态代理实例的工具方法。通过这个方法，可以创建实现指定接口的代理对象，并指定一个 InvocationHandler 来处理方法的调用。 动态代理的实现步骤 定义接口： 被代理对象必须实现一个接口。 处理器类实现 InvocationHandler 接口： 通过 InvocationHandler 接口来定义代理类的逻辑，重写invoke方法实现对方法的拦截。 Object proxy：代理对象 Method method：调用的方法 Object[] args：传递的实参 主类使用 Proxy.newProxyInstance() 创建代理对象： 通过 Proxy 类的 newProxyInstance() 方法创建代理对象。 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // 定义接口 public interface UserService { void addUser(String name); void deleteUser(String name); } // 实现接口 public class UserServiceImpl implements UserService { @Override public void addUser(String name) { System.out.println(\u0026#34;Adding user: \u0026#34; + name); } @Override public void deleteUser(String name) { System.out.println(\u0026#34;Deleting user: \u0026#34; + name); } } // 处理器实现InvocationHandler接口 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class LoggingHandler implements InvocationHandler { private final Object target; public LoggingHandler(Object target) { this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 在方法执行前添加日志 System.out.println(\u0026#34;Method \u0026#34; + method.getName() + \u0026#34; is called with arguments: \u0026#34; + args[0]); // 调用真实对象的方法 Object result = method.invoke(target, args); // 在方法执行后添加日志 System.out.println(\u0026#34;Method \u0026#34; + method.getName() + \u0026#34; execution completed.\u0026#34;); return result; } } // 创建代理对象 import java.lang.reflect.Proxy; public class ProxyExample { public static void main(String[] args) { UserService userService = new UserServiceImpl(); // 创建动态代理对象 UserService proxy = (UserService) Proxy.newProxyInstance( userService.getClass().getClassLoader(), userService.getClass().getInterfaces(), new LoggingHandler(userService) ); // 使用代理对象 proxy.addUser(\u0026#34;Alice\u0026#34;); proxy.deleteUser(\u0026#34;Bob\u0026#34;); } } ","date":"2025-01-19T20:10:12+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","title":"Java的动态代理"},{"content":"反射机制的定义 Java的反射机制是一种强大的特性，它允许在运行时动态地查询和操作类、方法、构造器、字段等信息，甚至可以在运行时创建对象、修改字段和调用方法。反射机制使得 Java 程序具备了更高的灵活性，可以编写更加通用和扩展性强的代码。\n反射机制的特性 运行时类信息访问：反射机制允许程序在运行时获取类的完整结构信息，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。 动态对象创建：可以使用反射API动态地创建对象实例，即使在编译时不知道具体的类名。这是通过Class类的newInstance()方法或Constructor对象的newInstance()方法实现的。 动态方法调用：可以在运行时动态地调用对象的方法，包括私有方法。这通过Method类的invoke()方法实现，允许你传入对象实例和参数值来执行方法。 访问和修改字段值：反射还允许程序在运行时访问和修改对象的字段值，即使是私有的。这是通过Field类的get()和set()方法完成的。 反射的核心类 Class 类：Class 类是反射的核心，它表示一个类或接口的元数据。通过 Class 类，可以获取类的构造器、方法、字段等信息。 Constructor 类：表示类的构造器，可以通过反射动态创建对象。 Method 类：表示类的方法，可以调用指定的实例方法。 Field 类：表示类的字段（成员变量），可以访问和修改字段的值。 Modifier 类：用于解析和获取类、方法、字段等的访问修饰符。 反射的常见操作 类对象（class） 获取类的class的对象 Class.forName(\u0026quot;全类名\u0026quot;)：对应于Java的源代码阶段 类名.class：对应于加载阶段（将字节码文件加入到内存中） 对象.getClass()：对应于运行阶段 上述三个方法获取的class的对象是同一个对象\n获取类的构造器（Constructor） getConstructor(Class\u0026lt;?\u0026gt;... parameterTypes)：获取类的公共构造器，构造器的参数类型必须与传入的类型匹配。\n如果构造器不存在，会抛出 NoSuchMethodException。\n1 2 3 Class\u0026lt;?\u0026gt; clazz = Person.class; Constructor\u0026lt;?\u0026gt; constructor = clazz.getConstructor(String.class, int.class); // 传入构造器参数类型 Person person = (Person) constructor.newInstance(\u0026#34;John\u0026#34;, 25); getDeclaredConstructor(Class\u0026lt;?\u0026gt;... parameterTypes)：获取类的所有构造器（包括私有构造器、受保护的构造器等），与 getConstructor 方法不同，getDeclaredConstructor 会返回类的所有构造器，而不仅限于公共构造器。\n1 2 3 Constructor\u0026lt;?\u0026gt; constructor = clazz.getDeclaredConstructor(String.class, int.class); // 获取指定参数类型的构造器 constructor.setAccessible(true); // 如果是私有构造器，需要解除访问权限 Person person = (Person) constructor.newInstance(\u0026#34;Alice\u0026#34;, 30); getConstructors()：获取类的所有公共构造器，返回一个 Constructor 数组，包含该类及其父类的所有公共构造器。\n1 2 3 4 Constructor\u0026lt;?\u0026gt;[] constructors = clazz.getConstructors(); for (Constructor\u0026lt;?\u0026gt; constructor : constructors) { System.out.println(constructor.getName()); } getDeclaredConstructors()：获取类的所有构造器（包括私有构造器、受保护的构造器等），返回一个 Constructor 数组，包含该类的所有构造器（不包括父类的构造器）。\n1 2 3 4 Constructor\u0026lt;?\u0026gt;[] declaredConstructors = clazz.getDeclaredConstructors(); for (Constructor\u0026lt;?\u0026gt; constructor : declaredConstructors) { System.out.println(constructor.getName()); } 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 import java.lang.reflect.*; class Person { private String name; private int age; // 公共构造器 public Person(String name, int age) { this.name = name; this.age = age; } // 默认构造器 public Person() {} // 私有构造器 private Person(String name) { this.name = name; } public void display() { System.out.println(\u0026#34;Name: \u0026#34; + name + \u0026#34;, Age: \u0026#34; + age); } } public class ConstructorDemo { public static void main(String[] args) throws Exception { Class\u0026lt;?\u0026gt; clazz = Person.class; // 1. 获取公共构造器 (带有参数) Constructor\u0026lt;?\u0026gt; constructor1 = clazz.getConstructor(String.class, int.class); Person person1 = (Person) constructor1.newInstance(\u0026#34;John\u0026#34;, 25); person1.display(); // 2. 获取默认构造器 Constructor\u0026lt;?\u0026gt; constructor2 = clazz.getConstructor(); Person person2 = (Person) constructor2.newInstance(); person2.display(); // 3. 获取私有构造器 Constructor\u0026lt;?\u0026gt; constructor3 = clazz.getDeclaredConstructor(String.class); constructor3.setAccessible(true); // 解除访问限制 Person person3 = (Person) constructor3.newInstance(\u0026#34;Alice\u0026#34;); person3.display(); // 4. 获取所有公共构造器 Constructor\u0026lt;?\u0026gt;[] constructors = clazz.getConstructors(); System.out.println(\u0026#34;Public constructors:\u0026#34;); for (Constructor\u0026lt;?\u0026gt; constructor : constructors) { System.out.println(constructor.getName()); } // 5. 获取所有构造器（包括私有的） Constructor\u0026lt;?\u0026gt;[] declaredConstructors = clazz.getDeclaredConstructors(); System.out.println(\u0026#34;Declared constructors:\u0026#34;); for (Constructor\u0026lt;?\u0026gt; constructor : declaredConstructors) { System.out.println(constructor.getName()); } } } // 输出 // Name: John, Age: 25 // Name: null, Age: 0 // Name: Alice, Age: 0 // Public constructors: // Person // Person // Declared constructors: // Person // Person // Person 获取类的方法（Method） getMethod(String name, Class\u0026lt;?\u0026gt;... parameterTypes) 获取类的公共方法，包括继承自父类的公共方法。 如果指定的方法不存在，会抛出 NoSuchMethodException。 该方法的第一个参数是方法名，后续参数是方法的参数类型（可以是空参数）。 getDeclaredMethod(String name, Class\u0026lt;?\u0026gt;... parameterTypes) 获取类的所有方法（包括私有方法和受保护的方法）。 如果指定的方法不存在，会抛出 NoSuchMethodException。 getMethods() 返回类的所有公共方法（包括继承自父类的公共方法）。 返回的是一个 Method 数组，包含该类的所有公共方法。 getDeclaredMethods() 返回类的所有方法（包括私有方法、受保护的方法和公共方法），但不包括从父类继承的方法。 返回的是一个 Method 数组，包含该类的所有方法。 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import java.lang.reflect.*; class Person { private String name; private int age; // 公共构造器 public Person(String name, int age) { this.name = name; this.age = age; } // 公共方法 public void display() { System.out.println(\u0026#34;Name: \u0026#34; + name + \u0026#34;, Age: \u0026#34; + age); } // 私有方法 private void privateMethod() { System.out.println(\u0026#34;This is a private method.\u0026#34;); } // 受保护的方法 protected void protectedMethod() { System.out.println(\u0026#34;This is a protected method.\u0026#34;); } } public class MethodDemo { public static void main(String[] args) throws Exception { // 创建对象实例 Person person = new Person(\u0026#34;John\u0026#34;, 25); // 1. 获取公共方法 Class\u0026lt;?\u0026gt; clazz = person.getClass(); Method method1 = clazz.getMethod(\u0026#34;display\u0026#34;); // 获取公共方法 method1.invoke(person); // 调用方法 // 2. 获取私有方法 Method method2 = clazz.getDeclaredMethod(\u0026#34;privateMethod\u0026#34;); // 获取私有方法 method2.setAccessible(true); // 解除访问限制 method2.invoke(person); // 调用私有方法 // 3. 获取受保护的方法 Method method3 = clazz.getDeclaredMethod(\u0026#34;protectedMethod\u0026#34;); // 获取受保护的方法 method3.setAccessible(true); // 解除访问限制 method3.invoke(person); // 调用受保护的方法 // 4. 获取所有方法（包括私有、受保护方法） Method[] declaredMethods = clazz.getDeclaredMethods(); // 获取所有方法 System.out.println(\u0026#34;Declared methods:\u0026#34;); for (Method method : declaredMethods) { System.out.println(method.getName()); } } } // 输出结果： // Name: John, Age: 25 // This is a private method. // This is a protected method. // Declared methods: // display // privateMethod // protectedMethod 获取类的字段（Field） getField(String name) 获取类的公共字段，包括继承自父类的公共字段。 如果指定的字段不存在，会抛出 NoSuchFieldException。 只能获取公共字段。 getDeclaredField(String name) 获取类的所有字段（包括私有字段、受保护字段和公共字段）。 如果指定的字段不存在，会抛出 NoSuchFieldException。 getFields() 获取类的所有公共字段（包括继承自父类的公共字段）。 返回一个 Field 数组，包含该类的所有公共字段。 getDeclaredFields() 获取类的所有字段（包括私有、受保护和公共字段），但不包括从父类继承的字段。 返回一个 Field 数组，包含该类的所有字段。 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 import java.lang.reflect.*; class Person { public String name; private int age; protected String gender; // 公共构造器 public Person(String name, int age, String gender) { this.name = name; this.age = age; this.gender = gender; } } public class FieldDemo { public static void main(String[] args) throws Exception { // 创建对象实例 Person person = new Person(\u0026#34;John\u0026#34;, 25, \u0026#34;Male\u0026#34;); // 1. 获取公共字段 Class\u0026lt;?\u0026gt; clazz = person.getClass(); Field field1 = clazz.getField(\u0026#34;name\u0026#34;); // 获取公共字段 System.out.println(\u0026#34;Public field \u0026#39;name\u0026#39;: \u0026#34; + field1.get(person)); // 获取字段值 // 2. 获取私有字段 Field field2 = clazz.getDeclaredField(\u0026#34;age\u0026#34;); // 获取私有字段 field2.setAccessible(true); // 解除访问限制 System.out.println(\u0026#34;Private field \u0026#39;age\u0026#39;: \u0026#34; + field2.get(person)); // 获取字段值 // 3. 获取受保护的字段 Field field3 = clazz.getDeclaredField(\u0026#34;gender\u0026#34;); // 获取受保护字段 field3.setAccessible(true); // 解除访问限制 System.out.println(\u0026#34;Protected field \u0026#39;gender\u0026#39;: \u0026#34; + field3.get(person)); // 获取字段值 // 4. 获取所有公共字段（包括从父类继承的公共字段） Field[] fields = clazz.getFields(); // 获取所有公共字段 System.out.println(\u0026#34;Public fields:\u0026#34;); for (Field field : fields) { System.out.println(field.getName()); } // 5. 获取所有字段（包括私有、受保护和公共字段） Field[] declaredFields = clazz.getDeclaredFields(); // 获取所有字段 System.out.println(\u0026#34;Declared fields:\u0026#34;); for (Field field : declaredFields) { System.out.println(field.getName()); } } } // 输出： // Public field \u0026#39;name\u0026#39;: John // Private field \u0026#39;age\u0026#39;: 25 // Protected field \u0026#39;gender\u0026#39;: Male // Public fields: // name // Declared fields: // name // age // gender 字段（Field） 访问对象字段属性 获取对象的 Field 对象。 通过 Field 对象访问或修改字段的值。 对于 private、protected 或默认访问级别的字段，使用 setAccessible(true) 解除访问限制。 获取字段：public Object get(Object obj) throws IllegalAccessException 获取对象中某个字段的值。\n获取字段名：public String getName()\n获取字段的数据类型：public Class\u0026lt;?\u0026gt; getType()\n获取访问修饰符：public int getModifiers() 如果多个修饰符一起使用，它们的整数值是通过位 OR 运算得出的\npublic：1 private：2 protected：4 static：8 final：16 获取访问修饰符的字符串表示：Modifier.toString(int modifiers)\n修改访问性：setAccessible(Boolean T)\n示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import java.lang.reflect.Field; import java.lang.reflect.Modifier; class Person { public String name; // 公共字段 private int age; // 私有字段 protected String gender; // 受保护字段 static String country; // 静态字段 // 公共构造器 public Person(String name, int age, String gender) { this.name = name; this.age = age; this.gender = gender; } } public class FieldInfoDemo { public static void main(String[] args) throws Exception { // 创建一个 Person 对象 Person person = new Person(\u0026#34;John Doe\u0026#34;, 30, \u0026#34;Male\u0026#34;); // 获取 Person 类的 Class 对象 Class\u0026lt;?\u0026gt; clazz = person.getClass(); // 获取所有字段，包括私有、受保护和公共字段 Field[] fields = clazz.getDeclaredFields(); // 遍历所有字段 for (Field field : fields) { // 获取字段名 String fieldName = field.getName(); // 获取字段的修饰符 int modifiers = field.getModifiers(); // 获取修饰符的字符串表示 String modifierString = Modifier.toString(modifiers); // 获取字段的值 // 使用 setAccessible(true) 来允许访问私有字段 field.setAccessible(true); Object fieldValue = field.get(person); // 输出字段信息 System.out.println(\u0026#34;Field: \u0026#34; + fieldName + \u0026#34;, Modifier: \u0026#34; + modifierString + \u0026#34;, Value: \u0026#34; + fieldValue); } } } // 输出： // Field: name, Modifier: public, Value: John Doe // Field: age, Modifier: private, Value: 30 // Field: gender, Modifier: protected, Value: Male // Field: country, Modifier: static, Value: null 修改对象字段 修改字段：public void set(Object obj, Object value) throws IllegalAccessException, IllegalArgumentException 修改对象中某个字段的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import java.lang.reflect.Field; class Person { public String name; // 公共字段 private int age; // 私有字段 protected String gender; // 受保护字段 static String country; // 静态字段 // 公共构造器 public Person(String name, int age, String gender) { this.name = name; this.age = age; this.gender = gender; } } public class ModifyFieldDemo { public static void main(String[] args) throws Exception { // 创建一个 Person 对象 Person person = new Person(\u0026#34;John Doe\u0026#34;, 30, \u0026#34;Male\u0026#34;); // 获取 Person 类的 Class 对象 Class\u0026lt;?\u0026gt; clazz = person.getClass(); // 获取所有字段，包括私有、受保护和公共字段 Field[] fields = clazz.getDeclaredFields(); // 遍历所有字段 for (Field field : fields) { // 获取字段名 String fieldName = field.getName(); // 获取字段的修饰符 int modifiers = field.getModifiers(); String modifierString = java.lang.reflect.Modifier.toString(modifiers); // 输出字段信息 System.out.println(\u0026#34;Field: \u0026#34; + fieldName + \u0026#34;, Modifier: \u0026#34; + modifierString + \u0026#34;, Original Value: \u0026#34; + field.get(person)); // 修改字段的值 field.setAccessible(true); // 设置字段为可访问 if (field.getType() == String.class) { // 如果是 String 类型，修改字段值 field.set(person, \u0026#34;Jane Doe\u0026#34;); } else if (field.getType() == int.class) { // 如果是 int 类型，修改字段值 field.set(person, 35); } // 输出修改后的字段值 System.out.println(\u0026#34;Modified Field: \u0026#34; + fieldName + \u0026#34;, New Value: \u0026#34; + field.get(person)); } } } 方法（Method） 访问对象方法属性 获取方法名：public String getName()\n获取方法的返回值类型：public Class\u0026lt;?\u0026gt; getReturnType()\n获取访问修饰符：public int getModifiers() 如果多个修饰符一起使用，它们的整数值是通过位 OR 运算得出的\npublic：1 private：2 protected：4 static：8 final：16 获取访问修饰符的字符串表示：Modifier.toString(int modifiers)\n获取方法的形参类型： Class\u0026lt;?\u0026gt;[] getParameterTypes()\n获取方法的形参数组：public Parameter[] getParameters()\ngetName()：获取参数名称。 getType()：获取参数的类型。 修改访问性：setAccessible(Boolean T)\n示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import java.lang.reflect.Method; import java.lang.reflect.Parameter; class Person { public String greet(String name, int age) { return \u0026#34;Hello, \u0026#34; + name + \u0026#34;. You are \u0026#34; + age + \u0026#34; years old.\u0026#34;; } public void display() { System.out.println(\u0026#34;This is a display method.\u0026#34;); } } public class ReflectDemo { public static void main(String[] args) throws Exception { // 获取 Person 类的 Class 对象 Class\u0026lt;?\u0026gt; clazz = Person.class; // 获取 greet 方法 Method greetMethod = clazz.getMethod(\u0026#34;greet\u0026#34;, String.class, int.class); // 获取方法的参数信息 Parameter[] parameters = greetMethod.getParameters(); // 输出参数的详细信息 System.out.println(\u0026#34;Method: \u0026#34; + greetMethod.getName()); for (Parameter param : parameters) { System.out.println(\u0026#34;Parameter name: \u0026#34; + param.getName()); System.out.println(\u0026#34;Parameter type: \u0026#34; + param.getType().getName()); } } } // 输出： // Method: greet // Parameter name: name // Parameter type: java.lang.String // Parameter name: age // Parameter type: int 调用对象方法 public Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException\nobj:\n类型：Object 说明：调用方法的目标对象。对于实例方法，它是目标对象实例；对于静态方法，这个参数可以是 null（尽管最好传递 null）。 args:\n类型：Object... 说明：方法的实际参数（如果有）。这个参数是一个可变参数，表示调用方法时传入的参数值。如果方法没有参数，args 可以是空数组或者不传递任何值。 Object: 返回调用方法的结果。如果方法是 void，则返回 null。\n示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class Person { private String name; public Person(String name) { this.name = name; } // 有返回值的方法 public String greet(String greeting) { return greeting + \u0026#34;, \u0026#34; + name; } // 无返回值的方法 public void display() { System.out.println(\u0026#34;Hello, \u0026#34; + name); } } import java.lang.reflect.Method; public class ReflectDemo { public static void main(String[] args) throws Exception { // 创建 Person 对象 Person person = new Person(\u0026#34;Alice\u0026#34;); // 获取 Person 类的 Class 对象 Class\u0026lt;?\u0026gt; clazz = person.getClass(); // 获取 greet 方法（具有一个 String 参数） Method greetMethod = clazz.getMethod(\u0026#34;greet\u0026#34;, String.class); // 调用 greet 方法，传递参数 \u0026#34;Hello\u0026#34; String result = (String) greetMethod.invoke(person, \u0026#34;Hello\u0026#34;); System.out.println(\u0026#34;Result from greet method: \u0026#34; + result); // 获取 display 方法（没有参数） Method displayMethod = clazz.getMethod(\u0026#34;display\u0026#34;); // 调用 display 方法 displayMethod.invoke(person); } } // 输出： // Result from greet method: Hello, Alice // Hello, Alice 对象 创建对象 通过反射得到的构造器创建对象（ Constructor）\n1 2 Constructor\u0026lt;MyClass\u0026gt; constructor = MyClass.class.getConstructor(); MyClass obj = constructor.newInstance(); 通过类的字节码（Class）来创建对象\n1 MyClass obj = (MyClass) Class.forName(\u0026#34;com.example.MyClass\u0026#34;).newInstance(); 反射的使用场景 Spring 框架的 IOC（动态加载管理 Bean），Spring通过配置文件配置各种各样的bean，你需要用到哪些bean就配哪些，spring容器就会根据你的需求去动态加载，你的程序就能健壮地运行。\nSpring通过XML配置模式装载Bean的过程：\n将程序中所有XML或properties配置文件加载入内存 Java类里面解析xml或者properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息 使用反射机制，根据这个字符串获得某个类的Class实例 动态配置实例的属性 ","date":"2025-01-17T09:15:30+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/","title":"Java的反射机制"},{"content":"Optional类的定义 Optional 类是 Java 8 引入的一个容器类，用来解决可能出现的 NullPointerException 问题。它表示一个值可能存在也可能不存在，提供了一种优雅的方式来避免显式的 null 检查。\n核心思想 避免显式使用 null： 使用 Optional 代替直接返回 null，从而避免潜在的空指针异常。 增强代码可读性： 提供清晰的 API，表示值的存在或缺失，并能安全处理缺失的值。 函数式编程支持： 支持链式调用和流式操作，更适合在函数式编程中使用 创建对象方法 Optional.empty()：创建一个空的 Optional 对象。 1 Optional\u0026lt;String\u0026gt; emptyOpt = Optional.empty(); Optional.of(value)：根据非空值创建一个 Optional 对象。 1 Optional\u0026lt;String\u0026gt; nameOpt = Optional.of(\u0026#34;John\u0026#34;); 注意：传入 null 值会抛出 NullPointerException。\nOptional.ofNullable(value)：根据值创建 Optional，值可以是 null。 1 Optional\u0026lt;String\u0026gt; nullableOpt = Optional.ofNullable(null); 判断值是否存在 isPresent()：值存在返回 true，否则返回 false。 isEmpty()：值不存在返回 true（Java 11 引入）。 获取值 get()：返回值，如果值不存在会抛出 NoSuchElementException。\n1 String name = nameOpt.get(); orElse(defaultValue)：值存在则返回值，否则返回默认值。\n1 String name = nullableOpt.orElse(\u0026#34;Default Name\u0026#34;); 操作值 ifPresent(Consumer\u0026lt;? super T\u0026gt;)：值存在时执行给定的动作。\nmap(Function\u0026lt;? super T, ? extends U\u0026gt;)：值存在时对值进行映射操作。\n","date":"2025-01-16T20:56:03+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84optional%E7%B1%BB/","title":"Java中的Optional类"},{"content":"回答重点 主要是为了节省内存空间，提高内存利用率。\n在 JDK 9 之前，String 类是基于 char[] 实现的，内部采用 UTF-16 编码，每个字符占用两个字节。但是，如果当前的字符仅需一个字节的空间，这就造成了浪费。例如一些 Latin-1 字符用一个字节即可表示。\n因此 JDK 9 做了优化采用 byte[] 数组来实现，ASCII 字符串（单字节字符）通过 byte[] 存储，仅需 1 字节，减小了内存占用。\n并引入了 coder 变量来标识编码方式（Latin-1 或 UTF-16）。如果字符串中只包含 Latin-1 范围内的字符（如 ASCII），则使用单字节编码，否则使用 UTF-16。这种机制在保持兼容性的同时，又减少了内存占用。\n","date":"2025-01-14T22:32:10+08:00","permalink":"https://Tyritic.github.io/p/jdk9%E4%B8%AD%E5%B0%86string%E7%B1%BB%E5%BA%95%E5%B1%82%E7%9A%84char%E6%95%B0%E7%BB%84%E6%94%B9%E6%88%90byte%E6%95%B0%E7%BB%84/","title":"JDK9中将String类底层的char数组改成byte数组"},{"content":"回答重点 概念辨析 面向对象编程(Object Oriented Programming，OOP)是一种对象为中心的编程范式或者说编程风格。把类或对象作为基本单元来组织代码，并且运用提炼出的：封装、继承和多态来作为代码设计指导。\n面向过程编程是一种以过程或函数为中心的编程范式或者说编程风格，以过程作为基本单元来组织代码。过程其实就是动作，对应到代码中来就是函数，面向过程中函数和数据是分离的，数据就是成员变量。\n总结来看：面向对象编程注重对象之间的交互和模块化设计，而面向过程编程注重逻辑的分步实现。\n主要区别 数据与行为的关系：\n面向对象：数据和行为封装在对象内部，数据操作由对象方法进行管理。 面向过程：数据和函数是分离的，函数对数据进行操作。 3）可扩展性和复用性：\n面向对象：通过继承、接口、多态等机制支持代码的高复用性和扩展性。 面向过程：复用性较低，扩展需要修改已有代码，影响整体稳定性。 优缺点 面向对象的优缺点：\n优点：高复用性、扩展性、维护性强，适合复杂系统的开发。 缺点：开发和理解成本较高，对于简单项目可能显得繁琐。 面向过程的优缺点：\n优点：开发简单，代码执行速度快，适合小型项目。 缺点：可维护性差，代码复用性低，扩展性差。 ","date":"2025-01-14T10:59:01+08:00","permalink":"https://Tyritic.github.io/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/","title":"面向对象编程和面向过程编程的区别"},{"content":"回答重点 BigDecimal 能够保证精度，是因为它使用了任意精度的整数表示法，而不是浮动的二进制表示。\nBigDecimal 内部使用两个字段存储数字，一个是整数部分 intVal，另一个是用来表示小数点的位置 scale，避免了浮点数转化过程中可能的精度丢失。\n计算时通过整数计算，再结合小数点位置和设置的精度与舍入行为，控制结果精度，避免了由默认浮点数舍入导致的误差。\n1 2 3 4 5 6 7 8 9 10 public class BigDecimal extends Number implements Comparable\u0026lt;BigDecimal\u0026gt; { private final BigInteger intVal; // 存储整数部分 private final int scale; // 存储小数点的位置 public BigDecimal(String val) { // 使用 BigInteger 来表示数值 intVal = new BigInteger(val.replace(\u0026#34;.\u0026#34;, \u0026#34;\u0026#34;)); scale = val.contains(\u0026#34;.\u0026#34;) ? val.length() - val.indexOf(\u0026#34;.\u0026#34;) - 1 : 0; } } ","date":"2025-01-14T10:19:12+08:00","permalink":"https://Tyritic.github.io/p/bigdecimal%E4%BF%9D%E8%AF%81%E7%B2%BE%E5%BA%A6%E4%B8%8D%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%9C%BA%E5%88%B6/","title":"BigDecimal保证精度不丢失的机制"},{"content":"回答重点： 基本类型：Java 中有 8 种基本数据类型（int、long、float、double、char、byte、boolean、short），它们是直接存储数值的变量，位于栈上（局部变量在栈上、成员变量在堆上、静态（类）字段在方法区），性能较高，且不支持 null。\n包装类型：每个基本类型都有一个对应的包装类型（Integer、Long、Float、Double、Character、Byte、Boolean、Short）。包装类型是类，存储在堆中，可以用于面向对象编程，并且支持 null。\n区别总结： 1）性能区别：\n基本类型：占用内存小，效率高，适合频繁使用的简单操作。 包装类型：因为是对象，涉及内存分配和垃圾回收，性能相对较低。 2）比较方式不同：\n基本类型：比较用 ==，直接比较数值。 包装类型：比较时，== 比较的是对象的内存地址，而 equals() 比较的是对象的值。 3）默认值不同：\n基本类型：默认值是 0，false 等。 包装类型：默认为 null。 4）初始化的方式不同：\n基本类型：直接赋值。 包装类型：需要采用 new 的方式创建。 5）存储方式不同：\n基本类型：如果是局部变量则保存在栈上面，如果是成员变量则在堆中。 包装类型：保存在堆上（成员变量，在不考虑 JIT 优化的栈上分配时，都是随着对象一起保存在堆上的） ","date":"2025-01-13T23:15:14+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E6%AF%94/","title":"Java中包装类和基本数据类型的对比"},{"content":"后端架构的发展过程 ","date":"2025-01-08T20:56:25+08:00","permalink":"https://Tyritic.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E6%89%B9%E5%A4%84%E7%90%86%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E4%B8%89%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","title":"分布式批处理计算平台（三）架构设计"},{"content":"批处理算法组件的设计动机 异常处理：大多数算法开发人员在程序开发过程中通常只关注程序的正常逻辑，而忽视了程序在运行过程中可能遇到的异常情况以及如何处理这些异常故障。 缺乏生命周期管理：缺乏提供生命周期管理接口，用户无法方便地查询程序的运行状态，也无法进行必要的生命周期管理操作，例如暂停、恢复或停止程序的执行。若在程序执行过程中发现逻辑错误或需要优先执行其他任务，用户只能通过终止进程的方式停止程序的执行。 批处理算法组件的模型结构 批处理算法组件是面向海量数据批处理场景的具有生命周期管理和检查点恢复机制的功能软件单元\n属性 属性是组件内部维护的数据成员，包含以下两种类型：组件启动配置属性、组件运行过程属性以及数据处理属性。\n组件启动配置属性 在组件启动时，外部环境将参数传递给组件，随后组件进入初始化阶段，利用这些参数为组件的启动配置属性进行赋值\nmode：组件运行模式 算法执行模式 （algorithm）：正常执行算法过程 数据清理模式（clean）：若组件的算法逻辑有误导致错误的数据输出或中间输出结果没有业务价值，则需要清理这些数据，减轻集群节点机器的磁盘资源压力。 restore：检查点标志位 1：组件在运行之前，会尝试读取本地的检查点文件，并从检查点处恢复执行 0：组件此次运行会重新开始处理所有数据 properties_url：数据处理参数的配置文件地址 组件运行过程属性 组件运行过程属性是用于记录组件的运行状态、运行进度等相关信息的属性集合\nstatus：组件当前的运行状态 初始化 （init） 运行中 （running） 暂停 （paused） 停止 （stop） 运行完成 （finished） 运行失败 （failed） now：当前处理的数据块序号。 total：数据块总数 progress：组件的运行进度，计算公式：$progress=now/total$。 start_at：组件的开始运行时间，组件初始化完毕后设置该属性。 pause_at：组件的运行暂停时间，该属性记录组件运行的最近一次暂停时间。 pause_duration：组件运行暂停的总时长，组件在运行时可以被多次暂停。 remain_time：组件运行的剩余时长 数据处理属性 数据处理属性是组件进行数据处理时需要使用的属性\n输入数据地址 输出结果地址 可选的算法模型动态参数 接口 接口定义了组件的各项行为\n生命周期管理 组件运行时会启动一个HTTP服务，并提供生命周期管理接口给外界控制和获取组件运行状态\ninfo ：获取组件运行状态，包括组件运行进度、运行状态等信息 pause：暂停组件运行 restart：恢复运行处于暂停状态的组件 stop：停止组件运行 数据处理 数据处理接口是组件读取、处理以及写入数据的接口集合\ngetConfig：获取数据处理属性。 getGenerator：返回一个获取批处理任务所需数据的生成器。组件进行数据处理时，数据被分成块进行处理。开发人员实现该接口时，可以根据需要指定块的粒度。 readItem：从生成器中遍历得到数据的存放地址，并将数据读取至内存中。 beforeProcess：输入数据的预处理环节。 process：主要的数据分析处理环节，开发人员要在该接口内实现批处理算法逻辑。 afterProcess：收尾工作，例如可将处理完毕的图片从内存中移除，避免过多的图片将内存占满 clean：清理组件执行过程中生成的所有数据 handleFinish：当数据的批处理任务后，将要退出前调用此接口进行收尾工作 算法运行模式 通过getGenerator接口获取数据生成器，并遍历该生成器 在每次遍历时，按照以下步骤进行数据处理操作。 通过readItem接口将数据块读入内存。 将读入的数据传入beforeProcress接口进行预处理操作。 预处理完毕后，将处理结果传入process接口进行数据分析处理，执行具体的数据处理算法或操作。 处理完毕的数据会进入到afterProcess接口进行收尾工作，如释放内存等。 进入下一次循环之前，组件程序会判断当前的运行状态。 如果状态为暂停，线程将被阻塞，直到状态重新变为运行中。 如果状态为停止或生成器已遍历完成，则进入使用handleFinish接口进行程序的收尾工作。 数据清理模式 通过getGenerator接口获取待清理数据生成器，并遍历该生成器。 在每次遍历时 将数据块地址传入clean接口进行数据清理工作。 数据清理完毕后，在进入下一次循环之前，需要判断组件运行状态 如果状态为暂停，线程将被阻塞，直到状态重新变为运行中。 如果状态为停止或生成器已遍历完成，则进入使用handleFinish接口进行程序的收尾工作。 检查点管理 检查点接口是负责组件运行过程中检查点设置和读取的接口集合\nsetCheckpoint：设置检查点内容，保存组件当前的运行状态。 getCheckpoint：读取检查点内容，组件重新启动时，调用该接口恢复组件运行状态。 事件发布 lifeCycleEventPublish：发布组件运行生命周期事件。 runPorgressEventPublish：发布组件运行进度事件。 事件 事件是批处理算法组件具备的主动向外界传递信息的能力，采用发布/订阅机制。\n消息队列接受组件模型发布的事件\n订阅者通过订阅获取事件\n运行生命周期事件（Life Cycle Event） 组件运行过程中，向外界告知当前组件的运行状态。\n1 2 3 4 5 6 { \u0026#34;id\u0026#34;: \u0026#34;\u0026#34;, // 组件运行唯一标识 \u0026#34;status\u0026#34;: \u0026#34;\u0026#34;, // 运行状态, running/paused/stopped/finished/failed \u0026#34;msg\u0026#34;: \u0026#34;\u0026#34;, // 消息，如运行异常的原因 \u0026#34;occurAt\u0026#34;: \u0026#34;\u0026#34; // 事件发生时间 } 运行进度事件（Run Progress Event） 组件运行时首先获取待处理数据，再将待处理数据分批并以循环的方式进行重复的算法操作。每个循环执行结束后，向外界告知组件当前的执行进度\n1 2 3 4 5 6 7 { \u0026#34;id\u0026#34;: \u0026#34;\u0026#34;, // 组件运行唯一标识 \u0026#34;progress\u0026#34;: 0, // 运行进度 \u0026#34;startTime\u0026#34;: 0, // 开始时间，毫秒级时间戳 \u0026#34;usedTime\u0026#34;: 0, // 使用时间，秒 \u0026#34;remainTime\u0026#34;: 0, // 剩余时间，秒 } 自定义事件（Custom Event） 自定义事件允许用户根据业务需求发送事件，事件内容不做限制\n组件运行入口 组件的运行入口是一个main函数，外界通过调用组件的main函数启动组件运行。\n首先接收外界传递的参数，以进行组件的初始化阶段。 启动一个HTTP服务线程，以便外界可以与组件进行通信。 通过判断mode属性值来确定组件进入哪种运行模式 如果mode为algorithm，进入算法执行模式； 如果mode为clean，进入数据清理模式。 批处理算法组件的模型机制 生命周期管理机制 初始化 （init） ：处于该状态的组件进行必要的初始化操作。 运行中 （running） ：处于该状态的组件按照既定的算法逻辑处理数据。 运行暂停 （paused） ：一旦组件进入暂停状态，线程将会持续阻塞，无法继续执行下一步操作。 运行停止 （stopped） ：组件主动终止当前的执行进入停止状态，组件进程将会退出 运行完成 （finished） ：当组件处理完所有的数据后，进入运行完成状态，进行收尾工作并退出进程。 运行失败 （failed） ：运行失败状态表示组件在执行过程中遇到了错误、异常或不可恢复的问题，导致无法继续正常运行 检查点恢复机制 检查点恢复机制确保组件运行时，即使组件运行停止或突然遇到故障导致组件崩溃退出，也能够在下一次重新启动时恢复到最近一个检查点的状态继续执行\n设置检查点 在每次数据处理循环结束之前，调用设置检查点接口 setCheckpoint 将当前组件处理输入数据的进度作为检查点文件保存在本地文件系统中。组件模型内部维护一个检查点对象，在保存检查点时，会将该对象进行序列化并以 Json 文件格式持久到本地的文件系统\n一个粗粒度的检查点对象示例\n1 2 3 4 5 6 { \u0026#34;offset\u0026#34;: 50, // 循环执行偏移量 \u0026#34;total\u0026#34;: 100, // 循环总数 \u0026#34;startTime\u0026#34;: 1640966400000, // 组件运行开始时间 \u0026#34;usedTime\u0026#34;: 100 // 组件运行时长 } 后续开发人员可以增加检查点中的数据成员用于保存数据处理的中间处理结果，并在 setCheckpoint 和 getCheckpoint 接口实现相应代码逻辑\n读取检查点 当组件恢复运行时，若属性restore的值为1，则判断本地是否存在该组件运行的检查点文件，存在则读取检查点文件并进行反序列化得到检查点对象\n批处理算法组件的编排模型 由算法程序封装得到的批处理算法组件只能提供单一的算法功能，无法单独完成完整的数据处理任务。\n因此在完成各个组件的独立开发后，还需要允许用户根据具体需求选择组件，并对多个组件进行编排，通过复用已有组件，处理复杂的数据处理任务。\n组件编排模型的结构设计 在组件编排模型中，多个组件之间以有向无环图（DAG）的方式进行编排\n有向箭头表示组件之间的依赖关系，例如，组件A指向组件B的有向箭头表示组件B需要在组件A的运行结果的基础上进行数据处理和分析，即组件A的运行输出结果作为组件B的运行输入数据。\n组件编排模型的结构实现 组件编排信息通过规范化的 Json 语言进行描述\nconnections：组件执行顺序 fromIndex：起始组件序号 toIndex：结束组件序号 components：组件列表 componentId：组件唯一标识 index：组件序号 mode：组件运行模式 machine：执行组件的计算节点名称 args：组件数据处理参数 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 { \u0026#34;connections\u0026#34;: [ { \u0026#34;fromIndex\u0026#34;: 0, \u0026#34;toIndex\u0026#34;: 1 }, { \u0026#34;fromIndex\u0026#34;: 1, \u0026#34;toIndex\u0026#34;: 2 } ], \u0026#34;components\u0026#34;: [ { // 道路水平面切片生成组件 \u0026#34;componentId\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;index\u0026#34;: 0, \u0026#34;mode\u0026#34;: \u0026#34;algorithm\u0026#34;, \u0026#34;machine\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;input\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;secatt\u0026#34;: 1, \u0026#34;canvasrl\u0026#34;: 30, \u0026#34;canvasrw\u0026#34;: 30, \u0026#34;begins\u0026#34;: [ 30, 61, 90, 120 ], \u0026#34;ends\u0026#34;: [ 40, 71, 100, 130 ], \u0026#34;canvasstep\u0026#34;: 1, \u0026#34;interratiol\u0026#34;: 4, \u0026#34;interratiow\u0026#34;: 6, \u0026#34;centralFilepath\u0026#34;: \u0026#34;#\u0026#34;, } }, { // 道路裂缝识别组件 \u0026#34;componentId\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;index\u0026#34;: 1, \u0026#34;mode\u0026#34;: \u0026#34;algorithm\u0026#34;, \u0026#34;machine\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;input\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;alpha\u0026#34;:\u0026#34;0.3\u0026#34; } }, { // 裂缝线状形态拟合组件 \u0026#34;componentId\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;index\u0026#34;: 2, \u0026#34;mode\u0026#34;: \u0026#34;algorithm\u0026#34;, \u0026#34;machine\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;input\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;rho\u0026#34;: 0.8, \u0026#34;theta\u0026#34;: 180, \u0026#34;threshold\u0026#34;: 40, \u0026#34;minLineLength\u0026#34;: 40, \u0026#34;maxLineGap\u0026#34;: 10, \u0026#34;delta1\u0026#34;: 0.1, \u0026#34;delta2\u0026#34;: 40 } } ] } ","date":"2025-01-07T15:43:24+08:00","permalink":"https://Tyritic.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E6%89%B9%E5%A4%84%E7%90%86%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E4%BA%8C%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9E%8B/","title":"分布式批处理计算平台（二）组件模型"},{"content":"项目背景 在数字经济时代，数据已经成为企业最重要的资产之一，如何有效地处理和分析这些数据以获取其潜在 价值，已经成为企业面临的重要任务。在进行数据处理和分析时，采用智能算法对数据进行批处理操作。处理过程 中，数据可被划分为适当大小的块，并通过循环逐块进行处理。\n业务场景分析 数据规模大：数字经济时代的数据规模可能以 TB 为单位 数据边缘存储 ：数据是企业的核心资产，通常情况下数据保存在企业内部服务器，即边缘端。在进行数据处理时，应避免将数据上传至云端，否则将占用大量的网络带宽，降低数据处理的效率，并且可能导致数据泄露的风险。 算法选择多样：在数据分析过程中，涉及的算法程序并没有一个统一的最优解，业务人员需要综合考虑业务需求、算法性能和特点等因素，从众多可行算法中选择最合适的算法来解决问题 项目目标 搭建分布式的批处理计算平台，将现有的批处理算法程序封装为可重用的批处理算法组件，通过平台实现组件的 构建与管理、任务编排与运行等功能。\n","date":"2025-01-07T15:05:51+08:00","permalink":"https://Tyritic.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E6%89%B9%E5%A4%84%E7%90%86%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E4%B8%80%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/","title":"分布式批处理计算平台（一）项目起步"},{"content":"体系结构 连接层：最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 服务层：第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。 引擎层：存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。 存储层：主要是将数据存储在文件系统之上，并完成与存储引擎的交互 存储引擎简介 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以不同表可以使用不同的存储引擎\n默认的存储引擎为 innoDB、\n查询当前数据库支持的存储引擎\n1 show engines 指定存储引擎\n1 2 create table table_name( )engine = 引擎名 存储引擎的特点 innoDB InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL5.5之后，InnoDB是默认的 MySOL存储引擎。\n特点 DML操作遵循ACID模型，支持事务 行级锁，提高并发访问性能 支持外键 FOREIGN KEY约束，保证数据的完整性和正确性 对应的磁盘文件 innoDB引擎的每张表都会对应这样一个表空间文件：xxx.ibd（xxx代表的是表名）\n存储该表的表结构（frm、sdi）、数据和索引\n参数：innodb_file_per_table\n","date":"2025-01-04T15:59:42+08:00","permalink":"https://Tyritic.github.io/p/mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/","title":"MySQL存储引擎"},{"content":"回答重点 方法重载（Overloading） ：在同一个类中，允许有多个同名方法，只要它们的参数列表不同（参数个数、类型或顺序）。主要关注方法的签名变化，适用于在同一类中定义不同场景下的行为。\n方法重写（Overriding）：子类在继承父类时，可以重写父类的某个方法（参数列表、方法名必须相同），从而为该方法提供新的实现。主要关注继承关系，用于子类改变父类的方法实现，实现运行时多态性。\n区别 重载 重写 发生的场所 在同一个类中 在继承关系的子类和父类之间 参数列表 必须不同（参数的数量、类型或顺序不同） 必须相同，不能改变参数列表 返回类型 可以不同 必须与父类方法的返回类型相同，或者是父类返回类型的子类（协变返回类型） 访问修饰符 不受访问修饰符影响 子类方法的访问修饰符不能比父类更严格，通常是相同或更宽泛 静态和非静态方法 可以是静态方法或非静态方法 只能重写非静态方法，静态方法不能被重写（静态方法可以被隐藏） 异常处理 方法的异常处理可以不同 子类的异常不能抛出比父类更多的异常（可以抛出更少的或相同类型的异常） 拓展知识 重载注意点 重载中提到的方法同名但参数列表不同（参数个数、类型或顺序），这里要注意和返回值没有关系，方法的签名仅是名字和参数列表，不包括返回值。\n重载通常用于提供同一操作的不同实现，例如构造函数的重载、不同类型输入的处理等。\n重写注意点 在重写时，子类方法不能使用比父类更严格的访问级别。例如，父类的方法是 protected，子类不能将其修改为 private，但可以改为 public。\n且子类方法抛出的异常必须与父类一致，或者是其父类异常的子类。\n重写通常用于在子类中提供父类方法的具体实现，以实现多态性。例如，子类对父类方法进行扩展或修改以适应特定需求。\n","date":"2025-01-03T16:05:05+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E5%92%8C%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/","title":"Java中的方法重载和方法重写"},{"content":"回答重点 概述 Java 中的继承机制是面向对象编程的核心特性之一，允许一个类（子类）继承另一个类（父类）的属性和方法。继承机制使得类之间可以形成层次结构，支持代码重用和扩展。它是实现多态、抽象和代码复用的关键机制。\n优缺点 优点：\n代码复用：子类可以复用父类的代码，减少重复实现。 易于维护：可以通过修改父类代码来影响所有子类。 缺点：\n紧耦合：子类依赖于父类的实现，父类的修改可能会影响子类。 灵活性差：继承层次结构可能会变得复杂，不易于调整或扩展。 基本概念 子类继承父类的字段和方法，可以重用和扩展父类的功能。Java 使用 extends 关键字来表示类的继承关系。\nJava 支持单继承，即一个类只能直接继承一个父类。子类可以继承父类的所有公共和受保护的成员，但不能继承父类的私有成员。\n子类构造方法首先调用父类的无参构造方法，如果父类没有无参构造方法，子类必须显式调用父类的其他构造方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 父类 public class Animal { protected String name; public Animal(String name) { this.name = name; } public void eat() { System.out.println(name + \u0026#34; is eating.\u0026#34;); } } // 子类 public class Dog extends Animal { public Dog(String name) { super(name); } public void bark() { System.out.println(name + \u0026#34; is barking.\u0026#34;); } } // 使用继承 public class Main { public static void main(String[] args) { Dog dog = new Dog(\u0026#34;Buddy\u0026#34;); dog.eat(); // 继承自 Animal dog.bark(); // Dog 自有的方法 } } super 关键字 super 关键字可以用来调用父类的方法或构造方法。\n1 2 3 public void eat() { super.eat(); // 调用父类的 eat 方法 } super 关键字也可以用来访问父类的字段。\n1 2 3 public void display() { System.out.println(super.name); // 访问父类的 name 字段 } 为什么不支持多继承 多继承会产生菱形继承的问题\nBC 继承了 A，然后 D 继承了 BC, 假设此时要调用 D 内定义在 A 的方法，因为 B 和 C 都有不同的实现，此时就会出现歧义，不知道应该调用哪个了\n为什么接口可以多实现？ 在 Java8 之前接口是无法定义具体方法实现的，所以即使有多个接口必须子类自己实现，所以并不会发生歧义。\nJava8 之后出了默认方法（default method），此时不就又出现的多继承的菱形继承问题了？\n所以 Java 强制规定，如果多个接口内有相同的默认方法，子类必须重写这个方法。\n","date":"2025-01-03T11:26:20+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6/","title":"Java的继承机制"},{"content":"回答重点 使用动机 抽象类的设计是 自下而上 的，当设计了很多类之后，发现类之间具有共性，有很多公共冗余的代码，于是设计抽象类将公共代码封装起来减少代码冗余\n接口的设计是 自上而下 的，我们事先知晓某一行为，基于这些行为约束定义了接口，一些类需要有这些行为，因此实现对应的接口。\n自上而下 指的是先约定接口，再实现。\n自下而上的 是先有一些类，才抽象了共同父类\n两者的区别 方法实现 接口中的方法默认是 public 和 abstract（但在 Java8 之后可以设置 default 方法或者静态方法，而且default方法可以被实现类重写）。 抽象类可以包含 abstract 方法（没有实现）和具体方法（有实现）。它允许子类继承并重用抽象类中的方法实现。 构造函数和成员变量 接口不能包含构造函数，接口中的成员变量默认为 public static final，即常量。 抽象类可以包含构造函数，成员变量可以有不同的访问修饰符（如 private、protected、public），并且包含实例变量和静态变量。 多继承 抽象类只能单继承 接口可以有多个实现。 ","date":"2025-01-03T11:13:40+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E8%BE%A8%E6%9E%90/","title":"Java中接口和抽象类的辨析"},{"content":"回答重点 访问修饰符的概念 Java 中的访问修饰符用于控制类、字段、方法和构造函数的访问权限。通过使用访问修饰符，可以实现封装，保护数据，并控制不同部分之间的访问范围。\nJava 主要有以下四种访问修饰符：\npublic：可以被任何类访问。 protected：可以被同一包中的其他类访问，也可以被子类（即使子类在不同包中）访问。 default：没有显式指定访问修饰符时，默认为包级别。只能被同一包中的其他类访问。 private：只能在定义它的类内部访问，外部无法直接访问。 表格整理如下\n修饰符 当前类 同一包内 子类（不同包） 其他包 public 是 是 是 是 protected 是 是 是 否 default 是 是 否 否 private 是 否 否 否 访问修饰符的选择动机 public：适用于需要被外部类广泛访问的成员。过多使用 public 可能导致封装性降低。 protected：适用于需要在继承关系中使用的成员。它提供了比 public 更严格的访问控制，但允许子类访问。 default：适用于仅在同一包内使用的类和成员。适当使用可以隐藏实现细节，减少类之间的耦合。 private：适用于内部实现细节，确保类的内部数据和方法不会被外部直接访问。最严格的访问控制，保护类的封装性。 ","date":"2025-01-03T11:06:24+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/","title":"Java中的访问修饰符"},{"content":"回答重点 静态方法 方法特点 由 static 关键字修饰 方法属于类，而不是类的某个实例 可以通过类名.方法名的格式直接调用，也可以通过对象调用（不推荐） 可以访问类的静态变量和其他静态方法（这些方法和变量属于类），但是不能访问类的实例方法和实例变量（实例方法和实例变量属于对象） 随着类的加载而加载，随着类的消亡而消失 典型使用场景 工具类 工厂方法 实例方法 方法特点 不使用 static 关键字声明的方法。 属于类的实例。 必须通过对象来调用。 可以访问实例变量和实例方法。也可以访问类的静态变量和静态方法。 随着对象的创建而存在，随着对象的销毁而消失。 典型使用场景 操作或修改对象的实例变量。 执行与对象状态相关的操作。 两者对比 特性 静态方法 实例方法 关键字 static 无 归属 类 对象 调用方式 通过类名或对象调用 通过对象调用 访问权限 只能访问静态变量和静态方法 可以访问实例变量、实例方法、静态变量和静态方法 典型用途 工具类方法、工厂方法 操作对象实例变量、与对象状态相关的操作 生命周期 类加载时存在，类卸载时消失 对象创建时存在，对象销毁时消失 拓展知识 静态方法中不能使用 this 关键字，因为 this 代表当前对象实例，而静态方法属于类，不属于任何实例。 静态方法可以被重载（同类中方法名相同，但参数不同），但不能被子类重写（因为方法绑定在编译时已确定）。实例方法可以被重载，也可以被子类重写。 实例方法中可以直接调用静态方法和访问静态变量。 静态方法不具有多态性，即不支持方法的运行时动态绑定。 ","date":"2025-01-03T10:56:32+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/","title":"Java中静态方法和实例方法的区别"},{"content":"回答重点 自动装箱（Autoboxing）：指的是 Java 编译器自动将基本数据类型转换为它们对应的包装类型。比如，将 int 转换为 Integer。\n自动拆箱（Unboxing）：指的是 Java 编译器自动将包装类型转换为基本数据类型。比如，将 Integer 转换为 int。\n主要作用：\n它在 Java 5 中引入，主要是为了提高代码的可读性，减少手动转换操作，简化了代码编写，开发者可以更方便地在基本类型和包装类型之间进行转换。 常见于：\n集合类如 List\u0026lt;Integer\u0026gt; 中无法存储基本类型，通过自动装箱，可以将 int 转换为 Integer 存入集合。\n1 2 3 4 int i = 99; //声明基础数据类型int变量 ArrayList list = new ArrayList(); list.add(i); //触发自动装箱，int类型自动转换成 Integer System.out.println(list); 自动装箱和拆箱经常在算术运算中出现，尤其是包装类型参与运算时。\n拓展知识 底层实现 自动装箱和拆箱并不是通过语法糖实现的，它是通过调用包装类型的 valueOf() 和 xxxValue() 方法实现的。\n自动装箱调用：Integer.valueOf(int i) 自动拆箱调用：Integer.intValue() 示例：\n1 2 Integer a = Integer.valueOf(10); // 自动装箱 int b = a.intValue(); // 自动拆箱 注意点 性能影响 自动装箱和拆箱虽然简化了编码，但在频繁使用的场景，可能导致性能开销，尤其是在循环中频繁发生装箱或拆箱时，容易引入不必要的对象创建和垃圾回收。\n所以尽量避免在性能敏感的代码中频繁使用自动装箱和拆箱。例如：\n1 2 3 4 Integer sum = 0; for (int i = 0; i \u0026lt; 10000; i++) { sum += i; // sum 是包装类型，导致多次装箱和拆箱 } NullPointerException 在进行拆箱操作时，如果包装类对象为 null，会抛出 NullPointerException。\n1 2 Integer num = null; int n = num; // 抛出 NullPointerException ","date":"2025-01-02T14:29:54+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1/","title":"Java中的自动装箱和自动拆箱"},{"content":"作用 Object类是Java所有类的父类，所有的Java类默认继承Object类，Object类中的所有方法都可以被Java类使用\n常见方法 以下是 Object 类中的主要方法及其作用：\n对象比较 public boolean equals(Object obj)\n作用：用于比较两个对象是否相等。默认实现比较对象的内存地址，即判断两个引用是否指向同一个对象。 使用：通常会重写此方法来比较对象的内容或特定属性，以定义对象的相等性。 public int hashCode()\n作用：返回对象的哈希码，是对象的整数表示。哈希码用于支持基于哈希的集合（如 HashMap 和 HashSet）。 使用：如果重写了 equals 方法，则通常也需要重写 hashCode 方法，以保证相等的对象具有相同的哈希码。 hashCode和equals的关系 equals决定了对象的逻辑相等性\nhashCode决定了对象的哈希存储方式。\nequals() 方法：\n用于判断两个对象是否相等。默认实现是使用 == 比较对象的内存地址，但可以在类中重写 equals() 来定义自己的相等逻辑。 hashCode() 方法：\n返回对象的哈希值，主要用于基于哈希的集合（如 HashMap、HashSet）。同一个对象每次调用 hashCode() 必须返回相同的值，且相等的对象必须有相同的哈希码。 equals 和 hashCode 的约定 相等对象的哈希值必须相等： 如果两个对象通过 equals 方法比较相等（a.equals(b) == true），那么它们的哈希值必须相同（a.hashCode() == b.hashCode()）。\n不相等的对象可以有相同的哈希值： 如果两个对象通过 equals 方法比较不相等（a.equals(b) == false），它们的哈希值不必不同，但为了提升性能，应尽量让不相等的对象有不同的哈希值。\n编码建议 重写 equals 方法的时候，也要重写 hashCode 方法，这样才能保持条件判断的同步。\n解释\n如果仅重写 equals 方法而不重写 hashCode，会违反 hashCode 与 equals 的约定，从而导致集合类行为异常。例如：HashSet 基于哈希值来判断对象是否相同，哈希值不同导致它们被视为不同的对象。\n对象转字符串 public String toString()\n作用：返回对象的字符串表示。默认实现返回对象的类名加上其哈希码的十六进制表示。 使用：通常会重写此方法以提供对象的更有意义的描述。 反射 public final Class\u0026lt;?\u0026gt; getClass()\n作用：返回对象的运行时类（Class 对象）。此方法是 Object 类中的一个 final 方法，不能被重写。 使用：可以用来获取对象的类信息，常用于反射操作。 多线程调度 public void notify()\n作用：唤醒在对象的监视器上等待的一个线程。该方法需要在同步块或同步方法中调用。 使用：用于在多线程环境中进行线程间的通信和协调。 public void notifyAll()\n作用：唤醒在对象的监视器上等待的所有线程。该方法需要在同步块或同步方法中调用。 使用：与 notify() 相似，但唤醒所有等待线程，用于处理多个线程之间的协作。 public void wait()\n作用：使当前线程等待，直到其他线程调用 notify() 或 notifyAll() 方法。此方法需要在同步块或同步方法中调用。 使用：用于线程间的通信，线程会等待直到被唤醒或超时。 public void wait(long timeout)\n作用：使当前线程等待，直到指定的时间到期或被唤醒。超时后线程会自动被唤醒。 使用：用于实现带有超时的等待机制。 public void wait(long timeout, int nanos)\n作用：使当前线程等待，直到指定的时间和纳秒数到期或被唤醒。 使用：用于实现更精细的等待控制，允许指定等待时间的精确到纳秒。 对象拷贝 protected Object clone()\n作用：创建并返回当前对象的一个副本。默认实现是进行浅拷贝。 使用：通常会重写此方法来实现深拷贝，以确保克隆对象的完整性。 垃圾回收 protected void finalize()\n作用：在垃圾回收器确定不存在对该对象的更多引用时调用，用于进行资源释放等清理工作。 使用：不建议使用，因为它依赖于垃圾回收器的实现，可能会导致不确定的性能问题。推荐使用 try-with-resources 和 AutoCloseable 接口进行资源管理 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } // 重写equals方法 @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null || getClass() != obj.getClass()) return false; Person person = (Person) obj; return age == person.age \u0026amp;\u0026amp; name.equals(person.name); } // 重写hashCode方法 @Override public int hashCode() { return Objects.hash(name, age); } // 重写toString方法 @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, age=\u0026#34; + age + \u0026#34;}\u0026#34;; } public static void main(String[] args) { Person p1 = new Person(\u0026#34;Alice\u0026#34;, 30); Person p2 = new Person(\u0026#34;Alice\u0026#34;, 30); System.out.println(p1.equals(p2)); // true System.out.println(p1.hashCode() == p2.hashCode()); // true System.out.println(p1); // Person{name=\u0026#39;Alice\u0026#39;, age=30} } } ","date":"2025-01-02T14:24:41+08:00","permalink":"https://Tyritic.github.io/p/object%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95/","title":"Object类的作用和相关方法"},{"content":"回答重点 Java 提供了 8 种基本数据类型（Primitive Types），用于处理不同类型的值：\n整型：\nbyte：占用 1 字节（8 位），取值范围为 -128 到 127。 short：占用 2 字节（16 位），取值范围为 -32,768 到 32,767。 int：占用 4 字节（32 位），取值范围为 -2^31 到 2^31-1。 long：占用 8 字节（64 位），取值范围为 -2^63 到 2^63-1。 浮点型：\nfloat：占用 4 字节（32 位），符合 IEEE 754 单精度标准。 double：占用 8 字节（64 位），符合 IEEE 754 双精度标准。 字符型：\nchar：占用 2 字节（16 位），存储单个 Unicode 字符，取值范围为 0 到 65,535。 布尔型：\nboolean：用于表示 true 或 false 两个值，具体存储大小依赖于虚拟机实现。 扩展知识 基本数据类型的特性：\n大小固定：每种基本类型在不同的操作系统和平台上占用的内存大小是固定的，保证了跨平台的一致性。 不支持 null：基本类型不能为 null，它们在声明时会有默认值，例如 int 的默认值是 0，boolean 的默认值是 false。 性能更高：基本类型直接存储在栈内存中，操作效率高于包装类型（如 Integer、Double）。 默认值：\nbyte、short、int、long 的默认值是 0。 float、double 的默认值是 0.0。 char 的默认值是 '\\u0000'。 boolean 的默认值是 false。 类型转换：\n隐式转换：当小类型赋值给大类型时（例如 int 到 long），会进行隐式转换，不会发生数据丢失。 强制类型转换：当大类型转换为小类型时（例如 double 到 float），需要显式进行强制类型转换，可能会造成精度丢失或溢出。 boolean 的存储：\n虽然 boolean 类型在逻辑上只占用 1 位，但 Java 的虚拟机对 boolean 的存储通常会根据系统架构分配 1 字节或更多位数的空间。这是因为 CPU 通常按字节操作内存，而非按位。 ","date":"2025-01-02T14:17:22+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","title":"Java的基本数据类型"},{"content":"回答重点 主要工具 javac：Java 编译器，负责将 Java 源代码编译成字节码（.class 文件）。 java：运行 Java 应用程序的命令，使用 JVM 来解释并执行编译后的字节码文件。 javadoc：生成 API 文档的工具，能够根据源代码中的注释生成 HTML 格式的文档。 jar：用于创建和管理 JAR 文件的工具，可以将多个 .class 文件打包为单一文件，便于分发和管理。 jdb：Java 调试工具，用于在命令行中调试 Java 应用程序，支持断点设置、变量查看等功能。 性能监控和分析工具 jps：Java 进程工具，显示所有正在运行的 Java 进程，便于监控和诊断。 jstack：生成线程堆栈信息的工具，常用于分析死锁和线程问题。 jmap：内存映射工具，可以生成堆转储（heap dump）文件，便于内存泄漏分析和垃圾回收优化。 jhat：堆分析工具，配合 jmap 使用，分析生成的堆转储文件，帮助开发者了解内存使用情况。 jstat：JVM 统计监控工具，实时监控垃圾回收、内存、类加载等信息，帮助开发者调优 JVM 性能。 jconsole：图形化的 JVM 监控工具，可以监控应用程序的内存、线程和类加载情况，常用于监控和调试。 jvisualvm：功能强大的性能分析工具，支持堆、线程、GC 的详细监控，还提供内存分析和 CPU 性能分析。 诊断工具 jinfo：用于查看和修改正在运行的 JVM 参数，便于动态调优和调整 JVM 行为。 jstatd：远程 JVM 监控工具，可以通过网络远程监控 JVM 的状态，适合分布式系统中的性能监控。 拓展知识 高级调试和性能优化工具 Java Mission Control (JMC)：一个功能强大的工具，用于分析和优化 Java 应用程序的性能，提供了基于飞行记录器（Java Flight Recorder，JFR）的性能分析功能，可以详细查看垃圾回收、线程活动、CPU 使用率等指标，是进行深度性能分析的利器。 Java Flight Recorder (JFR)：低开销的监控工具，能够记录 JVM 的运行时数据，适合生产环境中的性能分析，尤其是在高并发系统中使用频率较高。 GC 调优和内存分析 jmap 和 jhat 常用于排查内存泄漏或内存占用过高的问题。通过 jmap 生成堆转储文件后，开发者可以使用 jhat 或其他工具（如 Eclipse MAT）分析对象的引用链，从而发现潜在的内存问题。\n线程和死锁分析 jstack 是用于调试线程状态的利器，尤其是在分析线程死锁时。当应用卡死或响应时间异常时，通过 jstack 可以捕获应用的线程状态，并分析是否存在死锁情况。\n","date":"2025-01-02T14:03:21+08:00","permalink":"https://Tyritic.github.io/p/jdk%E5%B7%A5%E5%85%B7%E5%8C%85/","title":"JDK工具包"},{"content":"JRE JRE全称**（Java Runtime Environment）**是Java运行时环境，包含了 JVM, Java核心类库和其他支持Java程序的文件\n组成部分 JVM（Java Virtual Machine）：执行由源代码编译后得到的Java字节码，提供了Java程序的运行环境 核心类库：标准的类库（java.lang,java.utils）供Java程序使用 其他文件：配置文件，库文件，支持JVM的运行 JDK JDK全称 （Java Development Kit） 可以视为 JRE 的超集，是用于开发Java 程序的完整开发环境，它包含了JRE，以及用于开发、调试和监控 Java 应用程序的工具。\n组成部分 JRE：JDK包含了完整的JRE，可以运行java程序 开发工具：包含编译器（javac），打包工具（jar） 附加库和文件：支持开发，文档生成 拓展工具 javac：Java 编译器，用于将 Java 源代码（.java 文件）编译成字节码（.class 文件）。 java：Java 应用程序启动器，用于运行 Java 应用程序。 javadoc：文档生成器，用于从 Java 源代码中提取注释并生成 HTML 格式的 API 文档。 jar：归档工具，用于创建和管理 JAR（Java Archive）文件。 jdb：Java 调试器，用于调试 Java 程序。 jps：Java 进程状态工具，用于列出当前所有的 Java 进程。 jstat：JVM 统计监视工具，用于监视 JVM 统计信息。 jstatd：JVM 统计监视守护进程，用于在远程监视 JVM 统计信息。 jmap：内存映射工具，用于生成堆转储（heap dump）、查看内存使用情况。 jhat：堆分析工具，用于分析堆转储文件。 jstack：线程栈追踪工具，用于打印 Java 线程的栈追踪信息。 javap：类文件反汇编器，用于反汇编和查看 Java 类文件。 jdeps：Java 类依赖分析工具，用于分析类文件或 JAR 文件的依赖关系 ","date":"2025-01-02T12:10:06+08:00","permalink":"https://Tyritic.github.io/p/jdk%E5%92%8Cjre%E7%9A%84%E5%85%B3%E7%B3%BB/","title":"JDK和JRE的关系"},{"content":"回答重点 跨平台 垃圾回收 生态 面向对象 跨平台 Java 是跨平台的，通过 JVM 实现“一次编写，到处运行”。\nJava 源代码首先编译成字节码（.class 文件），然后由 JVM 将字节码转换成平台特定的机器码。只要在不同平台上安装相应的 JVM，字节码文件就能执行。\nJava 程序通过 JVM 这个“中间层”实现跨平台运行，编译生成的字节码文件是相同的，但不同平台的 JVM 会将其翻译成不同的机器码。尽管 Java 程序是跨平台的，但 JVM 本身是平台特定的，因此需要在每个平台上安装对应版本的 JVM 来支持执行。\nJVM 是跨平台的关键，它将字节码转换为机器码，因此 Java 程序能在不同平台上运行。即使将 Java 程序打包成可执行文件（.exe），仍然需要 JVM 的支持。\n提示\n解释执行比编译执行效率差\n解释执行：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢。（类比每次给你英语让你翻译阅读）\n编译执行：在程序执行之前，整个源代码会被编译成机器码或者字节码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性较差。（类比直接给你看中文）\nJava同时具有解释性和编译性\n编译性：Java源代码首先被编译成字节码，JIT 会把编译过的机器码保存起来,以备下次使用。 解释性：JVM中一个方法调用计数器通过统计发现一些高频次执行的代码（热点代码），然后将这些字节码交给 JIT 编译器进行编译，生成平台相关的机器码。下次执行时，JVM 会直接使用已编译的机器码，从而避免重新解释，提升性能。否则就是用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的 垃圾回收 Java 还提供垃圾自动回收功能，虽说手动管理内存意味着白由、精细化地掌控，但是很容易出错。 在内存较充裕的当下，将内存的管理交给 GC 来做，减轻了程序员编程的负担，提升了开发效率，更加划算!\n生态 Java 生态圈完善，丰富的第三方类库、企业级框架、各种中间件。\n面向对象 Java 是一种严格的面向对象编程语言，具有清晰的类、对象、继承、接口等概念，支持封装、继承、多态等 OOP 特性，有助于代码的可维护性和可扩展性。\n","date":"2025-01-02T10:53:37+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E7%89%B9%E7%82%B9/","title":"Java的优势与特点"},{"content":"Pojo类 pojo类在项目开发中用于标识实体类，该类在项目对应一个实际的业务对象，例如：user,student等\nPO/DO PO/DO类在项目中对应数据库中的一张表，数据库PO/DO是持久化对象，用于表示数据库中的一条记录映射成的Java对象，类中应该都是基本数据类型和String\nPO仅仅用于表示数据，不对数据进行操作，拥有get和set方法。对象类中的属性对应数据库表中的字段，有多少个字段就有多少个属性，完全匹配。\n命名规范：数据库表名+PO/DO\nDTO 全称（Data Transfer Object）用于后端接受前端的请求，将前端请求参数封装成对象\n通常用于将前端请求传递到控制层和控制层传递到业务逻辑层\nVO 全称（View Object）用于后端响应前端的过程中，作为视图对象\nBO 全称（Business Object）用于后端业务逻辑的处理\nBO是实际的业务对象，会参与业务逻辑的处理操作，里面可能会包含多个类，用于表示一个业务对象。遵循JavaBean规范，拥有get和set方法。\n","date":"2025-01-01T14:51:32+08:00","permalink":"https://Tyritic.github.io/p/bovopododto%E7%9A%84%E7%90%86%E8%A7%A3/","title":"BO、VO、PO、DO、DTO的理解"},{"content":"一维前缀和 题目描述 用于计算一维数组的区间和，将时间复杂度从$O(n * m) ,m 是查询的次数$简化到$O(n)$\n算法思想 前缀和的思想是重复利用计算过的子数组之和，从而降低区间查询需要累加计算的次数。\n例如，统计 vec[i] 这个数组上的区间和。\n先做累加，即 p[i] 表示 下标 0 到 i 的 vec[i] 累加 之和。 统计vec数组上 下标 i 到下标 j 之间的累加和时使用**p[j]-p[i-1]**即可 1 2 3 p[i] = vec[0] + vec[1] + ... vec[i]; p[j] = vec[0] + vec[1] + vec[2] + vec[3] + vec[4] + vec[5] + ..vec[j]; p[j] - p[i] = vec[i+1] + vec[i+2] + vec[i+3] + ... +vec[j]; 经典例题 题目描述 题目链接(opens new window)\n题目描述\n给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。\n输入描述\n第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间，直至文件结束。\n输出描述\n输出每个指定区间内元素的总和。\n输入示例\n1 2 3 4 5 6 7 8 5 1 2 3 4 5 0 1 1 3 输出示例\n1 2 3 9 数据范围：\n0 \u0026lt; n \u0026lt;= 100000\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int[] vec = new int[n]; int[] p = new int[n]; int presum = 0; for (int i = 0; i \u0026lt; n; i++) { vec[i] = scanner.nextInt(); presum += vec[i]; p[i] = presum; } while (scanner.hasNextInt()) { int a = scanner.nextInt(); int b = scanner.nextInt(); int sum; if (a == 0) { sum = p[b]; } else { sum = p[b] - p[a - 1]; } System.out.println(sum); } scanner.close(); } } ","date":"2024-12-31T20:35:31+08:00","permalink":"https://Tyritic.github.io/p/%E5%89%8D%E7%BC%80%E5%92%8C/","title":"前缀和"},{"content":"题目描述 通常用于在数组，链表中求解窗口的最值问题\n算法模板 最小滑动窗口 题目前提 给定数组 nums，定义滑窗的左右边界 i, j，求满足某个条件的滑窗的最小长度。\n思路解析 先固定左指针不动 一开始滑窗不满足条件，向右移动右指针直到窗口满足题目条件 迭代右移左指针同时更新结果（更新结果和移动左边界处于同一个while循环中） 代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class solution{ public result\u0026lt;T\u0026gt; search(int[]nums) { int left=0; for(int right=0;right\u0026lt;nums.length;right++) { calculate();// 计算约束条件 // 判断[i, j]是否满足条件 while 满足条件 { update(result); // 不断更新结果(注意在while内更新！) left++; //最大程度的压缩左边界，使得滑窗尽可能的小 } } return result; } } 最大滑动窗口 题目前提 给定数组 nums，定义滑窗的左右边界 i, j，求满足某个条件的滑窗的最大长度。\n思路解析 先固定左指针不动 一开始滑窗满足条件，向右移动右指针直到不满足条件 迭代右移右边界的过程中更新结果（更新结果和移动左边界不在一个while循环内） 最保守的压缩左边界，一旦满足条件了就退出压缩左边界的过程，使得滑窗尽可能的大 代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class solution{ public result\u0026lt;T\u0026gt; search(int[]nums) { int left=0; for(int right=0;right\u0026lt;nums.length;right++) { calculate();// 计算约束条件 // 判断[i, j]是否满足条件 while 不满足条件 { left++; //（最保守的压缩左边界，一旦满足条件了就退出压缩左边界的过程，使得滑窗尽可能的大） } update(result); } return result; } } 经典例题 leetcode 209. 长度最小的子数组 题目描述 力扣题目链接(opens new window)\n给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。\n示例：\n输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 提示：\n1 \u0026lt;= target \u0026lt;= 10^9 1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^5 思路解析 题目前提条件为\n给定数组 nums 求满足某个条件的滑窗的最小长度。 窗口一开始不满足条件 故采用最小滑动窗口策略\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int minSubArrayLen(int target, int[] nums) { int left=0; int sum=0; int result=Integer.MAX_VALUE; for(int right=0;right\u0026lt;nums.length;right++) {\t// 1.计算约束条件 sum+=nums[right]; // 2.当窗口满足条件 while(sum\u0026gt;=target) { // 3. 更新结果 result=Math.min(result,right-left+1); // 4. 右移右边界 sum-=nums[left]; left++; } } return result; } } leetcode 904. 水果成篮 题目描述 力扣题目链接\n你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。\n你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：\n你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。\n示例 1：\n1 2 3 输入：fruits = [1,2,1] 输出：3 解释：可以采摘全部 3 棵树。 示例 2：\n1 2 3 4 输入：fruits = [0,1,2,2] 输出：3 解释：可以采摘 [1,2,2] 这三棵树。 如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。 示例 3：\n1 2 3 4 输入：fruits = [1,2,3,2,2] 输出：4 解释：可以采摘 [2,3,2,2] 这四棵树。 如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。 示例 4：\n1 2 3 输入：fruits = [3,3,3,1,2,1,1,2,3,3,4] 输出：5 解释：可以采摘 [1,2,1,1,2] 这五棵树。 提示：\n1 \u0026lt;= fruits.length \u0026lt;= 105 0 \u0026lt;= fruits[i] \u0026lt; fruits.length 思路解析 本题可以抽象为求解一个滑动窗口，滑动窗口内只有两种数字，求解滑动窗口长度的最大值\n题目前提条件\n给定数组 nums 求满足某个条件的滑窗的最小长度。 窗口一开始满足条件 故采用最大滑动窗口策略\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int totalFruit(int[] fruits) { int n=fruits.length; if(n==1)return 1; if(n==2)return 2; int left=0; int ans=0; int result=1; HashMap\u0026lt;Integer,Integer\u0026gt;map=new HashMap\u0026lt;\u0026gt;(); for(int right=0;right\u0026lt;fruits.length;right++) { // 1.计算约束条件（水果的种类数） map.put(fruits[right],map.getOrDefault(fruits[right],0)+1); // 2.若不满足条件 while(map.size()\u0026gt;2) { // 3.右移左边界 map.put(fruits[left],map.get(fruits[left])-1); if(map.get(fruits[left])==0) map.remove(fruits[left]); left++; } // 4.更新结果 result=Math.max(result,right-left+1); } return result; } } leetcode 76 最小覆盖子串 题目描述 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \u0026quot;\u0026quot; 。\n注意：\n对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。 如果 s 中存在这样的子串，我们保证它是唯一的答案。 示例 1：\n1 2 3 输入：s = \u0026#34;ADOBECODEBANC\u0026#34;, t = \u0026#34;ABC\u0026#34; 输出：\u0026#34;BANC\u0026#34; 解释：最小覆盖子串 \u0026#34;BANC\u0026#34; 包含来自字符串 t 的 \u0026#39;A\u0026#39;、\u0026#39;B\u0026#39; 和 \u0026#39;C\u0026#39;。 示例 2：\n1 2 3 输入：s = \u0026#34;a\u0026#34;, t = \u0026#34;a\u0026#34; 输出：\u0026#34;a\u0026#34; 解释：整个字符串 s 是最小覆盖子串。 示例 3:\n1 2 3 4 输入: s = \u0026#34;a\u0026#34;, t = \u0026#34;aa\u0026#34; 输出: \u0026#34;\u0026#34; 解释: t 中两个字符 \u0026#39;a\u0026#39; 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。 提示：\nm == s.length n == t.length 1 \u0026lt;= m, n \u0026lt;= 105 s 和 t 由英文字母组成 思路解析 本题可以将覆盖子串抽象为一个滑动窗口，求解该滑动窗口的最小值\n故采用最小滑动窗口策略\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Solution { public String minWindow(String s, String t) { int[]cnS=new int[128]; int[]cnT=new int[128]; char[]S=s.toCharArray(); char[]T=t.toCharArray(); for(char e:T) { cnT[e]++; } int left=0; int ansLeft=-1; int ansRight=s.length-1; for(int right=0;right\u0026lt;s.length;right++) { // 1.计算约束条件 cnS[S[right]]++; // 2.若满足条件 while(isCover(cnS,cnT)) { // 3.更新结果 if(right-left+1\u0026lt;ansRight-ansLeft+1) { ansLeft=left; ansRight=right; } // 4.右移左边界 cnT[S[left]]--; left++; } } return ansLeft\u0026lt;0?\u0026#34;\u0026#34;:s.substring(ansLeft,ansRight+1); } //通过统计子串中字符的出现次数来判断是否覆盖 public static boolean isCover(int[]cnS,int[]cnT) { for(int i=\u0026#39;a\u0026#39;;i\u0026lt;=\u0026#39;z\u0026#39;;i++) { if(cnS[i]\u0026lt;cnT[i]) { return false; } } for(int i=\u0026#39;A\u0026#39;;i\u0026lt;=\u0026#39;Z\u0026#39;;i++) { if(cnS[i]\u0026lt;cnT[i]) { return false; } } return true; } } ","date":"2024-12-30T15:29:22+08:00","permalink":"https://Tyritic.github.io/p/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B3%95/","title":"双指针法-滑动窗口法"},{"content":"题目描述 通常当使用蛮力法需要两个for循环时，将两个for循环削减成一个for循环的优化方法。时间复杂度$O(n^2)$可以优化为$O(n)$\n同时数组排序为两端大，中间小\n算法模板 方法步骤 双指针法（左右指针法）： 通过一个左指针和右指针在一个for循环下完成两个for循环的工作。\n定义左右指针\n左指针：定义在数组左侧的指针 右指针：定义在数组尾部的指针 代码模板 1 2 3 4 5 6 7 8 9 10 11 class solution{ public int solution(int[]nums,int val) { int leftIndex=0; int rightIndex=nums.length-1; while(left\u0026lt;=right) { } } } 经典例题 leetcode 977. 有序数组的平方 题目描述 力扣题目链接(opens new window)\n给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n示例 1：\n输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100] 示例 2：\n输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] 思路解析 数组其实是有序的， 只不过负数平方之后可能成为最大数了。\n那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。\n此时可以考虑双指针法了，i指向起始位置，j指向终止位置。\n定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。比较左指针和右指针的平方大小\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int[] sortedSquares(int[] nums) { int leftIndex=0; int rightIndex=nums.length-1; int numsIndex=nums.length-1; int[]result=new int[nums.length]; while(leftIndex\u0026lt;=rightIndex) { if(nums[leftIndex]*nums[leftIndex]\u0026gt;=nums[rightIndex]*nums[rightIndex]) { result[numsIndex]=nums[leftIndex]*nums[leftIndex]; leftIndex++; } else{ result[numsIndex]=nums[rightIndex]*nums[rightIndex]; rightIndex--; } numsIndex--; } return result; } } ","date":"2024-12-30T11:44:58+08:00","permalink":"https://Tyritic.github.io/p/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95-%E5%B7%A6%E5%8F%B3%E6%8C%87%E9%92%88%E6%B3%95/","title":"双指针法 左右指针法"},{"content":"虚拟头节点 方法描述 设置一个虚拟头结点，这样原链表的所有节点就都可以按照统一的方式进行操作了。\n经典例题 leetcode 203. 移除链表元素 力扣题目链接(opens new window)\n题意：删除链表中等于给定值 val 的所有节点。\n示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]\n示例 2： 输入：head = [], val = 1 输出：[]\n示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * 时间复杂度 O(n) * 空间复杂度 O(1) * @param head * @param val * @return */ public ListNode removeElements(ListNode head, int val) { // 设置一个虚拟的头结点 ListNode dummy = new ListNode(); dummy.next = head; ListNode cur = dummy; while (cur.next != null) { if (cur.next.val == val) { cur.next = cur.next.next; } else { cur = cur.next; } } return dummy.next; } leetcode 24. 两两交换的节点 题目描述\n力扣题目链接(opens new window)\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n思路解析\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(-1); // 设置一个虚拟头结点 dummy.next = head; // 将虚拟头结点指向head，这样方便后面做删除操作 ListNode curr=dummy; ListNode temp; //保存两个节点后的节点 ListNode firstNode; //保存curr后的第一个节点 ListNode secondNode; //保存curr后的第二个节点 while(curr.next!=null\u0026amp;\u0026amp;curr.next.next!=null) { firstNode=curr.next; secondNode=firstNode.next; temp=secondNode.next; curr.next=secondNode; // 步骤一 secondNode.next=firstNode; //步骤二 firstNode.next=temp; // 步骤三 curr=firstNode; //重新设置为原先在secondNode位置上的节点 } return dummy.next; } } leetcode 19. 删除链表的倒数第N个节点 题目描述\n力扣题目链接(opens new window)\n给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n进阶：你能尝试使用一趟扫描实现吗？\n示例 1：\n输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5]\n示例 2：\n输入：head = [1], n = 1 输出：[]\n示例 3：\n输入：head = [1,2], n = 1 输出：[1]\n思路解析\n使用快慢指针和虚拟头节点，让快节点从虚拟头节点开始，提前移动n+1步。\n然后再让快节点和慢节点同时移动直到快节点移动到最后一个节点的后一个位置（null)\n此时快节点和慢节点之间间隔n个节点，慢节点位于要删除的节点的前一个节点位置\n直接删除即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { //新建一个虚拟头节点指向head ListNode dummyNode = new ListNode(0); dummyNode.next = head; //快慢指针指向虚拟头节点 ListNode fastIndex = dummyNode; ListNode slowIndex = dummyNode; // 快指针移动n+1步，使得快慢指针相差 n 个结点即可 for (int i = 0; i \u0026lt;= n; i++) { fastIndex = fastIndex.next; } // 两个指针同时移动，直到快指针移动到最后一个节点的后一个位置（null) while (fastIndex != null) { fastIndex = fastIndex.next; slowIndex = slowIndex.next; } // 检查 slowIndex.next 是否为 null，以避免空指针异常 if (slowIndex.next != null) { slowIndex.next = slowIndex.next.next; // 直接删除节点 } return dummyNode.next; } } 反转操作 思路解析 只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表\n定义节点\ncurr：当前节点 prev：当前节点的上一个节点 temp：当前节点的下一个节点 操作\n记录curr的下一个指针temp 将指针反转，让curr指向prev 将prev节点设置为curr 将curr设置为temp 经典例题 leetcode 206. 翻装链表 力扣题目链接(opens new window)\n题意：反转一个单链表。\n示例: 输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL 输出: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public ListNode reverseList(ListNode head) { ListNode prev=null; ListNode curr=head; ListNode temp=null; while(curr!=null) { temp=curr.next; curr.next=prev; prev=curr; curr=temp; } } } 判断链表是否相交 思路解析 求出A链表和B链表的长度 让currB到currA对齐的位置 此时比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。 经典例题 leetcode 160. 链表相交 力扣题目链接(opens new window)\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n图示两个链表在节点 c1 开始相交：\n题目数据 保证 整个链式结构中不存在环。\n注意，函数返回结果后，链表必须 保持其原始结构 。\n示例 1：\n示例 2：\n示例 3：\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode currA = headA; ListNode currB = headB; int lenA = 0, lenB = 0; while (currA != null) { // 求链表A的长度 lenA++; currA = currA.next; } while (currB != null) { // 求链表B的长度 lenB++; currB = currB.next; } // 将当前指针回到头节点 currA = headA; currB = headB; // 让currA为最长链表的头，lenA为其长度 if (lenB \u0026gt; lenA) { //1. swap (lenA, lenB); 交换长度 int tmpLen = lenA; lenA = lenB; lenB = tmpLen; //2. swap (currA, currB); 交换节点 ListNode tmpNode = currA; currA = currB; currB = tmpNode; } // 求长度差 int gap = lenA - lenB; // 让currA和currB在同一起点上（末尾位置对齐） for(int i=0;i\u0026lt;gap;i++) { currA=currA.next; } // 遍历currA 和 currB，遇到相同则直接返回 while (currA != null) { if (currA == currB) { return currA; } currA = currA.next; currB = currB.next; } return null; } } 环形链表 思路解析 判断是否是环形链表 使用快慢指针法，设置一个快指针和慢指针，让快指针一次移动两步，慢指针一次移动一步，若两个指针能相遇则该链表是环形链表\n证明过程\nfast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇\n其实相对于slow来说，fast是一个节点一个节点的靠近slow的\n如何找到环的入口 从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。\n经典例题 leetcode 142. 环形链表II 题目描述\n力扣题目链接(opens new window)\n题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。\n说明：不允许修改给定的链表。\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head; ListNode fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) {// 有环 ListNode index1 = fast; ListNode index2 = head; // 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口 while (index1 != index2) { index1 = index1.next; index2 = index2.next; } return index1; } } return null; } } ","date":"2024-12-29T17:25:11+08:00","permalink":"https://Tyritic.github.io/p/%E9%93%BE%E8%A1%A8/","title":"链表"},{"content":"题目描述 通常当使用蛮力法需要两个for循环时，将两个for循环削减成一个for循环的优化方法。时间复杂度$O(n^2)$可以优化为$O(n)$\n算法模板 方法步骤 双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。\n新数组指在旧数组的基础上修改后的数组\n定义快慢指针\n快指针：通过遍历旧数组来寻找新数组的元素 ，新数组就是不含有目标元素的数组 慢指针：指向更新后新数组下标的位置 代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 class solution{ public int solution(int[]nums,int val) { int slowIndex=0; for(int fastIndex=0;fastIndex\u0026lt;nums.length;fastIndex++) { //题目要求的操作,用于构建新数组，if条件内是符合新数组要求的谓词 //fastIndex用于遍历原数组 //slowIndex用于插入新数组 } return slowIndex; } } 结果分析 slowIndex是新数组的元素个数。\n经典例题 leetcode 27. 移除元素 题目描述 力扣题目链接(opens new window)\n给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。\n示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n你不需要考虑数组中超出新长度后面的元素。\n思路解析 题目条件中原地一词提示使用快慢指针法，将$O(n^2)$的操作转变为$O(n)$的操作\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int removeElement(int[] nums, int val) { int slowIndex=0; for(int fastIndex=0;fastIndex\u0026lt;nums.length;fastIndex++) { if(nums[fastIndex]!=val) { nums[slowIndex++]=nums[fastIndex]; } } return slowIndex; } } leetcode 26. 删除有序数组的重复项 题目描述 力扣题目链接\n给你一个 非严格递增排列 的数组 nums ，请你** 原地** 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。\n考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：\n更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。 返回 k 。 判题标准:\n系统会用下面的代码来测试你的题解:\n1 2 3 4 5 6 7 8 9 int[] nums = [...]; // 输入数组 int[] expectedNums = [...]; // 长度正确的期望答案 int k = removeDuplicates(nums); // 调用 assert k == expectedNums.length; for (int i = 0; i \u0026lt; k; i++) { assert nums[i] == expectedNums[i]; } 如果所有断言都通过，那么您的题解将被 通过。\n示例 1：\n1 2 3 输入：nums = [1,1,2] 输出：2, nums = [1,2,_] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2：\n1 2 3 输入：nums = [0,0,1,1,1,2,2,3,3,4] 输出：5, nums = [0,1,2,3,4] 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums 已按 非严格递增 排列 思路解析 题目条件中原地一词提示使用快慢指针法，将$O(n^2)$的操作转变为$O(n)$的操作\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int removeDuplicates(int[] nums) { int slowIndex=0; int fast=0; for(int fastIndex=0;fastIndex\u0026lt;nums.length-1;fastIndex++) { if(nums[fastIndex]!=nums[fastIndex+1]) { nums[slowIndex++]=nums[fastIndex]; } fast=fastIndex; // 1.跟踪快指针下标 } nums[slowIndex]=nums[fast+1]; // 2.slowIndex为下一个操作的数组下标，nums[fast+1]为数组最后一个元素（保证不与其他元素重复） return slowIndex+1; } } leetcode 283. 移动零 题目描述 力扣题目链接\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n示例 1:\n1 2 输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0] 示例 2:\n1 2 输入: nums = [0] 输出: [0] 提示:\n1 \u0026lt;= nums.length \u0026lt;= 104 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 思路解析 将所有不等于0的元素放入原先的数组中 在新数组的尾部全部置为零 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public void moveZeroes(int[] nums) { int slowIndex=0; for(int fastIndex=0;fastIndex\u0026lt;nums.length;fastIndex++) { if(nums[fastIndex]!=0) { nums[slowIndex++]=nums[fastIndex]; } } for(int i=slowIndex;i\u0026lt;nums.length;i++) { nums[i]=0; } } } leetcode 844. 比较含退格的字符串 题目描述 力扣题目链接\n给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。\n**注意：**如果对空文本输入退格字符，文本继续为空。\n示例 1：\n1 2 3 输入：s = \u0026#34;ab#c\u0026#34;, t = \u0026#34;ad#c\u0026#34; 输出：true 解释：s 和 t 都会变成 \u0026#34;ac\u0026#34;。 示例 2：\n1 2 3 输入：s = \u0026#34;ab##\u0026#34;, t = \u0026#34;c#d#\u0026#34; 输出：true 解释：s 和 t 都会变成 \u0026#34;\u0026#34;。 示例 3：\n1 2 3 输入：s = \u0026#34;a#c\u0026#34;, t = \u0026#34;b\u0026#34; 输出：false 解释：s 会变成 \u0026#34;c\u0026#34;，但 t 仍然是 \u0026#34;b\u0026#34;。 提示：\n1 \u0026lt;= s.length, t.length \u0026lt;= 200 s 和 t 只含有小写字母以及字符 '#' 思路解析 基本思路\n将s和t经过退格操作后的字符串求解出（封装成一个函数） 对比求解后的字符串来判断（主函数中进行） 退格操作的求解思路\n定义快慢指针fastIndex和slowIndex fastIndex从左往右遍历 当遇到非退格符号时slowIndex正常记录数组元素 当遇到退格符号时slowIndex向后退一位 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public boolean backspaceCompare(String s, String t) { String s1=checked(s); String s2=checked(t); if(s1.equals(s2)) { return true; } return false; } //求解退格处理后的字符串 public static String checked(String s) { char[]chars=s.toCharArray(s); int slowIndex=0; for(int fastIndex=0;fastIndex\u0026lt;chars.length;fastIndex++) { //遍历旧数组，不为退格符#的字符保留 if(chars[fastIndex]!=\u0026#39;#\u0026#39;) chars[slowIndex++]=chars[fastIndex]; //遍历旧数组，为退格符#的字符进行退格处理 else if(chars[fastIndex]==\u0026#39;#\u0026#39;) { //slowIndex是新数组的长度 if(slowIndex\u0026gt;0) slowIndex--; } } return new String(chars).substring(0,slow); } } ","date":"2024-12-29T16:21:01+08:00","permalink":"https://Tyritic.github.io/p/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E6%B3%95/","title":"双指针法——快慢指针法"},{"content":"题目特征 前提条件\n数组为有序数组 强调数组中无重复元素 题目的前提是数组为有序数组，同时题目还强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。\n算法模板 左闭右闭（推荐使用） 定义 target 是在一个在左闭右闭的区间里，也就是[left, right] 。\n临界条件的变化 while (left \u0026lt;= right) 要使用 \u0026lt;= ，因为left == right是有意义的，所以使用 \u0026lt;= if (nums[middle] \u0026gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class solution{ public int search(int[]nums,int target) { //定义target处于区间[left,right]中 int left=0; //左边界 int right=nums.length-1; //右边界 while(left\u0026lt;=right) { int mid=left+(right-left)/2; //防止溢出 等同于(left + right)/2 if(nums[mid]\u0026gt;target) right=mid-1; //查找区间为[left,mid-1] else if(nums[mid]\u0026lt;target) left=mid+1; //查找区间为[mid+1.right] else //nums[mid]==target return mid; } return -1; //若未找到返回-1，表示数组中不存在该元素 } } 结果分析 若数组中找不到元素此时满足条件\nleft=right+1 同时nums[left]是大于target的元素中最小的，nums[right]是小于target元素中最大的 左闭右开 定义 target 是在一个在左闭右开的区间里，也就是[left, right） 。\n临界条件的变化 while (left \u0026lt; right) 要使用 \u0026lt; ，因为left == right是没有意义的 if (nums[middle] \u0026gt; target) right 要赋值为 middle ，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle，下一个查询区间不会去比较nums[middle] 代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class solution{ public int search(int[]nums,int target) { //定义target处于区间[left,right)中 int left=0; //左边界 int right=nums.length; //右边界 while(left\u0026lt;right) { int mid=left+(right-left)/2; //防止溢出 等同于(left + right)/2 if(nums[mid]\u0026gt;target) right=mid; //查找区间为[left,mid-1] else if(nums[mid]\u0026lt;target) left=mid+1; //查找区间为[mid+1.right] else //nums[mid]==target return mid; } return -1; //若未找到返回-1，表示数组中不存在该元素 } } 结果分析 若数组中找不到元素此时满足条件\nleft=right 同时nums[left]=nums[right]是大于target的元素中最小的 经典例题 leetcode 704. 二分查找 题目描述 力扣题目链接(opens new window)\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n示例 1:\n1 2 3 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2:\n1 2 3 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示：\n你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 思路分析 直接嵌套算法模板即可\n参考代码 左闭右闭版本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int search(int[] nums, int target) { int left=0,right=nums.length-1; while(left\u0026lt;=right) { int mid=left+(right-left)/2; if(nums[mid]\u0026lt;target) left=mid+1; else if(nums[mid]\u0026gt;target) right=mid-1; else return mid; } return -1; } } 左闭右开版本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int search(int[] nums, int target) { int left=0,right=nums.length; while(left\u0026lt;right) { int mid=left+(right-left)/2; if(nums[mid]\u0026lt;target) left=mid+1; else if(nums[mid]\u0026gt;target) right=mid; else return mid; } return -1; } } leetcode 35. 搜索插入位置 题目描述 力扣题目链接(opens new window)\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n你可以假设数组中无重复元素。\n示例 1:\n输入: [1,3,5,6], 5 输出: 2 示例 2:\n输入: [1,3,5,6], 2 输出: 1 示例 3:\n输入: [1,3,5,6], 7 输出: 4 示例 4:\n输入: [1,3,5,6], 0 输出: 0 思路分析 注意这道题目的前提是数组是有序数组\n同时题目还强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的。\n分别处理四种可能情况\n目标值在数组所有元素之前 [0, -1] 目标值等于数组中某一个元素 return middle 目标值插入数组中的位置 [left, right]，return right + 1 目标值在数组所有元素之后的情况 [left, right]， 因为是右闭区间，所以 return right + 1 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int searchInsert(int[] nums, int target) { int left=0; int right=nums.length-1; while(left\u0026lt;=right) { int mid=left+(right-left)/2; if(nums[mid]\u0026lt;target) { left=mid+1; } else if(nums[mid]\u0026gt;target) { right=mid-1; } else{ return mid; } } // 2.目标值在数组所有元素之前 // 3.目标值插入数组中 // 4.目标值在数组所有元素之后 return right+1; } } leetcode 34. 在排序数组中查找元素的第一个和最后一个位置 题目描述 力扣链接(opens new window)\n给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n如果数组中不存在目标值 target，返回 [-1, -1]。\n进阶：你可以设计并实现时间复杂度为 $O(\\log n)$ 的算法解决此问题吗？\n示例 1：\n输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2：\n输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3：\n输入：nums = [], target = 0 输出：[-1,-1] 思路分析 题目条件\n给定一个按照升序排列的整数数组 nums 一个目标值 target。 符合二分查找的前提条件考虑使用二分查找\n具体思路如下\n首先，在 nums 数组中二分查找 target； 如果二分查找失败，则 binarySearch 返回 -1，表明 nums 中没有 target。此时，searchRange 直接返回 {-1, -1}； 如果二分查找成功，则 binarySearch 返回 nums 中值为 target 的一个下标。然后，通过左右滑动指针，来找到等于target的区间 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public int[] searchRange(int[] nums, int target) { int index=BinarySearch(nums,target); // 1.先进行二分查找 if(index==-1) return new int[]{-1,-1}; int left=index; //左边界 int right=index; //右边界 // 2.移动左边界 while(left\u0026gt;0\u0026amp;\u0026amp;nums[left-1]==nums[index]) left--; // 3.移动右边界 while(right\u0026lt;nums.length-1\u0026amp;\u0026amp;nums[right+1]==nums[index]) right++; return new int[]{left,right}; } public static int BinarySearch(int[] nums, int target) { int left=0; int right=nums.length-1; while(left\u0026lt;=right) { int mid=left+(right-left)/2; if(nums[mid]\u0026lt;target) { left=mid+1; } else if(nums[mid]\u0026gt;target) { right=mid-1; } else{ return mid; } } return -1; } } leetcode 69. x的平方根 题目描述 力扣题目链接\n给你一个非负整数 x ，计算并返回 x 的 算术平方根 。\n由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。\n**注意：**不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\n示例 1：\n1 2 输入：x = 4 输出：2 示例 2：\n1 2 3 输入：x = 8 输出：2 解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 提示：\n0 \u0026lt;= x \u0026lt;= 231 - 1 思路分析 题目中隐含条件，平方根在[1,x]中且该区域为有序递增数组，考虑使用二分查找\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int mySqrt(int x) { if(x==0)return 0; if(x==1)return 1; int left=0,right=x/2; while(left\u0026lt;=right) { int mid=left+(right-left)/2; if(nums[mid]\u0026lt;target) left=mid+1; else if(nums[mid]\u0026gt;target) right=mid-1; else return mid; } return right; //结果为比x小的最大整数 } } leetcode 367. 有效的完全平方数 题目描述 力扣题目链接\n给你一个正整数 num 。如果 num 是一个完全平方数，则返回 true ，否则返回 false 。\n完全平方数 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。\n不能使用任何内置的库函数，如 sqrt 。\n示例 1：\n1 2 3 输入：num = 16 输出：true 解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。 示例 2：\n1 2 3 输入：num = 14 输出：false 解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。 提示：\n1 \u0026lt;= num \u0026lt;= 231 - 1 思路分析 同上一题，注意细节：mid*mid非常容易溢出，所以采取的策略是用除法代替乘法\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public boolean isPerfectSquare(int num) { int left=0; int right=num; if(num==0||num==1)return true;// 1.特殊值判断 while(left\u0026lt;=right) { int mid=left+(right-left)/2; if(mid==num/(mid*1.0)) return true; else if (mid\u0026gt;num/(mid*1.0)) right=mid-1; else left=mid+1; } return false; } } ","date":"2024-12-29T10:52:54+08:00","permalink":"https://Tyritic.github.io/p/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","title":"二分查找"},{"content":"synchronized 关键字 synchronized 是 Java 提供的一种内置同步机制，用于解决多线程环境下的并发安全问题。它能够确保同一时刻只有一个线程执行同步代码块，从而防止线程间的数据不一致和竞态条件。\nsynchronized 的作用 保证原子性：同步代码块在执行时不会被其他线程打断，保证操作的完整性。 保证可见性：线程进入 synchronized 代码块前，必须先从主内存中读取变量最新的值，退出时必须将变量的修改刷新到主内存。 保证有序性：由于 synchronized 具有内存屏障（Memory Barrier），可以保证重排序不会影响同步代码块的正确性。 synchronized 使用方式 同步实例方法 ：为 当前对象 加锁，进入同步代码前要获得当前对象的锁； 同步静态方法 ：为 当前类（Class对象） 加锁，进入同步代码前要获得当前类的锁； 同步代码块 ：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 提示\n构造方法不能使用 synchronized 关键字修饰。但是可以在构造方法内部使用 synchronized 代码块。\n构造方法本身是 线程安全 的，但如果在构造方法中涉及到共享资源的操作，就需要采取适当的同步措施来保证整个构造过程的线程安全。\nsynchronized 修饰实例方法 在实例方法声明中加入 synchronized 关键字，可以保证在任意时刻，只有一个线程能执行该方法。也就是说，线程在执行这个方法的时候，其他线程不能同时执行，需要等待锁释放。\n1 2 3 synchronized void method() { //业务代码 } 注意事项\n修饰实例方法是给当前对象上锁 不同实例的 synchronized 方法不会相互影响（每个对象都有一个对象锁，不同的对象，他们的锁不会互相影响） synchronized 修饰静态方法 给 当前类 加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁。\n静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。\n1 2 3 synchronized static void method() { //业务代码 } 注意事项\n锁的是 当前类的 Class 对象，不属于某个对象。 当前类的 Class 对象锁被获取，不影响实例对象锁的获取，两者互不影响 静态 synchronized 方法和非静态 synchronized 方法之间的调用不互斥（因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。） synchronized 修饰代码块 对括号里指定的对象/类加锁：\nsynchronized(object) ：进入同步代码库前要获得 给定对象的锁。 synchronized(类.class) ：进入同步代码前要获得 给定 Class 的锁 1 2 3 synchronized(this) { //业务代码 } synchronized 属于可重入锁 可重入锁 是指同一个线程在获取了锁之后，可以再次重复获取该锁而不会造成死锁或其他问题。当一个线程持有锁时，如果再次尝试获取该锁，就会成功获取而不会被阻塞。\n因此一个线程调用 synchronized 方法的同时，在其方法体内部调用该对象另一个 synchronized 方法是允许的\n示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class AccountingSync implements Runnable{ static AccountingSync instance=new AccountingSync(); static int i=0; static int j=0; @Override public void run() { for(int j=0;j\u0026lt;1000000;j++){ //this,当前实例对象锁 synchronized(this){ i++; increase();//synchronized的可重入性 } } } public synchronized void increase(){ j++; } public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(instance); Thread t2=new Thread(instance); t1.start();t2.start(); t1.join();t2.join(); System.out.println(i); } } AccountingSync 类中定义了一个静态的 AccountingSync 实例 instance 和两个静态的整数 i 和 j，静态变量被所有的对象所共享。 在 run() 方法中，使用了 synchronized(this) 来加锁。这里的锁对象是 this（当前的 AccountingSync 实例）。在锁定的代码块中，对静态变量 i 进行增加，并调用了 increase() 方法。 increase() 方法是一个同步方法，它会对 j 进行增加。由于 increase() 方法也是同步的，所以它能在已经获取到锁的情况下被 run() 方法调用，体现 synchronized 关键字的可重入性。 在 main 方法中，创建了两个线程 t1 和 t2，它们共享同一个 Runnable 对象 synchronized(this) 和 synchronized 方法都使用了同一个锁对象（当前的 AccountingSync 实例），并且对静态变量 i 和 j 进行了增加操作，因此，在多线程环境下，也能保证 i 和 j 的操作是线程安全的。 实现原理 synchronized 底层是利用计算机系统mutex Lock实现的。每一个可重入锁都会关联一个线程ID和一个锁状态 status。\n当一个线程获取对象锁时，JVM 会将该线程的 ID 写入 Mark Word，并将锁计数器设为 1。 如果一个线程尝试再次获取已经持有的锁，JVM 会检查 Mark Word 中的线程 ID。 如果 ID 匹配，表示的是同一个线程，锁计数器递增。 当线程退出同步块时，锁计数器递减。如果计数器值为零，JVM 将锁标记为未持有状态，并清除线程 ID 信息。 synchronized 底层实现原理 synchronized 实现原理依赖于 JVM 的 Monitor（监视器锁） 和 对象头（Object Header）。\n当 synchronized 修饰在方法或代码块上时，会对特定的对象或类加锁，从而确保同一时刻只有一个线程能执行加锁的代码块。\nsynchronized 修饰方法：会在方法的访问标志中增加一个 ACC_SYNCHRONIZED 标志。每当一个线程访问该方法时，JVM 会检查方法的访问标志。如果包含 ACC_SYNCHRONIZED 标志，线程必须先获得该方法对应的对象的监视器锁（即对象锁），然后才能执行该方法，从而保证方法的同步性。 synchronized 修饰代码块：会在代码块的前后插入 monitorenter 和 monitorexit 字节码指令。 执行 monitorenter 指令时会尝试获取对象锁，如果对象没有被锁定或者已经获得了锁，锁的计数器+1。此时其他竞争锁的线程则会进入等待队列中。\n执行 monitorexit 指令时则会把计数器-1，当计数器值为0时，则锁释放，处于等待队列中的线程再继续竞争锁。\n原子性的保证 线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。 线程加锁后，其它线程无法获取主内存中的共享变量。 线程解锁前，必须把共享变量的最新值刷新到主内存中。 有序性的保证 synchronized 同步的代码块，具有排他性，一次只能被一个线程拥有，所以 synchronized 保证同一时刻，代码是单线程执行的。\n因为 as-if-serial 语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排。\n所以 synchronized 保证的有序是执行结果的有序性，而不是防止指令重排的有序性。\n","date":"2024-12-04T13:16:44+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84synchronized%E5%85%B3%E9%94%AE%E5%AD%97/","title":"Java中的synchronized关键字"},{"content":"volatile 关键字 volatile 是一个修饰符，用来修饰共享变量。它的作用是确保对该变量的读写操作直接在主存中进行，而不使用线程的本地缓存。这意味着所有线程访问 volatile 变量时都会看到该变量的最新值，避免了多线程环境下的内存可见性问题。\nvolatile 关键字的作用 可见性（Visibility）：\n当一个线程修改了 volatile 变量的值，新值会立即被刷新到主存中。 当其他线程读取这个 volatile 变量时，必须从主存读取新值，而不是从本地缓存中读取。 禁止指令重排序（Ordering）：\nvolatile 还通过内存屏障来禁止特定情况下的指令重排序，从而保证程序的执行顺序符合预期。 对 volatile 变量的写操作会在其后插入一个写屏障（写 volatile 变量之前的所有操作，必须在写操作之前完成 ） 对 volatile 变量的读操作则会在其后插入一个 读屏障。（读 volatile 变量之后的所有操作，必须在读操作之后执行。） volatile 可以保证 可见性 ，但不保证 原子性\nvolatile 保证数据可见性 volatile 关键字可以保证变量的可见性，如果将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。\nvolatile 保证指令有序性 在程序执行期间，为了提高性能，编译器和处理器会对指令进行重排序。但涉及到 volatile 变量时，它们必须遵循一定的规则：\n写 volatile 变量的操作之前的操作不会被编译器重排序到写操作之后。 读 volatile 变量的操作之后的操作不会被编译器重排序到读操作之前。 这意味着 volatile 变量的写操作总是发生在任何后续读操作之前。\n写屏障 写 volatile 变量时，强制刷新到主内存： 当一个线程对 volatile 变量进行写操作时，JVM 会插入一个 写屏障（Store Barrier），确保所有修改都会立刻刷新到主内存，而不是保留在线程的本地缓存中。\n这意味着，当线程 A 更新一个 volatile 变量时，其他线程（如线程 B）在读取该 volatile 变量时，可以看到线程 A 写入的最新值。\n写屏障保证\nStoreStore 屏障： 屏障内的 volatile 写操作 不会和屏障外的可能的写操作重排序，确保了在 volatile 写操作 之前的所有写操作都已完成，防止了这些写操作被重排序到 volatile写操作 之后。 StoreLoad 屏障：屏障外 volatile 写操作 不会和屏障内可能的读操作重排序，确保了在 volatile 写操作之后的所有读操作都不会被重排序到 volatile写操作 之前。 读屏障 当线程对 volatile 变量进行读操作时，JMM 会插入一个读屏障指令，这个指令会强制让本地内存中的变量值失效，从而重新从主内存中读取最新的值。\n保证\nLoadLoad 屏障：屏障外的 volatile 读操作 不会和屏障内可能的读操作重排序，确保 volatile 读操作 之后的所有读操作必须在 volatile 读操作 之后执行，防止了这些读操作被重排序到 volatile读操作 之前。 LoadStore 屏障：屏障外 volatile 读操作 不会和屏障内可能的写操作重排序，确保了 volatile读操作 之后的所有写操作必须在 volatile 读操作 之后执行，防止这个写操作被重排序到 volatile读操作 之前。 四种内存屏障的作用 StoreStore 屏障：防止屏障内外写操作的重排序，确保写操作按顺序执行。 LoadLoad 屏障：防止屏障内外读操作的重排序，确保读取操作按顺序执行。 StoreLoad 屏障：确保屏障外写操作先完成，再进行后续的读操作。 LoadStore 屏障：确保屏障外读操作完成后，再执行后续的写操作。 通用作用\n它会强制将对缓存的修改操作立即写入主存； 如果是写操作，它会导致其他 CPU 中对应的缓存行无效。 volatile 不保证原子性 虽然 volatile 保证了可见性和有序性，但它不能保证操作的原子性。原子性意味着一个操作不可分割，不能被中断。典型的例子是 i++ 操作，这实际上分为读取 i 的值、递增、写回三个步骤。如果多个线程同时执行 i++，最终结果可能不正确，因为每个线程都可能读取到相同的初始值。\n总而言之：volatile 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的\n因此 volatile 不能保证线程安全\n解决方式\n使用 AtomicInteger 使用 synchronized 块 volatile 与 synchronized 的对比 性能 volatile 是一种轻量级的同步机制，开销较小，但它只能用于变量的可见性和禁止重排序，无法实现复杂的同步逻辑 synchronized 则是重量级的同步机制，可以保证代码块的原子性和可见性，但开销较大。 使用场景： volatile 适用于简单的状态标志、标记等场景 synchronized 更适合复杂的临界区保护，需要确保多个操作的原子性时。 volatile 关键字在单例模式中的应用 使用双重检查锁定实现的单例模式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Penguin { private static volatile Penguin m_penguin = null; //类的静态变量，用来存储 Penguin 类的唯一实例。 // 一个成员变量 money private int money = 10000; // 避免通过 new 初始化对象，构造方法应为 private private Penguin() {} public void beating() { System.out.println(\u0026#34;打豆豆\u0026#34; + money); } // 对类的 Class 对象加锁，确保在多线程环境下，同时只能有一个线程进入同步代码块。 public static Penguin getInstance() { if (m_penguin == null) { synchronized (Penguin.class) { if (m_penguin == null) { m_penguin = new Penguin(); } } } return m_penguin; } } volatile 关键字用于防止 m_penguin = new Penguin() 这一步被指令重排序。因为实际上，new Penguin() 这一行代码分为三个子步骤：\n步骤 1：为 Penguin 对象分配足够的内存空间 步骤 2：调用 Penguin 的构造方法，初始化对象的成员变量 步骤 3：将内存地址赋值给 m_penguin 变量，使其指向新创建的对象 如果不使用 volatile 关键字，JVM 可能会对这三个子步骤进行指令重排\n为 Penguin 对象分配内存 将对象赋值给引用 m_penguin 调用构造方法初始化成员变量 这种重排序会导致 m_penguin 引用在对象完全初始化之前就被其他线程访问到。\n","date":"2024-12-03T09:32:05+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84volatile%E5%85%B3%E9%94%AE%E5%AD%97/","title":"Java中的volatile关键字"},{"content":"并发和并行 并行：多核 CPU 上的多任务处理，多个任务在同一时间真正地同时执行。 并发：单核 CPU 上的多任务处理，多个任务在同一时间段内交替执行，通过时间片轮转实现交替执行。 同步和异步 同步：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。 异步：调用在发出之后，不用等待返回结果，该调用直接返回。 进程和线程 进程：是对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现了操作系统的并发。 线程：是进程的子任务，是 CPU 调度和分派的基本单位，实现了进程内部的并发。 进程和线程之间的关系 线程在进程下进行 进程之间不会相互影响，主线程结束将会导致整个进程结束 不同的进程数据很难共享 同进程下的不同线程之间数据很容易共享 进程使用内存地址可以限定使用量 Java中的线程和操作系统的线程的关系 在 JDK 1.2 及以后，Java 线程改为基于原生线程（Native Threads）实现，也就是说 JVM 直接使用操作系统原生的内核级线程（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。\n所以本质上 java 程序创建的线程，就是和操作系统线程是一样的，是 1 对 1 的线程模型。\n线程的上下文切换 并发其实是一个 CPU 来应付多个线程。CPU 资源的分配采用了时间片轮转也就是给每个线程分配一个时间片，线程在时间片内占用 CPU 执行任务。当线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占用。\n线程在执行过程中会有自己的运行条件和状态（也称上下文）。线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。\n同时线程可以被多核调度。操作系统的调度器负责将线程分配给可用的 CPU 核心，从而实现并行处理。多核处理器提供了并行执行多个线程的能力。\n线程安全 线程安全的定义 线程安全是指多个线程访问某一共享资源时，能够保证一致性和正确性，即无论线程如何交替执行，程序都能够产生预期的结果，且不会出现数据竞争或内存冲突\n原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作.一个操作或一系列操作要么全部执行成功，要么全部不执行，期间不会被其他线程干扰。在Java中使用了atomic包（这个包提供了一些支持原子操作的类，这些类可以在多线程环境下保证操作的原子性）和 synchronized 关键字来确保原子性\n原子类与锁：Java 提供了 java.util.concurrent.atomic 包中的原子类，如 AtomicInteger ， AtomicLong ，来保证基本类型的操作具有原子性。此外，synchronized 关键字和 Lock 接口也可以用来确保操作的原子性。 CAS（Compare-And-Swap）：Java 的原子类底层依赖于 CAS 操作来实现原子性。CAS 是一种硬件级的指令，它比较内存位置的当前值与给定的旧值，如果相等则将内存位置更新为新值，这一过程是原子的。CAS 可以避免传统锁机制带来的上下文切换开销。 可见性：一个线程对主内存的修改可以及时地被其他线程看到\nvolatile：volatile 关键字是 Java 中用来保证可见性的轻量级同步机制。当一个变量被声明为 volatile 时，所有对该变量的读写操作都会直接从主内存中进行，从而确保变量对所有线程的可见性。 synchronized：synchronized 关键字不仅可以保证代码块的原子性，还可以保证进入和退出 synchronized 块的线程能够看到块内变量的最新值。每次线程退出 synchronized 块时，都会将修改后的变量值刷新到主内存中，进入该块的线程则会从主内存中读取最新的值。 Java Memory Model（JMM）：JMM 规定了共享变量在不同线程间的可见性和有序性规则。它定义了内存屏障的插入规则，确保在多线程环境下的代码执行顺序和内存可见性。 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，在Java中使用了happens-before原则来确保有序性。\n指令重排序：为了提高性能，处理器和编译器可能会对指令进行重排序。尽管重排序不会影响单线程中的执行结果，但在多线程环境下可能会导致严重的问题。例如，经典的双重检查锁定（DCL）模式在没有正确同步的情况下，由于指令重排序可能导致对象尚未完全初始化就被另一个线程访问。 happens-before 原则：JMM 定义了 happens-before 规则，用于约束操作之间的有序性。如果一个操作 A happens-before 操作 B，那么 A 的结果对于 B 是可见的，且 A 的执行顺序在 B 之前。这为开发者提供了在多线程环境中控制操作顺序的手段。 内存屏障：volatile 变量的读写操作会在指令流中插入内存屏障，阻止特定的指令重排序。对于 volatile 变量的写操作，会在写操作前插入一个 StoreStore 屏障，防止写操作与之前的写操作重排序；在读操作之后插入一个 LoadLoad 屏障，防止读操作与之后的读操作重排序。 活跃性：\n死锁是指多个线程因为环形等待锁的关系而永远地阻塞下去。 活锁：线程没有阻塞。当多个线程都在运行并且都在修改各自的状态，而其他线程又依赖这个状态，就导致任何一个线程都无法继续执行，只能重复着自身的动作，于是就发生了活锁。 饥饿：如果一个线程无其他异常却迟迟不能继续运行。 高优先级的线程一直在运行消耗 CPU，所有的低优先级线程一直处于等待； 一些线程被永久堵塞在一个等待进入同步块的状态，而其他线程总是能在它之前持续地对该同步块进行访问； 常见线程安全措施 同步锁：通过 synchronized 关键字或 ReentrantLock 实现对共享资源的同步控制。 原子操作类：Java 提供的 AtomicInteger、AtomicReference 等类确保多线程环境下的原子性操作。 线程安全容器：如 ConcurrentHashMap、CopyOnWriteArrayList 等，避免手动加锁。 局部变量：线程内独立的局部变量天然是线程安全的，因为每个线程都有自己的栈空间（线程隔离）。 ThreadLocal：类似于局部变量，属于线程本地资源，通过线程隔离保证了线程安全。 线程的创建方式 继承 Thread 类 创建一个类继承 Thread 类，并重写 run() 方法\nrun() 方法中定义了线程执行的具体任务。创建该类的实例后，通过调用 start() 方法启动线程\n1 2 3 4 5 6 7 8 9 10 11 class MyThread extends Thread { @Override public void run() { // 线程执行的代码 } } public static void main(String[] args) { MyThread t = new MyThread(); t.start(); } 优缺点\n优点: 编写简单，如果需要访问当前线程，无需使用 Thread.currentThread () 方法，直接使用 this ，即可获得当前线程 缺点：因为线程类已经继承了Thread类，所以不能再继承其他的父类 实现 Runnable 接口 创建一个类实现 Runnable 接口，并重写 run() 方法,使用 Thread 类的构造函数传入 Runnable 对象，调用 start() 方法启动线程\n1 2 3 4 5 6 7 8 9 10 11 class MyRunnable implements Runnable { @Override public void run() { // 线程执行的代码 } } public static void main(String[] args) { Thread t = new Thread(new MyRunnable()); t.start(); } 优缺点\n优点：线程类只是实现了 Runnable 接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。\n缺点：编程稍微复杂，如果需要访问当前线程，必须使用 Thread.currentThread() 方法。\n实现 Callable 接口与 FutureTask 实现 Callable 接口的 call() 方法\n使用 FutureTask 包装 Callable 对象\n再通过 Thread 包裹 FutureTask 对象。\n方法的返回值通过 FutureTask 的 get() 方法获取\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class MyCallable implements Callable\u0026lt;Integer\u0026gt; { @Override public Integer call() throws Exception { // 线程执行的代码，这里返回一个整型结果 return 1; } } public static void main(String[] args) { MyCallable task = new MyCallable(); FutureTask\u0026lt;Integer\u0026gt; futureTask = new FutureTask\u0026lt;\u0026gt;(task); Thread t = new Thread(futureTask); t.start(); try { Integer result = futureTask.get(); // 获取线程执行结果 System.out.println(\u0026#34;Result: \u0026#34; + result); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } } 缺点：编程稍微复杂，如果需要访问当前线程，必须调用 Thread.currentThread() 方法。 优点：线程只是实现Runnable或实现Callable接口，还可以继承其他类。这种方式下，多个线程可以共享一个target对象，非常适合多线程处理同一份资源的情形。 使用线程池（ ExecutorService ） 通过 ExecutorService 提交 Runnable 或 Callable 任务，不直接创建和管理线程，适合管理大量并发任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // 提交Runnable任务 class Task implements Runnable { @Override public void run() { // 线程执行的代码 } } public static void main(String[] args) { ExecutorService executor = Executors.newFixedThreadPool(10); // 创建固定大小的线程池 for (int i = 0; i \u0026lt; 10; i++) { executor.submit(new Task()); // 提交任务到线程池执行 } executor.shutdown(); // 关闭线程池 } //提交Callable任务 import java.util.concurrent.*; class Task implements Callable\u0026lt;String\u0026gt; { @Override public String call() { return \u0026#34;Task executed by \u0026#34; + Thread.currentThread().getName(); } } public class CallableExample { public static void main(String[] args) { ExecutorService executor = Executors.newFixedThreadPool(10); // 创建固定大小的线程池 Future\u0026lt;String\u0026gt;[] results = new Future[10]; // 存储任务的返回结果 for (int i = 0; i \u0026lt; 10; i++) { results[i] = executor.submit(new Task()); // 提交 Callable 任务 } // 获取任务的返回结果 for (Future\u0026lt;String\u0026gt; result : results) { try { System.out.println(result.get()); // get() 方法会阻塞直到结果可用 } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } } executor.shutdown(); // 关闭线程池 } } 优缺点\n缺点：线程池增加了程序的复杂度，特别是当涉及线程池参数调整和故障排查时。错误的配置可能导致死锁、资源耗尽等问题，这些问题的诊断和修复可能较为复杂。 优点：线程池可以重用预先创建的线程，避免了线程创建和销毁的开销，显著提高了程序的性能。对于需要快速响应的并发请求，线程池可以迅速提供线程来处理任务，减少等待时间。并且，线程池能够有效控制运行的线程数量，防止因创建过多线程导致的系统资源耗尽（如内存溢出）。通过合理配置线程池大小，可以最大化CPU利用率和系统吞吐量。 提示\nRunnable 和Callable：\nRunnable 的 run() 方法不返回结果，不能抛出检查异常 Callable 的 call() 方法可以返回结果，并允许抛出检查异常。使用 Callable 更适合需要返回结果或处理异常的并发任务。 Runnable 接口 和 Callable 接口 无返回值的 Runnable 1 2 3 public interface Runnable { public abstract void run(); } 执行完任务之后无法返回任何结果\n有返回值的 Callable 1 2 3 public interface Callable\u0026lt;V\u0026gt; { V call() throws Exception; } call() 方法返回的类型是一个 V 类型的泛型\nFuture 接口和 FutureTask 实现类 1 2 3 4 5 6 7 8 public interface Future\u0026lt;V\u0026gt; { boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; } Future 位于 java.util.concurrent 包下，是一个接口\ncancel() ：取消任务，如果取消任务成功则返回 true，如果取消任务失败则返回 false。 参数 mayInterruptIfRunning 表示是否允许取消正在执行却没有执行完毕的任务，如果设置 true，则表示可以取消正在执行过程中的任务。 isCancelled() ：表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。 isDone() ：表示任务是否已经完成，若任务完成，则返回 true； get()：获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回； get(long timeout, TimeUnit unit)：获取执行结果，如果在指定时间内，还没获取到结果，就直接返回 null。 1 public class FutureTask\u0026lt;V\u0026gt; implements RunnableFuture\u0026lt;V\u0026gt; FutureTask 是唯一的实现类\n构造器\n1 2 3 4 public FutureTask(Callable\u0026lt;V\u0026gt; callable) { } public FutureTask(Runnable runnable, V result) { } 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 创建一个固定大小的线程池 ExecutorService executorService = Executors.newFixedThreadPool(3); // 创建一系列 Callable Callable\u0026lt;Integer\u0026gt;[] tasks = new Callable[5]; for (int i = 0; i \u0026lt; tasks.length; i++) { final int index = i; tasks[i] = new Callable\u0026lt;Integer\u0026gt;() { @Override public Integer call() throws Exception { TimeUnit.SECONDS.sleep(index + 1); return (index + 1) * 100; } }; } // 将 Callable 包装为 FutureTask，并提交到线程池 FutureTask\u0026lt;Integer\u0026gt;[] futureTasks = new FutureTask[tasks.length]; for (int i = 0; i \u0026lt; tasks.length; i++) { futureTasks[i] = new FutureTask\u0026lt;\u0026gt;(tasks[i]); executorService.submit(futureTasks[i]); } // 获取任务结果 for (int i = 0; i \u0026lt; futureTasks.length; i++) { System.out.println(\u0026#34;Result of task\u0026#34; + (i + 1) + \u0026#34;: \u0026#34; + futureTasks[i].get()); } // 关闭线程池 executorService.shutdown(); 控制线程的常用方法 启动线程 public void start() 在 Java 中，启动一个新的线程应该调用其 start() 方法，而不是直接调用 run() 方法。\n当调用 start() 方法时，会启动一个新的线程，并让这个新线程调用 run() 方法。这样，run() 方法就在新的线程中运行，从而实现多线程并发。\n如果直接调用 run() 方法，那么 run() 方法就在当前线程中以同步的方式运行，没有新的线程被创建，也就没有实现多线程的效果。\n线程命名 public void setName(String) ：给当前线程取名字name) public void getName()：获取当前线程的名字。线程存在默认名称 子线程是Thread-索引 主线程是main public static ThreadcurrentThread()：获取当前线程对象，代码在哪个线程中执行 线程休眠 public static void sleep(long millis) throws InterruptedException：使当前正在执行的线程暂停指定的毫秒数，也就是进入休眠的状态，休眠期间线程不会占用 CPU 时间片。休眠结束后，线程会尝试重新获取 CPU 时间片，进入可运行状态，但是不会让出锁。 线程优先执行 public void join() throws InterruptedException public synchronized void join(long millis) throws InterruptedException public synchronized void join(long millis, int nanos) throws InterruptedException 等待这个线程执行完才会轮到后续线程得到 cpu 的执行权\n线程间通信 wait() 让当前线程释放锁并进入等待状态\npublic final void wait() throws InterruptedException public final void wait(long millis) throws InterruptedException public final void wait(long millis, int nanos) throws InterruptedException notify() 唤醒一个等待的线程，具体唤醒哪个等待的线程是随机的，notifyAll() 唤醒所有等待的线程。\npublic final void notify() public final void notifyAll() 中断线程 public void interrupt()：设置线程的中断标志为 true 并立即返回。仅仅是设置标志而不会实际中断 boolean isInterrupted()：检测当前线程是否被中断 boolean interrupted() ： 检测当前线程是否被中断，与 isInterrupted() 不同的是，该方法如果发现当前线程被中断，则会清除中断标志。 public void stop() ：强制线程停止执行，目前已经处于废弃状态，因为 stop 方法会导致线程立即停止，可能会在不一致的状态下释放锁，破坏对象的一致性，导致难以发现的错误和资源泄漏。 响应中断示例\n1 2 3 4 5 6 7 8 9 10 11 public void run() { try { while (!Thread.currentThread().isInterrupted()) { // 执行任务 } } catch (InterruptedException e) { // 线程被中断时的清理代码 } finally { // 线程结束前的清理代码 } } 让出时间片 yield() 方法用于暗示当前线程愿意放弃其当前的时间片，允许其他线程执行。它并不会使线程进入阻塞状态，线程依然处于 RUNNABLE 状态。但是它只是向线程调度器提出建议，调度器可能会忽略这个建议。具体行为取决于操作系统和JVM)的线程调度策略。（和 Thread.sleep(0) 功能相同）\npublic static void yield() 设置线程优先级 public final int getPriority() ：返回此线程的优先级 public final void setPriority(int priority)：更改此线程的优先级，规定线程优先级是1~1010的整数，较大的优先级能提高该线程被 CPU 调度的机率 守护线程 public void setDaemon() 将此线程标记为守护线程。\n守护线程：是服务其他的线程，像 Java 中的垃圾回收线程，就是典型的守护线程。\n当最后一个非守护线程束时， JVM 会正常退出，而不管当前是否存在守护线程（守护线程是否结束并不影响 JVM 退出）\n如果某线程是守护线程，那如果所有的非守护线程都结束了，这个守护线程也会自动结束。\n当所有的非守护线程结束时，守护线程会自动关闭，这就免去了还要继续关闭子线程的麻烦。\n线程默认是非守护线程\n提示\nsleep() 和 wait() 的区别（面试题）\n锁行为不同 当线程执行 sleep() 方法时，它不会释放任何锁。也就是说，如果一个线程在持有某个对象的锁时调用了 sleep，它在睡眠期间仍然会持有这个锁。 而当线程执行 wait() 方法时，它会释放它持有的那个对象的锁，这使得其他线程可以有机会获取该对象的锁。 使用条件不同 sleep() 方法可以在任何地方被调用。 wait() 方法必须在同步代码块或同步方法中被调用，这是因为调用 wait() 方法的前提是当前线程必须持有对象的锁。否则会抛出 IllegalMonitorStateException 异常。 唤醒方式不同 调用 sleep() 方法后，线程会进入 TIMED_WAITING 状态（定时等待状态），即在指定的时间内暂停执行。当指定的时间结束后，线程会自动恢复到 RUNNABLE 状态（就绪状态），等待 CPU 调度再次执行。 调用 wait() 方法后，线程会进入 WAITING 状态（无限期等待状态），直到有其他线程在同一对象上调用 notify() 或 notifyAll()，线程才会从 WAITING 状态转变为 RUNNABLE 状态，准备再次获得 CPU 的执行权。 线程的状态 可以使用Thread中的 getState() 方法获取状态\nJava中的线程状态\nNew（初始状态） ：线程对象创建后，但未调用 start() 方法。 Runnable（可运行状态） ：调用 start() 方法后，线程进入就绪状态，等待 CPU 调度。 Blocked（阻塞状态） ：线程试图获取一个对象锁而被阻塞。 Waiting（等待状态）：线程进入等待状态，需要被显式唤醒才能继续执行。 Timed Waiting（含等待时间的等待状态） ：线程进入等待状态，但指定了等待时间，超时后会被唤醒。 Terminated（终止状态） ：线程执行完成或因异常退出。 NEW（初始状态） 处于 NEW 状态的线程此时尚未启动。这里的尚未启动指的是还没调用 Thread 实例的 start() 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 使用synchronized关键字保证这个方法是线程安全的 public synchronized void start() { // threadStatus != 0 表示这个线程已经被启动过或已经结束了 // 如果试图再次启动这个线程，就会抛出IllegalThreadStateException异常 if (threadStatus != 0) throw new IllegalThreadStateException(); // 将这个线程添加到当前线程的线程组中 group.add(this); // 声明一个变量，用于记录线程是否启动成功 boolean started = false; try { // 使用native方法启动这个线程 start0(); // 如果没有抛出异常，那么started被设为true，表示线程启动成功 started = true; } finally { // 在finally语句块中，无论try语句块中的代码是否抛出异常，都会执行 try { // 如果线程没有启动成功，就从线程组中移除这个线程 if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { // 如果在移除线程的过程中发生了异常，我们选择忽略这个异常 } } } 因此\n反复调用同一个线程的 start() 方法不可行 假如一个线程执行完毕（此时处于 TERMINATED 状态），再次调用这个线程的 start() 方法不可行 在调用 start() 之后，threadStatus 的值会改变（ threadStatus !=0 ），再次调用 start() 方法会抛出 IllegalThreadStateException 异常。\nRUNNABLE（正在运行） 表示当前线程正在运行中。当调用线程的 start() 方法后，线程进入可运行状态。处于 RUNNABLE 状态的线程在 Java 虚拟机中运行，也有可能在等待 CPU 分配资源。\n1 2 3 4 5 6 /** * Thread state for a runnable thread. A thread in the runnable * state is executing in the Java virtual machine but it may * be waiting for other resources from the operating system * such as processor. */ Java 线程的RUNNABLE状态其实包括了操作系统线程的ready和running两个状态\n现代操作系统架构通常都是用所谓的时间分片方式进行抢占式轮转调度。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度。（也即回到 ready 状态）。线程切换的如此之快，区分这两种状态就没什么意义了。\nBLOCKED（阻塞状态） 线程在试图获取一个锁以进入同步块/方法时，如果锁被其他线程持有，线程将进入阻塞状态，直到它获取到锁。处于 BLOCKED 状态的线程正等待锁的释放以进入同步区\nWAITING（等待状态） 等待状态。处于等待状态的线程变成 RUNNABLE 状态需要其他线程唤醒\n调用下面这 3 个方法会使线程进入等待状态：\nObject.wait()：使当前线程处于等待状态直到另一个线程唤醒它； Thread.join()：等待线程执行完毕，底层调用的是 Object 的 wait 方法； LockSupport.park()：除非获得调用许可，否则禁用当前线程进行线程调度 TIMED_WAITING（超时等待） 超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。\nThread.sleep(long millis)：使当前线程睡眠指定时间； Object.wait(long timeout)：线程休眠指定时间，等待期间可以通过notify()/notifyAll()唤醒； Thread.join(long millis)：等待当前线程最多执行 millis 毫秒，如果 millis 为 0，则会一直执行； LockSupport.parkNanos(long nanos)： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间 TERMINATE（终止状态） 当线程的 run() 方法执行完毕后，或者因为一个未捕获的异常终止了执行，线程进入终止状态。一旦线程终止，它的生命周期结束，不能再被重新启动，此时线程已执行完毕\n","date":"2024-12-01T10:47:55+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/","title":"Java中的多线程"},{"content":"HashMap的特点 HashMap 是 Java 中的一个基于 哈希表 的集合类，用于存储键值对（key-value）映射。\n基于哈希表实现：\n数据存储在数组中，每个数组位置对应一个链表或红黑树（JDK 1.8 及以上版本）。\n通过哈希值定位键值对的存储位置。（同时重写 equals() 方法和 hashcode() 方法\n非线程安全：\n多线程操作可能导致数据不一致问题。 允许 null：\n键和值均可以为 null，但键只能有一个 null。 动态扩容：\n默认初始容量为 16。\n加载因子为 0.75。\n当使用的存储空间超过阈值（容量 × 加载因子）时，HashMap 会动态扩容。\nHashMap提升性能的建议 合理设置初始容量：如果在使用时可以预估 HashMap 存储的数据量大小，那么需要在创建时设置一个合适的初始容量，以避免频繁的扩容操作。Java 中 HashMap 默认初始容量是 16。 调整负载因子：官方提供的默认负载因子是 0.75。可以根据具体应用场景调整这个值。较低的负载因子会减少冲突，提高查找效率，但会占用更多内存（更加容易触发扩容）。较高的负载因子则会减少内存消耗，但可能增加冲突的概率，降低查找效率。 高并发读取场景：可以降低负载因子，以减少哈希冲突，提高读取性能。 内存受限场景：可以提高负载因子，以减少扩容次数和内存消耗，但可能会降低写入和查询的性能。 确保 hashCode 均匀分布：对应 key 的 hashCode() 方法生成的哈希值需均匀分布，减少哈希冲突。避免使用质量不高的哈希函数，防止大量键映射到相同的槽位上，造成性能瓶颈。 HashMap的常用方法 构造方法 public HashMap()：默认构造方法 public HashMap(int initialCapacity)：指定初始容量的构造方法 public HashMap(int initialCapacity, float loadFactor)：指定初始容量和加载因子的构造方法 public HashMap(Map\u0026lt;? extends K, ? extends V\u0026gt; m)：从其他 Map 初始化的构造方法 添加键值对 public V put(K key, V value)：添加或更新键值对 public void putAll(Map\u0026lt;? extends K, ? extends V\u0026gt; m)：批量添加键值对 删除键值对 public V remove(Object key)：移除键值对 public boolean remove(Object key, Object value)：按键值同时匹配移除 查询键值对 public V get(Object key)：获取值 public boolean containsKey(Object key)：检查是否包含键 public boolean containsValue(Object value)：检查是否包含值 public V getOrDefault(Object key, V defaultValue)：获取默认值 视图操作 public Set\u0026lt;K\u0026gt; keySet()：获取所有键的集合 public Collection\u0026lt;V\u0026gt; values()：获取所有值的集合 public Set\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; entrySet()：获取所有键值对的集合 替换操作 public V replace(K key, V value)：替换值 public boolean replace(K key, V oldValue, V newValue)：条件替换值 遍历操作 使用for-each循环和entrySet()方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import java.util.HashMap; import java.util.Map; public class MapTraversalExample { public static void main(String[] args) { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;key1\u0026#34;, 1); map.put(\u0026#34;key2\u0026#34;, 2); map.put(\u0026#34;key3\u0026#34;, 3); // 使用for-each循环和entrySet()遍历Map for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { System.out.println(\u0026#34;Key: \u0026#34; + entry.getKey() + \u0026#34;, Value: \u0026#34; + entry.getValue()); } } } 使用for-each循环和keySet()方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import java.util.HashMap; import java.util.Map; public class MapTraversalExample { public static void main(String[] args) { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;key1\u0026#34;, 1); map.put(\u0026#34;key2\u0026#34;, 2); map.put(\u0026#34;key3\u0026#34;, 3); // 使用for-each循环和keySet()遍历Map的键 for (String key : map.keySet()) { System.out.println(\u0026#34;Key: \u0026#34; + key + \u0026#34;, Value: \u0026#34; + map.get(key)); } } } 使用 Lambda 表达式和forEach()方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.util.HashMap; import java.util.Map; public class MapTraversalExample { public static void main(String[] args) { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;key1\u0026#34;, 1); map.put(\u0026#34;key2\u0026#34;, 2); map.put(\u0026#34;key3\u0026#34;, 3); // 使用Lambda表达式和forEach()方法遍历Map map.forEach((key, value) -\u0026gt; System.out.println(\u0026#34;Key: \u0026#34; + key + \u0026#34;, Value: \u0026#34; + value)); } } HashMap的底层原理 存储原理 JDK 1.7 以前 在 JDK 1.7 版本之前， HashMap 数据结构是数组和链表，HashMap 通过哈希算法将元素的键映射到数组中的槽位。如果多个键映射到同一个槽位，它们会以链表的形式存储在同一个槽位上，因为链表的查询时间是$O(n)$，所以冲突很严重，一个索引上的链表非常长，效率就很低了。\nHashMap 的默认初始容量为 16，负载因子为 0.75。也就是说，当存储的元素数量超过 16 × 0.75 = 12 个时，HashMap 会触发扩容操作，\n当要塞入一个键值对的时候，会根据一个 hash 算法计算 key 的 hash 值，然后通过数组大小 n-1 \u0026amp; hash 值之后，得到一个数组的下标，然后往那个位置塞入这键值对。当发生哈希冲突时会使用闭散列法\n链表的插入采用的是头插法，即每当发生哈希冲突时，新的节点总是插入到链表的头部，老节点依次向后移动，形成新的链表结构。\n在多线程环境下，头插法可能导致链表形成环，特别是在并发扩容时。当多个线程同时执行 put() 操作时，如果线程 A 正在进行头插，线程 B 也在同一时刻操作链表，可能导致链表结构出现环路，从而引发死循环，最终导致程序卡死或无限循环。\nJDK 1.8以后 在 JDK 1.8 版本的时候做了优化，当一个链表的长度超过 8 且数组大小大于等于 64 的时候就转换数据结构，不再使用链表存储，而是使用红黑树，查找时使用红黑树，时间复杂度为$O(log n)$，可以提高查询性能，但是在红黑树节点数量较少时，即数量小于6 时，会将红黑树转换回链表。\n在 JDK1.8 的时候，改成了尾插法，即新的节点插入到链表的尾部，保持插入的顺序。并且引入了红黑树。\nhash方法的底层实现 1 2 3 4 5 6 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); // 如果键值为 null，则哈希码为 0（依旧是说如果键为 null，则存放在第一个位置）； // 否则，通过调用hashCode()方法获取键的哈希码，并将其与右移 16 位的哈希码进行异或运算。 } 目的：将 key 的 hashCode 值进行处理，得到最终的哈希值。hash 方法就是为了增加随机性，让数据元素更加均衡的分布，减少碰撞\n将哈希值无符号右移 16 位，高位补0，意味着原哈希值的高 16 位被移到了低 16 位的位置。再与自身进行异或操作，从而使得原始哈希值的高 16 位和低 16 位就可以参与到最终用于索引计算的低位中。\n示例\n1 2 3 4 原始: 0001 0010 0011 0100 0101 0110 0111 1000 右移: 0000 0000 0000 0000 0001 0010 0011 0100 异或: --------------------------------------- 结果: 0001 0010 0011 0100 0100 0100 0100 1100 数组索引计算原理 通常基于哈希值计算数组下标使用该公式：hash % length，其中 hash 为以经过 hash() 方法优化后的哈希值， length 为数组容量\n从二进制的角度上是获取 hash 的二进制表示中最低 n 位的值。\n因此取余运算可以使用位运算代替，当 length 是 2 的幂时，n - 1 的二进制表示是全 1（如 n=16，n-1=15，即 1111），这样按位与操作实际上会相当于对 hash 的低 $log(length)$ 位进行保留。\n故可得公式：hash \u0026amp; (length - 1) = hash % length = (length - 1) \u0026amp; hash\n示例：hash 为 14，length 为 8，也就是**n**为3\n1 2 3 4 1110 (hash = 14) \u0026amp; 0111 (length - 1 = 7) ---- 0110 (结果 = 6) 提示\n为什么数组长度（容量）设计为2的n次方\nHashMap 采用 2 的 n 次方倍作为容量，主要是为了提高哈希值的分布均匀性和哈希计算的效率。\nHashMap 通过 (length - 1) \u0026amp; hash 来计算元素存储的索引位置，这种位运算只有在数组容量是 2 的 n 次方时才能确保索引均匀分布。位与运算的效率高于取模运算（hash % length），提高了哈希计算的速度。\n且当 HashMap 扩容时，通过容量为 2 的 n 次方，扩容时只需通过简单的位运算判断是否需要迁移，这减少了重新计算哈希值的开销，提升了重新哈希的效率。\n哈希碰撞的解决方法 Hash 碰撞是指在使用哈希算法时，不同的输入数据通过哈希函数计算后，得到了相同的哈希值（即散列值）。因为哈希值相同，所以这些键会被映射到哈希表的同一个位置，从而引发“碰撞”。\n解决方法\n拉链法（闭散列法）：将哈希表中每个槽的位置变成一个链表，当多个键的哈希值相同时，将它们存储在同一个链表中。 开放寻址法（开散列法）：如果出现碰撞，寻找哈希表中的下一个可用位置。 再哈希法（双重哈希）：在出现碰撞时，使用第二个哈希函数计算新的索引位置，减少碰撞的概率。 拉链法（闭散列法） 使用链表来处理冲突，每个哈希表的槽不仅存储单个元素，而是存储指向链表头部的指针。所有具有相同哈希值的元素都会被放入到同一个链表中。!\n优点：\n简单易实现，扩展性好。 在处理大量数据时，性能更为稳定。 缺点：\n如果碰撞频繁，链表会变长，导致查询性能下降。 需要额外的内存来存储链表的指针。 开放寻址法（开散列法） 在哈希表中寻找下一个空闲的槽位以存储发生碰撞的元素。\n线性探查法：在哈希表中查找下一个连续的空槽，将碰撞的键存入该槽中。 平方探查法：类似于线性探查，但探查的步长是二次方，减少了聚集问题。 双散列法：使用两个不同的哈希函数，第一次哈希决定初始位置，第二次哈希决定探查步长。 优点：\n不需要额外的内存来存储指针或链表结构。 如果负载因子低，查找和插入的效率较高。 缺点：\n随着哈希表的填充度增加，探查的次数会增加，导致性能下降。 删除元素时候，不能真的删除，只能打标，否则会导致查找错误。只能在下一个元素插入时，发现标记后才能替换原来的元素。 再哈希法（双重哈希） 在出现碰撞时，使用第二个哈希函数计算新的索引位置，减少碰撞的概率\n扩容机制 HashMap的默认负载因子为0.75，初始长度为16（初始化时可以指定容量，HashMap 会将这个值转换为大于或等于 17 的最小的 2 的幂。）\n当 HashMap 中的键值对中的数量大于容量*负载因子时发生扩容，容量扩大为当前容量的两倍\n扩容时，HashMap 需要重新计算所有元素的哈希值，并将它们重新分配到新的哈希桶中，这个过程称为 rehashing 。每个元素的存储位置会根据新容量的大小重新计算哈希值，并移动到新的数组中。\nJDK 1.7以前，所有元素的哈希值，并将它们重新分配到新的哈希桶中\nJDK 1.7以后，进行了优化。不需要每个节点重新 hash 算下标。因为元素的新位置只与高位有关\n此时重新哈希只要判断原来的hash拓展后新增的位是0还是1\n若为0则保持在原来的位置（hash 1 保持为 5）\n若为1则被移动到原来的位置加上旧数组长度的地方（hash 2 被移动到 5+16=21 处）\n插入原理（put方法） 根据要添加的键的哈希码（ hashcode() 方法+ hash 方法）计算在数组中的位置（索引） 检查该位置是否为空（即没有键值对存在） 如果为空，则直接在该位置创建一个新的Entry对象来存储键值对。将要添加的键值对作为该Entry的键和值，并保存在数组的对应位置。 如果不为空则遍历链表或者红黑树检查键值对的键是否与要添加的键值对的键相同（ equals() 方法） 如果相同，则表示找到了相同的键，直接将新的值替换旧的值，完成更新操作。 若不相同，根据对应的数据结构进行插入工作 检查链表长度是否达到阈值（默认为 8）：如果链表长度超过阈值，且 HashMap 的数组长度大于等于 64，则会将链表转换为红黑树，以提高查询效率 检查负载因子是否超过阈值（默认为 0.75）：如果键值对的数量（size）与数组的长度的比值大于阈值，则需要进行扩容操作 扩容操作： 创建一个新的两倍大小的数组。 将旧数组中的键值对重新计算哈希码并分配到新数组中的位置。 更新 HashMap 的数组引用和阈值参数。 完成添加操作。 equals方法和hashcode方法 HashMap 在比较元素时\n使用对象的 hashCode() 计算出桶的位置。\n在该位置，通过 equals() 方法检查键是否相等。\n所以 equals 相等的两个对象，hashCode一定相等。hashCode相等的两个对象，equals 不一定相等（比如散列冲突的情况）\n重写了 equals() 方法，不重写 hashCode() 方法时，可能会出现 equals() 方法返回为true，而 hashCode() 方法却返回false，这样的话，这两个逻辑上相同的对象会被放到不同的桶中，这样就会导致 get() 的时候，找不到对应的值。\nJDK 1.8 的改动 改进了哈希函数的计算：JDK 1.8 中优化了哈希函数，使得哈希值的分布更加均匀，减少了哈希冲突的发生。通过在生成哈希值时使用“扰动函数”，确保哈希值的高低位都能参与到桶的选择中。 扩容机制优化：JDK 1.8 改进了扩容时的元素迁移机制。在扩容过程中不再对每个元素重新计算哈希值，而是根据原数组长度的高位来判断元素是留在原位置，还是迁移到新数组中的新位置。这一改动减少了不必要的计算，提升了扩容效率。 头插法变为尾插法：头插法的好处就是插入的时候不需要遍历链表，直接替换成头结点，但是缺点是扩容的时候会逆序，而逆序在多线程操作下可能会出现环，产生死循环，于是改为尾插法。 HashMap的线程安全问题 JDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。 多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。 自定义HashMap 内部节点类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** * 节点类 * * @param \u0026lt;K\u0026gt; * @param \u0026lt;V\u0026gt; */ class Node\u0026lt;K, V\u0026gt; { //键值对 private K key; private V value; //链表，后继 private Node\u0026lt;K, V\u0026gt; next; public Node(K key, V value) { this.key = key; this.value = value; } public Node(K key, V value, Node\u0026lt;K, V\u0026gt; next) { this.key = key; this.value = value; this.next = next; } } 成员变量 1 2 3 4 5 6 7 8 //默认容量 final int DEFAULT_CAPACITY = 16; //负载因子 final float LOAD_FACTOR = 0.75f; //HashMap的大小 private int size; //桶数组 Node\u0026lt;K, V\u0026gt;[] buckets; 构造方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * 无参构造器，设置桶数组默认容量 */ public OwnHashMap() { buckets = new Node[DEFAULT_CAPACITY]; size = 0; } /** * 有参构造器，指定桶数组容量 * * @param capacity */ public OwnHashMap(int capacity) { buckets = new Node[capacity]; size = 0; } 哈希函数 1 2 3 4 5 6 7 8 9 10 11 12 13 /** * 哈希函数，获取地址 * * @param key * @return */ private int getIndex(K key, int length) { //获取hash code int hashCode = key.hashCode(); //和桶数组长度取余 int index = hashCode % length; return Math.abs(index); } 添加键值对 获取元素插入位置 当前位置为空，直接插入 位置不为空，发生冲突，遍历链表 如果元素key和节点相同，覆盖 否则新建节点插入链表头部 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /** * 将元素存入指定的node数组 * * @param key * @param value * @param table */ private void putVal(K key, V value, Node\u0026lt;K, V\u0026gt;[] table) { //获取位置 int index = getIndex(key, table.length); Node node = table[index]; //插入的位置为空 if (node == null) { table[index] = new Node\u0026lt;\u0026gt;(key, value); size++; return; } //插入位置不为空，说明发生哈希冲突，使用闭散列法,遍历链表 while (node != null) { //如果key相同，就覆盖掉 if ((node.key.hashCode() == key.hashCode()) \u0026amp;\u0026amp; (node.key == key || node.key.equals(key))) { node.value = value; return; } node = node.next; } //当前key不在链表中，插入链表头部 Node newNode = new Node(key, value, table[index]); table[index] = newNode; size++; } /** * put方法 * * @param key * @param value * @return */ public void put(K key, V value) { //判断是否需要进行扩容 if (size \u0026gt;= buckets.length * LOAD_FACTOR) resize(); putVal(key, value, buckets); } 扩容机制 创建两倍容量的新数组 将当前桶数组的元素重新散列到新的数组 新数组置为map的桶数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * 扩容 */ private void resize() { //创建一个两倍容量的桶数组 Node\u0026lt;K, V\u0026gt;[] newBuckets = new Node[buckets.length * 2]; //将当前元素重新散列到新的桶数组 rehash(newBuckets); buckets = newBuckets; } /** * 重新散列当前元素 * * @param newBuckets */ private void rehash(Node\u0026lt;K, V\u0026gt;[] newBuckets) { //map大小重新计算 size = 0; //将旧的桶数组的元素全部刷到新的桶数组里 for (int i = 0; i \u0026lt; buckets.length; i++) { //为空，跳过 if (buckets[i] == null) { continue; } Node\u0026lt;K, V\u0026gt; node = buckets[i]; while (node != null) { //将元素放入新数组 putVal(node.key, node.value, newBuckets); node = node.next; } } } 获取键值对的值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * 获取元素 * * @param key * @return */ public V get(K key) { //获取key对应的地址 int index = getIndex(key, buckets.length); if (buckets[index] == null) return null; Node\u0026lt;K, V\u0026gt; node = buckets[index]; //查找链表 while (node != null) { if ((node.key.hashCode() == key.hashCode()) \u0026amp;\u0026amp; (node.key == key || node.key.equals(key))) { return node.value; } node = node.next; } return null; } HashMap的衍生类——LinkedHashMap类 LinkedHashMap 是 Java 集合框架中的一个实现类，它继承自 HashMap，并且保留了键值对的插入顺序或访问顺序。\n它内部是通过维护了一个双向链表来记录元素的插入顺序或访问顺序。\n底层实现 LinkedHashMap 内部追加了双向链表，来维护元素的插入顺序\n1 2 3 4 5 6 static class Entry\u0026lt;K,V\u0026gt; extends HashMap.Node\u0026lt;K,V\u0026gt; { Entry\u0026lt;K,V\u0026gt; before, after; Entry(int hash, K key, V value, Node\u0026lt;K,V\u0026gt; next) { super(hash, key, value, next); } } 在 LinkedHashMap 中，链表中的节点顺序是按照插入顺序维护的。当使用 put() 方法向 LinkedHashMap 中添加键值对时，会将新节点插入到链表的尾部，并更新 before 和 after 属性，以保证链表的顺序关系\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 将指定节点插入到链表的尾部 * * @param p 要插入的节点 */ private void linkNodeLast(LinkedHashMap.Entry\u0026lt;K,V\u0026gt; p) { LinkedHashMap.Entry\u0026lt;K,V\u0026gt; last = tail; // 获取链表的尾节点 tail = p; // 将 p 设为尾节点 if (last == null) head = p; // 如果链表为空，则将 p 设为头节点 else { p.before = last; // 将 p 的前驱节点设为链表的尾节点 last.after = p; // 将链表的尾节点的后继节点设为 p } } 访问顺序 LinkedHashMap 不仅能够维持插入顺序，还能够维持访问顺序。访问包括调用 get() 方法、remove() 方法和 put() 方法。\n只需要在**LinkedHashMap**的构造方法中加入一个 Boolean 参数\n如果为 true 的话，就表示 LinkedHashMap 要维护访问顺序\n如果为 false 的话，就表示 LinkedHashMap 要维护插入顺序。\n默认是 false。\n这样便于使用LRU算法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 public class LRUCache\u0026lt;K,V\u0026gt; { class Node\u0026lt;K,V\u0026gt; { K key; V value; Node\u0026lt;K,V\u0026gt; prev, next; public Node(){} public Node(K key, V value) { this.key = key; this.value = value; } } private int capacity; private HashMap\u0026lt;K,Node\u0026gt; map; // 虚拟头尾节点 private Node\u0026lt;K,V\u0026gt; head; private Node\u0026lt;K,V\u0026gt; tail; public LRUCache(int capacity) { this.capacity = capacity; map = new HashMap\u0026lt;\u0026gt;(capacity); head = new Node\u0026lt;\u0026gt;(); tail = new Node\u0026lt;\u0026gt;(); head.next = tail; tail.prev = head; } public V get(K key) { Node\u0026lt;K,V\u0026gt; node = map.get(key); if (node == null) { return null; } moveNodeToHead(node); return node.value; } public void put(K key, V value) { Node\u0026lt;K,V\u0026gt; node = map.get(key); if (node == null) { if (map.size() \u0026gt;= capacity) { map.remove(tail.prev.key); removeTailNode(); } Node\u0026lt;K,V\u0026gt; newNode = new Node\u0026lt;\u0026gt;(key, value); map.put(key, newNode); addToHead(newNode); //置于表头 } else { node.value = value; moveNodeToHead(node); } } // 将节点添加到表头 private void addToHead(Node\u0026lt;K,V\u0026gt; newNode) { // 新节点和head节点以及head节点的后驱节点双向链接 newNode.prev = head; newNode.next = head.next; // head节点的后驱节点和新节点单向链接 head.next.prev = newNode; // head节点和新节点单向链接 head.next = newNode; } // 将当前节点移动到表头 private void moveNodeToHead(Node\u0026lt;K,V\u0026gt; node) { removeNode(node); addToHead(node); } // 删除当前节点 private void removeNode(Node\u0026lt;K,V\u0026gt; node) { // 当前节点的前驱节点和当前节点的后驱节点双向链接 node.prev.next = node.next; node.next.prev = node.prev; } // 删除尾节点 private void removeTailNode() { removeNode(tail.prev); } public static void main(String[] args) { LRUCache\u0026lt;Integer,Integer\u0026gt; lruCache = new LRUCache\u0026lt;\u0026gt;(3); lruCache.put(1,1); lruCache.put(2,2); lruCache.put(3,3); lruCache.get(1); lruCache.put(4,4); System.out.println(lruCache); } } HashMap的衍生类——TreeMap类 TreeMap 内部是通过红黑树实现的，可以让 key 的实现 Comparable 接口或者自定义实现一个 comparator 传入构造函数，这样塞入的节点就会根据你定义的规则进行排序。\n基本特性： 数据结构：TreeMap 基于红黑树实现，红黑树是一种自平衡的二叉查找树，能够保证基本操作（插入、删除、查找）的时间复杂度为 $O(log n)$。 键的有序性：TreeMap 中的键是有序的，默认按自然顺序（键的 Comparable 实现）排序，也可以通过构造时提供的 Comparator 进行自定义排序。 不允许 null 键：TreeMap 不允许键为 null，但允许值为 null。 与HashMap的区别 HashMap 是基于数组+链表+红黑树实现的，加入元素的时候会先计算 key 的哈希值，然后通过哈希值计算出元素在数组中的存放下标，然后将元素插入到指定的位置，如果发生哈希冲突，会使用链表来解决，如果链表长度大于 8，会转换为红黑树。\nTreeMap 是基于红黑树实现的，加入元素的时候会先判断根节点是否为空，如果为空，直接插入到根节点，如果不为空，会通过 key 的比较器来判断元素应该插入到左子树还是右子树。\n在没有发生哈希冲突的情况下，HashMap 的查找效率是 $O(1)$。适用于查找操作比较频繁的场景。\nTreeMap 的查找效率是 $O(logn)$。并且保证了元素的顺序，因此适用于需要大量范围查找或者有序遍历的场景。\n示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import java.util.Comparator; import java.util.TreeSet; class Person { String name; int age; Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, age=\u0026#34; + age + \u0026#34;}\u0026#34;; } } public class TreeSetExample2 { public static void main(String[] args) { // 自定义排序规则：按名字字典序排列 Comparator\u0026lt;Person\u0026gt; nameComparator = (p1, p2) -\u0026gt; p1.name.compareTo(p2.name); TreeSet\u0026lt;Person\u0026gt; treeSet = new TreeSet\u0026lt;\u0026gt;(nameComparator); treeSet.add(new Person(\u0026#34;Alice\u0026#34;, 30)); treeSet.add(new Person(\u0026#34;Charlie\u0026#34;, 35)); treeSet.add(new Person(\u0026#34;Bob\u0026#34;, 25)); for (Person person : treeSet) { System.out.println(person); } } } HashMap的衍生类——ConcurrentHashMap类 ConcurrentHashMap 是 Java 提供的一种线程安全的哈希表实现，位于 java.util.concurrent 包中，广泛用于高并发环境下。它与传统的 HashMap 不同，能够在多个线程并发操作时保持高效性和一致性。\n特点 线程安全： 多线程可以同时操作不同的桶，提高并发性能。 高效性： 通过细粒度锁或无锁机制（CAS），在高并发场景下效率比 Hashtable 更高。 不允许 null 键和值： 如果尝试插入 null 键或 null 值，会抛出 NullPointerException。 支持部分并发操作： 可以在迭代期间执行插入或删除操作，不会抛出 ConcurrentModificationException。 不支持键或值为null： 构造方法 public ConcurrentHashMap()：创建一个默认的 ConcurrentHashMap 实例\npublic ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)\ninitialCapacity：初始容量。 loadFactor：负载因子。 concurrencyLevel：并发级别（用于估计并发线程数，JDK 1.8 后不再显式使用）。 底层实现 JDK 1.7之前 在 JDK 1.7 中它使用的是数组加链表的形式实现的\n实现思想\n基于 分段锁机制（Segmented Locking），其核心思想是将整个哈希表分成多个段（ Segment ），每个段独立加锁，从而实现线程安全的高效访问。默认是 16 个 Segment ，所以最多有 16 个线程可以并发执行。\n核心数据结构\n一个 ConcurrentHashMap 里包含一个 Segment 数组，一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素。\nSegment：一种可重入锁，继承了 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色用来保护段内的数据安全。 HashEntry：表示一个键值对节点，类似于 HashMap 的链表节点 分段锁技术将数据分成一段一段的存储，然后给每一段数据配一把锁，不同 Segment 之间的操作互不影响，从而提高并发性能。。当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。\n先通过 key 的 hash 函数判断得到 Segment 数组的下标，将这个 Segment 上锁 再次通过 key 的 hash 函数得到 Segment 里 HashEntry 数组的下标 可以简化理解：每个 Segment 数组存放的就是一个单独的 HashMap\n缺陷\nSegment 数组一旦初始化了之后不会扩容，只有 HashEntry 数组会扩容，这就导致并发度过于死板，不能随着数据的增加而提高并发度\nJDK 1.7以后 ConcurrentHashMap 做了更细粒度的锁控制，可以理解为 HashMap 的节点数组的每个位置都是一把锁，这样扩容了锁也会变多，并发度也会增加。\n加锁机制 分段锁加锁机制（JDK 1.7以前） 在 ConcurrentHashMap 中，将整个数据结构分为多个 Segment，每个 Segment 都类似于一个小的 HashMap，每个 Segment 都有自己的锁，不同 Segment 之间的操作互不影响，从而提高并发性能。\n不同 Segment 的并发写入（可以并发执行） 同一 Segment 的一写一读（可以并发执行） 同一 Segment 的并发写入（同一 Segment 的并发写入会被阻塞） 在 ConcurrentHashMap 中，对于插入、更新、删除等操作，需要先定位到具体的 Segment，然后再在该 Segment 上加锁，而不是像传统的 HashMap 一样对整个数据结构加锁。这样可以使得不同 Segment 之间的操作并行进行，提高了并发性能。\nget操作（读操作）\n​\tget操作是无锁的。读操作不会阻塞写操作，从而提高了并发性能\n通过 volatile 保证 HashEntry 的可见性，允许多个线程同时读取。 遍历链表或红黑树时无需加锁。 put/remove操作（写操作）\n写操作如 put() 和 remove() 需要加锁，以确保写入时的线程安全性和一致性\n根据哈希值找到目标 Segment。 使用 lock() 方法（可重入锁）锁定该 Segment。 在加锁状态下，检查是否存在相同键： 存在：更新值。 不存在：插入新节点。 扩容机制\n基于 Segment：ConcurrentHashMap是由多个 Segment 组成的，每个 Segment 中包含一个 HashMap。当某个Segment 内的 HashMap 达到扩容阈值时，单独为该 Segment 进行扩容，而不会影响其他 Segment。 扩容过程：每个 Segment 维护自己的负载因子，当 Segment 中的元素数量超过阈值时，该 Segment 的 HashMap 会扩容，整体的 ConcurrentHashMap 并不是一次性全部扩容。 悲观锁和乐观锁（JDK 1.7以后） get操作（读操作）\n​\tget操作是无锁的。\n直接定位到目标桶，读取链表或红黑树中的数据。 由于数据节点的 value 是 volatile 修饰的，确保多线程下读取的数据一致性。 put操作（写操作）\n计算键的哈希值，定位目标桶。 如果桶为空，尝试使用 volatile 和 CAS（乐观锁） 创建新节点。 如果 CAS 失败或桶非空，使用 synchronized（悲观锁）锁定该桶： 遍历链表或者红黑树检查键值对的键是否与要添加的键值对的键相同（ equals() 方法） 如果相同，则表示找到了相同的键，直接将新的值替换旧的值，完成更新操作。 若不相同，根据对应的数据结构进行插入工作 如果链表长度超过阈值（8），将链表转换为红黑树。 扩容机制\n全局扩容：ConcurrentHashMap取消了Segment，变成了一个全局的数组（类似于 HashMap）。因此，当 ConcurrentHashMap 中任意位置的元素超过阈值时，整个 ConcurrentHashMap 的数组都会被扩容。 基于 CAS 的扩容：在扩容时，ConcurrentHashMap 采用了类似 HashMap 的方式，但通过CAS 操作确保线程安全，避免了锁住整个数组。在扩容时，多个线程可以同时帮助完成扩容操作。 渐进式扩容：JDK 1.8 的 ConcurrentHashMap 引入了渐进式扩容机制，扩容时并不是一次性将所有数据重新分配，而是多个线程共同参与，逐步迁移旧数据到新数组中，降低了扩容时的性能开销。 为什么不允许键和值为 null ConcurrentHashMap 的 key 和 value 不能为 null 主要是为了避免二义性。null 是一个特殊的值，表示没有对象或没有引用。如果你用 null 作为键，那么你就无法区分这个键是否存在于 ConcurrentHashMap 中，还是根本没有这个键。\n如果你用 null 作为值，那么你就无法区分这个值是否是真正存储在 ConcurrentHashMap 中的，还是因为找不到对应的键而返回的。\n","date":"2024-11-26T13:02:26+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84hashmap%E7%B1%BB%E5%8F%8A%E5%85%B6%E8%A1%8D%E7%94%9F%E7%B1%BB/","title":"Java中的HashMap类及其衍生类"},{"content":"Map接口的定义 Map 接口是 Java 集合框架中的一部分，用于存储键值对（key-value）的映射关系。Map 中的键是唯一的，而值可以重复。\nMap集合的特点 键值对存储： 每个元素由一个键（key）和一个值（value）组成。 键必须唯一，但值可以重复。 键的唯一性： 键的唯一性是通过调用键的 hashCode() 和 equals() 方法来保证的。 允许的值： 键和值都可以为 null，但实现类的行为可能不同： HashMap：允许一个 null 键和多个 null 值。 TreeMap：不允许 null 键。 Hashtable：不允许 null 键或 null 值。 无序或有序： HashMap 是无序的。 LinkedHashMap 按插入顺序或访问顺序存储。 TreeMap 按键的自然顺序或自定义排序存储。 线程安全性： HashMap 和 TreeMap 是非线程安全的。 Hashtable 和 ConcurrentHashMap 是线程安全的。 Map接口的实现类 HashMap： 基于哈希表实现，允许一个 null 键和多个 null 值。 无序。 LinkedHashMap： 基于哈希表和双向链表，维护插入顺序或访问顺序。 TreeMap： 基于红黑树实现，按自然顺序或自定义比较器排序键。 Hashtable： 线程安全，但性能较差，不允许 null 键或值。 ConcurrentHashMap： 线程安全，支持高并发。 Map 接口常用方法 添加键值对 1 V put(K key, V value) 添加或更新键值对。如果键已存在，返回旧值；否则返回 null。 1 default V putIfAbsent(K key, V value) 如果键不存在，添加键值对。 获取值 1 V get(Object key) 根据键获取对应的值。如果键不存在，返回 null 1 default V getOrDefault(Object key, V defaultValue) 如果键存在，返回对应的值；否则返回 defaultValue。 删除键值对 1 V remove(Object key) 移除指定键的键值对，返回被移除的值。如果键不存在，返回 null。 1 void clear() 清空所有键值对。 1 default boolean remove(Object key, Object value) 如果键存在且值匹配，则移除该键值对。 检查键值对 1 boolean containsKey(Object key) 检查是否包含指定的键。 1 boolean containsValue(Object value) 检查是否包含指定的值。 替换键值对 1 default boolean replace(K key, V oldValue, V newValue) 如果键的当前值等于 oldValue，则替换为 newValue。 1 default V replace(K key, V value) 替换键对应的值（如果键存在）。 集合视图 1 Set\u0026lt;Map.Entry\u0026lt;K, V\u0026gt;\u0026gt; entrySet() 返回所有键值对的集合。 1 Collection\u0026lt;V\u0026gt; values() 返回所有值的集合。 1 Set\u0026lt;K\u0026gt; keySet() 返回所有键的集合。 ","date":"2024-11-26T10:44:24+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84map%E6%8E%A5%E5%8F%A3/","title":"Java中的Map接口"},{"content":"Queue接口 Queue 是 Java 集合框架中的一个接口，位于 java.util 包下，用来表示 单向队列数据结构。队列通常遵循 FIFO（First In First Out，先进先出）的原则，即最先插入的元素最先被移除。\n特点 FIFO 顺序：队列通常按照先进先出的顺序处理元素。 不允许插入 null 值：避免产生歧义 常见实现类 LinkedList：实现了 Queue 接口，适用于一般队列操作。 PriorityQueue：基于优先级的队列，元素按照优先级排序。 ArrayDeque：高效的双端队列实现，也可以用作普通队列。 常见方法 添加元素 boolean add(E e)：将指定的元素插入队列。如果队列已满，会抛出 IllegalStateException 异常。 boolean offer(E e)：将指定的元素插入队列。如果队列已满，返回 false。推荐使用此方法以避免异常。 移除元素 E remove()：移除并返回队列头部的元素。如果队列为空，抛出 NoSuchElementException 异常。 E poll()：移除并返回队列头部的元素。如果队列为空，返回 null 获取队头元素 E element()：返回队列头部的元素，但不移除。如果队列为空，抛出 NoSuchElementException 异常。 E peek()：返回队列头部的元素，但不移除。如果队列为空，返回 null。 boolean contains(Object o)：检查队列中是否包含指定的元素。（继承自 Collection 接口） Deque接口 Deque（双端队列）是 Java 集合框架中的一个接口，位于 java.util 包下。它扩展了 Queue 接口，允许在 队列的两端插入和移除元素，既支持 FIFO（先进先出），也支持 LIFO（后进先出） 操作。\n特点 双端操作：支持从头部或尾部插入、删除、查看元素。 灵活性：可以用作 队列 或 栈。 不允许 null 元素：为了避免歧义，Deque 不允许存储 null。 常见实现类 ArrayDeque：基于数组实现，性能高效。 LinkedList：基于链表实现，支持动态扩展。 常见方法 队列操作 添加元素\nvoid addFirst(E e)：将指定元素插入到双端队列的头部。如果操作失败，抛出异常。 boolean offerFirst(E e)：将指定元素插入到双端队列的头部。如果操作失败，返回 false void addLast(E e)：将指定元素插入到双端队列的尾部。如果操作失败，抛出异常 boolean offerLast(E e)：将指定元素插入到双端队列的尾部。如果操作失败，返回 false 删除元素\nE removeFirst()：移除并返回头部的元素。如果双端队列为空，抛出异常。 E pollFirst()：移除并返回头部的元素。如果双端队列为空，返回 null E removeLast()：移除并返回尾部的元素。如果双端队列为空，抛出异常 E pollLast()：移除并返回尾部的元素。如果双端队列为空，返回 null 获取元素\nE getFirst()：返回头部的元素，但不移除。如果双端队列为空，抛出异常。 E peekFirst()：返回头部的元素，但不移除。如果双端队列为空，返回 null E getLast()：返回尾部的元素，但不移除。如果双端队列为空，抛出异常 E peekLast()：返回尾部的元素，但不移除。如果双端队列为空，返回 null 栈操作 void push(E e)：将元素压入到双端队列的头部，等价于入栈。 E pop()：移除并返回双端队列头部的元素，等价于出栈 E peek()：返回栈顶的元素 ArrayDeque类 特点 插入删除高效：\nArrayDeque 不需要维护节点指针，因此在时间和空间上更高效。 插入和删除操作在队列的头部和尾部都具有 $O(1) $的性能（在动态扩容时性能可能下降）。 双端操作：\n允许在 头部 和 尾部 插入、删除元素。 支持队列（FIFO）和栈（LIFO）操作。 动态扩容：\n底层通过动态数组实现，当存储空间不足时，会自动扩容为原来的两倍。 不支持 null 元素：\n为了避免混淆（例如，返回值为 null 时无法判断是队列为空还是插入了 null），ArrayDeque 不允许存储 null。 非线程安全：\nArrayDeque 没有内置的同步机制，若在多线程环境下使用，需要手动同步。 底层实现 ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组，也就是说数组的任何一点都可能被看作起点或者终点。\nhead指向首端第一个有效元素，\ntail指向尾端第一个可以插入元素的空位\naddFirst()方法 **addFirst(E e)的作用是在Deque的首端插入元素，也就是在head的前面插入元素，在空间足够且下标没有越界的情况下，只需要将elements[--head] = e**即可。\n1 2 3 4 5 6 7 8 //addFirst(E e) public void addFirst(E e) { if (e == null)//不允许放入null throw new NullPointerException(); elements[head = (head - 1) \u0026amp; (elements.length - 1)] = e;//2.下标是否越界 if (head == tail)//1.空间是否够用 doubleCapacity();//扩容 } addLast()方法 **addLast(E e)的作用是在Deque的尾端插入元素，也就是在tail的位置插入元素，由于tail总是指向下一个可以插入的空位，因此只需要elements[tail] = e**即可\n1 2 3 4 5 6 7 public void addLast(E e) { if (e == null)//不允许放入null throw new NullPointerException(); elements[tail] = e;//赋值 if ( (tail = (tail + 1) \u0026amp; (elements.length - 1)) == head)//下标越界处理 doubleCapacity();//扩容 } pollFirst()方法 pollFirst()的作用是删除并返回队列首端元素，也即是head位置处的元素。如果容器不空，只需要直接返回elements[head]即可，当然还需要处理下标的问题。由于ArrayDeque中不允许放入null，当**elements[head] == null**时，意味着容器为空。\n1 2 3 4 5 6 7 8 public E pollFirst() { E result = elements[head]; if (result == null)//null值意味着deque为空 return null; elements[h] = null;//let GC work head = (head + 1) \u0026amp; (elements.length - 1);//下标越界处理 return result; } pollLast方法 **pollLast()的作用是删除并返回队列尾端元素，也即是tail**位置前面的那个元素\n1 2 3 4 5 6 7 8 9 public E pollLast() { int t = (tail - 1) \u0026amp; (elements.length - 1);//tail的上一个位置是最后一个元素 E result = elements[t]; if (result == null)//null值意味着deque为空 return null; elements[t] = null;//let GC work tail = t; return result; } PriorityQueue类 PriorityQueue 是 Java 集合框架中的一个队列实现类，位于 java.util 包下，用于实现基于 优先级堆排序 的队列。它按照元素的自然顺序（Comparable）或通过自定义比较器（Comparator）定义的顺序对队列进行排序，每次从队列中获取或移除的都是 优先级最高的元素。\n特点 底层实现： PriorityQueue 底层基于 小顶堆 实现（默认为自然顺序），用一个动态调整大小的数组存储堆结构。 排序机制： 默认按照元素的自然顺序（对象需要实现 Comparable 接口）。 可以通过构造器传入自定义的 Comparator 定义排序规则。 非线程安全： 适用于单线程环境，多线程环境下需要使用外部同步机制或使用线程安全的队列（如 PriorityBlockingQueue）。 允许 null 元素： 不允许插入 null 元素。 元素的去重： 不提供去重功能，允许重复元素。 动态扩容： 底层数组的容量会根据需求动态调整。 堆 堆是一种完全二叉树，堆的特点是根节点的值最小（小顶堆）或最大（大顶堆），并且任意非根节点i的值都不大于（或不小于）其父节点的值。\n在堆中，每个节点的下标和其在数组中的下标是一一对应的，假设节点下标为**i，则其父节点下标为(i-1)/2，其左子节点下标为2i+1，其右子节点下标为2i+2**。\n小顶堆\n1 2 3 4 5 1 / \\ 2 3 / \\ / \\ 4 5 6 7 大顶堆\n1 2 3 4 5 8 / \\ 7 5 / \\ / \\ 6 4 2 1 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import java.util.PriorityQueue; class Task implements Comparable\u0026lt;Task\u0026gt; { private String name; private int priority; public Task(String name, int priority) { this.name = name; this.priority = priority; } public String getName() { return name; } @Override public int compareTo(Task other) { // 按优先级升序排序 return Integer.compare(this.priority, other.priority); } @Override public String toString() { return \u0026#34;Task{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, priority=\u0026#34; + priority + \u0026#39;}\u0026#39;; } } public class CustomObjectPriorityQueueExample { public static void main(String[] args) { PriorityQueue\u0026lt;Task\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(); pq.add(new Task(\u0026#34;Task1\u0026#34;, 5)); pq.add(new Task(\u0026#34;Task2\u0026#34;, 1)); pq.add(new Task(\u0026#34;Task3\u0026#34;, 3)); // 按优先级移除任务 while (!pq.isEmpty()) { System.out.println(pq.poll()); } // 输出顺序：Task2, Task3, Task1 } } ","date":"2024-11-25T13:50:30+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84queue%E6%8E%A5%E5%8F%A3%E5%92%8Cdeque%E6%8E%A5%E5%8F%A3/","title":"Java中的Queue接口和Deque接口"},{"content":"HashSet类 HashSet 是 Java 集合框架中的一个实现类，属于 Set 接口的一种实现，基于哈希表来存储数据。它不允许存储重复元素，并且不保证元素的顺序。\n特点 无重复元素：\nHashSet 使用哈希算法来存储元素，保证集合中没有重复的元素。\n元素的唯一性由 equals() 和 hashCode() 方法决定。\n无序存储：\nHashSet 不保证元素的存储顺序，与插入顺序无关。 允许存储一个 null 值：\n只能包含一个 null 值。 非线程安全：\n默认情况下，HashSet 不是线程安全的。 性能高效：\n添加、删除和查找操作的时间复杂度为 $O(1)$，但需要良好的哈希算法来避免哈希冲突。 注意事项 必须同时重写**hashCode()方法和equal()**方法 通过 hashCode() 方法快速找到存储位置（哈希桶）。 再通过 equals() 方法检查对象是否相等，避免重复存储。 **hashCode()方法默认根据地址值计算，equal()**方法默认根据地址值判断对象是否相同 底层原理 HashSet 的底层是由一个 HashMap 实现的，它将需要存储的元素作为 HashMap 的键（key），而值（value）则是一个固定的常量 PRESENT。\n去重原理 HashSet 是基于 哈希表 实现的集合类，它的去重功能依赖于两个方法：\nhashCode() 方法：用于快速定位存储位置（哈希桶）。 equals() 方法：用于确定逻辑相等性（是否是重复元素）。 当调用 HashSet 的 add() 方法时，具体过程如下：\n计算哈希值： 调用元素的 hashCode() 方法，计算出该元素的哈希值，用于确定其存储位置（哈希桶）。 定位哈希桶： 根据哈希值找到对应的哈希桶。 检查冲突： 如果桶中已经有一个或多个元素（两个对象具有相同的哈希值，发生哈希冲突），则调用元素的**equals()**方法，与桶中已有元素逐一比较： 如果 equals() 返回 true，说明两个对象逻辑相等，不添加新元素，去重成功。 如果 equals() 返回 false，说明不是重复元素，将新元素添加到桶中。 存储元素： 如果桶中没有冲突（即不存在相同的哈希值和 equals() 相等的对象），直接存储该元素。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import java.util.HashSet; import java.util.Objects; class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; return age == person.age \u0026amp;\u0026amp; Objects.equals(name, person.name); } @Override public int hashCode() { return Objects.hash(name, age); } @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, age=\u0026#34; + age + \u0026#34;}\u0026#34;; } } public class HashSetExample { public static void main(String[] args) { HashSet\u0026lt;Person\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); Person p1 = new Person(\u0026#34;Alice\u0026#34;, 25); Person p2 = new Person(\u0026#34;Alice\u0026#34;, 25); // 与 p1 逻辑相等 Person p3 = new Person(\u0026#34;Bob\u0026#34;, 30); set.add(p1); set.add(p2); // 不会添加，因为 p1 和 p2 逻辑相等 set.add(p3); System.out.println(\u0026#34;HashSet contains:\u0026#34;); for (Person p : set) { System.out.println(p); } } } 扩容机制 初始容量\nHashSet 的底层 HashMap 默认初始容量为 16。 如果在创建 HashSet 时指定了初始容量，则会根据该容量初始化底层的 HashMap。 负载因子\n默认负载因子为 0.75。 负载因子是一个用来衡量哈希表满的程度的指标。 当哈希表中的元素个数达到 容量 × 负载因子 时，触发扩容。 扩容条件\n当 HashSet 中的元素数量达到容量的 75% 时（即 size ≥ capacity × loadFactor），底层的 HashMap 会触发扩容操作\n扩容过程\n容量翻倍：每次扩容时，HashMap 的容量会 翻倍。 重新哈希：扩容后，所有已有元素需要重新计算哈希值并分配到新的桶中 迁移数据：将原哈希表中的元素迁移到新的哈希表中 遍历旧哈希表中的每个桶。 对每个桶中的元素重新计算哈希值，将其分配到新哈希表中 常见方法 构造方法 public HashSet()：创建一个空的 HashSet，默认容量为 16，负载因子为 0.75。 public HashSet(int initialCapacity)：创建一个具有指定初始容量的空 HashSet。 public HashSet(int initialCapacity, float loadFactor)：创建一个具有指定初始容量和负载因子的空 HashSet。 public HashSet(Collection\u0026lt;? extends E\u0026gt; c)：创建一个包含指定集合中所有元素的 HashSet 添加元素 public boolean add(E e)：如果元素不存在，则添加成功并返回 true；否则返回 false。 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c)：将指定集合中的所有元素添加到当前 HashSet。 删除元素 public boolean remove(Object o)：如果集合中存在该元素，则移除并返回 true；否则返回 false。 public boolean removeAll(Collection\u0026lt;?\u0026gt; c)：从当前集合中移除指定集合中的所有元素 public void clear()：移除集合中的所有元素 查询元素 public boolean contains(Object o)：如果集合中存在指定的元素，则返回 true public boolean containsAll(Collection\u0026lt;?\u0026gt; c)：如果当前集合包含指定集合中的所有元素，则返回 true 集合大小 public boolean isEmpty()：如果集合为空，则返回 true public int size()：返回集合中的元素数量 集合运算 并集（Union） 将两个集合的所有元素合并在一起，去重后返回新集合 public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 将指定集合中的所有元素添加到当前集合中 交集（Intersection） 将两个集合中共同的元素取出来 public boolean retainAll(Collection\u0026lt;?\u0026gt; c) 只保留当前集合和指定集合中的交集部分 差集（Difference） 从一个集合中去除另一个集合中的元素 public boolean removeAll(Collection\u0026lt;?\u0026gt; c) 从当前集合中移除与指定集合相交的元素 与HashMap的关系 实际上**HashSet** 内部使用 HashMap 来实现，HashSet 中的元素实际上存储在 HashMap 的键中，而所有的值都是一个常量对象 PRESENT。因此，HashSet 仅操作 HashMap 的键部分。\nLinkedHashSet类 LinkedHashSet 是 Java 集合框架中的一个类，它实现了 Set 接口，并且结合了 HashSet 和链表的特性。它是 HashSet 的一个变种，具有元素唯一性和顺序性的特点。LinkedHashSet 维护了元素插入的顺序（即按插入顺序遍历元素），这使得它在保持 Set 接口的特性（元素唯一性）的同时，还能提供元素的顺序遍历。\n特点 元素唯一性：\nLinkedHashSet 和 HashSet 一样，保证集合中的元素不重复，即不允许重复元素。 保持插入顺序：\n与 HashSet 不同的是，LinkedHashSet 维护了元素的插入顺序。也就是说，元素是按照它们被添加到集合中的顺序来存储的。 这使得 LinkedHashSet 在遍历时能按照元素的插入顺序进行。 基于哈希表和链表实现：\n它继承了 HashSet，因此内部使用哈希表来存储元素，同时使用链表来记录元素的插入顺序。\n使用哈希表来实现高效的查找、插入和删除操作。\n底层原理 插入顺序的维护 LinkedHashSet 通过内部维护一个 双向链表 来保持元素的插入顺序。每个元素在哈希表中不仅存储它的哈希值，还会保存指向前一个元素和后一个元素的引用。这使得集合可以按照插入顺序遍历元素。\n插入时创建新节点：\n当调用 add(E e) 方法插入一个新元素时，LinkedHashSet 会先通过哈希表检查该元素是否已存在。如果不存在，它会将元素插入到哈希表中，并在双向链表的末尾添加该元素。\n每次添加元素时，它会被插入到链表的末尾，并通过双向链表保持元素之间的顺序。这样，在遍历 LinkedHashSet 时，元素会按照它们被插入的顺序输出。\nTreeSet类 特点 排序功能：\nTreeSet 中的元素是自动按升序排序的。它使用 自然顺序（元素必须实现 Comparable 接口）或者提供的 Comparator 对元素进行排序。 元素唯一性：\n与 HashSet 一样，TreeSet 保证集合中的元素不重复，即不允许添加重复元素。 基于红黑树实现：\nTreeSet 是基于 红黑树 数据结构实现的。红黑树是一种自平衡的二叉查找树，能够保证树的高度始终处于对数级别，从而保证了操作的效率。\n由于使用了红黑树，TreeSet 可以在对元素进行插入、删除、查找时提供 $O(log n)$ 的时间复杂度。\n不允许 null 元素：\nTreeSet 不允许 null 元素。如果尝试向 TreeSet 中添加 null 元素，将会抛出 NullPointerException。 线程不安全：\nTreeSet 不是线程安全的。如果多个线程同时访问一个 TreeSet，并且至少有一个线程修改了该集合，则必须在外部进行同步。 访问和操作性能：\nTreeSet 的常见操作（如 add()、remove()、contains()）的时间复杂度是 $O(log n)$，这是因为它使用了红黑树来存储元素。 排序规则 对于数值类型默认采用升序排列 对于字符类型默认采用ASCII码排序 对于字符串类型采用字典序进行排列 自定义规则 让元素实现 Comparable 接口 创建集合时传递 Comparator 指定规则 ","date":"2024-11-25T10:21:08+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84set%E5%AE%9E%E7%8E%B0%E7%B1%BB/","title":"Java中的Set实现类"},{"content":"Set接口的定义 Set 是 Java 集合框架中的一个接口，位于 java.util 包中，表示一个不包含重复元素的集合。\nSet集合的特点 无重复元素： Set 不允许存储重复的元素。 元素的唯一性是通过 equals() 方法来判断的。 无顺序保证： Set 本身并不保证元素的顺序。 具体的实现类可能会对顺序有不同的处理，例如： HashSet：无序。 LinkedHashSet：按插入顺序。 TreeSet：自然顺序或自定义排序。 允许存储 null： 大多数 Set 集合实现允许一个 null 元素（例如，HashSet）。 TreeSet 不允许存储 null，因为排序比较时会抛出 NullPointerException。 线程安全： Set 接口的实现类（如 HashSet）不是线程安全的。 可以使用 Collections.synchronizedSet() 创建线程安全的 Set。 Set接口的实现类 HashSet：基于哈希表实现，无序，不保证顺序 LinkedHashSet：基于哈希表和链表实现，按插入顺序存储。 TreeSet：基于红黑树实现，按自然顺序或自定义排序存储 ConcurrentSkipListSet：线程安全的 Set，按自然顺序或自定义排序存储，基于跳表实现 Set接口的常用方法 添加元素 boolean add(E e)：向集合中添加一个元素，如果已存在该元素，则返回 false。 boolean addAll(Collection\u0026lt;? extends E\u0026gt; c)：将指定集合中的所有元素添加到当前集合 删除元素 void clear()：清空集合中的所有元素 boolean remove(Object o)：从集合中移除指定的元素 查询元素 boolean contains(Object o)：判断集合中是否包含指定的元素 获取大小 int size()：返回集合中的元素个数 boolean isEmpty()：判空 ","date":"2024-11-25T10:01:22+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84set%E6%8E%A5%E5%8F%A3/","title":"Java中的Set接口"},{"content":"ArrayList类 ArrayList 是 Java 集合框架中的一个类，属于 java.util 包，是一种 基于动态数组实现的可变长度集合。它实现了 List 接口，提供了一个可调整大小的数组，能够存储任意类型的对象（包括自定义类和基本类型的包装类）。\n特点 动态数组： ArrayList 的大小是可变的，默认容量为 10。当元素数量超过当前容量时，ArrayList 会自动扩容，通常以 1.5 倍的速度增长。 有序： 元素按照插入的顺序存储，可以通过索引访问，顺序不会改变（除非显式调整）。 允许重复元素： ArrayList 允许存储重复的元素。 支持随机访问： 因为底层是数组，ArrayList 支持快速随机访问，时间复杂度为$ O(1)$。 线程不安全： ArrayList 是非同步的，因此在多线程环境下需要手动同步（可以使用 Collections.synchronizedList() 或 CopyOnWriteArrayList 替代）。 常见方法 构造方法 public ArrayList()：创建一个默认初始容量为 10 的空 ArrayList public ArrayList(int initialCapacity)：创建一个具有指定初始容量的空 ArrayList public ArrayList(Collection\u0026lt;? extends E\u0026gt; c)：创建一个包含指定集合中所有元素的 ArrayList，按照集合的迭代器顺序。 添加元素 boolean add(E e)：将指定的元素添加到列表的末尾 void add(int index, E element)：将指定的元素插入到列表的指定位置 boolean addAll(Collection\u0026lt;? extends E\u0026gt; c)：将指定集合中的所有元素添加到当前列表的末尾 boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c)：将指定集合中的所有元素插入到当前列表的指定位置。 删除元素 void clear()：删除全部元素 E remove(int index)：删除列表中指定位置的元素 boolean remove(Object o)：删除列表中第一次出现的指定元素。如果列表中没有该元素，则不做任何操作。 boolean removeAll(Collection\u0026lt;?\u0026gt; c)：删除当前列表中所有与指定集合中的元素相同的元素 void removeRange(int from,int to)：删除索引[from，to）之间的元素 判断元素 boolean contains(Object o)：判断列表中是否包含指定的元素 boolean containsAll(Collection\u0026lt;?\u0026gt; c)：判断列表是否包含指定集合中的所有元素 修改元素 E set(int index, E element)：用指定的元素替换列表中指定位置的元素 访问元素 E get(int index)：返回指定位置的元素 int indexOf(Object o)：返回指定元素在列表中的第一次出现位置的索引。如果列表中没有该元素，则返回 -1 int lastIndexOf(Object o)：返回指定元素在列表中的最后一次出现位置的索引。如果列表中没有该元素，则返回 -1 获取大小 int size()：返回列表中元素的数量 boolean isEmpty()：判断列表是否为空 void ensureCapacity(int minCapacity)：确保列表能够容纳至少指定数量的元素，不会导致扩容。 扩容机制 源码分析 往 ArrayList 中添加元素时会有 ensureCapacityInternal 的判断\n1 2 3 4 5 public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } ensureCapacityInternal 内部会调用 ensureExplicitCapacity 方法，若 minCapacity - elementData.length \u0026gt; 0 即容量不够了，则会调用 grow 方法：\n1 2 3 4 5 6 7 8 9 10 11 /** * 检查并确保集合容量足够，如果需要则增加集合容量。 * * @param minCapacity 所需最小容量 */ private void ensureExplicitCapacity(int minCapacity) { // 检查是否超出了数组范围，确保不会溢出 if (minCapacity - elementData.length \u0026gt; 0) // 如果需要增加容量，则调用 grow 方法 grow(minCapacity); } grow 扩容逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 扩容 ArrayList 的方法，确保能够容纳指定容量的元素 * @param minCapacity 指定容量的最小值 */ private void grow(int minCapacity) { // 检查是否会导致溢出，oldCapacity 为当前数组长度 int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); // 扩容至原来的1.5倍 if (newCapacity - minCapacity \u0026lt; 0) // 如果还是小于指定容量的最小值 newCapacity = minCapacity; // 直接扩容至指定容量的最小值 if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) // 如果超出了数组的最大长度 newCapacity = hugeCapacity(minCapacity); // 扩容至数组的最大长度 // 将当前数组复制到一个新数组中，长度为 newCapacity elementData = Arrays.copyOf(elementData, newCapacity); } 总结 当 ArrayList 中的元素数量超过其当前容量时，会触发扩容机制。\n默认情况下，ArrayList 的初始容量为 10。\n当发生扩容时，ArrayList 会创建一个新的数组，其容量为原数组的 1.5 倍（即 oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1)），若还是小于指定容量的最小值会直接扩容到指定容量的最小值\n然后将原数组中的元素复制到新数组中。复制过程是通过 Arrays.copyOf() 方法实现的。\n更新引用：将 ArrayList 内部指向原数组的引用指向新数组。\n完成扩容：扩容完成后，可以继续添加新元素。\n线程安全问题 为什么是线程不安全的 ArrayList 不是线程安全的。ArrayList 会暴露三个问题;\n部分值为 null（我们并没有add null进去） 索引越界异常 线程1走到扩容那里发现当前 size 是 n，数组容量是n+1不用扩容，cpu让出执行权 线程2也发现不用扩容，这时候数组的容量就是n+1 而线程1 set完之后 size++，这时候线程2再进来 size 就是 n+1，数组的大小只有n+1，而你要设置下标索引为n+1的就会越界（数组的下标索引 size 从0开始）； size 与add的数量不符 因为 size++ 本身不是原子操作，可以分为三步： 获取 size 的值 将 size 的值加1 将新的 size 值覆盖掉原来的 线程1和线程2拿到一样的 size 值加完了同时覆盖，就会导致一次没有加上，所以肯定不会与add的数量保持一致的； 解决方法 使用Collections类的 synchronizedList 方法将 ArrayList 包装成线程安全的 List\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import java.util.ArrayList; import java.util.Collections; import java.util.List; public class SynchronizedListExample { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = Collections.synchronizedList(new ArrayList\u0026lt;\u0026gt;()); // 同步块中操作列表，保证线程安全 synchronized (list) { list.add(1); list.add(2); System.out.println(list); } } } 使用线程安全的替代类 CopyOnWriteArrayList\n增删查改的机制 查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * 返回列表中指定位置的元素。 * * @param index 要返回的元素的索引 * @return 列表中指定位置的元素 * @throws IndexOutOfBoundsException 如果索引超出范围（index \u0026lt; 0 || index \u0026gt;= size()） */ public E get(int index) { rangeCheck(index); // 检查索引是否合法 return elementData(index); // 调用 elementData 方法获取元素 } /** * 返回列表中指定位置的元素。 * 此方法不进行边界检查，因此只应由内部方法和迭代器调用。 * * @param index 要返回的元素的索引 * @return 列表中指定位置的元素 */ E elementData(int index) { return (E) elementData[index]; // 返回指定索引位置上的元素 } 时间复杂度为$ O(1)$，因为 ArrayList 内部使用数组来存储元素，所以可以直接根据索引来访问元素。\n插入 添加一个元素（调用 add() 方法时）的时间复杂度最好情况为 $O(1)$，最坏情况为 $O(n)$。\n如果在列表末尾添加元素，时间复杂度为 $O(1)$。 如果要在列表的中间或开头插入元素，则需要将插入位置之后的元素全部向后移动一位，时间复杂度为 $O(n)$。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * 在指定位置插入一个元素。 * * @param index 要插入元素的位置 * @param element 要插入的元素 * @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常 */ public void add(int index, E element) { rangeCheckForAdd(index); // 检查索引是否越界 ensureCapacityInternal(size + 1); // 确保容量足够，如果需要扩容就扩容 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 将 index 及其后面的元素向后移动一位 elementData[index] = element; // 将元素插入到指定位置 size++; // 元素个数加一 } 修改 修改一个元素（调用 set() 方法时）可以直接根据索引来访问元素，时间复杂度为 $O(1)$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 用指定元素替换列表中指定位置的元素。 * * @param index 要替换元素的索引 * @param element 要放入列表中的元素 * @return 原来在指定位置上的元素 * @throws IndexOutOfBoundsException 如果索引超出范围（index \u0026lt; 0 || index \u0026gt;= size()） */ public E set(int index, E element) { rangeCheck(index); // 检查索引是否合法 E oldValue = elementData(index); // 获取原来在指定位置上的元素 elementData[index] = element; // 将指定位置上的元素替换为新元素 return oldValue; // 返回原来在指定位置上的元素 } 删除 删除一个元素（调用 remove(Object) 方法时）的时间复杂度最好情况 $O(1)$，最坏情况 $O(n)$。\n如果要删除列表末尾的元素，时间复杂度为 $O(1)$。 如果要删除列表中间或开头的元素，则需要将删除位置之后的元素全部向前移动一位，时间复杂度为 $O(n)$。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /** * 删除指定位置的元素。 * * @param index 要删除的元素的索引 * @return 先前在指定位置的元素 * @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常 */ public E remove(int index) { rangeCheck(index); // 检查索引是否越界 E oldValue = elementData(index); // 获取要删除的元素 int numMoved = size - index - 1; // 计算需要移动的元素个数 if (numMoved \u0026gt; 0) // 如果需要移动元素，就用 System.arraycopy 方法实现 System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // 将数组末尾的元素置为 null，让 GC 回收该元素占用的空间 return oldValue; // 返回被删除的元素 } /** * 删除列表中第一次出现的指定元素（如果存在）。 * * @param o 要删除的元素 * @return 如果列表包含指定元素，则返回 true；否则返回 false */ public boolean remove(Object o) { if (o == null) { // 如果要删除的元素是 null for (int index = 0; index \u0026lt; size; index++) // 遍历列表 if (elementData[index] == null) { // 如果找到了 null 元素 fastRemove(index); // 调用 fastRemove 方法快速删除元素 return true; // 返回 true，表示成功删除元素 } } else { // 如果要删除的元素不是 null for (int index = 0; index \u0026lt; size; index++) // 遍历列表 if (o.equals(elementData[index])) { // 如果找到了要删除的元素 fastRemove(index); // 调用 fastRemove 方法快速删除元素 return true; // 返回 true，表示成功删除元素 } } return false; // 如果找不到要删除的元素，则返回 false } LinkedList类 LinkedList 是 Java 集合框架中的一个类，位于 java.util 包下，它同时实现了 List 和 Deque 接口，是一种基于双向链表的数据结构。\n特点 双向链表： 每个节点包含： 一个存储数据的字段。 两个指针，分别指向前一个节点和后一个节点。 动态容量： LinkedList 的大小可以动态变化，无需像数组那样预定义容量。 线程不安全： LinkedList 是非同步的，因此在多线程环境下需要手动同步 插入和删除效率高： 插入操作：在链表任意位置插入元素的时间复杂度为 $O(1)$，只需调整指针即可（如果已定位到插入点）。 删除操作：删除元素也只需调整相关指针，时间复杂度为 $O(1)$。 有序： 元素按照插入的顺序存储，可以通过索引访问，顺序不会改变（除非显式调整）。 允许重复元素： LinkedList 允许存储重复的元素。 常见方法 构造方法 public LinkedList()：创建一个空的 LinkedList 实例 public LinkedList(Collection\u0026lt;? extends E\u0026gt; c)：使用指定集合中的所有元素初始化 LinkedList 添加元素 boolean add(E e)：将指定的元素添加到链表的末尾 void add(int index, E element)：将指定的元素插入到链表的指定位置 void addFirst(E e)：在链表头部添加元素 void addLast(E e)：在链表尾部添加元素 访问元素 E get(int index)：返回指定位置的元素 E getFirst()：返回链表头部的第一个元素 E getLast()：返回链表尾部的最后一个元素 int indexOf(Object o)：返回指定元素在列表中的首次出现位置，如果列表中不包含该元素，返回 -1 。 int lastIndexOf(Object o)：返回指定元素在列表中最后一次出现的位置，如果列表中不包含该元素，返回 -1 。 删除元素 E remove(int index)：删除指定位置的元素，并返回被删除的元素 boolean remove(Object o)：删除链表中第一个匹配的元素 E removeFirst()：删除并返回链表头部的第一个元素 E removeLast()：删除并返回链表尾部的最后一个元素 void clear()：删除全部元素 判断元素 boolean contains(Object o)：判断列表中是否包含指定的元素 boolean containsAll(Collection\u0026lt;?\u0026gt; c)：判断列表是否包含指定集合中的所有元素 获取大小 int size()：返回列表中元素的数量 boolean isEmpty()：判断列表是否为空 修改元素 E set(int index, E element)：用指定的元素替换列表中指定位置的元素 源码解析 链表节点类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * 链表中的节点类。 */ private static class Node\u0026lt;E\u0026gt; { E item; // 节点中存储的元素 Node\u0026lt;E\u0026gt; next; // 指向下一个节点的指针 Node\u0026lt;E\u0026gt; prev; // 指向上一个节点的指针 /** * 构造一个新的节点。 * * @param prev 前一个节点 * @param element 节点中要存储的元素 * @param next 后一个节点 */ Node(Node\u0026lt;E\u0026gt; prev, E element, Node\u0026lt;E\u0026gt; next) { this.item = element; // 存储元素 this.next = next; // 设置下一个节点 this.prev = prev; // 设置上一个节点 } } 组成结构\n节点上的元素 下一个节点 上一个节点 插入节点 add 方法内部其实调用的是 linkLast 方法\n1 2 3 4 5 6 7 8 9 10 /** * 将指定的元素添加到列表的尾部。 * * @param e 要添加到列表的元素 * @return 始终为 true（根据 Java 集合框架规范） */ public boolean add(E e) { linkLast(e); // 在列表的尾部添加元素 return true; // 添加元素成功，返回 true } linkLast 方法就是在链表的尾部添加元素（尾插法）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 在列表的尾部添加指定的元素。 * * @param e 要添加到列表的元素 */ void linkLast(E e) { final Node\u0026lt;E\u0026gt; l = last; // 获取链表的最后一个节点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(l, e, null); // 创建一个新的节点，并将其设置为链表的最后一个节点 last = newNode; // 将新的节点设置为链表的最后一个节点 if (l == null) // 如果链表为空，则将新节点设置为头节点 first = newNode; else l.next = newNode; // 否则将新节点链接到链表的尾部 size++; // 增加链表的元素个数 } linkFirst 方法就是在链表的头部添加元素，把新的节点设为 first，并将新的 first 的 next 更新为之前的 first。（头插法）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 在列表的开头添加指定的元素。 * * @param e 要添加到列表的元素 */ private void linkFirst(E e) { final Node\u0026lt;E\u0026gt; f = first; // 获取链表的第一个节点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(null, e, f); // 创建一个新的节点，并将其设置为链表的第一个节点 first = newNode; // 将新的节点设置为链表的第一个节点 if (f == null) // 如果链表为空，则将新节点设置为尾节点 last = newNode; else f.prev = newNode; // 否则将新节点链接到链表的头部 size++; // 增加链表的元素个数 } 删除节点 remove(int) 内部调用的是 unlink 方法\n1 2 3 4 5 6 7 8 9 10 11 /** * 删除指定位置上的元素。 * * @param index 要删除的元素的索引 * @return 从列表中删除的元素 * @throws IndexOutOfBoundsException 如果索引越界（index \u0026amp;lt; 0 || index \u0026amp;gt;= size()） */ public E remove(int index) { checkElementIndex(index); // 检查索引是否越界 return unlink(node(index)); // 删除指定位置的节点，并返回节点的元素 } unlink 方法就是更新当前节点的 next 和 prev，然后把当前节点上的元素设为 null。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * 从链表中删除指定节点。 * * @param x 要删除的节点 * @return 从链表中删除的节点的元素 */ E unlink(Node\u0026lt;E\u0026gt; x) { final E element = x.item; // 获取要删除节点的元素 final Node\u0026lt;E\u0026gt; next = x.next; // 获取要删除节点的下一个节点 final Node\u0026lt;E\u0026gt; prev = x.prev; // 获取要删除节点的上一个节点 if (prev == null) { // 如果要删除节点是第一个节点 first = next; // 将链表的头节点设置为要删除节点的下一个节点 } else { prev.next = next; // 将要删除节点的上一个节点指向要删除节点的下一个节点 x.prev = null; // 将要删除节点的上一个节点设置为空 } if (next == null) { // 如果要删除节点是最后一个节点 last = prev; // 将链表的尾节点设置为要删除节点的上一个节点 } else { next.prev = prev; // 将要删除节点的下一个节点指向要删除节点的上一个节点 x.next = null; // 将要删除节点的下一个节点设置为空 } x.item = null; // 将要删除节点的元素设置为空 size--; // 减少链表的元素个数 return element; // 返回被删除节点的元素 } 修改节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 将链表中指定位置的元素替换为指定元素，并返回原来的元素。 * * @param index 要替换元素的位置（从 0 开始） * @param element 要插入的元素 * @return 替换前的元素 * @throws IndexOutOfBoundsException 如果索引超出范围（index \u0026lt; 0 || index \u0026gt;= size()） */ public E set(int index, E element) { checkElementIndex(index); // 检查索引是否超出范围 Node\u0026lt;E\u0026gt; x = node(index); // 获取要替换的节点 E oldVal = x.item; // 获取要替换节点的元素 x.item = element; // 将要替换的节点的元素设置为指定元素 return oldVal; // 返回替换前的元素 } node() 方法用于定位要替换的节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * 获取链表中指定位置的节点。 * * @param index 节点的位置（从 0 开始） * @return 指定位置的节点 * @throws IndexOutOfBoundsException 如果索引超出范围（index \u0026lt; 0 || index \u0026gt;= size()） */ Node\u0026lt;E\u0026gt; node(int index) { if (index \u0026lt; (size \u0026gt;\u0026gt; 1)) { // 如果索引在链表的前半部分 Node\u0026lt;E\u0026gt; x = first; for (int i = 0; i \u0026lt; index; i++) // 从头节点开始向后遍历链表，直到找到指定位置的节点 x = x.next; return x; // 返回指定位置的节点 } else { // 如果索引在链表的后半部分 Node\u0026lt;E\u0026gt; x = last; for (int i = size - 1; i \u0026gt; index; i--) // 从尾节点开始向前遍历链表，直到找到指定位置的节点 x = x.prev; return x; // 返回指定位置的节点 } } node 方法会对下标进行一个初步判断，如果靠近前半截，就从下标 0 开始遍历；如果靠近后半截，就从末尾开始遍历。\nStack类 Stack 是 Java 集合框架中的一个类，位于 java.util 包中，作为 Vector 的子类间接实现了List接口，用于实现 栈（Stack） 数据结构\n特点 Stack 类继承自 Vector 类，因此它是一种 同步的（线程安全的） 集合。 常用方法 入栈操作 public E push(E item)：将元素压入栈顶 出栈操作 public synchronized E pop() 移除并返回栈顶的元素。 如果栈为空，则抛出 EmptyStackException 。 查看栈顶元素 public synchronized E peek() 返回栈顶的元素，但不移除。 如果栈为空，则抛出 EmptyStackException 。 检查栈空 public boolean empty()：判断栈是否为空 搜索元素 public synchronized int search(Object o) 返回元素在栈中的位置（以 1 为基准）。 如果元素不存在，则返回 -1。 CopyOnWriteArrayList类 CopyOnWriteArrayList 是 Java 的一个线程安全的动态数组实现，属于 java.util.concurrent 包。\n它通过写时复制机制，即在每次修改（写入）操作时，复制原始数组的内容来保证线程安全。\n由于写操作涉及复制整个数组，所以它的写操作开销较大，但读取操作则完全无锁。这使得 CopyOnWriteArrayList 适合于读多写少的场景。\n特点 写时复制是一种保证数据一致性和线程安全的技术。核心思想是在进行写操作时，不直接修改原来的数据结构，而是先复制一份副本，在副本上进行修改，然后将修改后的副本替换原来的数据结构。 保证数据一致性和线程安全 常见方法 构造方法 public CopyOnWriteArrayList()：创建一个空的 CopyOnWriteArrayList public CopyOnWriteArrayList(Collection\u0026lt;? extends E\u0026gt; c)：使用指定的集合初始化 CopyOnWriteArrayList public CopyOnWriteArrayList(E[] toCopyIn)：使用指定的数组初始化 CopyOnWriteArrayList 。 添加元素 boolean add(E e) ：将指定的元素添加到链表的末尾 void add(int index, E element) ：将指定的元素插入到链表的指定位置 void addFirst(E e) ：在链表头部添加元素 void addLast(E e) ：在链表尾部添加元素 访问元素 E get(int index) ：返回指定位置的元素 E getFirst() ：返回链表头部的第一个元素 E getLast() ：返回链表尾部的最后一个元素 int indexOf(Object o) ：返回指定元素在列表中的首次出现位置，如果列表中不包含该元素，返回 -1。 int lastIndexOf(Object o)：返回指定元素在列表中最后一次出现的位置，如果列表中不包含该元素，返回 -1。 删除元素 E remove(int index)：删除指定位置的元素，并返回被删除的元素 boolean remove(Object o)：删除链表中第一个匹配的元素 E removeFirst()：删除并返回链表头部的第一个元素 E removeLast()：删除并返回链表尾部的最后一个元素 void clear()：删除全部元素 判断元素 boolean contains(Object o)：判断列表中是否包含指定的元素 boolean containsAll(Collection\u0026lt;?\u0026gt; c)：判断列表是否包含指定集合中的所有元素 获取大小 int size()：返回列表中元素的数量 boolean isEmpty()：判断列表是否为空 修改元素 E set(int index, E element)：用指定的元素替换列表中指定位置的元素 源码分析 CopyOnWriteArrayList 底层也是通过一个数组保存数据，使用 volatile 关键字修饰数组，保证当前线程对数组对象重新赋值后，其他线程可以及时感知到。\n1 private transient volatile Object[] array; 写操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public boolean add(E e) { //获取锁 final ReentrantLock lock = this.lock; //加锁 lock.lock(); try { //获取到当前List集合保存数据的数组 Object[] elements = getArray(); //获取该数组的长度（这是一个伏笔，同时len也是新数组的最后一个元素的索引值） int len = elements.length; //将当前数组拷贝一份的同时，让其长度加1 Object[] newElements = Arrays.copyOf(elements, len + 1); //将加入的元素放在新数组最后一位，len不是旧数组长度吗，为什么现在用它当成新数组的最后一个元素的下标？建议自行画图推演，就很容易理解。 newElements[len] = e; //替换引用，将数组的引用指向给新数组的地址 setArray(newElements); return true; } finally { //释放锁 lock.unlock(); } } 读取当前数组：首先读取当前的数组，这个数组是 CopyOnWriteArrayList 当前持有的数组。 复制数组：创建一个当前数组的副本（新的数组），这个副本会拷贝当前数组中的所有元素。 在副本上进行修改：在副本数组上进行写操作（如添加、删除元素）。 用新数组替换旧数组：将修改后的副本数组设置为 CopyOnWriteArrayList 持有的数组，旧数组将不再使用。 读操作 1 2 3 public E get(int index) { return get(getArray(), index); } 所有读操作都可以无锁地直接读取 CopyOnWriteArrayList 当前持有的数组，因为这个数组在读操作期间不会被修改。\nCopyOnWriteArrayList 和 Collections.synchronizedList 的区别（面试题） 回答要点 CopyOnWriteArrayList\n是一个线程安全的 List 实现，特性就是写时复制。\n每次对 List 的修改操作（如 add, set, remove）都会复制创建一个新的底层数组。读操作不需要加锁，写操作需要加锁。\n优点：\n读操作无锁：每次写操作都会创建并复制新数组，所以读写之间不冲突，因此读操作不需要加锁，能够提供非常高效的并发读性能。 缺点：\n写操作开销大：每次写操作都会创建并复制新数组，且要将数据复制到新的数组中，在写操作频繁的场景下性能会较低。 内存消耗大：每次写操作都会创建并复制新数组，在数据量大的情况下，同一时刻会存在两倍 List 大小的内存占用，开销较大。 Collections.synchronizedList：\n是一个包装方法，可以将任何 List 转换为线程安全的版本，它会对每个访问方法（如 get, set, add, remove）进行同步（加 synchronized 锁），从而保证线程安全。\n优点：\n方便：简单一个方法就可以将 List 变为线程安全版本，非常方便。 缺点：\n并发低：读写操作都需要加锁，高并发场景下性能不高。 Collections.synchronizedList 适用于简单将 List 转为线程安全版本临时使用的场景。特定的场景还需使用并发度高的 JUC 类。\n","date":"2024-11-21T16:00:25+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84list%E5%AE%9E%E7%8E%B0%E7%B1%BB/","title":"Java中的List实现类"},{"content":"网络编程基础 IP地址 在互联网中，一个 IP 地址用于唯一标识一个网络设备。一台联入互联网的计算机肯定有一个 IP 地址，但也可能有多个 IP 地址。\nIP 地址又分为公网 IP 地址和内网 IP 地址。公网 IP 地址可以直接被访问，内网 IP 地址只能在内网访问。\n假设一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址127.0.0.1，还有一个 IP 地址，例如101.202.99.12，可以通过这个 IP 地址接入网络。\n假设路由器或者交换机有两个网卡，它有两个 IP 地址，分别接入不同的网络，让网络之间连接起来。\n如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的 IP 地址前段（网络号）是相同的。\n网络号是 IP 地址与子网掩码过滤后得到的。（子网掩码转换成二进制和IP地址转换成二进制后按位进行与操作）\n1 2 3 IP = 101.202.99.2 Mask = 255.255.255.0 Network = IP \u0026amp; Mask = 101.202.99.0 如果两台计算机计算出的网络号相同，说明两台计算机在同一个网络，可以直接通信。\n如果两台计算机计算出的网络号不同，那么两台计算机不在同一个网络，不能直接通信，它们之间必须通过路由器或者交换机这样的网络设备（网关）间接通信。\n网卡的关键配置\nIP 地址，例如：10.0.2.15 子网掩码，例如：255.255.255.0 网关的 IP 地址，例如：10.0.2.2 域名 直接记忆 IP 地址非常困难，所以通常使用域名访问某个特定的服务。\n域名解析服务器 DNS 负责把域名翻译成对应的 IP，客户端再根据 IP 地址访问服务器。\n端口号 用于标识计算机上的具体应用程序或进程。端口号与 IP 地址结合，共同用于标识一个主机上的具体服务或应用。\n协议 网络通信的规则\n网络套接字Socket Socket（套接字）：网络通信的基本单位，通过 IP 地址和端口号标识。\n套接字（Socket）是一个抽象层，应用程序可以通过它发送或接收数据；就像操作文件那样可以打开、读写和关闭。套接字允许应用程序将 I/O 应用于网络中，并与其他应用程序进行通信。网络套接字是 IP 地址与端口的组合。\nInetAddressIP地址类 InetAddress 是 Java 中用于表示一个 IP 地址的类，它提供了多种方法用于获取和处理与主机名或 IP 地址相关的信息。InetAddress 类位于 java.net 包中，常用于网络编程中。\n常用方法 public static InetAddress getByName(String host) throws UnknownHostException：该方法通过主机名或 IP 地址字符串返回一个 InetAddress 对象 public static InetAddress getByAddress(String host, byte[] addr) throws UnknownHostException：通过给定的 IP 地址（字节数组）和主机名，返回一个 InetAddress 对象。 public static InetAddress getLocalHost() throws UnknownHostException：该方法返回当前计算机的 InetAddress 对象。 public String getHostName()：获取与 InetAddress 对象相关联的主机名。 public String getHostAddress()：获取与 InetAddress 对象相关联的 IP 地址（以字符串形式返回） UDP协议传输 UDP 协议通过 DatagramSocket 和 DatagramPacket 类来实现。\n服务端 创建一个 DatagramSocket 来监听端口。 等待并创建 DatagramPacket 用于接收客户端发送的数据包。 处理数据并可能向客户端发送响应。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import java.net.*; public class UDPServer { public static void main(String[] args) { DatagramSocket socket = null; try { // 创建一个 DatagramSocket 并绑定到端口 9876 socket = new DatagramSocket(9876); System.out.println(\u0026#34;UDP Server is running...\u0026#34;); // 创建一个数据包来接收客户端的数据 byte[] receiveData = new byte[1024]; while (true) { // 创建 DatagramPacket 用于接收数据 DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length); // 接收客户端发送的数据 socket.receive(receivePacket); // 获取客户端的消息 String clientMessage = new String(receivePacket.getData(), 0, receivePacket.getLength()); System.out.println(\u0026#34;Received from client: \u0026#34; + clientMessage); // 创建并发送响应消息 String serverResponse = \u0026#34;Hello from UDP Server!\u0026#34;; byte[] sendData = serverResponse.getBytes(); // 获取客户端的地址和端口 InetAddress clientAddress = receivePacket.getAddress(); int clientPort = receivePacket.getPort(); // 创建一个数据包并发送给客户端 DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, clientAddress, clientPort); socket.send(sendPacket); } } catch (Exception e) { e.printStackTrace(); } finally { if (socket != null \u0026amp;\u0026amp; !socket.isClosed()) { socket.close(); } } } } 客户端 创建一个 DatagramSocket 用于发送数据。 创建一个 DatagramPacket，通过该包发送数据到服务器。 等待接收服务器的响应。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import java.net.*; public class UDPClient { public static void main(String[] args) { DatagramSocket socket = null; try { // 创建一个 DatagramSocket 用于发送数据 socket = new DatagramSocket(); // 服务器的地址和端口 InetAddress serverAddress = InetAddress.getByName(\u0026#34;localhost\u0026#34;); int serverPort = 9876; // 发送到服务器的消息 String message = \u0026#34;Hello, UDP Server!\u0026#34;; byte[] sendData = message.getBytes(); // 创建一个 DatagramPacket 发送消息到服务器 DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, serverAddress, serverPort); socket.send(sendPacket); System.out.println(\u0026#34;Sent to server: \u0026#34; + message); // 接收服务器的响应 byte[] receiveData = new byte[1024]; DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length); socket.receive(receivePacket); // 获取服务器响应并打印 String serverResponse = new String(receivePacket.getData(), 0, receivePacket.getLength()); System.out.println(\u0026#34;Received from server: \u0026#34; + serverResponse); } catch (Exception e) { e.printStackTrace(); } finally { if (socket != null \u0026amp;\u0026amp; !socket.isClosed()) { socket.close(); } } } } 核心类 DatagramSocket网络套接字 DatagramSocket 提供了发送和接收数据包的功能。\n构造方法\npublic DatagramSocket() throws SocketException public DatagramSocket(int port) throws SocketException public DatagramSocket(int port, InetAddress bindAddress) throws SocketException 收发数据\npublic void send(DatagramPacket packet) throws IOException：发送一个数据包到目标地址。 public void receive(DatagramPacket packet) throws IOException：接收来自远程主机的数据包 设置超时\npublic void setSoTimeout(int timeout) throws SocketException：设置超时时间，如果在指定的时间内没有数据到达，则会抛出 SocketTimeoutException。 关闭套接字\npublic void close()：关闭套接字 DatagramPacket数据包类 DatagramPacket 类提供了封装数据包的功能，常用于 UDP 协议的通信中。它可以用于存储接收到的数据或准备发送的数据。\n构造方法\npublic DatagramPacket(byte[] buf, int length) buf：用于存储数据的字节数组。 length：数据包的有效数据长度（在字节数组中的有效数据部分）。 public DatagramPacket(byte[] buf, int length, InetAddress address, int port) buf：用于存储数据的字节数组。 length：数据包的有效数据长度。 address：目标主机的 IP 地址。 port：目标主机的端口号。 获取数据\npublic byte[] getData() ：返回 DatagramPacket 中存储的数据字节数组。 public int getLength() ：返回 DatagramPacket 中有效数据的长度（字节数）。 public InetAddress getAddress() ：返回 DatagramPacket 中目标主机的 IP 地址。 public int getPort()：返回 DatagramPacket 中目标主机的端口号。 设置属性\npublic void setData(byte[] buf) public void setLength(int length) public void setAddress(InetAddress address) public void setPort(int port) TCP协议传输 服务端 创建一个 ServerSocket 来监听端口。 调用ServerSocket的accept()返回一个Socket对象监听客户端的套接字请求 获取连接通道的输入流读取来自客户端的数据 释放资源 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import java.io.*; import java.net.*; public class TCPServer { public static void main(String[] args) { try { // 创建 ServerSocket 监听端口 12345 ServerSocket serverSocket = new ServerSocket(12345); System.out.println(\u0026#34;Server is waiting for a client connection...\u0026#34;); // 接受客户端连接 Socket clientSocket = serverSocket.accept(); System.out.println(\u0026#34;Client connected!\u0026#34;); // 获取输入流读取客户端发送的数据 BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream())); PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true); // 读取客户端数据并响应 String clientMessage; while ((clientMessage = in.readLine()) != null) { System.out.println(\u0026#34;Received from client: \u0026#34; + clientMessage); if (clientMessage.equalsIgnoreCase(\u0026#34;bye\u0026#34;)) { out.println(\u0026#34;Goodbye!\u0026#34;); break; } // 向客户端返回消息 out.println(\u0026#34;Server received: \u0026#34; + clientMessage); } // 关闭连接 in.close(); out.close(); clientSocket.close(); serverSocket.close(); System.out.println(\u0026#34;Server closed.\u0026#34;); } catch (IOException e) { e.printStackTrace(); } } } 客户端 创建客户端的Socket对象 创建Socket对象时同时连接服务端 若服务端不可访问会发生阻塞直到抛出异常 获取连接通道的输出流，写入数据 释放资源 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import java.io.*; import java.net.*; public class TCPClient { public static void main(String[] args) { try { // 连接到服务器 (IP 地址和端口号) Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 12345); System.out.println(\u0026#34;Connected to server.\u0026#34;); // 获取输出流，发送数据 PrintWriter out = new PrintWriter(socket.getOutputStream(), true); // 获取输入流，接收服务器的数据 BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); BufferedReader userInput = new BufferedReader(new InputStreamReader(System.in)); String message; System.out.println(\u0026#34;Enter message to send to server (type \u0026#39;bye\u0026#39; to exit):\u0026#34;); while (true) { message = userInput.readLine(); // 读取用户输入 out.println(message); // 发送消息到服务器 String response = in.readLine(); // 从服务器接收响应 System.out.println(\u0026#34;Server response: \u0026#34; + response); if (message.equalsIgnoreCase(\u0026#34;bye\u0026#34;)) { break; } } // 关闭连接 userInput.close(); in.close(); out.close(); socket.close(); System.out.println(\u0026#34;Client closed.\u0026#34;); } catch (IOException e) { e.printStackTrace(); } } } 核心类 ServerSocket服务端套接字 ServerSocket 类是 Java 中用于实现 TCP 服务器端的类。它主要用于监听客户端的连接请求并接受连接。\n构造方法\npublic ServerSocket(int port) throws IOException public ServerSocket(int port, int backlog) throws IOException public ServerSocket(int port, int backlog, InetAddress bindAddr) throws IOException 接受连接\npublic Socket accept() throws IOException：接受客户端的连接请求。 此方法会阻塞，直到有客户端发起连接请求。 返回一个已连接的 Socket 实例，客户端可以通过该 Socket 与服务器通信。 状态检测\npublic boolean isBound() ：检查 ServerSocket 是否已经绑定到一个本地地址和端口。 public boolean isClosed()：检查 ServerSocket 是否已关闭 Socket客户端套接字 Socket 类是 Java 中用于实现 TCP 客户端通信的类，它提供了与服务器建立连接、发送和接收数据的功能。\n构造方法\npublic Socket(String host, int port) throws UnknownHostException, IOException：创建一个指定主机和端口的 Socket，并与目标主机建立连接。 host：目标主机的 IP 地址或域名。 port：目标主机的端口号。 public Socket(InetAddress address, int port) throws IOException：创建一个指定 IP 地址和端口号的 Socket，并与目标主机建立连接 address：目标主机的 IP 地址（InetAddress 类型）。 port：目标主机的端口号。 获取IO流\npublic InputStream getInputStream() throws IOException：返回与此 Socket 关联的输入流，客户端可以通过该流接收从服务器发送的数据 public OutputStream getOutputStream() throws IOException：返回与此 Socket 关联的输出流，客户端可以通过该流向服务器发送数据。 设置超时时间\npublic void setSoTimeout(int timeout) throws SocketException：设置读取数据的超时时间。如果在指定的时间内没有数据可读取，则会抛出 SocketTimeoutException。 ","date":"2024-11-20T10:04:34+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","title":"Java的网络编程"},{"content":"IO流的定义 Java 的 I/O（输入/输出）流是用于处理输入和输出数据的类库。通过流，程序可以从各种输入源（如文件、网络）读取数据，或将数据写入目标位置（如文件、控制台）。\nI/O 流分为两大类：字节流 和 字符流，分别用于处理字节级和字符级的数据：\n字节流：处理 8 位字节数据，适合于处理二进制文件，如图片、视频等。主要类是 InputStream 和 OutputStream 及其子类。 字符流：处理 16 位字符数据，适合于处理文本文件。主要类是 Reader 和 Writer 及其子类。 字符流和字节流的区别 字节流一般用来处理图像、视频、音频、PPT、Word等类型的文件。字符流一般用于处理纯文本类型的文件，如TXT文件等，但不能处理图像视频等非文本文件。用一句话说就是：字节流可以处理一切文件，而字符流只能处理纯文本文件。 字节流本身没有缓冲区，缓冲字节流相对于字节流，效率提升非常高。而字符流本身就带有缓冲区，缓冲字符流相对于字符流效率提升就不是那么大了。 编码和解码 输出流将缓冲区存储的字符通过查ASCII表转换为对应数字再进行编码\n输入流对文件进行解码转换为ASCII码对应的数字，然后通过查表转换为读取到的字符\n中文编码通常使用GBK字符集\n规则\n汉字使用两个字节进行存储 高位字节以1开头，转换成十进制后为负数 Unicode字符集（万国码）是国家标准字符集同时兼任ASCII码\nUTF-16编码：使用2-4个字节保存 UTF-32编码：固定4个字节保存 UTF-8编码：使用1-4个字节保存 ASCII码：1个字节 简体中文：3个字节 乱码的原因\n字符编码与解码不一致。乱码问题常常由字符编码（比如 UTF-8、GBK）和解码过程的不一致引起。如果在编码时使用了一种字符集，而在解码时使用了另一种，字符将无法正确显示，从而出现乱码。 文件流 一切文件（文本、视频、图片）的数据都是以二进制的形式存储的，传输时也是。所以，字节流可以传输任意类型的文件数据。\n文件字节流 FileOutputStream文件输出流 构造方法\npublic FileOutputStream(String s)：接收文件路径创建输出流，如果文件不存在，则创建一个新文件；如果文件已经存在，则覆盖原有文件。 public FileOutputStream(File file)：使用文件对象创建 FileOutputStream 对象 写入数据\npublic void write(int b)：写入一个ASCII码为b的字符 public void write(char b)：写入一个字符 public void write(byte[] b)：写入一个字节数组 public void write(byte[] b,int off,int len)：从指定的字节数组写入 len 字节到此输出流，从偏移量 off开始。 也就是说从off个字节数开始一直到len个字节结束 追加数据\n在构造方法中加入第二个Boolean类型参数指示是否继续读写\nFileInputStream文件输入流 构造方法\nFileInputStream(String name)：创建一个 FileInputStream 对象，并打开指定名称的文件进行读取。文件名由 name 参数指定。如果文件不存在，将会抛出 FileNotFoundException 异常。 FileInputStream(File file)：创建一个 FileInputStream 对象，并打开指定的 File 对象表示的文件进行读取。 读入数据\npublic int read()：read()方法会读取一个字节并返回其整数表示。如果已经到达文件的末尾，则返回 -1。如果在读取时发生错误，则会抛出 IOException 异常。 public int read(byte[] b) throws IOException：读取数据并将其存储在字节数组 b 中。返回实际读取的字节数。 public int read(byte[] b, int off, int len) throws IOException：从文件中读取最多 len 个字节的数据，存储到字节数组 b 中，从偏移量 off 开始。返回实际读取的字节数。 常见操作 文件拷贝\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class FileCopy { public static void main(String[] args) { String sourceFile = \u0026#34;source.txt\u0026#34;; // 源文件 String destFile = \u0026#34;destination.txt\u0026#34;; // 目标文件 try (FileInputStream fis = new FileInputStream(sourceFile); FileOutputStream fos = new FileOutputStream(destFile)) { byte[] buffer = new byte[1024]; // 缓冲区大小，可以根据需要调整 int length; // 读取源文件并写入目标文件 while ((length = fis.read(buffer)) \u0026gt; 0) { fos.write(buffer, 0, length); } System.out.println(\u0026#34;文件拷贝完成！\u0026#34;); } catch (IOException e) { e.printStackTrace(); } } } 文件夹拷贝\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; public class DirectoryCopy { public static void main(String[] args) { String sourceDir = \u0026#34;sourceDirectory\u0026#34;; // 源文件夹 String destDir = \u0026#34;destinationDirectory\u0026#34;; // 目标文件夹 try { copyDirectory(new File(sourceDir), new File(destDir)); System.out.println(\u0026#34;文件夹拷贝完成！\u0026#34;); } catch (IOException e) { e.printStackTrace(); } } // 递归复制文件夹 public static void copyDirectory(File sourceDir, File destDir) throws IOException { if (!sourceDir.exists()) { throw new IOException(\u0026#34;源文件夹不存在！\u0026#34;); } // 如果目标文件夹不存在，则创建它 if (!destDir.exists()) { destDir.mkdir(); } // 获取源文件夹中的所有文件和子文件夹 File[] files = sourceDir.listFiles(); if (files != null) { for (File file : files) { // 如果是文件，则直接拷贝 if (file.isFile()) { copyFile(file, new File(destDir, file.getName())); } else if (file.isDirectory()) { // 如果是文件夹，则递归调用 copyDirectory(file, new File(destDir, file.getName())); } } } } // 拷贝文件 private static void copyFile(File sourceFile, File destFile) throws IOException { try (InputStream in = new FileInputStream(sourceFile); OutputStream out = new FileOutputStream(destFile)) { byte[] buffer = new byte[1024]; // 缓冲区 int length; // 读取文件并写入目标文件 while ((length = in.read(buffer)) != -1) { out.write(buffer, 0, length); } } } } 文件字符流 字符流 = 字节流 + 编码表\nFileReader文件输入流 一次读取一个字节，遇到中文时一次读入多个字节\n构造方法\nFileReader(File file)：创建一个新的 FileReader，参数为File对象。 FileReader(String fileName)：创建一个新的 FileReader，参数为文件名。 FileReader(File file，Charset set)：创建一个新的 FileReader，参数为File对象和字符集。 读取数据\npublic int read()：每次可以读取一个字符，返回读取的字符（转为 int 类型），当读取到文件末尾时，返回-1 public int read(char[]buffer,int off,int len):读取多个字符到字符数组buffer，返回值为读入的字符数，读到文件末尾返回-1 释放资源\npublic int close()：释放字符流\nFileWriter文件输出流 构造方法\nFileWriter(File file)： 创建一个新的 FileWriter，参数为要读取的File对象。可以后跟Boolean参数指定是否追加数据 FileWriter(String fileName)： 创建一个新的 FileWriter，参数为要读取的文件的名称。可以后跟Boolean参数指定是否追加数据 写入数据\npublic void write(int b)：写入一个ASCII码为b的字符 public void write(String b)：写入字符串 public void write(String str, int off, int len) ：将指定字符串的一部分写入输出流 public void write(char[] cbuf) ：将指定字符数组写入输出流 public void write(char[] cbuf, int off, int len) ：将指定字符数组的一部分写入输出流 关闭和刷新\nflush() ：刷新缓冲区，将缓冲区中的数据强制写入目标设备或流中,流对象可以继续使用。 close() ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 缓冲流： 缓冲流是对基础流的包装，可以显著提高 I/O 性能。常见的缓冲流有 BufferedInputStream、BufferedOutputStream、BufferedReader 和 BufferedWriter，它们通过内部缓冲区减少实际 I/O 操作的次数。\n在处理大文件或频繁 I/O 操作时，使用缓冲流可以有效提高性能。\n字节缓冲流 底层自带8KB的缓冲区\nBufferedInputStream 字节缓冲输入流 构造方法\nBufferedInputStream(InputStream in) ：创建一个新的缓冲输入流，注意参数类型为InputStream。\n读入数据\npublic int read()：read()方法会读取一个字节并返回其整数表示。如果已经到达文件的末尾，则返回 -1。如果在读取时发生错误，则会抛出 IOException 异常。 public int read(byte[] b) throws IOException：读取数据并将其存储在字节数组 b 中。返回实际读取的字节数。 public int read(byte[] b, int off, int len) throws IOException：从文件中读取最多 len 个字节的数据，存储到字节数组 b 中，从偏移量 off 开始。返回实际读取的字节数。 BufferedOutputStream字节缓冲输出流 构造方法\nBufferedOutputStream(OutputStream in) ：创建一个新的缓冲输入流，注意参数类型为OutputStream。\n写入数据\npublic void write(int b)：写入一个ASCII码为b的字符 public void write(String b)：写入字符串 public void write(String str, int off, int len) ：将指定字符串的一部分写入输出流 public void write(char[] cbuf) ：将指定字符数组写入输出流 public void write(char[] cbuf, int off, int len) ：将指定字符数组的一部分写入输出流 关闭和刷新\nflush() ：刷新缓冲区，将缓冲区中的数据强制写入目标设备或流中,流对象可以继续使用。 close() ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。只用关闭高级流的流对象底层会自动关闭基本流 字符缓冲流 BufferedReader字符缓冲输入流 构造方法\nBufferedReader(Reader in) ：创建一个新的缓冲输入流，注意参数类型为Reader。 读取数据\npublic int read()：每次可以读取一个字符，返回读取的字符（转为 int 类型），当读取到文件末尾时，返回-1 public int read(char[]buffer,int off,int len):读取多个字符到字符数组buffer，返回值为读入的字符数，读到文件末尾返回-1 String readLine(): 读一行数据，读取到最后返回 null 释放资源\npublic int close()：释放字符流\nBufferedWriter字符缓冲输出流 构造方法\nBufferedWriter(Writer out)： 创建一个新的缓冲输出流，注意参数类型为Writer。 写入数据\npublic void write(int b)：写入一个ASCII码为b的字符 public void write(String b)：写入字符串 public void write(String str, int off, int len) ：将指定字符串的一部分写入输出流 public void write(char[] cbuf) ：将指定字符数组写入输出流 public void write(char[] cbuf, int off, int len) ：将指定字符数组的一部分写入输出流 public void newLine()：输出换行符 关闭和刷新\nflush() ：刷新缓冲区，将缓冲区中的数据强制写入目标设备或流中,流对象可以继续使用。 close() ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 转换流 将字符流和字节流进行连接，实现互相转换\nInputStreamReader ：将一个字节输入流转换为一个字符输入流，\nOutputStreamWriter ：将一个字节输出流转换为一个字符输出流。\n它们使用指定的字符集将字节流和字符流之间进行转换。常用的字符集包括 UTF-8、GBK、ISO-8859-1 等。\nInputStreamReader 作用 将字节流（InputStream）转换为字符流（Reader） 同时支持指定的字符集编码方式，从而实现字节流到字符流之间的转换。 构造方法 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 常用方法 read()：从输入流中读取一个字符的数据。 read(char[] cbuf, int off, int len)：从输入流中读取 len 个字符的数据到指定的字符数组 cbuf 中，从 off 位置开始存放。 ready()：返回此流是否已准备好读取。 close()：关闭输入流。 OutputStreamWriter 作用 将字符流（Writer）转换为字节流（OutputStream） 同时支持指定的字符集编码方式，从而实现字符流到字节流之间的转换。 构造方法 OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字节流。 OutputStreamWriter(OutputStream in, String charsetName)：创建一个指定字符集的字节流。 常用方法 write(int c)：向输出流中写入一个字符的数据。 write(char[] cbuf, int off, int len)：向输出流中写入指定字符数组 cbuf 中的 len 个字符，从 off 位置开始。 flush()：将缓冲区的数据写入输出流中。 close()：关闭输出流 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 try { // 从文件读取字节流，使用UTF-8编码方式 FileInputStream fis = new FileInputStream(\u0026#34;test.txt\u0026#34;); // 将字节流转换为字符流，使用UTF-8编码方式 InputStreamReader isr = new InputStreamReader(fis, \u0026#34;UTF-8\u0026#34;); // 使用缓冲流包装字符流，提高读取效率 BufferedReader br = new BufferedReader(isr); // 创建输出流，使用UTF-8编码方式 FileOutputStream fos = new FileOutputStream(\u0026#34;output.txt\u0026#34;); // 将输出流包装为转换流，使用UTF-8编码方式 OutputStreamWriter osw = new OutputStreamWriter(fos, \u0026#34;UTF-8\u0026#34;); // 使用缓冲流包装转换流，提高写入效率 BufferedWriter bw = new BufferedWriter(osw); // 读取输入文件的每一行，写入到输出文件中 String line; while ((line = br.readLine()) != null) { bw.write(line); bw.newLine(); // 每行结束后写入一个换行符 } // 关闭流 br.close(); bw.close(); } catch (IOException e) { e.printStackTrace(); } 序列化流 序列化\n是将对象转换为字节流的过程，这样对象可以通过网络传输、持久化存储或者缓存。Java 提供了 java.io.Serializable 接口来支持序列化，只要类实现了这个接口，就可以将该类的对象进行序列化。\n反序列化\n是将字节流重新转换为对象的过程，即从存储中读取数据并重新创建对象。\nObjectOutputStream序列化流 构造方法 ObjectOutputStream(OutputStream out)\n1 2 FileOutputStream fos = new FileOutputStream(\u0026#34;file.txt\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); 写入方法 public final writeObject (Object obj)：写入一个对象 public void write(int b) throws IOException public void write(byte[] b, int off, int len) throws IOException 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class ObjectOutputStreamDemo { public static void main(String[] args) { Person person = new Person(\u0026#34;沉默王二\u0026#34;, 20); try { FileOutputStream fos = new FileOutputStream(\u0026#34;logs/person.dat\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(person); oos.close(); } catch (IOException e) { e.printStackTrace(); } } } class Person implements Serializable { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } } ObjectInputStream反序列化流 ObjectInputStream 可以读取 ObjectOutputStream 写入的字节流，并将其反序列化为相应的对象（包含对象的数据、对象的类型和对象中存储的属性等信息）。\n构造方法 ObjectInputStream(InputStream in) 读入方法 public Object readObject()：读入对象 public void read()：读一个字节 Serializable序列化接口 定义\n1 2 public interface Serializable { } 注意事项\nstatic和 transient修饰的字段是不会被序列化的 被反序列化后，transient 字段的值被设为初始值 Java底层根据类的内容对实现了Serializable接口的类计算出类型为long的版本号serialVersionUID，若类的代码发生改变会使版本号改变导致无法反序列化 Java 虚拟机会把字节流中的 serialVersionUID 与被序列化类中的 serialVersionUID 进行比较，如果相同则可以进行反序列化，否则就会抛出序列化版本不一致的异常 通常使用private ，static ，final 来修饰serialVersionUID transient瞬态关键字 在实际开发过程中，不需要被序列化的字段，比如说用户的一些敏感信息（如密码、银行卡号等），为了安全起见，不希望在网络操作中传输或者持久化到磁盘文件中，那这些字段就可以加上 transient 关键字。\n被 transient 关键字修饰的成员变量在反序列化时会被自动初始化为默认值\n","date":"2024-11-19T16:32:57+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84io%E6%B5%81/","title":"Java中的IO流"},{"content":"File类 File类是文件的抽象表示，用于文件与目录的创建，查找，删除，只能对文件本身操作，不能对文件内容操作\n构造方法 public File(String pathname) // 根据路径创建文件对象 public File(String parent, String child) // 根据父路径和子路径创建文件对象 public File(File parent, String child) // 根据父目录 File 对象和子路径创建文件对象 注意事项\nFile对象代表硬盘中实际存在的文件和目录 File类的构造方法不检查是否存在该路径 常见操作 判断文件/目录 public boolean isFile()：判断是否是文件 public boolean isDirectory()：判断是否为目录 获取文件/目录的基本信息 public String getName()：获取文件名 public String getAbsolutePath()：获取绝对路径 public String getParent()：获取父目录 public long length()：获取文件大小（以B为单位） public long lastModified()：获取最后修改时间 检查读/写/可执行权限 public boolean canRead() public boolean canWrite() public boolean canExecute() 创建文件/目录 public boolean createNewFile() throws IOException：创建文件 原先文件不存在则创建成功返回true 原先文件存在则创建失败返回false 创建目录 public boolean mkdir()：创建单级目录，父目录不存在则创建失败 public boolean mkdirs()：创建多级目录，父目录不存在则一并创建 删除文件目录 public boolean delete() 列举目录文件 public String[] list()：列出目录中的文件名 public File[] listFiles()：列出目录中的File对象 ","date":"2024-11-17T15:48:33+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","title":"Java的文件操作"},{"content":"异常的定义 在 Java 中，异常（Exception） 是程序运行过程中发生的一种错误或意外情况，可能会中断程序的正常执行流程。异常机制通过捕获和处理错误，避免程序崩溃，提供了一种高效的错误管理方式。\n本质：异常是一个对象，表示程序运行中的问题。\n异常的继承结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 java.lang.Object └── java.lang.Throwable ├── java.lang.Error │ ├── VirtualMachineError │ │ ├── OutOfMemoryError │ │ ├── StackOverflowError │ │ └── InternalError │ ├── LinkageError │ └── AssertionError └── java.lang.Exception ├── IOException │ ├── FileNotFoundException │ └── EOFException ├── RuntimeException │ ├── NullPointerException │ ├── ArithmeticException │ ├── ArrayIndexOutOfBoundsException │ ├── ClassCastException │ └── IllegalArgumentException ├── SQLException ├── ParseException └── ClassNotFoundException Throwable 类 所有错误和异常的超类。 定义了 printStackTrace()、getMessage() 和 toString() 等常用方法。 Error 类 定义：表示程序运行时的严重问题，通常是 JVM 无法处理的情况。 特点 是 Throwable 的子类。 不受检查的异常，编译器不强制要求处理。 程序无法通过代码处理这些错误，通常由 JVM 抛出。 常见类型 OutOfMemoryError：JVM 堆内存耗尽。 StackOverflowError：递归调用过深导致栈溢出。 InternalError：JVM 内部错误。 Exception 类 定义：表示程序中可预料的问题，可以通过代码进行捕获和处理。\n特点：\n是 Throwable 的子类。 包括两种子类： 受检异常（Checked Exception）：在源代码里必须显式地捕获或者抛出，否则编译器会提示你进行相应的操作。 非受检异常（Unchecked Exception，RuntimeException）：通常是由程序逻辑错误导致的，可以通过编码进行规避的，并不需要显式地捕获或者抛出。 Exception和Error的区别 Exception 和 Error 都是 Throwable 类的子类（在 Java 代码中只有继承了 Throwable 类的实例才可以被 throw 或者被 catch）它们表示在程序运行时发生的异常或错误情况。\n总结来看：Exception 表示可以被处理的程序异常，Error 表示系统级的不可恢复错误。\nException：是程序中可以处理的异常情况，表示程序逻辑或外部环境中的问题，可以通过代码进行恢复或处理。Exception 又分为 Checked Exception（编译期异常）和 Unchecked Exception（运行时异常）。\nChecked Exception：在编译时必须显式处理（如使用 try-catch 块或通过 throws 声明抛出）。如 IOException。\nUnchecked Exception：运行时异常，不需要显式捕获。常见的如 NullPointerException、IllegalArgumentException 等，继承自 RuntimeException。\nError：表示严重的错误，通常是 JVM 层次内系统级的、无法预料的错误，程序无法通过代码进行处理或恢复。例如内存耗尽（OutOfMemoryError）、栈溢出（StackOverflowError）。Error 不应该被程序捕获或处理，因为一般出现这种错误时程序无法继续运行。\n异常的处理方式 JVM默认处理方式 查找异常处理器：\nJVM 会尝试在当前方法调用栈中寻找匹配该异常的处理器（ catch 块）。\n如果找到对应的处理器，程序会进入相应的 catch 块执行。\n未找到处理器：\n如果当前方法没有匹配的异常处理器，JVM 会将该异常抛给调用它的方法。\n这个过程会沿着方法调用栈向上查找，直到主方法 main()。\n异常到达 main() 方法：\n如果异常传播到 main() 方法仍然未被捕获，JVM 默认的异常处理机制会接管。 异常信息打印：\nJVM 会调用异常对象的\n1 printStackTrace() 方法，打印异常的堆栈跟踪信息，包括：\n异常类型（如 NullPointerException、ArithmeticException 等）。 异常的详细信息（如异常消息）。 异常发生的代码位置（方法名和行号）。 堆栈信息从异常发生的位置开始，逐步列出调用栈的各个方法。\n终止程序： 打印完堆栈跟踪信息后，JVM 会终止程序的执行。\n捕获并处理异常 try-catch-finally块 使用 try-catch-finally 块捕获异常并对其进行处理。\n语法格式\n1 2 3 4 5 6 7 8 9 try { // 可能抛出异常的代码 } catch (ExceptionType1 e1) { // 处理 ExceptionType1 的异常 } catch (ExceptionType2 e2) { // 处理 ExceptionType2 的异常 } finally { // 可选：无论是否发生异常，都会执行的代码 } try 块中包含可能抛出异常的代码 catch 块用于捕获并处理特定类型的异常。可以有多个catch块来处理不同类型的异常。 finally 块：用于定义无论是否发生异常都会执行的代码块。通常用于释放资源，确保资源的正确关闭。 执行流程\n没有异常\n当 try 块中没有发生异常时：\n执行 try 块中的代码（ return 之前的部分），将 return 中的返回值暂时保存。 跳过 catch 块。 执行 finally 块中的代码，如果 finally 中有 return 则覆盖之前的返回值。 return 返回值并继续执行后续代码。 try中没有return的示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Main { public static void main(String[] args) { try { System.out.println(\u0026#34;try block executed\u0026#34;); } catch (Exception e) { System.out.println(\u0026#34;catch block executed\u0026#34;); } finally { System.out.println(\u0026#34;finally block executed\u0026#34;); } System.out.println(\u0026#34;program continues\u0026#34;); } } // 输出： // try block executed // finally block executed // program continues try中有return的示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Main { public static int test() { try { System.out.println(\u0026#34;try block executed\u0026#34;); return 1; // 返回值暂时保存 } catch (Exception e) { System.out.println(\u0026#34;catch block executed\u0026#34;); return 2; } finally { System.out.println(\u0026#34;finally block executed\u0026#34;); } } public static void main(String[] args) { System.out.println(\u0026#34;Return value: \u0026#34; + test()); } } // 输出： // try block executed // finally block executed // Return value: 1 异常发生且被捕获\n当 try 块中发生异常，并且异常被 catch 块捕获时：\n执行 try 块，直到发生异常的位置。 跳转到对应的 catch 块，执行 return 之前的代码，将返回值暂存。 执行 finally 块中的代码，如果 finally 中有 return 则覆盖之前的返回值。 返回之前的返回值或继续执行后续代码。 catch中没有return的示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Main { public static void main(String[] args) { try { System.out.println(\u0026#34;try block executed\u0026#34;); int result = 10 / 0; // 抛出异常 } catch (ArithmeticException e) { System.out.println(\u0026#34;catch block executed: \u0026#34; + e.getMessage()); } finally { System.out.println(\u0026#34;finally block executed\u0026#34;); } System.out.println(\u0026#34;program continues\u0026#34;); } } // 输出： // try block executed // catch block executed: / by zero // finally block executed // program continues catch中有return的示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Main { public static int test() { try { System.out.println(\u0026#34;try block executed\u0026#34;); int result = 10 / 0; // 抛出异常 } catch (ArithmeticException e) { System.out.println(\u0026#34;catch block executed: \u0026#34; + e.getMessage()); return 2; // 被暂存 } finally { System.out.println(\u0026#34;finally block executed\u0026#34;); return 3; // 覆盖之前的返回值 } } public static void main(String[] args) { System.out.println(\u0026#34;Return value: \u0026#34; + test()); } } // 输出： // try block executed // catch block executed: / by zero // finally block executed // Return value: 3 特点\n当不出现异常时， try 块中的代码正常执行 当 try 块中可能出现多种异常时，书写多个对应的 catch 块捕获异常 一个 catch 只能处理一种异常 可以在 catch 块中同时捕获多种异常，异常之间用|隔开，表示多种异常采用相同的处理方式 当 try 中的异常没有被捕获则执行JVM默认异常处理方式 尽量将特定的异常放在前面，通用型的异常放在后面，不然编译器只会提示通用型的异常，其他的 catch 块永远也不会执行 finally 块的特点 如果 finally 块中包含 return 语句，会覆盖 try 或 catch 块中的 return 值。 finally 块前面必须有 try 块，不要把 finally 块单独拉出来使用。编译器也不允许这样做。 finally 块不是必选项，有 try 块的时候不一定要有 finally 块。 如果 finally 块中的代码可能会发生异常，也应该使用 try-catch 进行包裹。 即便是 try 块中执行了 return 、break、continue 这些跳转语句， finally 块也会被执行。 如果 catch 块抛出一个异常，而 finally 块中也抛出异常，那么最终抛出的将是 finally 块中的异常。 catch 块中的异常会被丢弃，而 finally 块中的异常会覆盖并向上传递。 finally 块中的逻辑一定被执行，无论是否出现异常，如果在 try 或 catch 块中调用了 System.exit() 方法，或者程序被强制终止， finally 块不会执行 try-with-resources 块 try-with-resources 是 Java 中的一种简洁方式，用于自动管理资源。资源在使用完成后会被自动关闭，而无需显式调用 close() 方法，从而减少资源泄漏的风险。\n它是在 Java 7 中引入的，资源必须实现 java.lang.AutoCloseable 接口（或其子接口 java.io.Closeable）。\n语法格式\n1 2 3 4 5 try (ResourceType resource = new ResourceType()) { // 使用资源的代码 } catch (ExceptionType e) { // 异常处理 } ResourceType：资源类型，例如文件流、数据库连接等。\n资源自动关闭：在 try 块结束后，resource 会自动调用 close() 方法。\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import java.io.BufferedReader; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; public class MultiResourceExample { public static void main(String[] args) { try ( BufferedReader reader = new BufferedReader(new FileReader(\u0026#34;input.txt\u0026#34;)); FileWriter writer = new FileWriter(\u0026#34;output.txt\u0026#34;) ) { String line; while ((line = reader.readLine()) != null) { writer.write(line + \u0026#34;\\n\u0026#34;); } } catch (IOException e) { System.out.println(\u0026#34;Error occurred: \u0026#34; + e.getMessage()); } } } 抛出异常 在方法声明中使用 throws 关键字\n在方法体中使用 throw 手动抛出异常\nthrows关键字 作用：声明一个方法可能抛出的异常，用于通知调用该方法的代码，必须处理这些异常 语法：放在方法签名中，位于参数列表和方法体之间。 适用范围：主要用于受检异常（Checked Exception）。 支持多个异常：可以在 throws 后列出多个异常类型，用逗号分隔。 语法格式\n1 method() throws ExceptionType { ... } 使用 throws 关键字，在方法签名上声明可能会抛出的异常，然后在调用该方法的地方使用 try-catch 进行处理。”\n示例\n1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String args[]){ try { myMethod1(); } catch (ArithmeticException e) { // 算术异常 } catch (NullPointerException e) { // 空指针异常 } } public static void myMethod1() throws ArithmeticException, NullPointerException{ // 方法签名上声明异常 } throw 关键字 作用：在方法体或代码块中，实际抛出一个异常对象，用于在代码中触发异常处理逻辑 语法：后面必须紧跟一个异常对象的实例（new ExceptionType(...)）。 适用范围：可以抛出任何异常（受检异常和运行时异常）。 每次只能抛出一个异常：不能同时抛出多个异常。 自定义异常 在 Java 中，除了使用内置异常（如 IOException 或 NullPointerException），还可以根据具体需求定义自己的异常类。自定义异常通常用于表示应用程序中的特定错误场景，提供更清晰的错误语义。\n实现方法 定义异常类：根据业务逻辑定义异常类\n继承现有异常类：\n通常从 Exception 或 RuntimeException 类派生。 如果希望异常必须被显式捕获（受检异常），继承 Exception 。 如果希望异常可以被选择性捕获（非受检异常），继承 RuntimeException 。 提供构造函数：\n提供默认构造函数。 提供接受错误消息和/或原因（Throwable）的构造函数。 定义受检异常 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 自定义受检异常 class CustomCheckedException extends Exception { public CustomCheckedException() { super(); } public CustomCheckedException(String message) { super(message); } public CustomCheckedException(String message, Throwable cause) { super(message, cause); } public CustomCheckedException(Throwable cause) { super(cause); } } public class CheckedExceptionDemo { public static void main(String[] args) { try { throwCustomException(); } catch (CustomCheckedException e) { System.out.println(\u0026#34;Caught exception: \u0026#34; + e.getMessage()); } } public static void throwCustomException() throws CustomCheckedException { throw new CustomCheckedException(\u0026#34;This is a custom checked exception\u0026#34;); } } 定义非受检异常 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 自定义非受检异常 class CustomUncheckedException extends RuntimeException { public CustomUncheckedException() { super(); } public CustomUncheckedException(String message) { super(message); } public CustomUncheckedException(String message, Throwable cause) { super(message, cause); } public CustomUncheckedException(Throwable cause) { super(cause); } } public class UncheckedExceptionDemo { public static void main(String[] args) { try { throwCustomException(); } catch (CustomUncheckedException e) { System.out.println(\u0026#34;Caught exception: \u0026#34; + e.getMessage()); } } public static void throwCustomException() { throw new CustomUncheckedException(\u0026#34;This is a custom unchecked exception\u0026#34;); } } ","date":"2024-11-16T15:20:48+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","title":"Java中的异常处理"},{"content":"MyBatis-Plus对MyBatis的改进 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 MyBatis和MyBatis-Plus开发流程的区别 MyBatis开发流程 引入相关依赖\n定义被@Mapper注解修饰mapper接口以及相关方法\n1 2 3 4 @Mapper public interface DistrictMapper { List\u0026lt;District\u0026gt;searchAll(String tname); } 在对应mapper.xml文件中书写对应的SQL语句或者在mapper接口中使用注解书写SQL语句\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34; \u0026gt; \u0026lt;mapper namespace=\u0026#34;org.example.operator.mapper.DistrictMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;searchAll\u0026#34; resultType=\u0026#34;org.example.operator.pojo.entity.District\u0026#34;\u0026gt; select did,dname,tdid,content,d_url,district.tid from district left join theme on district.tid = theme.tid where theme.tname = #{tname} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 在Service层中创建对应的Service接口\n1 2 3 4 5 6 7 package org.example.operator.service; import org.example.operator.pojo.dto.District.DistrictDTO; public interface DistrictDetailService { public void updateDistrictDetail(DistrictDTO districtDTO,String oldName); } 以及Service接口的实现类注入Mapper对象实现业务逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package org.example.operator.service.impl; import org.example.operator.common.exception.District.DistrictNotFound; import org.example.operator.common.exception.Theme.ThemeNotFound; import org.example.operator.common.utils.AliyunOSSUtils; import org.example.operator.mapper.DistrictMapper; import org.example.operator.mapper.ThemeMapper; import org.example.operator.pojo.dto.District.DistrictDTO; import org.example.operator.pojo.entity.District; import org.example.operator.pojo.entity.Theme; import org.example.operator.service.DistrictDetailService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; @Service public class DistrictDetailServiceImpl implements DistrictDetailService { @Autowired private ThemeMapper themeMapper; @Autowired private DistrictMapper districtMapper; @Autowired private AliyunOSSUtils aliyunOSSUtils; @Transactional @Override public void updateDistrictDetail(DistrictDTO districtDTO, String oldName) { String tname = districtDTO.getTname(); Theme theme = themeMapper.getThemeByName(tname); if (theme == null) { throw new ThemeNotFound(\u0026#34;主题不存在\u0026#34;); } District district = districtMapper.getDistrictByName(oldName); if (district == null) { throw new DistrictNotFound(\u0026#34;展品不存在\u0026#34;); } String durl = district.getD_url(); aliyunOSSUtils.deleteExhibitImage(durl); Long did = district.getDid(); Long tid = themeMapper.getThemeIdByName(districtDTO.getTname()); districtDTO.setDid(did); districtDTO.setTid(tid); districtMapper.updateDistrictDetail(districtDTO); districtMapper.updateDistrictTdid(districtDTO); } } 在Controller层使用Service接口对象进行响应\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.multipart.MultipartFile; @RestController @Slf4j @RequestMapping(\u0026#34;Operator/productDetail\u0026#34;) public class DistrictDetailController { @Autowired private DistrictSummeryService districtSummeryService; @Autowired private AliyunOSSUtils aliyunOSSUtils; @Autowired private DistrictDetailService districtDetailService; @RequestMapping(\u0026#34;/getProduct\u0026#34;) public Result\u0026lt;DistrictDetailVO\u0026gt; getProduct(String dname) { try{ DistrictDetailVO districtDetailVO = districtSummeryService.getDistrictDetail(dname); log.info(\u0026#34;展品详情：{}\u0026#34;, districtDetailVO); return Result.success(\u0026#34;查询展品详情成功\u0026#34;,districtDetailVO); } catch (Exception e){ log.error(\u0026#34;查询展品详情失败\u0026#34;); return Result.error(\u0026#34;查询展品详情失败\u0026#34;); } } } MyBatis-Plus开发流程 引入相关依赖\n自定义Mapper继承MyBatis-Plus提供的接口BaseMapper，对于自定义SQL语句可以在对应mapper.xml文件中书写\n1 2 3 public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt;{ } 在Service层自定义Service接口继承IService接口\n1 2 3 public interface IUserService extends IService\u0026lt;User\u0026gt;{ } 自定义Service实现类，实现自定义接口并继承Servicelmpl类，注入Mapper对象实现业务逻辑（Wrapper条件构造器在这里使用）\n1 2 3 4 @Service public class UserServiceImpl extends ServiceImpl\u0026lt;UserMapper,User\u0026gt; implements IUserService{ } 在Controller层使用Service接口对象进行响应\n具体使用 引入依赖（参见官方文档 ），MyBatisPlus官方提供了starter，其中集成了Mybatis和MybatisPlus的所有功能，并且实现了自动装配效果。因此我们可以用MybatisPlus的starter代替Mybatis的starter:\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-spring-boot3-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 定义Mapper：自定义Mapper继承MyBatis-Plus提供的接口BaseMapper\n1 2 3 public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt;{ } 默认配置 MyBatis-Plus通过扫描实体类，利用反射机制获取实体类的信息作为数据库表的信息\n类名驼峰转下划线作为表名 名为id的字段作为主键 变量名驼峰转下划线作为表的字段名 1 2 3 public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt;{ } 1 2 3 4 5 6 7 8 9 10 11 public class User{ private Long id; private String username; private string password; private String phone; private string info; private Integer status; private Integer balance; private LocalDateTime createTime; //对应表的字段 create_time private LocalDateTime updateTime; //对应表的字段 update_time } 自定义配置 如果不符合Mybatis-Plus的约定就要使用自定义配置。\n基于注解的配置 @TableName：用来指定表名（该注解用于指定实体类对应的数据库表名。当实体类名与数据库表名不一致，或者实体类名不是数据库表名的驼峰写法时，您需要使用这个注解来明确指定表名。） @TableId：用来指定表中的主键字段信息 value：对应数据库表中的主键字段名 type：主键策略 AUTO：数据库自增长 INPUT：通过set方法自行输入 ASSIGN_ID：分配id @TableField ：用来指定表中的普通字段信息 使用场景 成员变量名与数据库字段名不一致 成员变量名以is开头，且是布尔值(经过反射处理，它会将is去掉作为数据库字段名) 成员变量名与数据库关键字冲突 成员变量名不是数据库字段(数据库中不存在该字段) 具体注解参考官方文档\n基于yml的注解 在SpringBoot项目中可以通过修改application.yml来配置\n1 2 3 4 5 6 7 8 9 10 11 mybatis-plus: type-aliases-package: com.gty.mp.domain.po #注册后，在 Mapper 对应的 XML 文件中可以直接使用类名，无需使用全限定类名。 mapper-locations: \u0026#34;classpath*:/mapper/**/*.xml\u0026#34; #mapper.xml文件地址, 默认值 configuration: map-underscore-to-camel-case: true #是否开启下划线和驼峰的映射 cache-enabled: true #是否开启二级映射 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl #开启mybatis打印日志 global-config: db-config: id-type: assign_id #id为雪花算法生成,注解配置大于全局配置 update-strategy: not_null # 更新策略:只更新非空字段 具体详细配置参考官方文档\n条件构造器（Wrapper） MyBatis-Plus 提供了一套强大的条件构造器（Wrapper），用于构建复杂的数据库查询条件。（BaseMapper实现简单的单表查询）\nWrapper 类允许开发者以链式调用的方式构造查询条件，无需编写繁琐的 SQL 语句，从而提高开发效率并减少 SQL 注入的风险。\n通常作为mapper方法（自定义在mapper接口或者MyBatis-Plus已经实现的）的参数在service层使用\n类的继承结构 AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件\nQueryWrapper ： Query条件封装 UpdateWrapper ： Update条件封装 AbstractLambdaWrapper ： 使用Lambda语法 LambdaQueryWrapper ：基于Lambda语法使用的查询Wrapper LambdaUpdateWrapper ： 基于Lambda语法使用的更新Wrapper QueryWrapper和LambdaQueryWrapper通常用来构建select、delete、update的where条件部分\nUpdateWrapper和LambdaUpdateWrapper通常只有在set语句比较特殊才使用\n具体使用 创建Wrapper对象 Wrappers静态方法： public static \u0026lt;T\u0026gt; QueryWrapper\u0026lt;T\u0026gt; query() 通过QueryWrapper对象的构造方法： public QueryWrapper() 通过lambda方法可以将普通Wrapper转换成lambdaWrapper 基于复杂条件构建wrapper，使用链式编程 示例方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package com.dfbz; import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.baomidou.mybatisplus.core.toolkit.Wrappers; import com.dfbz.entity.User; import com.dfbz.mapper.UserMapper; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import java.util.List; /** * @author lscl * @version 1.0 * @intro: */ @SpringBootTest(classes = MyBatisPlusApplication.class) @RunWith(SpringRunner.class) public class Demo06_LambdaQueryMapper { @Autowired private UserMapper userMapper; /** * 使用QueryWrapper * @throws Exception */ @Test public void test1() throws Exception { QueryWrapper\u0026lt;User\u0026gt; wrapper = Wrappers.query(); wrapper.eq(\u0026#34;id\u0026#34;,\u0026#34;1\u0026#34;); List\u0026lt;User\u0026gt; userList = userMapper.selectList(wrapper); for (User user : userList) { System.out.println(user); } } /** * 使用LambdaQueryWrapper * @throws Exception */ @Test public void test2() throws Exception { LambdaQueryWrapper\u0026lt;User\u0026gt; wrapper = Wrappers.lambdaQuery(); // id=1 // wrapper.eq(User::getId,1); // select id,name,age from user where id in (1,2,3) and name like \u0026#34;%a%\u0026#34; wrapper.in(User::getId,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;) .like(User::getName,\u0026#34;a\u0026#34;) .select(User::getId,User::getName,User::getAge); List\u0026lt;User\u0026gt; userList = userMapper.selectList(wrapper); for (User user : userList) { System.out.println(user); } } } 条件方法 方法名 解释 示例 eq 等于 = eq(“name”, “老王”)**---\u0026gt;** name = ‘老王’ ne 不等于 \u0026lt;\u0026gt; ne(“name”, “老王”)**---\u0026gt;** name \u0026lt;\u0026gt; ‘老王’ gt 大于 \u0026gt; gt(“age”, 18)**---\u0026gt;** age \u0026gt; 18 ge 大于等于 \u0026gt;= ge(“age”, 18)**---\u0026gt;** age \u0026gt;= 18 lt 小于 \u0026lt; lt(“age”, 18)**---\u0026gt;** age \u0026lt; 18 le 小于等于 \u0026lt;= le(“age”, 18)**---\u0026gt;** age \u0026lt;= 18 between between 值1 and 值2 between(“age”, 18, 30)**---\u0026gt;** age between 18 and 30 notBetween not between 值1 and 值2 notBetween(“age”, 18, 30)**---\u0026gt;** age not between 18 and 30 like LIKE ‘%值%’ like(“name”, “王”)**---\u0026gt;** name like ‘%王%’ notLike NOT LIKE ‘%值%’ notLike(“name”, “王”)**---\u0026gt;** name not like ‘%王%’ likeLeft LIKE ‘%值’ likeLeft(“name”, “王”)**---\u0026gt;** name like ‘%王’ likeRight LIKE ‘值%’ likeRight(“name”, “王”)**---\u0026gt;** name like ‘王%’ isNull 字段 IS NULL isNull(“name”)**---\u0026gt;** name is null isNotNull 字段 IS NOT NULL isNotNull(“name”)**---\u0026gt;** name is not null in 字段 IN (v0, v1, …) in(“age”, 1, 2, 3)**---\u0026gt;** age in (1,2,3) notIn 字段 NOT IN (v0, v1, …) notIn(“age”, 1, 2, 3)**---\u0026gt;** age not in (1,2,3) inSql 字段 IN ( sql语句 ) inSql(“id”, “select id from table where id \u0026lt; 3”)**---\u0026gt;** id in (select id from table where id \u0026lt; 3) notInSql 字段 NOT IN ( sql语句 ) notInSql(“id”, “select id from table where id \u0026lt; 3”)**---\u0026gt;** id not in (select id from table where id \u0026lt; 3) groupBy 分组：GROUP BY 字段, … groupBy(“id”, “name”)**---\u0026gt;** group by id,name orderByAsc 排序：ORDER BY 字段, … ASC orderByAsc(“id”, “name”)**---\u0026gt;** order by id ASC,name ASC orderByDesc 排序：ORDER BY 字段, … DESC orderByDesc(“id”, “name”)**---\u0026gt;** order by id DESC,name DESC orderBy 排序：ORDER BY 字段, … orderBy(true, true, “id”, “name”)**---\u0026gt;** order by id ASC,name ASC having HAVING ( sql语句 ) 例1：having(“sum(age) \u0026gt; 10”)**---\u0026gt;** having sum(age) \u0026gt; 10 例2：having(“sum(age) \u0026gt; {0}”, 11)**---\u0026gt;** having sum(age) \u0026gt; 11 func 主要解决条件拼接 func(i -\u0026gt; if(true) {i.eq(“id”, 1)} else {i.ne(“id”, 1)}) or 拼接 OR eq(“id”,1).or().eq(“name”,“老王”)**---\u0026gt;** id = 1 or name = ‘老王’ and AND 嵌套 and(i -\u0026gt; i.eq(“name”, “李白”).ne(“status”, “活着”))**---\u0026gt;** and (name = ‘李白’ and status \u0026lt;\u0026gt; ‘活着’) nested 用于多条件拼接时 nested(i -\u0026gt; i.eq(“name”, “李白”).ne(“status”, “活着”))**---\u0026gt;** (name = ‘李白’ and status \u0026lt;\u0026gt; ‘活着’) apply 用于拼接SQL语句 例1：apply(“id = 1”)**---\u0026gt;** id = 1 例2：apply(“id = {0}”,1)**---\u0026gt;** *id = 1 例3：apply(“name like {0} and age \u0026gt; {1}”,“%J%”,18) **\\*\\*---\u0026gt;\\*\\* *name like ‘%J%’ and age \u0026gt; 18 last 无视优化规则直接拼接到 sql 的最后 *last(“limit 1”) **\\*\\*---\u0026gt;\\*\\* *在SQL语句最后面拼接：limit 1 exists 拼接 EXISTS ( sql语句 ) exists(“select id from table where age = 1”)**---\u0026gt;** exists (select id from table where age = 1) notExists 拼接 NOT EXISTS ( sql语句 ) notExists(“select id from table where age = 1”)**---\u0026gt;** not exists (select id from table where age = 1) 具体参见官方文档\n自定义SQL 可以利用MyBatis-Plus的Wrapper来构建复杂的where条件，然后自己定义SQL语句中剩下的部分。\n基于Wrapper定义复杂的Where条件\n在mapper方法参数中用@Param注解声明wrapper变量名称，名称必须为ew或者使用注解 @Param(Constants.WRAPPER) 明确指定参数为 Wrapper 对象。\n1 2 3 4 5 6 7 8 import com.baomidou.mybatisplus.core.conditions.Wrapper; import com.baomidou.mybatisplus.core.toolkit.Constants; import org.apache.ibatis.annotations.Param; public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt; { @Select(\u0026#34;SELECT * FROM user ${ew.customSqlSegment}\u0026#34;) List\u0026lt;User\u0026gt; selectByCustomSql(@Param(Constants.WRAPPER) Wrapper\u0026lt;User\u0026gt; wrapper); } 自定义SQL语句，使用${ew.customSqlSegment}来引用 Wrapper 对象生成的 SQL 片段。\n1 2 3 QueryWrapper\u0026lt;User\u0026gt; queryWrapper = new QueryWrapper\u0026lt;\u0026gt;(); queryWrapper.eq(\u0026#34;name\u0026#34;, \u0026#34;张三\u0026#34;); List\u0026lt;User\u0026gt; userList = userMapper.selectByCustomSql(queryWrapper); Service层接口（IService） MyBatis提供了Service层接口IService和默认实现类ServiceImpl\n使用流程 自定义Service接口继承IService接口（其中IService接口中的泛型为操纵的实体类）\n1 2 3 public interface IUserService extends IService\u0026lt;User\u0026gt;{ } 自定义Service实现类，实现自定义接口并继承Servicelmpl类（其中ServiceImpl中的泛型为对应的Mapper类和实体类）\n1 2 3 4 @Service public class UserServiceImpl extends ServiceImpl\u0026lt;UserMapper,User\u0026gt; implements IUserService{ } LambdaQuery和LambdaUpdate IService中还提供了Lambda功能来简化我们的复杂查询及更新功能。\n在Service层中可以代替Wrapper实现更加复杂的查询/更新\nlambdaQuery()和lambdaUpdate()方法直接获得一个Wrapper的子类通过链式编程简化\n在service层中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Override public List\u0026lt;User\u0026gt; queryUsers(UserQuery userQuery) { return lambdaQuery() .like(userQuery.getName() != null, User::getUsername, userQuery.getName()) .eq(userQuery.getStatus() != null, User::getStatus, userQuery.getStatus()) .ge(userQuery.getMinBalance() != null, User::getBalance, userQuery.getMinBalance()) .le(userQuery.getMaxBalance() != null, User::getBalance, userQuery.getMaxBalance()) .list(); } @Override public void deductionBalance(Long id, Integer money) { // 1.查询用户 User user = getById(id); // 2.校验用户状态 if (user == null || user.getStatus() == UserStatus.FREEZE) { throw new RuntimeException(\u0026#34;用户状态异常!\u0026#34;); } // 3.校验余额是否充足 if (user.getBalance() \u0026lt; money) { throw new RuntimeException(\u0026#34;用户余额不足\u0026#34;); } // 4.扣减余额 int remainBalance = user.getBalance() - money; lambdaUpdate() .set(User::getBalance, remainBalance) .set(remainBalance == 0, User::getStatus, UserStatus.FREEZE) .eq(User::getId, id) .eq(User::getBalance, user.getBalance()) //乐观锁 .update(); } 还需要在链式编程的最后添加一个list()，这是在告诉MP我们的调用结果需要是一个list集合。这里不仅可以用list()，可选的方法有：\n.one()：最多1个结果 .list()：返回集合结果 .count()：返回计数结果 批量插入 1 2 3 4 // 插入（批量） boolean saveBatch(Collection\u0026lt;T\u0026gt; entityList); // 插入（批量） boolean saveBatch(Collection\u0026lt;T\u0026gt; entityList, int batchSize); 效率一般：MybatisPlus的批处理是基于PrepareStatement的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。而想得到最佳性能，最好是将多条SQL合并为一条。\n提升效率的方式\nMySQL的客户端连接参数中有这样的一个参数：rewriteBatchedStatements。顾名思义，就是重写批处理的statement语句。这个参数的默认值是false，我们需要修改连接参数，将其配置为true。\n在配置文件中，在数据库连接配置中在url后面加上 rewriteBatchedStatements=true 的一个参数：\n分页插件 具体参见官方文档\n在配置类中注册MyBatis-Plus的核心插件。同时添加分页插件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Configuration @MapperScan(\u0026#34;scan.your.mapper.package\u0026#34;) public class MybatisPlusConfig { /** * 添加分页插件 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { //创建MyBatis-Plus拦截器 MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); //添加内部拦截器（插件） // 添加分页插件 PaginationInnerInterceptor paginationInnerInterceptor = new PaginationInnerInterceptor(DbType.MYSQL); //可以给分页插件添加属性 //overflow\tboolean\tfalse\t溢出总页数后是否进行处理 //maxLimit\tLong\t单页分页条数限制 //dbType\tDbType\t数据库类型 //dialect\tIDialect\t方言实现类 interceptor.addInnerInterceptor(paginationInnerInterceptor); // 如果配置多个插件, 切记分页最后添加 // 如果有多数据源可以不配具体类型, 否则都建议配上具体的 DbType return interceptor; } } 在Mapper方法使用分页相关API\n设置分页参数\n1 2 3 4 5 6 7 8 //方法一 int pageNo = 1; //页码 int pageSize = 2; //每页大小 Page\u0026lt;User\u0026gt; pageInfo = Page.of(pageNo, pageSize); Page\u0026lt;User\u0026gt;p=userMapper.page(pageInfo); //方法二 Page\u0026lt;User\u0026gt; pageInfo = new Page\u0026lt;\u0026gt;(page,pageSize); Page\u0026lt;User\u0026gt;p = userService.page(pageInfo); 进行分页查询\n1 2 Page\u0026lt;T\u0026gt; page_name=userMapper.selectPage(page, wrapper); //条件分页查询 Page\u0026lt;T\u0026gt; page_name=userMapper.page(page);//普通分页查询 使用相关API\n1 2 3 4 5 6 7 当前页数：page.getCurrent() 总页数： page.getPages() 记录数： page.getTotal() 是否有上一页： page.hasPrevious() 是否有下一页： page.hasNext() 分页数据：page.getRecords() 排序条件：page.addOrder(new OrderItem(\u0026#34;数据库字段名\u0026#34;,true)); //升序为true,降序为false ","date":"2024-11-16T10:56:19+08:00","permalink":"https://Tyritic.github.io/p/mybatis-plus/","title":"MyBatis Plus"},{"content":"泛型的定义 泛型是 Java 编程语言中的一个重要特性，它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型。\n泛型的主要目的是在编译时提供更强的类型检查，并且在编译后能够保留类型信息，避免了在运行时出现类型转换异常。\n泛型的作用 类型安全：泛型允许在编译时进行类型检查，确保在使用集合或其他泛型类时，不会出现类型不匹配的问题，减少了运行时的 ClassCastException 错误。 代码重用：泛型使代码可以适用于多种不同的类型，减少代码重复，提升可读性和维护性。 消除显式类型转换：泛型允许在编译时指定类型参数，从而消除了运行时需要显式类型转换的麻烦。 泛型的使用 泛型类 类的成员变量的类型不确定，可以使用泛型表示\n语法格式\n1 2 3 class className\u0026lt;T\u0026gt;{ } 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 泛型类的定义 public class Box\u0026lt;T\u0026gt; { private T value; public void setValue(T value) { this.value = value; } public T getValue() { return value; } } // 使用泛型类 Box\u0026lt;Integer\u0026gt; intBox = new Box\u0026lt;\u0026gt;(); intBox.setValue(10); Integer intValue = intBox.getValue(); System.out.println(intValue); // 输出: 10 Box\u0026lt;String\u0026gt; stringBox = new Box\u0026lt;\u0026gt;(); stringBox.setValue(\u0026#34;Hello, Generic!\u0026#34;); String strValue = stringBox.getValue(); System.out.println(strValue); // 输出: Hello, Generic! 泛型接口 用类型参数来参数化接口的方法和字段，泛型类和非泛型类都可以实现泛型接口，只是非泛型类给泛型接口提供具体类型\n示例代码\n泛型类实现泛型接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 泛型接口的定义 interface Pair\u0026lt;K, V\u0026gt; { K getKey(); V getValue(); } // 泛型接口的实现 class MyPair\u0026lt;K, V\u0026gt; implements Pair\u0026lt;K, V\u0026gt; { private K key; private V value; public MyPair(K key, V value) { this.key = key; this.value = value; } @Override public K getKey() { return key; } @Override public V getValue() { return value; } } // 使用泛型接口 Pair\u0026lt;String, Integer\u0026gt; pair = new MyPair\u0026lt;\u0026gt;(\u0026#34;Age\u0026#34;, 30); System.out.println(pair.getKey() + \u0026#34;: \u0026#34; + pair.getValue()); // 输出: Age: 30 非泛型类实现泛型接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 泛型接口 interface Pair\u0026lt;K, V\u0026gt; { K getKey(); V getValue(); } // 非泛型类实现泛型接口 class MyPair implements Pair\u0026lt;String, Integer\u0026gt; { private String key; private Integer value; public MyPair(String key, Integer value) { this.key = key; this.value = value; } @Override public String getKey() { return key; } @Override public Integer getValue() { return value; } } public class Main { public static void main(String[] args) { MyPair pair = new MyPair(\u0026#34;Age\u0026#34;, 30); System.out.println(pair.getKey() + \u0026#34;: \u0026#34; + pair.getValue()); // 输出: Age: 30 } } 泛型方法 泛型方法是指在方法的定义中，使用类型参数。与泛型类不同的是，泛型方法的类型参数只适用于该方法，而不影响整个类。\n语法格式\n1 2 3 访问控制符 \u0026lt;T\u0026gt; 方法返回值 方法名(形参列表){ } 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 泛型方法的定义 public class GenericMethodExample { public static \u0026lt;T\u0026gt; void printArray(T[] array) { for (T element : array) { System.out.print(element + \u0026#34; \u0026#34;); } System.out.println(); } public static void main(String[] args) { Integer[] intArray = {1, 2, 3}; String[] strArray = {\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;}; // 调用泛型方法 printArray(intArray); // 输出: 1 2 3 printArray(strArray); // 输出: Hello World } } 泛型的通配符 Java 泛型的上限定符 用于对泛型类型参数进行范围限制\n无界通配符 无界通配符表示泛型类型没有任何限制，可以接受任何类型。它适用于不关心具体类型的场景，常用于方法参数中。\n语法参数\n1 \u0026lt;?\u0026gt; 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.util.List; public class WildcardExample { public static void printList(List\u0026lt;?\u0026gt; list) { for (Object obj : list) { System.out.println(obj); } } public static void main(String[] args) { List\u0026lt;String\u0026gt; stringList = List.of(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); List\u0026lt;Integer\u0026gt; intList = List.of(1, 2, 3); printList(stringList); // 可以传递任何类型的 List printList(intList); } } 上界通配符 语法格式\n1 \u0026lt;? extends T\u0026gt; 上界通配符限制泛型类型必须是指定类型 T 或 T 的子类。这意味着，\u0026lt;? extends T\u0026gt; 可以接受 T 类型及其所有子类型。上界通配符通常用于读取操作，确保可以读取为 T 或 T 的子类的对象。。\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.util.List; public class UpperBoundWildcardExample { public static void printNumbers(List\u0026lt;? extends Number\u0026gt; list) { for (Number number : list) { System.out.println(number); } } public static void main(String[] args) { List\u0026lt;Integer\u0026gt; intList = List.of(1, 2, 3); List\u0026lt;Double\u0026gt; doubleList = List.of(1.1, 2.2, 3.3); printNumbers(intList); // 可以传递 List\u0026lt;Integer\u0026gt; printNumbers(doubleList); // 可以传递 List\u0026lt;Double\u0026gt; } } 下界通配符 语法格式\n1 \u0026lt;? super T\u0026gt; 下界通配符限制泛型类型必须是指定类型 T 或 T 的父类。\u0026lt;? super T\u0026gt; 适用于我们要往集合中添加元素的情况，它保证了能够安全地将 T 类型及其子类型的对象放入容器中。\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import java.util.List; public class LowerBoundWildcardExample { public static void addNumbers(List\u0026lt;? super Integer\u0026gt; list) { list.add(42); // 只允许添加 Integer 或其子类型的元素 } public static void main(String[] args) { List\u0026lt;Number\u0026gt; numberList = List.of(1, 2, 3); List\u0026lt;Object\u0026gt; objectList = List.of(\u0026#34;string\u0026#34;, 10.5); addNumbers(numberList); // 可以传递 List\u0026lt;Number\u0026gt; addNumbers(objectList); // 可以传递 List\u0026lt;Object\u0026gt; } } 使用规则 \u0026lt;? extends T\u0026gt; 的泛型集合中只能读取数据不能写入数据 示例\n1 2 3 4 5 6 7 8 9 10 11 import java.util.List; public class Test { public static void addToList(List\u0026lt;? extends Number\u0026gt; list) { for (Number num : list) { System.out.println(num); // 读取是安全的 } // list.add(1); // 编译错误 // list.add(3.14); // 编译错误 } } 解释\n当使用\u0026lt;? extends T\u0026gt; ,泛型集合中元素的类型是 T 类型或 T 的任意子类型 可读取性：\u0026lt;? extends T\u0026gt; 确保了集合中的每个元素至少是 T 类型或其子类，因此可以安全地以多态（向上转型）赋值给 T 类型的变量 。 不可写入性：List\u0026lt;? extends T\u0026gt; 限定了泛型上界为 T 的子类，但无法保证具体是哪种类型，因此不能添加元素（除了 null），否则会违反类型安全性。 \u0026lt;? super T\u0026gt; 的泛型集合中只能写入数据不能读取数据 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import java.util.List; import java.util.ArrayList; public class Test { public static void addToList(List\u0026lt;? super Integer\u0026gt; list) { list.add(10); // 可以添加 Integer 类型的数据 list.add(100); // 可以继续添加 Integer 类型的数据 } public static void main(String[] args) { List\u0026lt;Number\u0026gt; numberList = new ArrayList\u0026lt;\u0026gt;(); addToList(numberList); // 传入 List\u0026lt;Number\u0026gt; 是安全的 List\u0026lt;Object\u0026gt; objectList = new ArrayList\u0026lt;\u0026gt;(); addToList(objectList); // 传入 List\u0026lt;Object\u0026gt; 也是安全的 Object obj = list.get(0); // 可以读取为 Object 类型 // Integer num = list.get(0); // 编译错误，不能直接读取为 Integer } } 解释\n当使用 \u0026lt;? super T\u0026gt; 时，泛型集合中元素的类型是 T 类型或 T 的任意父类型 可写入性：\u0026lt;? super T\u0026gt; 确保了集合中的每个元素至少是 T 类型或其父类，因此可以安全地写入 T 类型及其子类的变量。 不可读取性：编译器并不知道集合实际存储的具体类型，因此无法确定返回的元素类型是什么，唯一可以确定的是，所有元素至少是 Object 类型，因此只能将读取的元素视为 Object。 PECS 原则 PECS 原则是 Producer Extends, Consumer Super 的缩写，帮助理解何时使用上界和下界限定符：\nProducer Extends：如果某个对象提供数据（即生产者），使用 extends（上界限定符）。 Consumer Super：如果某个对象接收数据（即消费者），使用 super（下界限定符）。 类型擦除和伪泛型 Java 中的泛型被称为 伪泛型（erasure），这是因为 Java 的泛型是通过 类型擦除（type erasure） 实现的\n类型擦除 实现方式 编译时：\n用原始类型替换泛型类型：所有泛型类和方法会被编译为使用原始类型的代码。例如，List\u0026lt;String\u0026gt; 会变成 List，T 会变成 Object。 类型边界：如果泛型类或方法有上界限制（如 T extends Number），那么在擦除时，T 会被替换为这个边界类型（例如 Number）。 类型参数的强制转换：在泛型类和方法中，编译器会插入强制类型转换，以确保在运行时正确转换类型。 运行时：在运行时，Java 并不保留泛型类型信息，所有泛型类型都被转换成了原始类型。\n示例说明\n编译前\n1 2 3 4 5 6 7 8 9 10 11 public class Box\u0026lt;T\u0026gt; { private T value; public void setValue(T value) { this.value = value; } public T getValue() { return value; } } 编译后\n1 2 3 4 5 6 7 8 9 10 11 public class Box { private Object value; public void setValue(Object value) { this.value = value; } public Object getValue() { return value; } } 作用和影响 作用：泛型擦除确保了 Java 代码的向后兼容性，但它也限制了在运行时对泛型类型的操作。\n影响：\n类型信息丢失：由于类型擦除，无法在运行时获取泛型的实际类型，导致无法进行以下操作 不能创建泛型类型的数组，不能实例化泛型类型的变量 对泛型类型使用 instanceof 检查 类型转换异常：在运行时，由于类型擦除的存在，可能会导致类型转换异常。例如，如果你错误地将 List\u0026lt;Integer\u0026gt; 和 List\u0026lt;String\u0026gt; 混用，编译时可能不会发现问题，而在运行时会导致 ClassCastException。 无法使用基本类型作为泛型：由于类型擦除的原因，Java 泛型无法直接使用基本数据类型（如 int、char 等），只能使用它们的包装类型（如 Integer、Character）。 利用反射获取泛型类型的情况 因为泛型信息保存在class文件中\n成员变量的泛型 方法入参的泛型 方法返回值的泛型 带来的问题 1 2 3 4 5 6 7 8 9 10 public class Cmower { public static void method(ArrayList\u0026lt;String\u0026gt; list) { System.out.println(\u0026#34;ArrayList\u0026lt;String\u0026gt; list\u0026#34;); } public static void method(ArrayList\u0026lt;Date\u0026gt; list) { System.out.println(\u0026#34;ArrayList\u0026lt;Date\u0026gt; list\u0026#34;); } } 在 Java 中，泛型是在编译时擦除的，这意味着 ArrayList\u0026lt;String\u0026gt; 和 ArrayList\u0026lt;Date\u0026gt; 在编译后会变成相同的类型 ArrayList。\n当方法重载时，如果两种方法的签名 在类型擦除后相同，就会发生冲突。 在这段代码中，ArrayList\u0026lt;String\u0026gt; 和 ArrayList\u0026lt;Date\u0026gt; 在类型擦除后都会变成 ArrayList，因此，编译器无法区分这两个方法，导致编译时发生冲突。 为什么是伪泛型 泛型只在编译时进行类型检查，运行时并不会保留泛型类型信息。\n在运行时泛型根本没有起作用！也就是说在运行的时候 JVM 获取不到泛型的信息，也会不对其做任何的约束。\n因此，虽然在 IDE 写代码的时候泛型生效了，而实际上在运行的时候泛型的类型是被擦除的。\n一言蔽之，Java的泛型只在编译时生效，JVM 运行时没有泛型。\n","date":"2024-11-16T09:46:03+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B/","title":"Java中的泛型"},{"content":"StringBuffer的定义 StringBuffer 是 Java 中用于创建可变字符串的类，提供了一个与 StringBuilder 类似的功能。它们都用于处理可变的字符串数据，不同之处在于 StringBuffer 是线程安全的，而 StringBuilder 不是。\nStringBuffer 的特点 可变字符串： StringBuffer 提供了修改字符串内容的方法，避免了每次修改字符串时创建新的 String 对象，从而提高了性能。 线程安全： StringBuffer 是线程安全的，意味着它可以在多个线程间安全地共享和操作。StringBuffer 中的方法通常都被同步（使用 synchronized），确保多线程环境下的线程安全。 效率较低： 由于线程安全的特性，StringBuffer 的性能通常比 StringBuilder 略差，因为 StringBuffer 的方法被加锁，而 StringBuffer 的方法没有锁定。 StringBuffer的构造函数 public StringBuffer() ：默认构造，初始化容量为 16 public StringBuffer(String str) ：以指定字符串初始化 public StringBuffer(int capacity)：以指定初始容量初始化 StringBuffer的常见操作 追加数据 public StringBuffer append(String str)：将字符串str追加到 StringBuffer 对象的末尾。 public StringBuffer append(int i)：将 i 转换为字符串并追加到 StringBuffer 对象的末尾。 public StringBuffer append(char c)：将 c 转换为字符串并追加到 StringBuffer 对象的末尾。 作用\nappend() 方法用于在 StringBuffer 对象的末尾追加指定的内容。 支持多种类型的参数，包括 String、int、char 等。调用时会将传入的内容转换为字符串后附加到原字符串的后面。 示例\n1 2 3 StringBuffer sb = new StringBuffer(\u0026#34;Hello\u0026#34;); sb.append(\u0026#34; World\u0026#34;).append(123).append(\u0026#39;!\u0026#39;); System.out.println(sb); // 输出：Hello World123! 插入内容 public StringBuffer insert(int offset, String str) public StringBuffer insert(int offset, int i) public StringBuffer insert(int offset, char c) 作用\ninsert() 方法将指定的内容插入到 StringBuffer 对象中指定位置。 offset 参数表示插入的位置，内容会从这个位置开始插入。 示例\n1 2 3 StringBuffer sb = new StringBuffer(\u0026#34;Hello!\u0026#34;); sb.insert(5, \u0026#34; Java\u0026#34;); System.out.println(sb); // 输出：Hello Java! 删除内容 public StringBuffer delete(int start, int end) 作用：\ndelete() 方法删除 StringBuffer 中从 start 到 end-1 位置的字符。 删除的是一个字符范围，start 是包含的起始位置，end 是不包含的结束位置。 示例：\n1 2 3 StringBuffer sb = new StringBuffer(\u0026#34;Hello Java!\u0026#34;); sb.delete(5, 10); System.out.println(sb); // 输出：Hello! 替换子串 public StringBuffer replace(int start, int end, String str) 作用：\nreplace() 方法将指定范围（start，end-1）内的字符替换为给定的字符串。 start 到 end 范围的字符被替换为 str。 示例：\n1 2 3 StringBuffer sb = new StringBuffer(\u0026#34;Hello World!\u0026#34;); sb.replace(6, 11, \u0026#34;Java\u0026#34;); System.out.println(sb); // 输出：Hello Java! 反转字符串 public StringBuffer reverse() 作用：\nreverse() 方法将 StringBuffer 中的字符序列反转。 例如，Hello 会变成 olleH。 示例：\n1 2 3 StringBuffer sb = new StringBuffer(\u0026#34;Hello\u0026#34;); sb.reverse(); System.out.println(sb); // 输出：olleH 获取属性 public int length()：获取字符串长度 public int capacity()：获取容量 操作指定位置的字符 public char charAt(int index)：获取指定位置的字符 public void setCharAt(int index, char ch)：设置指定位置的字符 截取子串 public String substring(int start) public String substring(int start, int end) 作用：\nsubstring() 方法返回 StringBuffer 中指定位置的子字符串。 如果只有 start 参数，则返回从 start 到最后的子字符串。 如果提供了 start 和 end，则返回该范围内的子字符串。 示例\n1 2 3 StringBuffer sb = new StringBuffer(\u0026#34;Hello World\u0026#34;); System.out.println(sb.substring(6)); // 输出：World System.out.println(sb.substring(0, 5)); // 输出：Hello 查找子串 public int indexOf(String str) public int indexOf(String str, int fromIndex) 作用：\nindexOf() 方法返回指定子字符串首次出现的位置。如果子字符串不存在，则返回 -1。 可以通过 fromIndex 参数指定从哪个位置开始查找。 示例\n1 2 3 StringBuffer sb = new StringBuffer(\u0026#34;Hello World\u0026#34;); System.out.println(sb.indexOf(\u0026#34;World\u0026#34;)); // 输出：6 System.out.println(sb.indexOf(\u0026#34;o\u0026#34;, 5)); // 输出：7 总体使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class StringBufferExample { public static void main(String[] args) { // 创建一个 StringBuffer 对象 StringBuffer sb = new StringBuffer(\u0026#34;Hello\u0026#34;); // 使用 append() 方法追加内容 sb.append(\u0026#34; World!\u0026#34;); System.out.println(sb); // 输出：Hello World! // 使用 insert() 方法插入内容 sb.insert(5, \u0026#34;,\u0026#34;); System.out.println(sb); // 输出：Hello, World! // 使用 delete() 方法删除内容 sb.delete(5, 6); // 删除从索引 5 到 6 的字符 System.out.println(sb); // 输出：Hello World! // 使用 reverse() 方法反转字符串 sb.reverse(); System.out.println(sb); // 输出：!dlroW olleH // 将 StringBuffer 转换为 String String str = sb.toString(); System.out.println(str); // 输出：!dlroW olleH // 获取 StringBuffer 的长度 System.out.println(sb.length()); // 输出：13 // 获取 StringBuffer 的容量 System.out.println(sb.capacity()); // 输出：27 (因为默认容量是16，加上追加的内容后，容量自动扩展) } } String，StringBuffer，StringBuilder的区别（面试题） String\n不可变：String 是不可变类，字符串一旦创建，其内容无法更改。每次对 String 进行修改操作（如拼接、截取等），都会创建新的 String 对象。 适合场景：String 适用于字符串内容不会频繁变化的场景，例如少量的字符串拼接操作或字符串常量。 StringBuffer\n可变：StringBuffer 是可变的，可以进行字符串的追加、删除、插入等操作。 线程安全：StringBuffer 是线程安全的，内部使用了 synchronized 关键字来保证多线程环境下的安全性。 适合场景：StringBuffer 适用于在多线程环境中需要频繁修改字符串的场景。 StringBuilder\n可变：StringBuilder 也是可变的，提供了与 StringBuffer 类似的操作接口。 非线程安全：StringBuilder 不保证线程安全，性能比 StringBuffer 更高。 适合场景：StringBuilder 适用于单线程环境中需要大量修改字符串的场景，如高频拼接操作。 ","date":"2024-11-15T23:03:07+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84stringbuffer/","title":"Java中的StringBuffer"},{"content":"StringBuilder的定义 StringBuilder 是 Java 中的一个 可变字符序列类，位于 java.lang 包中。它用于创建和操作可变的字符串（字符序列），与 String 不同，StringBuilder 的内容是 可变的，不会像 String 那样在每次修改时创建新的对象，从而提高了性能，尤其在需要频繁修改字符串时非常有用。\nStringBuilder的特点 可变性： StringBuilder 维护一个可变的char数组，操作时直接修改这个数组，不会生成新的对象。 效率高： 在进行字符串拼接、插入、删除等操作时，相比 String 创建大量临时对象，StringBuilder 只需在原对象上进行操作，因此效率更高。 线程不安全： 与 StringBuffer（线程安全版本）不同，StringBuilder 不是线程安全的，但在单线程环境下效率更高。 StringBuilder的构造方法 StringBuilder()\n无参构造函数，创建一个初始容量为 16 的空 StringBuilder 对象。\nStringBuilder(int capacity)\n指定初始容量的构造函数，创建一个具有指定初始容量的 StringBuilder 对象，如果在追加字符时超出指定容量，StringBuilder 会自动扩容，扩容规则为：\n新容量 = (旧容量 * 2) + 2\nStringBuilder(String str)\n以指定字符串内容为初始值的构造函数，创建一个包含给定字符串内容的 StringBuilder 对象，同时容量为 str.length() + 16。\nStringBuilder(CharSequence seq)\n以 CharSequence 接口实现类为初始内容的构造函数，创建一个包含指定字符序列的 StringBuilder 对象。\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Main { public static void main(String[] args) { // 无参构造 StringBuilder sb1 = new StringBuilder(); System.out.println(\u0026#34;sb1 的初始容量：\u0026#34; + sb1.capacity()); // 输出：16 // 指定容量构造 StringBuilder sb2 = new StringBuilder(30); System.out.println(\u0026#34;sb2 的初始容量：\u0026#34; + sb2.capacity()); // 输出：30 // 以字符串为初始值的构造 StringBuilder sb3 = new StringBuilder(\u0026#34;Hello\u0026#34;); System.out.println(\u0026#34;sb3 的初始内容：\u0026#34; + sb3.toString()); // 输出：Hello System.out.println(\u0026#34;sb3 的初始容量：\u0026#34; + sb3.capacity()); // 输出：21（5 + 16） // 以 CharSequence 为初始值的构造 CharSequence seq = \u0026#34;World\u0026#34;; StringBuilder sb4 = new StringBuilder(seq); System.out.println(\u0026#34;sb4 的初始内容：\u0026#34; + sb4.toString()); // 输出：World } } StringBuilder的常见操作 追加数据 public StringBuilder append(String str)：将字符串str追加到 StringBuilder 对象的末尾。 public StringBuilder append(int i)：将 i 转换为字符串并追加到 StringBuilder 对象的末尾。 public StringBuilder append(char c)：将 c 转换为字符串并追加到 StringBuilder 对象的末尾。 作用\nappend() 方法用于在 StringBuilder 对象的末尾追加指定的内容。 支持多种类型的参数，包括 String、int、char 等。调用时会将传入的内容转换为字符串后附加到原字符串的后面。 示例\n1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello\u0026#34;); sb.append(\u0026#34; World\u0026#34;).append(123).append(\u0026#39;!\u0026#39;); System.out.println(sb); // 输出：Hello World123! 插入内容 public StringBuilder insert(int offset, String str) public StringBuilder insert(int offset, int i) public StringBuilder insert(int offset, char c) 作用\ninsert() 方法将指定的内容插入到 StringBuilder 对象中指定位置。 offset 参数表示插入的位置，内容会从这个位置开始插入。 示例\n1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello!\u0026#34;); sb.insert(5, \u0026#34; Java\u0026#34;); System.out.println(sb); // 输出：Hello Java! 删除内容 public StringBuilder delete(int start, int end) 作用：\ndelete() 方法删除 StringBuilder 中从 start 到 end-1 位置的字符。 删除的是一个字符范围，start 是包含的起始位置，end 是不包含的结束位置。 示例：\n1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello Java!\u0026#34;); sb.delete(5, 10); System.out.println(sb); // 输出：Hello! 替换子串 public StringBuilder replace(int start, int end, String str) 作用：\nreplace() 方法将指定范围（start，end-1）内的字符替换为给定的字符串。 start 到 end 范围的字符被替换为 str。 示例：\n1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello World!\u0026#34;); sb.replace(6, 11, \u0026#34;Java\u0026#34;); System.out.println(sb); // 输出：Hello Java! 反转字符串 public StringBuilder reverse() 作用：\nreverse() 方法将 StringBuilder 中的字符序列反转。 例如，Hello 会变成 olleH。 示例：\n1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello\u0026#34;); sb.reverse(); System.out.println(sb); // 输出：olleH 获取属性 public int length()：获取字符串长度 public int capacity()：获取容量 操作指定位置的字符 public char charAt(int index)：获取指定位置的字符 public void setCharAt(int index, char ch)：设置指定位置的字符 截取子串 public String substring(int start) public String substring(int start, int end) 作用：\nsubstring() 方法返回 StringBuilder 中指定位置的子字符串。 如果只有 start 参数，则返回从 start 到最后的子字符串。 如果提供了 start 和 end，则返回该范围内的子字符串。 示例\n1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello World\u0026#34;); System.out.println(sb.substring(6)); // 输出：World System.out.println(sb.substring(0, 5)); // 输出：Hello 查找子串 public int indexOf(String str) public int indexOf(String str, int fromIndex) 作用：\nindexOf() 方法返回指定子字符串首次出现的位置。如果子字符串不存在，则返回 -1。 可以通过 fromIndex 参数指定从哪个位置开始查找。 示例\n1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello World\u0026#34;); System.out.println(sb.indexOf(\u0026#34;World\u0026#34;)); // 输出：6 System.out.println(sb.indexOf(\u0026#34;o\u0026#34;, 5)); // 输出：7 equals方法 StringBuilder 类中的 equals() 方法在默认情况下并不按内容比较两个 StringBuilder 对象，而是按 引用 比较，即两个 StringBuilder 对象是否指向相同的内存位置。\nStringBuilder的实现原理 大致核心实现 内部使用字符数组 (char[] value) 来存储字符序列 通过方法如 append()、insert() 等操作，直接修改内部的字符数组，而不会像 String 那样创建新的对象。 每次进行字符串操作时，如果当前容量不足，它会通过扩展数组容量来容纳新的字符，按 2 倍的容量扩展，以减少扩展次数，提高性能。 底层具体实现 StringBuilder 底层使用 char 数组 value 来存储字符，并且用 count 来记录存放的字符数 为了防止频繁地复制和申请内存，需要提供 capacity 参数来设置初始化数组的大小，这样可以减少数组的扩容次数，有效的提升效率！ append()的具体实现 int值转成 char 需要占数组的几位，然后计算一下现在的数组够不够放，如果不够就扩容，然后再把 int 转成 char 放进去，再更新现有的字符数。 扩容时调用 Arrays.copyOf，进行一波扩容加拷贝，扩容之后的数组容量为之前的两倍+2。 insert()的具体实现 这里是把 数据 转成 string 插入前先判断下数组长度足够，若不够就扩容。 移动字符，给待插入的位置腾出空间，然后往对应位置插入字符 最后更新 StringBuilder 已有的字符数 优化方法（JDK 11的优化） char 数组是可以优化的，底层可以用 byte 数组+一个 coder 标志位来实现，这样更节省内存，因为 char 占用两个字节，这样对于 latin 系的字符来说，太大了，就很浪费，所以用 byte 数组，然后配备一个 coder 来标识所用的编码。\n","date":"2024-11-15T21:13:12+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84stringbuilder/","title":"Java中的StringBuilder"},{"content":"一级缓存 一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问\n使一级缓存失效的四种情况: 不同的SqlSession对应不同的一级缓存 同一个SqlSession但是查询条件不同 同一个SqlSession两次查询期间执行了任何一次增删改操作 同一个SqlSession两次查询期间手动清空了缓存 二级缓存 二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存;此后若再次执行相同的查询语句，结果就会从缓存中获取。\n二级缓存开启的条件: 在核心配置文件中，设置全局配置属性cacheEnabled=\u0026ldquo;true\u0026rdquo;，默认为true，不需要设置 在mapper.xml映射文件中设置标签\u0026lt;cache \u0026gt; 二级缓存必须在SqlSession关闭或提交之后有效 查询的数据所转换的实体类类型必须实现序列化的接口 失效的情况 在两次查询之间进行任意的增删改，手动清空缓存只会清空一级缓存\n相关配置 在mapper.xml映射文件中设置标签\u0026lt;cache \u0026gt;\n相关属性参见 MyBatis官方文档\n缓存查询顺序 先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用 如果二级缓存没有命中，再查询一级缓存 如果一级缓存也没有命中，则查询数据库 Sqisession关闭之后，一级缓存中的数据会写入二级缓存 ","date":"2024-11-15T20:31:12+08:00","permalink":"https://Tyritic.github.io/p/mybatis%E7%BC%93%E5%AD%98/","title":"MyBatis缓存"},{"content":"Arrays类是用于对数组进行操作的工具类\n常见操作 排序 static void sort(int[] a) static \u0026lt;T\u0026gt; void sort(T[] a, Comparator\u0026lt;? super T\u0026gt; c) // 使用 Comparator 自定义排序 示例 1 2 3 4 5 6 7 int[] arr = {5, 2, 8, 1, 3}; Arrays.sort(arr); System.out.println(Arrays.toString(arr)); // 输出：[1, 2, 3, 5, 8] String[] strs = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;pear\u0026#34;}; Arrays.sort(strs, (s1, s2) -\u0026gt; s2.compareTo(s1)); // 按降序排序 System.out.println(Arrays.toString(strs)); // 输出：[pear, banana, apple] 二分查找 在已排序的数组中使用二分查找指定元素的索引。\nstatic int binarySearch(int[] a, int key) static \u0026lt;T\u0026gt; int binarySearch(T[] a, T key, Comparator\u0026lt;? super T\u0026gt; c) 示例 1 2 3 int[] arr = {1, 2, 3, 5, 8}; int index = Arrays.binarySearch(arr, 5); System.out.println(\u0026#34;元素 5 的索引：\u0026#34; + index); // 输出：元素 5 的索引：3 判断是否相等 判断两个数组是否相等（长度相同且对应元素相等）。\nstatic boolean equals(int[] a, int[] a2) static \u0026lt;T\u0026gt; boolean equals(T[] a, T[] a2) 示例 1 2 3 4 5 int[] arr1 = {1, 2, 3}; int[] arr2 = {1, 2, 3}; int[] arr3 = {1, 2, 4}; System.out.println(Arrays.equals(arr1, arr2)); // 输出：true System.out.println(Arrays.equals(arr1, arr3)); // 输出：false 判断两个多维数组是否相等\nstatic boolean deepEquals(Object[] a1, Object[] a2) 批量赋值 将数组的所有元素赋值为指定值\nstatic void fill(int[] a, int val) static \u0026lt;T\u0026gt; void fill(T[] a, T val) 示例 1 2 3 int[] arr = new int[5]; Arrays.fill(arr, 9); System.out.println(Arrays.toString(arr)); // 输出：[9, 9, 9, 9, 9] 复制数组 将指定数组复制到新的数组，返回一个新数组。\nstatic int[] copyOf(int[] original, int newLength) static \u0026lt;T\u0026gt; T[] copyOf(T[] original, int newLength) 示例 1 2 3 int[] arr = {1, 2, 3}; int[] newArr = Arrays.copyOf(arr, 5); System.out.println(Arrays.toString(newArr)); // 输出：[1, 2, 3, 0, 0] 将指定数组的某个范围复制到新的数组。\nstatic int[] copyOfRange(int[] original, int from, int to) static \u0026lt;T\u0026gt; T[] copyOfRange(T[] original, int from, int to) 示例\n1 2 3 int[] arr = {1, 2, 3, 4, 5}; int[] newArr = Arrays.copyOfRange(arr, 1, 4); // [from, to) System.out.println(Arrays.toString(newArr)); // 输出：[2, 3, 4] 数组转换为集合 static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; asList(T... a) 示例\n1 2 3 String[] strs = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;pear\u0026#34;}; List\u0026lt;String\u0026gt; list = Arrays.asList(strs); System.out.println(list); // 输出：[apple, banana, pear] ","date":"2024-11-15T17:32:46+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E5%B7%A5%E5%85%B7-arrays%E7%B1%BB/","title":"Java中的数组操作工具 Arrays类"},{"content":"内部类的定义 在 Java 中，**内部类（Inner Class）**是定义在另一个类内部的类。内部类可以更方便地访问外部类的成员变量和方法，同时也提升了封装性和代码的逻辑关联性。\n内部类的访问特定 内部类可以直接访问外部类的成员（包括private） 外部类要访问内部类的成员必须创建内部类对象 成员内部类 成员内部类是定义在外部类成员位置中的普通类。它与外部类的实例关联，只有在创建了外部类对象后，才能创建其内部类对象。\n特点 内部类可以直接访问外部类的私有成员。 创建内部类对象需要先创建外部类对象，再通过外部类对象创建内部类对象。 内部类中的变量可以被访问控制符和static修饰 使用格式 1 外部类.内部类 内存实现 在创建内部类对象时使用Outer.this记录外部类对象的地址值\n示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Outer { private String name = \u0026#34;OuterClass\u0026#34;; // 成员内部类 public class Inner { public void display() { System.out.println(\u0026#34;内部类访问外部类的成员: \u0026#34; + name); } } public static void main(String[] args) { Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); // 创建内部类对象 inner.display(); } } 静态内部类 静态内部类使用 static 修饰符定义，可以独立于外部类的实例进行创建\n特点 可以直接访问外部类的静态成员 不可以直接访问外部类的非静态成员,若要访问则要创建外部类对象 不存在Outer.this 语法格式 创建静态内部类对象\n1 外部类.内部类 变量名=new 外部类.内部类构造器 调用静态内部类方法的格式\n非静态方法：先创建静态内部类对象再调用 静态方法：外部类.内部类.方法名() 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Outer { private static String staticName = \u0026#34;StaticOuterClass\u0026#34;; // 静态内部类 public static class StaticInner { public void display() { System.out.println(\u0026#34;静态内部类访问外部类的静态成员: \u0026#34; + staticName); } } public static void main(String[] args) { Outer.StaticInner inner = new Outer.StaticInner(); // 直接创建静态内部类对象 inner.display(); } } 局部内部类 局部内部类是在方法或代码块中定义的类，作用域仅限于所在方法或代码块。\n特点 局部内部类的作用域仅限于定义它的方法或代码块中。 局部内部类可以访问外部类的成员以及方法中的局部变量（需要局部变量使用 final 或隐式 final 修饰）。 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Outer { public void method() { class LocalInner { public void display() { System.out.println(\u0026#34;这是局部内部类\u0026#34;); } } LocalInner inner = new LocalInner(); // 创建局部内部类对象 inner.display(); } public static void main(String[] args) { Outer outer = new Outer(); outer.method(); } } 匿名内部类 匿名内部类是没有名字的内部类，它是在定义类的同时创建该类的对象，通常用于简化代码，尤其在需要实现接口或继承抽象类时，可以避免单独定义实现类。\n本质：隐藏了名字的内部类\n使用前提：必须继承一个父类或实现一个接口\n特点 没有名字：匿名内部类在创建时定义，没有类名。\n一次性使用：匿名内部类只能使用一次，不能重复创建多个实例。\n可以继承类或实现接口：\n如果继承一个类，匿名内部类只能继承一个父类。\n如果实现一个接口，匿名内部类可以实现该接口并提供方法实现。\n与外部类关系：\n匿名内部类可以直接访问外部类的成员（包括私有成员）。\n如果匿名内部类是在局部方法中定义的，它只能访问**final**的局部变量。\n不能有构造方法：因为匿名内部类没有名字，无法定义构造方法。\n语法格式 1 2 3 new 接口名或父类名() { // 方法实现 }; Lambda表达式 Lambda 表达式是 Java 8 引入的一种新特性，旨在简化代码，特别是当使用匿名内部类实现接口时。Lambda 表达式可以理解为一种匿名函数，直接将行为（函数）作为参数传递，使代码更加简洁、可读。\n语法格式 1 (参数列表) -\u0026gt; { 方法体 } 可以用于简写匿名内部类 Lambda表达式只能简化实现函数式接口的匿名内部类\n函数式接口：有且仅有一个抽象方法的接口，被@FunctionalInterface注解\n省略规则 在参数列表中，参数类型可以省略，因为编译器会根据上下文推断参数的类型。 当 Lambda 表达式只有一个参数时，可以省略参数两边的小括号 () 当 Lambda 表达式的方法体中只有一条语句时，可以省略大括号 {}。同时，如果这条语句是 return 语句，可以省略 return 关键字。 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import java.util.Comparator; public class LambdaExample { public static void main(String[] args) { // 匿名内部类 Comparator\u0026lt;String\u0026gt; comparatorAnonymous = new Comparator\u0026lt;String\u0026gt;() { @Override public int compare(String s1, String s2) { return s1.length() - s2.length(); } }; // Lambda 表达式完整格式 Comparator\u0026lt;String\u0026gt; comparatorFull = (String s1, String s2) -\u0026gt; { return s1.length() - s2.length(); }; // Lambda 表达式省略格式 Comparator\u0026lt;String\u0026gt; comparatorSimplified = (s1, s2) -\u0026gt; s1.length() - s2.length(); // 使用匿名内部类 String resultAnonymous = max(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, comparatorAnonymous); System.out.println(\u0026#34;使用匿名内部类较长的字符串是：\u0026#34; + resultAnonymous); // 使用 Lambda 表达式完整格式 String resultFull = max(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, comparatorFull); System.out.println(\u0026#34;使用 Lambda 完整格式较长的字符串是：\u0026#34; + resultFull); // 使用 Lambda 表达式省略格式 String resultSimplified = max(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, comparatorSimplified); System.out.println(\u0026#34;使用 Lambda 省略格式较长的字符串是：\u0026#34; + resultSimplified); } // 辅助方法：根据 Comparator 返回较长的字符串 public static String max(String s1, String s2, Comparator\u0026lt;String\u0026gt; comparator) { return comparator.compare(s1, s2) \u0026gt; 0 ? s1 : s2; } } ","date":"2024-11-15T16:14:45+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB/","title":"Java中的内部类"},{"content":"JavaWeb的三大组件 Servlet Servlet是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容。\n狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。\n作用： 接收请求数据 处理请求 完成响应 使用方法 实现javax.servlet.Servlet接口； 继承javax.servlet.GenericServlet类； 继承javax.servlet.http.HttpServlet类； 工作原理 ​\tServlet接口定义了Servlet与servlet容器之间的契约。这个契约是：Servlet容器将Servlet类载入内存，并产生Servlet实例和调用它具体的方法。但是要注意的是，在一个应用程序中，每种Servlet类型只能有一个实例。\n​\t用户请求致使Servlet容器调用Servlet的Service（）方法，并传入一个ServletRequest对象和一个ServletResponse对象。ServletRequest对象和ServletResponse对象都是由Servlet容器（例如TomCat）封装好的，并不需要程序员去实现，程序员可以直接使用这两个对象。\nServletRequest中封装了当前的Http请求，因此，开发人员不必解析和操作原始的Http数据。ServletResponse表示当前用户的Http响应，程序员只需直接操作ServletResponse对象就能把响应轻松的发回给用户。 对于每一个应用程序，Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）的环境详情。每个应用程序只有一个ServletContext。每个Servlet对象也都有一个封装Servlet配置的ServletConfig对象。 生命周期 init( ),当Servlet第一次被请求时，Servlet容器就会开始调用这个方法来初始化一个Servlet对象出来，但是这个方法在后续请求中不会在被Servlet容器调用，就像人只能“出生”一次一样。我们可以利用init（ ）方法来执行相应的初始化工作。调用这个方法时，Servlet容器会传入一个ServletConfig对象进来从而对Servlet对象进行初始化。 service( )方法，每当请求Servlet时，Servlet容器就会调用这个方法。就像人一样，需要不停的接受老板的指令并且“工作”。第一次请求时，Servlet容器会先调用init( )方法初始化一个Servlet对象出来，然后会调用它的service( )方法进行工作，但在后续的请求中，Servlet容器只会调用service方法了。 destory,当要销毁Servlet时，Servlet容器就会调用这个方法，就如人一样，到时期了就得死亡。在卸载应用程序或者关闭Servlet容器时，就会发生这种情况，一般在这个方法中会写一些清除代码。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class MyFirstServlrt implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { System.out.println(\u0026#34;Servlet正在初始化\u0026#34;); } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { //专门向客服端提供响应的方法 System.out.println(\u0026#34;Servlet正在提供服务\u0026#34;); } @Override public String getServletInfo() { return null; } @Override public void destroy() { System.out.println(\u0026#34;Servlet正在销毁\u0026#34;); } } ServletRequest接口 Servlet容器对于接受到的每一个Http请求，都会创建一个ServletRequest对象，并把这个对象传递给Servlet的Sevice( )方法。其中，ServletRequest对象内封装了关于这个请求的许多详细信息。\n1 2 3 4 5 6 7 8 9 public interface ServletRequest { int getContentLength();//返回请求主体的字节数 String getContentType();//返回主体的MIME类型 String getParameter(String var1);//返回请求参数的值 } ServletResponse接口 javax.servlet.ServletResponse接口表示一个Servlet响应，在调用Servlet的Service( )方法前，Servlet容器会先创建一个ServletResponse对象，并把它作为第二个参数传给Service( )方法。ServletResponse隐藏了向浏览器发送响应的复杂过程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public interface ServletResponse { String getCharacterEncoding(); String getContentType(); ServletOutputStream getOutputStream() throws IOException; PrintWriter getWriter() throws IOException; void setCharacterEncoding(String var1); void setContentLength(int var1); void setContentType(String var1); //在发送任何HTML之前，应该先调用setContentType（）方法，设置响应的内容类型，并将“text/html”作为一个参数传入，这是在告诉浏览器响应的内容类型为HTML，需要以HTML的方法解释响应内容而不是普通的文本，或者也可以加上“charset=UTF-8”改变响应的编码方式以防止发生中文乱码现象。 void setBufferSize(int var1); int getBufferSize(); void flushBuffer() throws IOException; void resetBuffer(); boolean isCommitted(); void reset(); void setLocale(Locale var1); Locale getLocale(); } HttpServlet抽象类 HttpServlet抽象类是继承于GenericServlet抽象类而来的。使用HttpServlet抽象类时，还需要借助分别代表Servlet请求和Servlet响应的HttpServletRequest和HttpServletResponse对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doPut(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doDelete(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } HttpServletRequest接口 HttpServletRequest表示Http环境中的Servlet请求。它扩展于javax.servlet.ServletRequest接口，并添加了几个方法。\n获取请求的相关数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 String getContextPath();//返回请求上下文的请求URI部分 Cookie[] getCookies();//返回一个cookie对象数组 String getHeader(String var1);//返回指定HTTP标题的值 String getMethod();//返回生成这个请求HTTP的方法名称 String getQueryString();//返回请求URL中的查询字符串 HttpSession getSession();//返回与这个请求相关的会话对象 String getRequestURI(); StringBuffer getRequestURL(); String[] getParameterValues(String name); //获得如checkbox类（名字相同，但值有多个）的数据。 接收数组变量 String getParameter(String name)； //获得相应名的数据，如果有重复的参数名，则返回第一个的值 HttpServletResponse接口 在Service API中，定义了一个HttpServletResponse接口，它继承自ServletResponse接口，专门用来封装HTTP响应消息。 由于HTTP请求消息分为状态行，响应消息头，响应消息体三部分，因此，在HttpServletResponse接口中定义了向客户端发送响应状态码，响应消息头，响应消息体的方法。\n设置响应的相关数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void addCookie(Cookie var1);//给这个响应添加一个cookie void addHeader(String var1, String var2);//给这个请求添加一个响应头 void sendRedirect(String var1) throws IOException;//发送一条响应码，讲浏览器跳转到指定的位置 void setStatus(int var1);//设置响应行的状态码 void addHeader(String name, String value);//添加响应头 void addIntHeader(String name, int value) void addDateHeader(String name, long date) void setHeader(String name, String value) void setDateHeader(String name, long date) void setIntHeader(String name, int value) PrintWriter getWriter();//获得字符流，通过字符流的write(String s)方法可以将字符串设置到response 缓冲区中，随后Tomcat会将response缓冲区中的内容组装成Http响应返回给浏览器端。 ServletOutputStream getOutputStream();//获得字节流，通过该字节流的write(byte[] bytes)可以向response缓冲区中写入字节，再由Tomcat服务器将字节内容组成Http响应返回给浏览器。 Filter 参见先前博客 Filter\nListener 概述 ​\t监听器就是监听某个对象的状态变化的组件，监听web应用中某些对象、信息的创建、销毁、增加，修改，删除等动作的发生，然后作出相应的响应处理\n具体实现 实现ServletContextListener接口\n1 2 3 4 5 6 7 8 9 10 public class MyListener implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent sce){ System.out.println(\u0026#34;Servlet上下文---\u0026gt;当前web项目启动\u0026#34;); } @Override public void contextDestroyed(ServletContextEvent sce){ System.out.println(\u0026#34;当前类销毁\u0026#34;); } } 注册Listenner监听器\nSpringBoot对三大组件的集成 SpringBoot中内嵌的Servlet容器是Tomcat服务器\n嵌入式Servlet容器配置修改 方法一：通过全局配置文件Application.yml修改\n可以通过server.xxx 来进行web服务配置， 没有带服务器名称的则是通用配置,通过带了具体的服务器名称则是单独对该服务器进行设置，比如server.tomcat.xxx 就是专门针对tomcat的配置,具体配置参见SpringBoot官方文档\n1 2 3 server: port: 8080 tomcat: 方法二：通过注册一个实现 WebServerFactoryCustomizer 接口的Spring Bean\n1 2 3 4 5 6 7 8 9 10 11 12 13 import org.springframework.boot.web.server.WebServerFactoryCustomizer; import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory; import org.springframework.stereotype.Component; @Component public class MyWebServerFactoryCustomizer implements WebServerFactoryCustomizer\u0026lt;ConfigurableServletWebServerFactory\u0026gt; { @Override public void customize(ConfigurableServletWebServerFactory server) { server.setPort(9000); } } 修改server.xxx 配置的相关内容 会跟配置文件形成互补 三大组件的注册 方法一：servlet3.0规范提供的注解方式注册\n在组件的实现类使用提供的注解注册\n1 2 3 4 5 6 7 8 @WebServlet(name=\u0026#34;HelloServlet\u0026#34;,urlPatterns = \u0026#34;/HelloServlet\u0026#34;) public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { PrintWriter writer = resp.getWriter(); writer.println(\u0026#34;hello servlet!\u0026#34;); } } @WebServlet @WebListener @WebFilter 在SpringBoot启动类上添加注解@ServletComponentScan\n1 2 3 4 5 6 7 @SpringBootApplication @ServletComponentScan public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } }\t方法二：SpringBoot提供的注册方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package com.hzl.boot.config.filter; import org.springframework.boot.web.servlet.FilterRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.servlet.Filter; /** * @description * @create: 2024-09-23 22:25 **/ @Configuration public class FilterRegistrationDemo { @Bean public FilterRegistrationBean filterRegistrationBean(){ FilterRegistrationBean\u0026lt;Filter\u0026gt; registrationBean = new FilterRegistrationBean\u0026lt;\u0026gt;(); // 设置自己的过滤器 registrationBean.setFilter(new MyFilter()); // 设置自定义的拦截规则 registrationBean.addUrlPatterns(\u0026#34;/*\u0026#34;); // 设置拦截器的顺序 registrationBean.setOrder(1); return registrationBean; } } ServletRegistrationBean FilterRegistrationBean ServletListenerRegistrationBean 切换内嵌Servlet容器 SpringBoot包含了对Tomcat,Jetty（Socket)等服务器的支持\n通过修改pom.xml的依赖即可排除相关依赖并添加相关依赖即可\n排除原有的tomcat依赖\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring‐boot‐starter‐web\u0026lt;/artifactId\u0026gt; \u0026lt;!‐‐1.排除tomcat‐‐\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;spring‐boot‐starter‐tomcat\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 引入相关依赖\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!‐‐2.依赖jetty --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;artifactId\u0026gt;spring‐boot‐starter‐jetty\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!‐‐3.依赖undertow ‐‐\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;artifactId\u0026gt;spring‐boot‐starter‐undertow\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;/dependency\u0026gt; ","date":"2024-11-15T15:55:52+08:00","permalink":"https://Tyritic.github.io/p/springboot%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6/","title":"SpringBoot中的三大组件"},{"content":"接口的定义 接口 (Interface) 是 Java 中一种特殊的引用类型，类似于类，但是接口只定义方法的签名，而不包含方法的实现。接口用于定义类应该遵循的行为规范，即一组方法的集合，而具体的实现由实现接口的类来完成。\n可以理解为特殊的类，接口的所有字段为 public static final ，不包含构造方法，成员方法中除了 默认方法 (default methods) 和静态方法 (static methods) 以外都是抽象方法\n接口的主要特点 接口无法实例化，不存在构造方法 接口的实现类要么是抽象类，要么实现接口中全部的抽象方法 接口允许多实现（一个实现类同时实现多个接口） 在 Java8 之前接口是无法定义具体方法实现的，所以即使有多个接口必须子类自己实现，所以并不会发生歧义。 Java8 之后出了默认方法（default method），该方法具有方法体，为了避免菱形继承的问题，强制规定，如果多个接口内有相同的默认方法，子类必须重写这个方法。 接口允许多继承 不要在定义接口的时候使用 final 关键字 接口的语法实现 定义接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 接口定义 public interface InterfaceName { // 常量（隐式 public static final） int CONSTANT_VALUE = 100; // 抽象方法（隐式 public abstract） void method1(); // 默认方法（Java 8 引入） default void defaultMethod() { System.out.println(\u0026#34;This is a default method.\u0026#34;); } // 静态方法（Java 8 引入） static void staticMethod() { System.out.println(\u0026#34;This is a static method.\u0026#34;); } } 实现接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 实现接口的类 public class MyClass implements InterfaceName { // 实现接口中的抽象方法 @Override public void method1() { System.out.println(\u0026#34;Method1 implemented in MyClass.\u0026#34;); } // 实现接口中的默认方法（可选） @Override public void defaultMethod(){ // 重写该方法 } } 接口中的变量 接口中的变量默认为public static final 接口中定义的变量会在编译的时候自动加上 public static final 修饰符 接口中的方法 抽象方法 抽象方法是接口的核心部分，所有实现接口的类都必须实现这些方法。接口中的方法默认为public abstract（没有使用 private、default 或者 static 关键字修饰的方法是隐式抽象的，在编译的时候会自动加上 public abstract 修饰符）\n注意事项 接口的抽象方法不能是 private、protected 或者 final 默认方法 接口中允许定义默认方法，默认方法被default修饰，必须具有方法体可供实现类使用或者重写，为实现该接口而不覆盖该方法的类提供默认实现\n定义格式 1 public default 返回值类型 方法名(形参列表){} 注意事项 默认方法可以被子接口继承 default方法不需要被强制重写 如果子类没有重写接口中的默认方法，那么会直接使用接口中提供的默认实现 若子类重写了默认方法，要去除该方法中的default关键字 public可以省略 不能通过接口名调用 如果子类实现了多个接口且多个接口内有相同的默认方法，子类必须重写这个方法。 静态方法 属于接口本身的方法，具有方法体，不依赖具体的实现类就能调用\n定义格式 1 public static 返回值类型 方法名(形参列表){} 调用格式 1 接口名.静态方法名() 私有方法 Java 9 引入了 接口私有方法，允许在接口中定义只能供默认方法和静态方法调用的私有辅助方法。这进一步增强了接口的灵活性和代码复用能力，同时隐藏了实现细节。\n方法类型 实例私有方法\n只能被默认方法调用。 不能被实现类调用，也不能被接口外部访问。 使用 private 关键字修饰。 静态私有方法\n只能被静态方法调用。 不能被默认方法或实现类调用。 接口的使用 作为变量类型 在 Java 中，接口不仅可以定义方法的签名，还可以作为 类型的约束，使得不同的类能够遵循相同的行为约定。\n在 Java 中，所有的类、接口、数组和枚举类型都被视为引用类型。接口定义了类应该具备的方法签名，但它本身不能直接创建实例。实际上，接口是用于为类定义一个“行为契约”的类型。接口可以作为变量类型，来指向那些实现了该接口的类的实例。\n多态性 Java 中的接口支持 多态性，这意味着一个接口类型的变量可以指向任何实现该接口的对象，哪怕是不同类的对象。因此，作为接口类型的变量，可以引用任何实现了接口的对象，而无需关心具体是哪一个类。\n接口和抽象类的区别 参考博客\n常见接口 Comparable接口 Comparable 接口是 Java 提供的一个用于定义对象自然排序的接口。它位于 java.lang 包中，常用于让类的对象能够通过 Collections.sort() 或 Arrays.sort() 方法进行排序。\n接口定义\n1 2 3 public interface Comparable\u0026lt;E\u0026gt; { public int compareTo(E o); } 接口使用\n让实现类实现该接口中的compareTo方法，返回值如下\n返回负值：当前对象小于参数对象 o。\n返回零值：当前对象等于参数对象 o。\n返回正值：当前对象大于参数对象 o。\n升序：当当前对象小于参数对象时，compareTo 返回负值。\n降序：当当前对象小于参数对象时，compareTo 返回正值。\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Person implements Comparable\u0026lt;Person\u0026gt; { private String name; private int age; // 构造方法 public Person(String name, int age) { this.name = name; this.age = age; } // 实现 compareTo 方法，按年龄升序排序 @Override public int compareTo(Person other) { return this.age - other.age; } // 重写 toString 方法，方便打印 @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } 缺点：需要在类定义时就要实现\nComparator接口 Comparator 是 Java 提供的一个用于定义对象自定义排序的接口，位于 java.util 包中。与 Comparable 接口不同，Comparator 可以让我们在不修改类本身代码的情况下，通过外部比较器灵活定义多种排序规则。\nComparator接口支持多排序规则：可以为同一类对象定义多种不同的排序规则，而不需要修改类本身。\n核心方法： compare\n1 int compare(T o1, T o2); 返回负值：当前对象o1小于参数对象 o2。\n返回零值：当前对象o1等于参数对象 o2。\n返回正值：当前对象o1大于参数对象 o2。\n升序：当当前对象小于参数对象时，compare 返回负值。\n降序：当当前对象小于参数对象时，compare 返回正值。\n使用方法\n声明一个比较器类实现Comparator接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 比较器类 import java.util.Comparator; public class AgeComparator implements Comparator\u0026lt;Person\u0026gt; { @Override public int compare(Person p1, Person p2) { return p1.getAge() - p2.getAge(); } } // 测试代码 import java.util.ArrayList; import java.util.Collections; import java.util.List; public class Test { public static void main(String[] args) { List\u0026lt;Person\u0026gt; people = new ArrayList\u0026lt;\u0026gt;(); people.add(new Person(\u0026#34;Alice\u0026#34;, 25)); people.add(new Person(\u0026#34;Bob\u0026#34;, 20)); people.add(new Person(\u0026#34;Charlie\u0026#34;, 30)); // 使用 AgeComparator 进行排序 Collections.sort(people, new AgeComparator()); // 输出排序结果 for (Person p : people) { System.out.println(p); } } } 在Collections.sort 或 Arrays.sort 方法，通过传入 Comparator 对象（匿名内部类）来进行排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import java.util.*; public class Test { public static void main(String[] args) { List\u0026lt;Person\u0026gt; people = new ArrayList\u0026lt;\u0026gt;(); people.add(new Person(\u0026#34;Alice\u0026#34;, 25)); people.add(new Person(\u0026#34;Bob\u0026#34;, 20)); people.add(new Person(\u0026#34;Charlie\u0026#34;, 30)); // 使用匿名内部类按年龄排序 Collections.sort(people, new Comparator\u0026lt;Person\u0026gt;() { @Override public int compare(Person p1, Person p2) { return p1.getAge() - p2.getAge(); } }); System.out.println(\u0026#34;按年龄排序：\u0026#34; + people); } } 其他方法\ncomparing(Function\u0026lt;T, U\u0026gt; keyExtractor)\t按指定字段升序排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import java.util.*; public class Test { public static void main(String[] args) { List\u0026lt;Person\u0026gt; people = Arrays.asList( new Person(\u0026#34;Alice\u0026#34;, 25), new Person(\u0026#34;Bob\u0026#34;, 20), new Person(\u0026#34;Charlie\u0026#34;, 30) ); // 按年龄升序排序 people.sort(Comparator.comparing(Person::getAge)); System.out.println(\u0026#34;按年龄升序排序：\u0026#34; + people); } } class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } reversed()\t将当前排序顺序反转\n1 2 people.sort(Comparator.comparing(Person::getAge).reversed()); System.out.println(\u0026#34;按年龄降序排序：\u0026#34; + people); thenComparing()\t在已有排序规则基础上追加新的排序规则\n1 2 people.sort(Comparator.comparing(Person::getAge).thenComparing(Person::getName)); System.out.println(\u0026#34;按年龄排序后再按姓名排序：\u0026#34; + people); naturalOrder()\t生成按自然顺序排序的 Comparator\n1 2 3 List\u0026lt;String\u0026gt; names = Arrays.asList(\u0026#34;Charlie\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;); names.sort(Comparator.naturalOrder()); System.out.println(\u0026#34;按自然顺序排序：\u0026#34; + names); reverseOrder()\t生成按自然顺序的反序排序 Comparator\n1 2 names.sort(Comparator.reverseOrder()); System.out.println(\u0026#34;按降序排序：\u0026#34; + names); nullsFirst()\t处理 null 值，null 排在前面\nnullsLast()\t处理 null 值，null 排在后面\nCloneable接口 Cloneable 接口是 Java 中的一个标记接口（Marker Interface），它位于 java.lang 包中。实现了 Cloneable 接口的类表示该类的对象可以使用 Object 类的 clone() 方法进行浅拷贝。\n深拷贝和浅拷贝 深拷贝：在复制对象的同时，将对象内部的所有引用类型字段的内容也复制一份，而不是共享引用。换句话说，深拷贝会递归复制对象内部所有引用类型的字段，生成一个全新的对象以及其内部的所有对象。\n浅拷贝：只复制对象本身和其内部的值类型字段，但不会复制对象内部的引用类型字段。换句话说，浅拷贝只是创建一个新的对象，然后将原对象的字段值复制到新对象中，但如果原对象内部有引用类型的字段，只是将引用复制到新对象中，两个对象指向的是同一个引用对象。\n浅拷贝的实现方式 使用 Object.clone() 方法是浅拷贝的常见方式。默认情况下，clone() 方法只是对对象的字段进行字段拷贝，对于基本类型的字段会复制值，对于引用类型的字段则复制引用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import java.util.*; public class Person implements Cloneable { private String name; private List\u0026lt;String\u0026gt; hobbies; public Person(String name, List\u0026lt;String\u0026gt; hobbies) { this.name = name; this.hobbies = hobbies; } @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, hobbies=\u0026#34; + hobbies + \u0026#39;}\u0026#39;; } @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); // 浅拷贝 } public static void main(String[] args) { try { List\u0026lt;String\u0026gt; hobbies = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;Reading\u0026#34;, \u0026#34;Traveling\u0026#34;)); Person p1 = new Person(\u0026#34;Alice\u0026#34;, hobbies); Person p2 = (Person) p1.clone(); System.out.println(\u0026#34;原对象：\u0026#34; + p1); System.out.println(\u0026#34;克隆对象：\u0026#34; + p2); // 修改原对象的 hobbies p1.hobbies.add(\u0026#34;Swimming\u0026#34;); // 查看克隆对象的 hobbies 是否也发生了变化 System.out.println(\u0026#34;修改后的原对象：\u0026#34; + p1); System.out.println(\u0026#34;修改后的克隆对象：\u0026#34; + p2); } catch (CloneNotSupportedException e) { e.printStackTrace(); } } } // 输出结果 // 原对象：Person{name=\u0026#39;Alice\u0026#39;, hobbies=[Reading, Traveling]} // 克隆对象：Person{name=\u0026#39;Alice\u0026#39;, hobbies=[Reading, Traveling]} // 修改后的原对象：Person{name=\u0026#39;Alice\u0026#39;, hobbies=[Reading, Traveling, Swimming]} // 修改后的克隆对象：Person{name=\u0026#39;Alice\u0026#39;, hobbies=[Reading, Traveling, Swimming]} 深拷贝的实现方式 实现 Cloneable 接口并重写 clone() 方法\n要求对象及其所有引用类型字段都实现 Cloneable 接口，并且重写 clone() 方法。在 clone() 方法中，通过递归克隆引用类型字段来实现深拷贝。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Address implements Cloneable { String city; public Address(String city) { this.city = city; } @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); // 浅拷贝 } } class Person implements Cloneable { String name; int age; Address address; public Person(String name, int age, Address address) { this.name = name; this.age = age; this.address = address; } @Override protected Object clone() throws CloneNotSupportedException { Person cloned = (Person) super.clone(); // 创建了一个浅拷贝的 Person 对象 cloned，此时 cloned 中的 address 引用与原始 Person 对象的 address 引用指向同一个 Address 对象。 cloned.address = (Address) address.clone(); // address 是当前对象（this）中的 Address 字段，调用 address.clone() 会对这个 Address 对象进行克隆，生成一个新的 Address 对象 return cloned; } } 手动递归复制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Person { String name; int age; Address address; public Person(String name, int age, Address address) { this.name = name; this.age = age; this.address = address; } // 手动复制字段 public Person(Person person) { this.name = person.name; this.age = person.age; this.address = new Address(person.address.city); } } class Address { String city; public Address(String city) { this.city = city; } } public class Main { public static void main(String[] args) { Address address = new Address(\u0026#34;河南省洛阳市\u0026#34;); Person person1 = new Person(\u0026#34;王二\u0026#34;, 18, address); Person person2 = new Person(person1); System.out.println(person1.address == person2.address); // false } } 序列号和反序列化的方式\n通过将对象序列化为字节流，再从字节流反序列化为对象来实现深拷贝。要求对象及其所有引用类型字段都实现 Serializable 接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import java.io.*; // Address 类实现 Serializable 接口 class Address implements Serializable { private static final long serialVersionUID = 1L; String city; public Address(String city) { this.city = city; } @Override public String toString() { return \u0026#34;Address{city=\u0026#39;\u0026#34; + city + \u0026#34;\u0026#39;}\u0026#34;; } } // Person 类实现 Serializable 接口 class Person implements Serializable { private static final long serialVersionUID = 1L; String name; int age; Address address; public Person(String name, int age, Address address) { this.name = name; this.age = age; this.address = address; } // 使用序列化和反序列化来实现深拷贝 public Person deepClone() throws IOException, ClassNotFoundException { // 序列化 ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); // 将当前对象写入字节流 // 反序列化 ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return (Person) ois.readObject(); // 从字节流中读取对象 } @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, age=\u0026#34; + age + \u0026#34;, address=\u0026#34; + address + \u0026#34;}\u0026#34;; } } public class DeepCopyDemo { public static void main(String[] args) throws IOException, ClassNotFoundException { // 创建原始对象 Address address = new Address(\u0026#34;New York\u0026#34;); Person person1 = new Person(\u0026#34;Alice\u0026#34;, 25, address); // 深拷贝 Person person2 = person1.deepClone(); // 修改原始对象的地址字段 person1.address.city = \u0026#34;Los Angeles\u0026#34;; // 输出两个对象 System.out.println(\u0026#34;原始对象: \u0026#34; + person1); System.out.println(\u0026#34;深拷贝对象: \u0026#34; + person2); } } ","date":"2024-11-15T10:46:39+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3/","title":"Java中的接口"},{"content":"抽象方法 定义 抽象方法是没有方法体的方法。它只是声明了方法的签名（方法名、返回类型、参数），而没有提供具体的实现。抽象方法只能出现在抽象类中，且必须由子类实现。\n特点 没有方法体： 抽象方法只定义方法的签名，没有具体实现。 必须由子类实现： 如果一个类继承了抽象类，必须实现抽象类中的所有抽象方法，除非子类本身也是抽象类。 语法格式 1 2 3 abstract class ClassName { abstract void methodName(); } 抽象类 定义 抽象类是一个不能直接实例化的类，通常包含抽象方法（未实现的方法）和已实现的方法。抽象类作为其他类的父类，提供通用的接口和功能，而让子类去实现和完善。\n特点： 不能实例化： 你不能直接创建抽象类的对象，只能通过其子类来实例化。\n可以有抽象方法和非抽象方法：\n抽象类可以包含抽象方法（没有方法体的方法），也可以包含已实现的方法（有方法体的普通方法）。 抽象类的子类必须实现所有抽象方法，除非子类本身也是抽象类。 抽象类不一定包含抽象方法，但是有抽象方法的一定是抽象类 构造方法： 抽象类可以有构造方法，构造方法可以被子类调用，用于初始化父类的成员变量。\n可以有字段（成员变量）： 抽象类可以定义实例字段（成员变量）和静态字段。\n可以实现接口： 抽象类可以实现接口，因此也可以被用于约定子类需要实现的接口方法。\n抽象类不能被final修饰：\nJava中的抽象类是用来被继承的，而final修饰符用于禁止类被继承或方法被重写，因此，抽象类和final修饰符是互斥的，不能同时使用。\n语法格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 abstract class ClassName { // 抽象方法（没有方法体） abstract void abstractMethod(); // 非抽象方法（有方法体） void concreteMethod() { System.out.println(\u0026#34;This is a concrete method.\u0026#34;); } // 可以有构造方法 public ClassName() { System.out.println(\u0026#34;Abstract class constructor.\u0026#34;); } } ","date":"2024-11-15T10:21:43+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/","title":"Java中的抽象类和抽象方法"},{"content":"局部代码块 定义 局部代码块 是 Java 中一种由一对大括号 {} 包裹的代码块，通常用于限制变量的作用域，或者在某些情况下提供代码逻辑的分隔。\n特点 作用域限制：局部代码块中的变量只在代码块内有效，代码块外不可访问，因此可以避免变量命名冲突，增强代码的可读性和可维护性。 不影响程序的控制流：局部代码块只是对代码逻辑的封装，不会改变程序的控制流。它通常是为了作用域控制或某些资源的临时管理。 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Test { public static void main(String[] args) { int x = 10; // 局部代码块 { int y = 20; // y的作用域仅限于该局部代码块 System.out.println(\u0026#34;x = \u0026#34; + x); // 可以访问外部的x System.out.println(\u0026#34;y = \u0026#34; + y); // 可以访问该代码块内定义的y } // System.out.println(\u0026#34;y = \u0026#34; + y); // 编译错误，y超出了作用域 } } 构造代码块 定义 构造代码块 是 Java 类中的一块独立代码，由一对大括号 {} 包裹，直接定义在类中，不属于任何方法或构造方法。当创建类的对象时，构造代码块会在每次调用构造方法前自动执行。\n构造代码块的作用是将一些对象的公共初始化逻辑集中起来，避免在每个构造方法中重复编写相同的代码。\n特点 构造代码块的书写位置在类的定义中，用于收集构造函数中的公共逻辑 类实例化的时候执行构造代码块，而且构造代码块内的逻辑在构造方法内的逻辑执行之前执行 代码初始化块里的执行顺序是从前到后的 构造代码块的实现原理 对象在初始化的时候会先调用构造方法，构造方法在执行的时候会把代码初始化块放在构造方法中其他代码之前\n静态代码块 定义 静态代码块（Static Block）是 Java 中的一种特殊代码块，它用于在类加载时执行一次初始化操作。静态代码块由 static 关键字修饰，通常用于初始化类的静态变量，或者执行一些静态资源的初始化工作。\n特点 只在类加载时执行一次： 静态代码块在类第一次被加载到内存时执行，不依赖于类的对象实例化。 在构造函数之前执行： 类的构造函数在对象创建时执行，而静态代码块在类加载时就执行，因此它会先于任何构造函数或实例方法执行。 可以访问类的静态成员： 静态代码块可以访问类的静态变量和静态方法，但不能访问实例变量和实例方法，因为此时类的实例尚未创建。 执行顺序： 如果类中有多个静态代码块，它们会按照定义的顺序依次执行。 只有类第一次被加载时执行： 静态代码块不会在每次创建类的对象时执行，只会在类加载进 JVM 时执行一次。 语法格式 1 2 3 4 5 class ClassName { static { // 静态代码块中的初始化代码 } } 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 public class Example { // 静态变量 public static int staticVar = 1; // 实例变量 public int instanceVar = 2; // 静态初始化块 static { System.out.println(\u0026#34;执行静态初始化块\u0026#34;); staticVar = 3; } // 实例初始化块 { System.out.println(\u0026#34;执行实例初始化块\u0026#34;); instanceVar = 4; } // 构造方法 public Example() { System.out.println(\u0026#34;执行构造方法\u0026#34;); } public static void main(String[] args) { System.out.println(\u0026#34;执行main方法\u0026#34;); Example e1 = new Example(); Example e2 = new Example(); System.out.println(\u0026#34;e1的静态变量：\u0026#34; + e1.staticVar); System.out.println(\u0026#34;e1的实例变量：\u0026#34; + e1.instanceVar); System.out.println(\u0026#34;e2的静态变量：\u0026#34; + e2.staticVar); System.out.println(\u0026#34;e2的实例变量：\u0026#34; + e2.instanceVar); } } //执行结果 // 执行静态初始化块 // 执行main方法 // 执行实例初始化块 // 执行构造方法 // 执行实例初始化块 // 执行构造方法 // e1的静态变量：3 // e1的实例变量：4 // e2的静态变量：3 // e2的实例变量：4 ","date":"2024-11-15T09:35:34+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97/","title":"Java中的代码块"},{"content":"作用 final关键字用于修饰不可被改变的变量/方法\n修饰方式 方法：被final修饰的方法不能被继承，同时也意味着不能被重写 类：被final修饰的类无法被继承 变量：表明这个变量是常量，只能被赋值一次 修饰基本数据类型则变量存储的数值不变 修饰引用数据类型则变量存储的地址值不变，但是对象的属性可以改变 ","date":"2024-11-14T23:16:07+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84final%E5%85%B3%E9%94%AE%E5%AD%97/","title":"Java中的final关键字"},{"content":"什么是封装 封装是指利用抽象将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。\n数据被保护在类的内部，尽可能地隐藏内部的实现细节，只保留一些对外接口使之与外部发生联系。\n其他对象只能通过已经授权的操作来与这个封装的对象进行交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。\n基本概念 数据隐藏：通过将类的字段（成员变量）声明为 private 或 protected，避免直接被外部访问。只有通过类提供的公共方法（如 getter 和 setter）才能访问和修改这些字段。 公共接口：通过公共方法（如 getter 和 setter）提供访问对象数据的方式。这样可以对数据进行控制和验证，确保数据的一致性和合法性。 保护数据：封装通过限制对数据的直接访问，减少了对对象状态的不安全修改和潜在的错误。 优势 数据保护：通过隐藏数据和提供受控的访问方法，可以防止外部代码对数据进行不合法的修改。 维护性：封装使得对象的内部实现与外部接口分离，可以更容易地对内部实现进行更改，而不影响外部使用者。 简化接口：提供简洁的公共接口，减少外部代码对类的复杂性理解，从而降低系统的耦合度。 代码复用：通过封装，类可以重用已有的功能而不必重新实现，有助于构建模块化和可维护的代码。 ","date":"2024-11-14T23:02:48+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%B0%81%E8%A3%85/","title":"Java中的封装"},{"content":"什么是多态 多态是指同一个接口或父类引用变量可以指向不同的对象实例，并根据实际指向的对象类型执行相应的方法。\n它允许同一方法在不同对象上表现出不同的行为，是面向对象编程（OOP）的核心特性之一\n多态的前提条件 子类继承父类 子类重写父类的方法 父类引用指向子类的对象 语法格式\n1 father_className father=new son_className () 多态的运行特点 调用成员变量 遵守规则：编译看声明类型（左边），运行看声明类型（左边）\n编译代码时，会看左边的父类中有没有该变量，若不存在该变量则编译失败\n运行代码时，实际获取的是左边父类中成员变量的值\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Parent { public int num = 10; } class Child extends Parent { public int num = 20; } public class Test { public static void main(String[] args) { Parent obj = new Child(); // 左边是Parent类型，右边是Child类型 System.out.println(\u0026#34;num = \u0026#34; + obj.num); // 访问属性 } } // 输出：num = 10 调用成员方法 遵守规则：编译看声明类型（左边），运行看实际类型（右边）\n编译代码时，会看左边的父类中有没有该方法，若不存在该方法则编译失败\n运行代码时，实际执行的是右边父子中成员方法\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Parent { public void show() { System.out.println(\u0026#34;Parent的show方法\u0026#34;); } } class Child extends Parent { @Override public void show() { System.out.println(\u0026#34;Child的show方法\u0026#34;); } } public class Test { public static void main(String[] args) { Parent obj = new Child(); // 左边是Parent类型，右边是Child类型 obj.show(); // 调用show方法 } } // 输出：Child的show方法 多态的实现原理 动态绑定 多态通过动态绑定实现，Java 使用虚方法表存储方法指针，方法调用时根据对象实际类型从虚方法表查找具体实现。\n多态的实现方式 编译时多态和运行时多态是面向对象编程中多态性的两种实现方式，它们分别在不同的阶段决定方法的绑定。\n编译时多态：通过方法重载实现，在编译时确定方法的调用。 运行时多态：通过方法重写实现，在运行时确定方法的调用。 编译时多态（Compile-time Polymorphism） 编译时多态，也称为静态多态，是在编译阶段确定方法的调用。编译时多态主要通过 方法重载（Method Overloading） 实现。\n方法重载：指在同一个类中定义多个方法，这些方法的名称相同但参数列表（参数的类型或数量）不同。Java 编译器在编译时会根据方法调用时传入的参数类型和数量，决定调用哪一个重载方法。\n运行时多态（Runtime Polymorphism） 运行时多态，也称为动态多态，是在运行时确定方法的调用。运行时多态通过 方法重写（Method Overriding） 实现。\n方法重写：子类重写父类的一个或多个方法。通过父类引用调用方法时，实际执行的是子类重写后的方法。这种多态性是在运行时根据对象的实际类型决定的。\n向上转型和向下转型 向上转型（儿子变父亲） 向上转型是使用父类类型的引用指向子类对象，通过子类对象(小范围)实例化父类对象(大范围)\n父类引用变量指向子类对象后，只能使用父类已声明的方法，但方法如果被重写会执行子类的方法，如果方法未被重写那么将执行父类的方法。\n语法格式\n1 2 3 father_className father=new son_className () // 声明类型：father_className // 实际类型：son_className 向下转型（父亲变儿子） 向下转型是将父类引用转回其子类类型，通过父类对象(大范围)实例化子类对象(小范围)，但在执行前需要确认父类引用变量实际引用必须是子类对象才能成功转型以避免 ClassCastException\n向下转型允许我们通过父类引用访问子类特有的方法和属性\n语法格式 1 son_className son=(son_className) father 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Animal { public void makeSound() { System.out.println(\u0026#34;Animal makes a sound\u0026#34;); } } class Dog extends Animal { public void makeSound() { System.out.println(\u0026#34;Dog barks\u0026#34;); } public void wagTail() { System.out.println(\u0026#34;Dog wags its tail\u0026#34;); } } public class Test { public static void main(String[] args) { Animal animal = new Dog(); // 向上转型，父类引用指向子类对象 animal.makeSound(); // 调用子类重写的方法，输出：Dog barks // 向下转型，将Animal引用强制转换为Dog类型 if (animal instanceof Dog) { Dog dog = (Dog) animal; dog.wagTail(); // 输出：Dog wags its tail } else { System.out.println(\u0026#34;animal 不是 Dog 类型\u0026#34;); } Animal animal = new Cat(); // Animal引用指向Cat对象 // 强制将Cat对象转为Dog类型，会引发ClassCastException Dog dog = (Dog) animal; dog.makeSound(); } } instance of关键字 判断对象是否符合指定的类型，结果要么是 true，要么是 false\n语法格式\n1 2 3 4 5 6 (object) instanceof (className) // JDK16的新用法 if (obj instanceof String s) { // 如果类型匹配 直接使用 s } 判定为true的条件\nobject 是 ClassName 类型或其子类（或实现类）的对象 ClassName 是 object 实现的接口。 无论右边的类型是什么，null 对象总是返回 false。即：null instanceof SomeClass // 结果为 false\n","date":"2024-11-14T22:00:32+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81/","title":"Java中的多态"},{"content":"继承的定义 继承（inheritance）是面向对象中的一个概念。它使得复用以前的代码非常容易。\n在 Java 语言中继承就是子类继承父类的属性和方法，使得子类对象（实例）具有父类的属性和方法，或子类从父类继承方法，使得子类具有父类相同的方法。\n继承的优缺点 优点：\n代码复用：子类可以复用父类的代码，减少重复实现。 易于维护：可以通过修改父类代码来影响所有子类。 缺点：\n紧耦合：子类依赖于父类的实现，父类的修改可能会影响子类。 灵活性差：继承层次结构可能会变得复杂，不易于调整或扩展。 继承的特点 Java不允许多重继承（一个子类同时继承多个父类）但是支持多层继承，一个类只能继承一个父类 Object类是所有类中的公共父类 继承当中子类抛出的异常必须是父类抛出的异常或父类抛出异常的子异常 子类可以继承父类的部分属性和方法 继承的语法实现 1 class 子类名 extends 父类名{} 子类继承的内容 父类的所有属性 子类继承父类的所有的属性（但是被private修饰的变量被隐藏无法直接使用）\n如果要使用父类的private属性可以通过父类的getter方法和setter方法\n父类的构造方法不能被继承 父类的构造方法不能被子类继承：因为构造方法语法是与类同名，而继承则不更改方法名，如果子类继承父类的构造方法，那明显与构造方法的语法冲突了。\n成员方法（虚方法） 方法传递机制 Java虚拟机从最顶级的父类开始设置虚方法表，父类会将虚方法表传递给自己的子类，然后在父类的虚方法表的基础上添加自己的虚方法从而形成自己的虚方法表\n虚方法的条件\n非static 非final 非private 只有虚方法表中的方法会被子类继承\nsuper关键字 super关键字用于指代父类的存储空间\n指向父类对象； 调用父类的方法； super() 可以调用父类的无参构造方法。 继承中成员变量调用规则 成员变量的调用规则满足就近原则\n寻找顺序为：方法局部位置——\u0026gt;本类的成员位置——\u0026gt;父类成员位置\n逐级向上寻找\n使用this直接调用本类的变量\n使用super调用父类的变量\n继承中成员方法调用规则 直接调用 成员方法的调用规则满足就近原则\n寻找顺序为：方法局部位置——\u0026gt;本类的成员方法——\u0026gt;父类成员方法\n逐级向上寻找\n使用this直接调用本类的方法\n使用super调用父类的方法\n方法重写 子类中重写父类中的方法，保持返回值类型，方法名，参数列表不变，它建立在继承的基础上。\n重写条件 重写方法的名称、形参列表必须与父类中的一致。 子类重写父类方法时，访问权限子类必须大于等于父类(default\u0026lt;protected\u0026lt;public) 子类重写父类方法时，返回值类型子类必须小于等于父类 只有被添加到虚方法表中的方法才能被重写（静态方法，私有方法，被final修饰的方法不能重写） 继承当中子类抛出的异常必须是父类抛出的异常或父类抛出异常的子异常 底层实现 子类重写的新方法覆盖从父类继承来的虚方法表中父类的同名方法\n示例代码 1 2 3 4 5 6 7 8 9 10 11 class E1{ public void doA(int a){ System.out.println(\u0026#34;这是父类的方法\u0026#34;); } } class E2 extends E1{ @Override public void doA(int a) { System.out.println(\u0026#34;我重写父类方法，这是子类的方法\u0026#34;); } } 构造方法 子类的所有构造方法默认必须调用其父类的构造方法再执行自己的构造方法：Java 虚拟机构造子类对象前会先构造父类对象，父类对象构造完成之后再来构造子类特有的属性，这被称为内存叠加。 如果子类的构造方法中没有显式地调用父类构造方法，则系统默认调用父类无参数的构造方法：所有子类的构造方法第一行必须为super() 任何情况下实例化对象会调用继承链的所有父类构造方法 子类无法继承父类的构造方法但是可以通过super关键字来调用 当父类只有有参构造函数时，子类必须显式调用 super 并传入合适的参数。 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 正确继承演示 class A{ public String name; public A() {//无参构造 } public A (String name){//有参构造 } } class B extends A{ public B() {//无参构造 super(); } public B(String name) {//有参构造 //super(); super(name); } } 继承中类的加载顺序 在Java继承中，父子类初始化先后顺序为：\n父类中静态成员变量和静态代码块 子类中静态成员变量和静态代码块 父类中普通成员变量和代码块，父类的构造函数 子类中普通成员变量和代码块，子类的构造函数 总的来说，就是静态\u0026gt;非静态，父类\u0026gt;子类，非构造函数\u0026gt;构造函数。同一类别（例如普通变量和普通代码块）成员变量和代码块执行从前到后，需要注意逻辑。\n","date":"2024-11-14T19:21:51+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/","title":"Java中的继承"},{"content":"不可变类的定义 一个类的对象在通过构造方法创建后如果状态不会再被改变，那么它就是一个不可变（immutable）类。\n它的所有成员变量的赋值仅在构造方法中完成，不会提供任何 setter 方法供外部类去修改，这种类的实例在整个生命周期内保持不变。\n不可变类的实现 类被final修饰，保证该类不被继承 所有的字段都是private和final的，确保它们在初始化后不能被更改 不提供setter方法 通过构造函数初始化所有字段 如果类包含可变对象的引用，确保这些引用在对象外部无法被修改。例如 getter 方法中返回对象的副本（new 一个新的对象）来保护可变对象 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // 不可变类 Writer public final class Writer { private final String name; private final int age; private final Book book; public Writer(String name, int age, Book book) { this.name = name; this.age = age; this.book = book; } public int getAge() { return age; } public String getName() { return name; } // 确保返回的是可变对象的副本 public Book getBook() { Book clone = new Book(); clone.setPrice(this.book.getPrice()); clone.setName(this.book.getName()); return clone; } } // 可变类 Book public class Book { private String name; private int price; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getPrice() { return price; } public void setPrice(int price) { this.price = price; } @Override public String toString() { return \u0026#34;Book{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, price=\u0026#34; + price + \u0026#39;}\u0026#39;; } } 不可变类的特点 优点：\n线程安全：由于不可变对象的状态不能被修改，它们天生是线程安全的，在并发环境中无需同步。 缓存友好：不可变对象可以安全地被缓存和共享，如 String 的字符串常量池。 防止状态不一致：不可变类可以有效避免因意外修改对象状态而导致的不一致问题。 缺点：\n性能问题：不可变对象需要在每次状态变化时创建新的对象，这可能会导致性能开销，尤其是对于大规模对象或频繁修改的场景（例如 String 频繁拼接）。 ","date":"2024-11-14T19:07:43+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/","title":"Java中的不可变对象"},{"content":"static关键字 用于修饰成员变量，成员方法，代码块以及内部类，表示这是静态的，归属于整个类\n静态变量 被static修饰的成员变量\n特点 该变量被类的所有对象共享 静态变量不属于单个对象而属于整个类 随着类的加载而加载，在对象的产生之前存在 静态变量只会获取一次内存空间，所以任何对象对它的修改都会得到保留。如果一个实例修改了静态变量的值，其他实例也会看到这个更改。 内存原理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Student { String name; int age; static String school = \u0026#34;华南理工大学\u0026#34;; public Student(String name, int age) { this.name = name; this.age = age; } public static void main(String[] args) { Student s1 = new Student(\u0026#34;沉默王二\u0026#34;, 18); Student s2 = new Student(\u0026#34;沉默王三\u0026#34;, 16); } } s1 和 s2 这两个引用变量存放在栈区（stack） 沉默王二+18 这个对象和沉默王三+16 这个对象存放在堆区（heap） school 这个静态变量存放在公共的地址（静态区）。 调用方式 类名.静态变量（推荐） 对象名.静态变量 静态方法 被static修饰的成员方法\n特点 无须依赖类的实例就可以使用 只能访问静态变量和其他静态方法 不能使用this关键字 静态方法可以被重载（同类中方法名相同，但参数不同），但不能被子类重写（因为方法绑定在编译时已确定） 调用方式 类名.静态方法（推荐） 对象名.静态方法 ","date":"2024-11-14T17:11:24+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/","title":"Java中的静态变量和静态方法"},{"content":"MVC设计模式 MVC 是一种常见的软件设计模式，用于分离应用程序的不同部分以实现松散耦合和高内聚性。MVC 模式由三个核心组件组成：\n模型（Model）：表示应用程序的数据和业务逻辑。模型处理应用程序的数据，并根据控制器的指令执行相应的操作。 视图（View）：提供模型数据的用户界面。视图通常是模板、HTML 页面、XML 文件或其他格式，可以呈现模型数据给用户。 控制器（Controller）：处理用户交互并更新模型和视图。控制器负责接收来自视图的用户输入，对模型进行相应的操作，并更新视图以反映更改。 MVC 模式的优点是可以将代码分离成三个独立的组件，使得应用程序更易于维护和扩展。例如，如果要更改视图的外观，可以修改视图而不影响模型和控制器；如果要更改数据存储方式，可以修改模型而不影响视图和控制器。同时，MVC 模式还有助于降低应用程序中的耦合度，使得各组件更加独立和可重用。\nSpringMVC框架 概述： Spring MVC 是非常著名的 Web 应用框架，现在的大多数 Web 项目都采用 Spring MVC。它与 Spring 有着紧密的关系。是 Spring 框架中的模块，专注 Web 应用，能够使用 Spring 提供的强大功能，IOC、AOP等。 Spring MVC 框架底层是基于 Servlct 技术。遵循 Servlet 规范，Web 组件 Servlet 、Filter、Listener在 Spring MVC 中都能使用。同时 Spring MVC 也是基于 MVC 架构模式的，职责分离，每个组件只负责自己的功能，组件解耦。 Spring Boot 的自动配置、按约定编程极大简化，提高了 Web 应用的开发效率。 响应流程： 大体流程：请求到控制器（controller），经过业务模型（model）处理后返回响应给视图层。\n具体流程：\nDispatcherServlet 首先收到请求，将请求映射到对应的处理器（controller）上，映射到controller的时候会触发拦截器 处理器处理完后封装数据模型，交给视图解析器将数据模型解析为对应的视图返回给前端。 SpringMVC组件 控制器controller 控制器是一种由 Spring 管理的 Bean 对象，赋予角色是“控制器”。\n作用：处理请求，接收浏览器发送过来的参数，将数据或视图应答给浏览器或者客户端 App等。\n具体实现：一个Java类，使用@Controller或@RestController\n提示\n@Controller 和 @RestController 注解的区别：\n@RestController 包含了 @Controller 的功能，同时加入了 @ResponseBody 的注解。 表示当前控制器类中的方法，都会默认加入 @ResponseBody 的功能。方法的返回值是数据可以通过 HttpServletResponse 输出给浏览器。 接收请求\n@RequestMapping ：用于将 Web 请求映射到控制器类的方法。此方法处理请求。可用作在类上或方法上。在类上和方法上同时使用。\n1 2 3 @RequestMapping(value = \u0026#34;/updateProduct\u0026#34;,method = RequestMethod.POST) public Result\u0026lt;String\u0026gt; updateProduct(@RequestParam MultipartFile file, @RequestParam String dname, @RequestParam String tname, @RequestParam String content,@RequestParam String olddname) Value：别名 path 表示请求的 URI，在类和方法上同时使用 value，方法上的继承类上的 value。 method：请求方式，支持 GET、POST、HEAD、OPTIONS、PUT、PATCH、DELETE、TRACE。值为：RequestMethod[] method()，RquestMethod 是 enum 类型。 快捷注解：\n@GetMapping: 表示 get 请求方式的@RequestMapping @PostMapping:表示 post 请求方式的@RequestMapping @PutMapping：表示 put 请求方式的@RequestMapping @DeleteMapping: 表示 delete 请求方式的@RequestMapping 接收请求参数\n@RequestParam：把请求中的指定名称的参数传递给控制器中的形参赋值\nvalue属性值指定请求中的参数 required 属性指定请求中的参数是否必须，默认为 true ，如果加上 required=false，没对应上则不会报错，而是获取值为 null。 如果参数前不写@RequestParam(xxx)的话，那么就前端可以有可以没有对应的参数名字都行，如果有参数名的话，那么就会自动匹配；没有的话，请求也能正确发送。 HttpServletRequest对象 使用 HttpServletRequest 对象接收参数，request.getParameter(\u0026quot;XXX\u0026quot;)获取对应的值，这是原始的 JavaWeb 中的方式 @RequestBody：主要用来接收前端传递给后端的json字符串中的数据的(通常json字符串放在请求体中)\nGET方式无请求体，所以使用@RequestBody接收数据时，前端不能使用GET方式提交数据，而是用POST方式进行提交。 在后端的同一个接收方法里，@RequestBody与@RequestParam()可以同时使用，@RequestBody最多只能有一个，而@RequestParam()可以有多个。 如果后端参数是一个对象，且该参数前是以@RequestBody修饰的，那么前端传递json参数时，必须满足以下要求：后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类(即：@RequestBody后面的类)时，会根据json字符串中的key来匹配对应实体类的属性，如果匹配一致且json中的该key对应的值符合(或可转换为)实体类的对应属性的类型要求时，会调用实体类的setter方法将值赋给该属性 @RequestHeader：从请求头中获取某些值\n1 2 3 4 5 6 7 8 9 10 11 12 import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestHeader; import org.springframework.web.bind.annotation.RestController; @RestController public class MyController { @GetMapping(\u0026#34;/greet\u0026#34;) public String greet(@RequestHeader(\u0026#34;User-Agent\u0026#34;) String userAgent) { return \u0026#34;Hello! You are using \u0026#34; + userAgent; } } 返回值\n不使用 @ResponseBody的 String 返回值，返回的是一个页面视图 使用 @ResponseBody的 String 返回值，返回的是一个JSON数据 返回ModelAndView ，返回的是一个视图其中包含数据。（最后数据都是放到 Request 中的） 返回自定义的对像，默认的返回格式是json字符串（有jackson工具） 返回 Map，默认的返回格式是json字符串（有jackson工具） 返回ResponseEntity：包含数据和自定义的HttpStatus Code。（默认转为json格式的字符串） 模型 Model 在许多实际项目需求中，后台要从控制层直接返回前端所需要的数据，这时 Model 大家族就派上用场了。 Model Spring MVC 中的 ”M“，是用来传输数据的。从控制层直接返回数据给前端。内置的 JSP，模板技术能够展现 Model 中存储的数据。 Model 可以是承载数据的，也可以是处理具体业务的类，这些都是指 Spring MVC 中的Model。 视图 View Spring MVC 中的 View（视图）用于展示数据的，视图技术的使用是可插拔的。无论选择使用 thymleaf、jsp 还是其他技术，classpath 有 jar 就能使用视图了。开发者主要就是更改配置。SpringBoot3 不推荐使用 FreeMarker、JSP 这些了。建议使用 Thymeleaf。 SpringBoot框架中对SpringMVC框架的集成 自动配置：SpringBoot会自动配置一个嵌入式的Servlet容器（如Tomcat），并为我们提供默认的SpringMVC配置。这样我们无需手动配置Servlet容器和SpringMVC，只需添加相应的依赖即可快速搭建一个Web应用。 视图解析器：SpringBoot默认使用Thymeleaf作为视图解析器，如果需要更换其他视图解析器，可以在pom.xml中修改对应的依赖。 静态资源处理：SpringBoot默认会处理静态资源（如HTML、CSS、JavaScript等），并将其放在项目的/static或/public目录下。如果需要自定义静态资源的处理方式，可以通过编写一个类实现WebMvcConfigurer接口，并重写addResourceHandlers方法来实现。 拦截器：SpringBoot支持自定义拦截器，可以通过实现HandlerInterceptor接口来创建拦截器，同时编写一个类实现WebMvcConfigurer接口，并重写addInterceptors方法来实现。 异常处理：SpringBoot默认使用WhitelabelErrorView来处理异常，如果需要自定义异常处理方式，可以通过编写一个类实现ErrorController接口，并重写errorHtml方法来实现。 参数绑定：SpringBoot支持多种参数绑定方式，如@RequestParam、@PathVariable、@RequestBody等。如果需要自定义参数绑定方式，可以通过编写一个类实现MethodArgumentResolver接口，并重写resolveArgument方法来实现。 跨域支持：SpringBoot默认支持CORS跨域请求，如果需要自定义跨域配置，可以通过编写一个类实现WebMvcConfigurer接口，并重写addCorsMappings方法来实现。 Spring Boot中配置Spring MVC 配置方法 因为Spring Boot自动装配机制的存在，一般来说我们不需要对Spring MVC进行配置，如果要进行特别定制化的配置，Spring Boot也支持配置文件或者编写代码的两种方式来进行配置。\n方法一：修改application.xml 可以通过修改application.xml的spring.mvc属性来修改SpringBoot对SpringMVC的默认配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 spring: mvc: # 启用Spring MVC enabled: true # 配置静态资源路径 static-path-pattern: /static/** static-locations: classpath:/static/ # 配置视图解析器 view.prefix: /WEB-INF/views/ view.suffix: .jsp # 配置拦截器 interceptor: exclude-path-patterns: /login,/logout include-path-patterns: /admin/** # 配置HTTP缓存 resources: cache: period: 3600 servlet: # 配置文件上传 multipart: max-file-size: 10MB max-request-size: 10MB # 配置会话管理 session: timeout: 1800 cookie.max-age: 1800 # 配置JSON序列化 jackson: serialization: indent_output: true date-format: yyyy-MM-dd HH:mm:ss # 配置异常处理 error: whitelabel: enabled: false 方法二：编写一个被注解@WebMvcConfiguration修饰的Java配置类 WebMvcConfigurer接口是Spring提供的一个用于自定义Spring MVC配置的接口，主要提供了WebMvcConfigurer接口是Spring提供的一个用于自定义Spring MVC配置的接口，主要提供了多个回调方法，包括添加或修改Spring MVC的配置，如添加拦截器，自定义消息转换器等。具体来说，WebMvcConfigurer接口的主要方法包括：\nconfigurePathMatch（S）：此方法用于配置路由请求规则。 configureContentNegotiation（S）：该方法用于内容协商配置。 configureAsyncSupport（S）：该方法用于异步支持配置。 configureDefaultServletHandling（S）：该方法用于配置默认静态资源处理器。 addFormatters（S）：此方法用于注册自定义转化器。 addInterceptors（S）：此方法用于拦截器配置。 addResourceHandlers（S）：此方法用于资源处理。 addCorsMappings（S）：此方法用于CORS配置。 在使用时，只需要实现WebMvcConfigurer接口，重写上述的方法即可完成自定义配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @Configuration public class MyWebMvcConfig implements WebMvcConfigurer { // 配置视图解析器 @Override public void configureViewResolvers(ViewResolverRegistry registry) { InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix(\u0026#34;/WEB-INF/views/\u0026#34;); resolver.setSuffix(\u0026#34;.jsp\u0026#34;); registry.viewResolver(resolver); } // 配置静态资源 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\u0026#34;/static/**\u0026#34;).addResourceLocations(\u0026#34;/static/\u0026#34;); } // 配置拦截器 @Autowired private MyInterceptor myInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(myInterceptor).addPathPatterns(\u0026#34;/**\u0026#34;); } // 配置消息转换器 @Override public void configureMessageConverters(List\u0026lt;HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converters) { MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter(); List\u0026lt;MediaType\u0026gt; supportedMediaTypes = new ArrayList\u0026lt;MediaType\u0026gt;(); supportedMediaTypes.add(MediaType.APPLICATION_JSON); converter.setSupportedMediaTypes(supportedMediaTypes); converters.add(converter); } // 配置异常处理器 @ControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(value = Exception.class) public ModelAndView handleException(HttpServletRequest req, Exception e) { ModelAndView mav = new ModelAndView(); mav.addObject(\u0026#34;exception\u0026#34;, e); mav.addObject(\u0026#34;url\u0026#34;, req.getRequestURL()); mav.setViewName(\u0026#34;error\u0026#34;); return mav; } } // 配置全局跨域资源共享（CORS） @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\u0026#34;/user/*\u0026#34;) // 映射服务器中那些http接口运行跨域访问 .allowedOrigins(\u0026#34;http://localhost:8081\u0026#34;) // 配置哪些来源有权限跨域 .allowedMethods(\u0026#34;GET\u0026#34;,\u0026#34;POST\u0026#34;,\u0026#34;DELETE\u0026#34;,\u0026#34;PUT\u0026#34;); // 配置运行跨域访问的请求方法 } // 配置文件上传 @Bean public MultipartResolver multipartResolver() { CommonsMultipartResolver resolver = new CommonsMultipartResolver(); resolver.setMaxUploadSize(10485760); resolver.setMaxInMemorySize(4096); return resolver; } // 配置请求缓存 @Bean public KeyGenerator keyGenerator() { return new DefaultKeyGenerator(); } @Bean public RequestCache requestCache() { return new HttpSessionRequestCache(); } // 配置视图控制器 @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\u0026#34;/\u0026#34;).setViewName(\u0026#34;index\u0026#34;); registry.addViewController(\u0026#34;/login\u0026#34;).setViewName(\u0026#34;login\u0026#34;); } } 提示\n使用Springboot框架对SpringMVC的默认设置：直接编写控制器逻辑\n手动设置SpringMVC的部分功能，定义MVC的底层组件：@Configuration+配置WebMvcConfiguration，不要使用@EnableWebMvc\n手动设置SpringMVC的所有功能：@Configuration+配置WebMvcConfiguration+@EnableMvc\n使用 @EnableWebMvc 会完全覆盖 SpringBoot 对 SpringMVC 的自动配置，因此如果使用了 @EnableWebMvc，就需要自己配置 Spring MVC 的全部内容，包括视图解析器、资源处理、异常处理等。通常情况下，只有在需要非常精细的控制 Spring MVC 配置时才会使用 @EnableWebMvc。\n","date":"2024-11-14T16:21:47+08:00","permalink":"https://Tyritic.github.io/p/springmvc/","title":"SpringMVC"},{"content":"构造方法的作用 用于给对象实例进行初始化，只有在构造方法被调用的时候，对象才会被分配内存空间。\n构造方法的调用时机 每次使用 new 关键字创建对象的时候，构造方法至少会被调用一次。”\n定义构造方法的规则 构造方法的名字必须和类名一样； 构造方法没有返回类型，包括 void； 构造方法不能是抽象的（abstract）、静态的（static）、最终的（final）、同步的（synchronized）。 由于构造方法不能被子类继承，所以用 final 和 abstract 关键字修饰没有意义； 构造方法用于初始化一个对象，所以用 static 关键字修饰没有意义； 多个线程不会同时创建内存地址相同的同一个对象，所以用 synchronized 关键字修饰没有必要。 无参构造方法（默认构造方法） 如果一个构造方法中没有任何参数，那么它就是一个默认构造方法，也称为无参构造方法。\n通常情况下，无参构造方法是可以缺省的，开发者并不需要显式的声明无参构造方法，编译器将提供一个无参数，方法体为空的构造方法。\n当用户显式定义了构造方法后，系统将不再提供默认构造函数。\n默认构造方法的目的主要是为对象的字段提供默认值\n有参构造方法 有参数的构造方法被称为有参构造方法，参数可以有一个或多个。有参构造方法可以为不同的对象提供不同的值。\n如果没有有参构造方法的话，就需要通过 setter 方法给字段赋值了。\n重载构造方法 构造方法它也可以像方法一样被重载。构造方法的重载只需要提供不同的参数列表即可。编译器会通过参数的数量来决定应该调用哪一个构造方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class OverloadingConstrutorPerson { private String name; private int age; private int sex; public OverloadingConstrutorPerson(String name, int age, int sex) { this.name = name; this.age = age; this.sex = sex; } public OverloadingConstrutorPerson(String name, int age) { this.name = name; this.age = age; } public void out() { System.out.println(\u0026#34;姓名 \u0026#34; + name + \u0026#34; 年龄 \u0026#34; + age + \u0026#34; 性别 \u0026#34; + sex); } public static void main(String[] args) { OverloadingConstrutorPerson p1 = new OverloadingConstrutorPerson(\u0026#34;王二\u0026#34;,18, 1); p1.out(); OverloadingConstrutorPerson p2 = new OverloadingConstrutorPerson(\u0026#34;王三\u0026#34;,16); p2.out(); } } 拷贝构造方法 利用一个已有对象将该对象的参数字段直接传递给新的对象\n语法格式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 语法格式 class_name(class_name obj) { //字段赋值操作 } //示例代码 public class CopyConstrutorPerson { private String name; private int age; public CopyConstrutorPerson(String name, int age) { this.name = name; this.age = age; } public CopyConstrutorPerson(CopyConstrutorPerson person) { this.name = person.name; this.age = person.age; } public void out() { System.out.println(\u0026#34;姓名 \u0026#34; + name + \u0026#34; 年龄 \u0026#34; + age); } public static void main(String[] args) { CopyConstrutorPerson p1 = new CopyConstrutorPerson(\u0026#34;沉默王二\u0026#34;,18); p1.out(); CopyConstrutorPerson p2 = new CopyConstrutorPerson(p1); p2.out(); } } ","date":"2024-11-14T12:15:40+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/","title":"Java中的构造方法"},{"content":"就近原则 通常是指在方法调用过程中，编译器或 JVM 根据 \u0026ldquo;就近\u0026rdquo; 的方式来解析某些元素，特别是 变量、方法、类型、类 等的访问。\n示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Example { private int x = 10; // 类成员变量 public void myMethod(int x) { // 参数 x 会遮蔽成员变量 x System.out.println(\u0026#34;Local x: \u0026#34; + x); // 使用的是方法参数 x System.out.println(\u0026#34;Member x: \u0026#34; + this.x); // 使用成员变量 x } public static void main(String[] args) { Example obj = new Example(); obj.myMethod(20); } } this关键字 this关键字用于指代类实例化后的当前实例\n使用场景 当局部变量和实例变量重名时进行区分 其中被this修饰的变量是实例变量\n不被 this修饰的变量是局部变量\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class WithThisStudent { String name; int age; WithThisStudent(String name, int age) { this.name = name; this.age = age; } void out() { System.out.println(name+\u0026#34; \u0026#34; + age); } public static void main(String[] args) { WithThisStudent s1 = new WithThisStudent(\u0026#34;王二\u0026#34;, 18); WithThisStudent s2 = new WithThisStudent(\u0026#34;王三\u0026#34;, 16); s1.out(); s2.out(); // 输出： // 王二 18 // 王三 16 } } 调用当前类的方法 可以在一个类中使用 this 关键字来调用另外一个方法，如果没有使用的话，编译器会自动帮我们加上\n调用当前类的其他构造方法 this关键字可以用于在当前类的构造方法中调用当前类的其他构造方法，但是this() 必须放在构造方法的第一行\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 调用当前类的无参构造方法 public class InvokeConstrutor { InvokeConstrutor() { System.out.println(\u0026#34;hello\u0026#34;); } InvokeConstrutor(int count) { this(); System.out.println(count); } public static void main(String[] args) { InvokeConstrutor invokeConstrutor = new InvokeConstrutor(10); } // 输出 // hello // 10 } // 调用当前类的有参构造方法 public class InvokeParamConstrutor { InvokeParamConstrutor() { this(10); System.out.println(\u0026#34;hello\u0026#34;); } InvokeParamConstrutor(int count) { System.out.println(count); } public static void main(String[] args) { InvokeParamConstrutor invokeConstrutor = new InvokeParamConstrutor(); } } 作为方法的参数 “this 关键字可以作为参数在方法中传递，此时，它指向的是当前类的对象。\n作为返回值实现链式调用 this 关键字作为方法的返回值的时候，方法的返回类型为类的类型\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class ThisAsMethodResult { ThisAsMethodResult getThisAsMethodResult() { return this; } void out() { System.out.println(\u0026#34;hello\u0026#34;); } public static void main(String[] args) { new ThisAsMethodResult().getThisAsMethodResult().out(); } } 内存实现 this代表当前调用方法的对象引用，哪个对象调用方法，this就代表哪个对象的地址值\n","date":"2024-11-14T11:44:37+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84this%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E5%B0%B1%E8%BF%91%E5%8E%9F%E5%88%99/","title":"Java中的this关键字和就近原则"},{"content":"面向对象编程和面向过程编程 面向对象编程 面向对象编程是一种编程范式，它将现实世界中的事物抽象为对象，把类或对象作为基本单元来组织代码，对象具有属性（称为字段或属性）和行为（称为方法）。面向对象编程的设计思想是以对象为中心，通过对象之间的交互来完成程序的功能，具有灵活性和可扩展性，通过封装和继承可以更好地应对需求变化。\n面向过程编程 面向过程编程是一种以过程或函数为中心的编程范式，以过程作为基本单元来组织代码。过程其实就是动作，对应到代码中来就是函数，面向过程中函数和数据是分离的，数据就是成员变量。\n主要区别 数据与行为的关系：\n面向对象：数据和行为封装在对象内部，数据操作由对象方法进行管理。 面向过程：数据和函数是分离的，函数对数据进行操作。 可扩展性和复用性：\n面向对象：通过继承、接口、多态等机制支持代码的高复用性和扩展性。 面向过程：复用性较低，扩展需要修改已有代码，影响整体稳定性。 面向对象的特性和设计原则 三大特性 封装：将数据和行为封装在对象内部，提供接口进行访问，隐藏实现细节，提高安全性。 继承：子类可以继承父类的属性和方法，实现代码复用和扩展。 多态：对象可以通过父类或接口进行多态性调用，不同对象在运行时执行不同的行为。 六大设计原则 单一职责原则（SRP）：一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例子：考虑一个员工类，它应该只负责管理员工信息，而不应负责其他无关工作。 开放封闭原则（OCP）：软件实体应该对扩展开放，对修改封闭。例子：通过制定接口来实现这一原则，比如定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身。 里氏替换原则（LSP）：子类对象应该能够替换掉所有父类对象。例子：一个正方形是一个矩形，但如果修改一个矩形的高度和宽度时，正方形的行为应该如何改变就是一个违反里氏替换原则的例子。 接口隔离原则（ISP）：客户端不应该依赖那些它不需要的接口，即接口应该小而专。例子：通过接口抽象层来实现底层和高层模块之间的解耦，比如使用依赖注入。 依赖倒置原则（DIP）：高层模块不应该依赖低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。例子：如果一个公司类包含部门类，应该考虑使用合成/聚合关系，而不是将公司类继承自部门类。 最少知识原则 (Law of Demeter)：一个对象应当对其他对象有最少的了解，只与其直接的朋友交互。 类的组成结构 变量（属性） 静态变量：归属于整个类 实例变量：归属于一个对象 方法（行为） 静态方法：归属于整个类 实例方法：归属于一个对象 实现细节 打印对象名可以输出该对象的内存地址 成员变量具有默认值 一个源文件中可以定义多个类但是只能出现一个主类（被 public修饰）且该类与源文件的文件名相同 内存原理 对象在内存中的创建过程 加载.class文件 在栈区声明局部变量（对象的引用） 在堆区中开辟内存空间并产生对象的地址值 默认初始化（对成员变量赋默认值） 显式初始化（对常量进行初始化） 构造方法初始化 单个对象的内存情况 栈区 主方法main\n对象的引用\n堆区 对象的变量 成员方法的地址 项目开发中类的种类 Bean类 使用场景 用于描述事物的类\n特点 至少两个构造方法，一个无参构造方法，一个有参构造方法 成员变量为private 为所有成员变量提供getter和setter 工具类（Utils) 使用场景 将常用的方法封装成工具类\n特点 构造方法是private的 方法都是静态方法（static） 测试类 使用场景 用于检查代码的正确性\n特点 带有main方法 ","date":"2024-11-14T10:26:52+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","title":"Java中的类与对象"},{"content":"简介 Springdoc-OpenApi是一个规范且完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。\nSpringdoc-OpenApi 的目标是对 REST API 定义一个标准且和语言无关的接口，可以让人和计算机拥有无须访问源码、文档或网络流量监测就可以发现和理解服务的能力。\n具体使用 引入具体依赖springfox\n1 2 3 4 5 6 \u0026lt;!-- 导入相关依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springdoc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springdoc-openapi-starter-webmvc-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 添加配置类用于Api文档的基本配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package org.example.user.config; import io.swagger.v3.oas.models.OpenAPI; import io.swagger.v3.oas.models.info.Contact; import io.swagger.v3.oas.models.info.Info; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class SpringDocConfig { // OpenAPI类用于定制全局文档信息 @Bean public OpenAPI customOpenAPI() { return new OpenAPI() // 定制文档基本信息 .info(new Info() //关于文档信息 .title(\u0026#34;API 文档标题\u0026#34;) .description(\u0026#34;API 文档描述\u0026#34;) .version(\u0026#34;1.0.0\u0026#34;) .termsOfService(\u0026#34;https://example.com/terms\u0026#34;) //关于开发者 .contact(new Contact() .name(\u0026#34;开发者姓名\u0026#34;) .url(\u0026#34;开发者网址\u0026#34;) .email(\u0026#34;开发者邮箱\u0026#34;)) //关于许可证 .license(new License() .name(\u0026#34;许可证名称\u0026#34;) .url(\u0026#34;许可证文件\u0026#34;))) //配置服务器信息（可选） .servers(List.of( new Server().url(\u0026#34;服务器url\u0026#34;).description(\u0026#34;服务器描述\u0026#34;), new Server().url(\u0026#34;https://api.example.com\u0026#34;).description(\u0026#34;生产服务器\u0026#34;))) //配置外部文档信息（可选） .externalDocs(new ExternalDocumentation() .description(\u0026#34;外部文档描述\u0026#34;) .url(\u0026#34;外部文档url\u0026#34;)); } } 修改application.yml配置文件\n1 2 3 4 5 springdoc: api-docs: enable: true swagger-ui: enable: true 其余属性参见官方文档 SpringDoc-OpenApi官方文档\n提示\n1 2 3 4 5 6 7 8 springdoc: group-configs: #进行文档分组每个组配置对应的请求路径以及区分所在包 - group: \u0026#39;user\u0026#39; paths-to-match: \u0026#39;/api/users/**\u0026#39; packages-to-scan: com.toher.springdoc.user - group: \u0026#39;product\u0026#39; paths-to-match: \u0026#39;/api/product/**\u0026#39; packages-to-scan: com.toher.springdoc.product 可以在微服务架构中进行分组\n查看接口文档\nSwagger-UI接口文档：http://localhost:8080/swagger-ui/index.html Json形式接口文档：localhost:8080/v3/api-docs 使用注解编写接口文档\n常用注解 对实体类的描述 @Schema：用于描述类或字段的数据结构和属性，支持OpenAPI 3规范中的各种特性，如类型、格式、默认值等。\n1 2 3 4 5 6 7 8 9 10 11 12 @Data @NoArgsConstructor @AllArgsConstructor @Builder public class User { @Schema(description = \u0026#34;用户ID\u0026#34;, example = \u0026#34;1\u0026#34;) private int id; @Schema(description = \u0026#34;用户姓名\u0026#34;, example = \u0026#34;张三\u0026#34;) private String name; @Schema(description = \u0026#34;用户年龄\u0026#34;, example = \u0026#34;18\u0026#34;) private int age; } 对方法的描述 @Operation：用于方法级别，提供对API操作的详细描述，包括摘要、描述、响应、参数等信息。\nsummary：操作的简要描述。 description：操作的详细描述。 tags：与操作相关的标签。 operationId：操作的唯一标识符。 parameters：操作的参数列表。 responses：操作的响应列表。 1 2 3 4 5 6 7 8 9 10 @Operation( summary = \u0026#34;获取用户信息\u0026#34;, description = \u0026#34;根据用户ID获取用户详细信息\u0026#34;, tags = {\u0026#34;用户操作\u0026#34;}, operationId = \u0026#34;getUserById\u0026#34; ) @RequestMapping(\u0026#34;/users\u0026#34;) public User getUserById(@PathVariable Long id) { // 实现逻辑 } @ApiResponses是一个容器注解，用于收集多个@ApiResponse，描述方法可能返回的各种响应情况。\n@ApiResponse描述了API操作的一个特定响应，包括响应的状态码、描述、内容类型等。\nresponseCode：响应代码。 description：响应描述。 content：响应内容。 1 2 3 4 5 6 7 8 9 10 11 12 13 @RequestMapping(value=\u0026#34;/{id}\u0026#34;, method = RequestMethod.GET) @Operation(summary = \u0026#34;findById方法\u0026#34;, description = \u0026#34;根据id查询用户\u0026#34;) @Parameter(name = \u0026#34;id\u0026#34;, description = \u0026#34;用户id\u0026#34;, required = true, in = ParameterIn.PATH) @ApiResponses(value = { @ApiResponse(responseCode = \u0026#34;200\u0026#34;, description = \u0026#34;查询成功\u0026#34;,content={@Content(mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = Result.class))}), @ApiResponse(responseCode = \u0026#34;500\u0026#34;, description = \u0026#34;查询失败\u0026#34;,content={@Content(mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = Result.class))}) }) public Result\u0026lt;User\u0026gt; findById(@PathVariable Integer id) { return Result.success(\u0026#34;查询成功\u0026#34;, new User(id, \u0026#34;张三\u0026#34;, 20)); } @Parameters是一个容器注解，用于收集多个@Parameter注解，描述方法的多个请求参数。\n@Parameter：用于描述单个请求参数，可以是查询参数、路径参数、请求头等。\nname：参数名。 description：参数描述。 required：是否必需参数。 in：参数所在位置（query、header、path、cookie）。 1 2 3 4 5 6 7 8 @Parameters(value = { @Parameter(name = \u0026#34;name\u0026#34;, description = \u0026#34;姓名\u0026#34;, in = ParameterIn.PATH), @Parameter(name = \u0026#34;age\u0026#34;, description = \u0026#34;年龄\u0026#34;, in = ParameterIn.QUERY) }) @GetMapping(\u0026#34;/{name}\u0026#34;) public List\u0026lt;Programmer\u0026gt; getProgrammers(@PathVariable(\u0026#34;name\u0026#34;) String name, @RequestParam(\u0026#34;age\u0026#34;) Integer age) { ... } 对类的描述 @Tag：用于标记API控制器或方法属于哪一个功能分类或标签，有助于组织和分类API文档中的不同部分\n1 2 3 4 5 6 @Tag(name = \u0026#34;程序员\u0026#34;, description = \u0026#34;程序员乐园\u0026#34;) @RestController @RequestMapping(\u0026#34;/api/programmer\u0026#34;) public class ProgrammerController { ... } ","date":"2024-11-12T10:01:20+08:00","permalink":"https://Tyritic.github.io/p/springboot%E6%95%B4%E5%90%88springdoc-openapi/","title":"SpringBoot整合Springdoc-OpenApi"},{"content":"Restful服务 Restful是目前流行的互联网软件服务架构设计风格\n服务特点 每一个URL代表一种资源 客户端使用GET、POST、PUT、DELETE四种表示操作方式的动词对服务端资源进行操作：GET用于获取资源，POST用于新建资源（也可以用于更新资源），PUT用于更新资源，DELETE用于删除资源。 通过操作资源的表现形式来实现服务端请求操作。 资源的表现形式是JSON或者HTML。 客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都包含必需的信息。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @RestController public class UserController{ @ApiOperation(\u0026#34;获取用户\u0026#34;) @GetMapping(\u0026#34;/user/{id}\u0026#34;) public String getUserById(@PathVariable int id){ System.out.println(id); return \u0026#34;根据ID获取用户信息\u0026#34;; } @PostMapping(\u0026#34;/user\u0026#34;) public String save(User user){ return \u0026#34;添加用户\u0026#34;; } @PutMapping(\u0026#34;/user\u0026#34;) public String update(User user){ return \u0026#34;更新用户\u0026#34;; } @DeleteMapping(\u0026#34;/user/{id}\u0026#34;) public String deleteById(@PathVariable int id){ System.out.println(id); return \u0026#34;根据ID删除用户\u0026#34;; } } 最佳实现 接口设计 URL的组成 网络协议 服务器地址 接口名称 ？参数列表（GET方法） 响应设计 Content-body用来存放数据 用于描述数据的msg和code放入Content-header中 RestTemplate 简介 RestTemplate是Spring提供的用于访问Rest服务的，RestTemplate提供了多种便捷访问远程Http服务的方法，传统情况下在java代码里访问restfuI服务，一般使用Apache的HttpClient，不过此种方法使用起来太过繁琐。spring提供了一种简单便捷的模板类来进行操作，这就是RestTemplate.（常用于客户端和微服务）\n具体使用 以微服务为例\n创建一个Controller类（用@RestController修饰）\n创建一个Config类对RestTemplate进行配置和创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Configuration public class RestTemplateConfig { /** * 没有实例化RestTemplate时，初始化RestTemplate * 性能上OkHttp优于Apache的HttpClient，Apache的HttpClient优于HttpURLConnection（默认）。 * @return */ @ConditionalOnMissingBean(RestTemplate.class) @Bean public RestTemplate restTemplate(){ RestTemplate restTemplate = new RestTemplate(getClientHttpRequestFactory()); return restTemplate; } /** * 使用OkHttpClient作为底层客户端 * @return */ private ClientHttpRequestFactory getClientHttpRequestFactory(){ OkHttpClient okHttpClient = new OkHttpClient.Builder() .connectTimeout(5, TimeUnit.SECONDS) .writeTimeout(5, TimeUnit.SECONDS) .readTimeout(5, TimeUnit.SECONDS) .build(); return new OkHttp3ClientHttpRequestFactory(okHttpClient); } } 进行依赖注入并使用该Bean对象\n常见方法 GET请求 getForObject：获取请求体\n不带参数：(uri, \u0026lt;T \u0026gt;.class) 代表 请求地址、HTTP响应转换被转换成的对象类型 带参数(uri, String.class, paramMap) 代表 请求地址、HTTP响应转换被转换成的对象类型，请求参数 getForEntity：获取整个请求，除了包含响应体，还包含HTTP状态码、contentType、contentLength、Header等信息\nPOST请求 postForObject：获取请求体 postForEntity：获取整个请求，除了包含响应体，还包含HTTP状态码、contentType、contentLength、Header等信息 PUT请求 put： Delete请求 delete： 通用请求 exchange(String url, HttpMethod method,@Nullable HttpEntity\u003c?\u003e requestEntity, Class responseType, Map uriVariables) url: 请求地址； method: 请求类型(如：POST,PUT,DELETE,GET)； requestEntity: 请求实体，封装请求头，请求内容 responseType: 响应类型，根据服务接口的返回类型决定 uriVariables: url中参数变量值 ","date":"2024-11-11T18:48:31+08:00","permalink":"https://Tyritic.github.io/p/resttemplate/","title":"RestTemplate"},{"content":"List集合的定义 在 Java 中，List 是一个接口，继承自 Collection 接口，表示一个有序的元素集合。List 集合中的元素是按插入顺序排列的，允许元素重复。\nList集合的特点 集合中允许重复元素 集合中的元素是按插入顺序排列 集合支持动态扩容 只能存储引用数据类型，基本数据类型要转化成包装类 List接口的实现类 ArrayList：基于动态数组实现，支持快速随机访问，插入和删除操作效率相对较低，适用于查询频繁的场景。 LinkedList：基于双向链表实现，支持快速插入和删除，查询效率较低，适用于频繁修改的场景。 Vector：与 ArrayList 类似，但它是同步的，线程安全的，适用于多线程并发的场景（但现在不常用）。 Stack：继承自 Vector，实现了栈的功能，支持后进先出（LIFO）操作。 List接口的常用方法 增加元素 boolean add(E e)：将指定的元素添加到列表的末尾 void add(int index, E element)：将指定的元素插入到列表的指定位置 boolean addAll(Collection\u0026lt;? extends E\u0026gt; c)：将指定集合中的所有元素添加到当前列表的末尾 boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c)：将指定集合中的所有元素插入到当前列表的指定位置。 删除元素 void clear()：删除全部元素 E remove(int index)：删除列表中指定位置的元素 boolean remove(Object o)：删除列表中第一次出现的指定元素。如果列表中没有该元素，则不做任何操作。 boolean removeAll(Collection\u0026lt;?\u0026gt; c)：删除当前列表中所有与指定集合中的元素相同的元素 void removeRange(int from,int to)：删除索引[from，to）之间的元素 判断元素 boolean contains(Object o)：判断列表中是否包含指定的元素 boolean containsAll(Collection\u0026lt;?\u0026gt; c)：判断列表是否包含指定集合中的所有元素 修改元素 E set(int index, E element)：用指定的元素替换列表中指定位置的元素 访问元素 E get(int index)：返回指定位置的元素 int indexOf(Object o)：返回指定元素在列表中的第一次出现位置的索引。如果列表中没有该元素，则返回 -1 int lastIndexOf(Object o)：返回指定元素在列表中的最后一次出现位置的索引。如果列表中没有该元素，则返回 -1 获取大小 int size()：返回列表中元素的数量 boolean isEmpty()：判断列表是否为空 ","date":"2024-11-11T15:34:52+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84list%E6%8E%A5%E5%8F%A3/","title":"Java中的List接口"},{"content":"集合体系结构 Collection 接口：单列数据，所有集合类的根接口，提供基本的集合操作方法 List 接口：元素有序（存储顺序与存放顺序一致），可重复有索引的集合 ArrayList ：基于动态数组，查询速度快，插入、删除慢，线程不安全。 LinkedList ：基于双向链表，插入、删除快，查询速度慢，线程不安全。 Vector ：线程安全的动态数组，类似于 ArrayList，但开销较大。 Set 接口：元素无序，不可重复，无索引的集合 HashSet ：基于哈希表，元素无序，不允许重复。 LinkedHashSet ：基于链表和哈希表，维护插入顺序，不允许重复。 TreeSet ：基于红黑树，元素有序（元素是按照自然顺序或提供的比较器进行排序的），不允许重复。 Queue 接口：表示一个先进先出的集合 PriorityQueue ：基于优先级堆，元素按照自然顺序或指定比较器排序。 LinkedList ：可以作为队列使用，支持 FIFO（先进先出）操作。 ArrayQueue ：基于数组实现的双端队列 Map 接口：双列数据，保存具有映射关系的键值对 HashMap ：基于哈希表，键值对无序，不允许键重复，线程不安全。 LinkedHashMap ：基于链表和哈希表，维护插入顺序，不允许键重复。 TreeMap ：基于红黑树，键值对有序，不允许键重复。 Hashtable ：线程安全的哈希表，不允许键或值为 null。 ConcurrentHashMap ：线程安全的哈希表，适合高并发环境，不允许键或值为 null。 Collection接口 Collection 接口是 Java 集合框架的根接口，定义了集合类的基本操作方法。\n添加元素 boolean add(E e) ：将指定的元素添加到集合中，如果集合允许该元素的添加（比如没有重复元素限制），则返回 true，如果集合已经包含该元素，则返回 ** false** 向 List 集合中添加数据则方法将固定返回 true ，List 集合中允许添加重复元素 向 Set 集合中添加数据若当前元素已经存在返回 false，若当前元素不存在返回true boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) ：将指定集合中的所有元素添加到当前集合中 如果当前集合因为某些原因没有改变（例如集合为空或元素没有添加成功），则返回 false，否则返回 true。 删除元素 void clear() ：移除集合中的所有元素，使集合为空。 boolean remove(Object o) ：从集合中移除指定的元素。 如果集合中包含该元素并且成功移除，返回 true；如果元素不存在，返回 false。 boolean removeAll(Collection\u0026lt;?\u0026gt; c)：移除集合中与指定集合相同的所有元素。 如果集合因移除操作发生变化，则返回 true；如果没有任何元素被移除，则返回 false。 boolean retainAll(Collection\u0026lt;?\u0026gt; c) ：只保留集合中与指定集合相同的元素，移除其他元素。 如果集合发生变化（即移除了某些元素），则返回 true；如果没有元素被移除，则返回 false。 判断元素 boolean contains(Object o) ：判断集合是否包含指定元素 如果集合中包含该元素，返回 true；否则返回 false。 boolean containsAll(Collection\u0026lt;?\u0026gt; c)：判断当前集合是否包含指定集合中的所有元素。 boolean isEmpty()：判断集合是否为空 如果集合中没有元素，返回 true ；否则返回 false。 遍历方法 迭代器 Iterator 是 Java 集合框架中用于遍历集合元素的接口，允许开发者依次访问集合中的每一个元素，而不需要关心集合的具体实现。它提供了一种统一的方式来遍历 List、Set 等集合类型，通常与 Collection 类接口一起使用。Iterator 只能单向遍历集合，不能向前遍历。\n核心方法 hasNext() ：返回 true 表示集合中还有下一个元素，返回 false 则表示遍历完毕。 next()：返回集合中的下一个元素，如果没有更多元素则抛出 NoSuchElementException。 remove()：从集合中移除最近一次通过 next() 方法返回的元素，执行时只能在调用 next() 之后使用。这个方法是可选的，不是所有的实现都支持该操作。如果不支持，调用时会抛出 UnsupportedOperationException。 注意事项 迭代器越界会报错 迭代器遍历完毕，指针不会复位 迭代器遍历时不允许使用集合的方法进行添加和删除 （fail—fast）， 在用迭代器遍历一个集合对象时，如果线程 A 遍历过程中，线程 B 对集合对象的内容进行了修改（增加、删除、修改），则会抛出 Concurrent Modification Exception。 原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class IteratorExample { public static void main(String[] args) { // 创建一个List集合并添加元素 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;Apple\u0026#34;); list.add(\u0026#34;Banana\u0026#34;); list.add(\u0026#34;Cherry\u0026#34;); // 获取集合的迭代器 Iterator\u0026lt;String\u0026gt; iterator = list.iterator(); // 使用迭代器遍历集合 while (iterator.hasNext()) { String element = iterator.next(); System.out.println(element); // 输出元素 // 删除元素（示例：删除“Banana”） if (element.equals(\u0026#34;Banana\u0026#34;)) { iterator.remove(); // 删除“Banana” } } // 打印修改后的集合 System.out.println(\u0026#34;Modified list: \u0026#34; + list); } } // 输出： // Apple // Banana // Cherry // Modified list: [Apple, Cherry] ListIterator（List 特有的迭代器） ListIterator 是 Iterator 的子接口，专门用于操作 List 类型集合。与 Iterator 不同，它支持双向遍历和元素修改。\n核心方法\nhasPrevious()：判断是否还有前一个元素。 previous()：返回前一个元素。 add(E e)：向当前遍历的位置插入元素。 set(E e)：修改当前元素。 for-each循环 语法格式 1 2 3 for (Type item : collection) { // 使用 item } 主要特点 简洁性：语法更简单，减少了初始化、条件检查和更新的样板代码。适合用于遍历数组和实现了 Iterable 接口的集合。 只读访问：不提供对当前索引的访问，因此不适合需要根据索引进行复杂操作的场景。 安全性：在遍历过程中不能修改集合的结构（例如，不能在遍历 List 的同时添加或删除元素），否则会抛出 ConcurrentModificationException。 底层实现 实际上是通过 Iterator 实现的。Java 编译器会将 for-each 循环转换为一个使用 Iterator 或索引的标准迭代过程。\nLambda表达式遍历（forEach方法） 集合类（如 List、Set）实现了 Iterable 接口，Iterable 接口提供了一个默认的 forEach 方法，可以直接与 Lambda 表达式结合，进行遍历。\n语法格式 1 2 3 4 5 6 7 8 foreach(new Consumer\u0026lt;? super T\u0026gt; action) { @Override public void accept(T s) { //重写 } } ","date":"2024-11-11T09:36:04+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E5%92%8C%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/","title":"Java中的集合体系和集合遍历方式"},{"content":"devtool热部署 为了进一步提高开发效率,springboot为我们提供了全局项目热部署,日后在开发过程中修改了部分代码以及相关配置文件后,不需要每次重启使修改生效,在项目中开启springboot全局热部署之后只需要在修改之后等待几秒即可使修改生效。\n开启热部署 引入相关依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; Java的日志体系 日志门面 每一种日志框架都有自己单独的API，要使用对应的框架就要使用其对应的API，这就大大的增加应用程序代码对于日志框架的耦合性。\n为了解决这个问题，就是在日志框架和应用程序之间架设一个沟通的桥梁，对于应用程序来说，无论底层的日志框架如何变，都不需要有任何感知。只要门面服务做的足够好，随意换另外一个日志框架，应用程序不需要修改任意一行代码，就可以直接上线。总而言之，日志门面用于整合不同日志框架的日志（类似接口），不实现具体日志\n常见的日志门面\nJCL（Java Common Logging）：Java自带的日志门面 SLF4J：目前最常用的日志门面 JCL 用户可以自由选择第三方的日志组件作为具体实现，像log4j，或者jdk自带的jul， common-logging会通过动态查找的机制，在程序运行时自动找出真正使用的日志库。\nJCL默认的情况下，会使用JUL日志框架做日志的记录操作。\nJCL使用原则：如果有log4j，优先使用log4j，如果没有任何第三方日志框架的时候，使用的就是JUL。再没有则使用JCL内部提供的 SimpleLog 实现\n具体实现\n导入相关依赖\n编写业务代码\n1 2 3 4 5 6 7 public class JulMain { public static void main(String[] args){ Log log= LogFactory.getLog(JulMain.class) log.info(\u0026#34;Hello world\u0026#34;); } } SLF4J 简单日志门面(Simple Logging Facade For Java) SLF4J主要是为了给Java日志访问提供一套标准、规范的API框架，\n主要意义：提供接口，具体的实现可以交由其他日志框架，例如log4j和logback等。\n对于一般的Java项目而言，日志框架会选择slf4j-api作为门面，配上具体的实现框架（log4j、logback等），中间使用桥接器完成桥接。所以我们可以得出SLF4J最重要的两个功能就是对于日志框架的绑定以及日志框架的桥接。\n具体使用\n引入相关依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!--slf4j 核心依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--slf4j 自带的简单日志实现 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-simple\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--具体日志框架的slf4j桥接器（可选）--\u0026gt; 编写业务代码(如果在没有任何其他日志实现框架集成的基础之上，slf4j使用的就是自带的框架slf4j-simple，slf4j-simple也必须以单独依赖的形式导入进来。)\n1 2 3 4 5 6 7 8 9 10 public class SLF4JTest01 { // 都是slf4j包下的 Logger logger = LoggerFactory.getLogger(SLF4JTest.class); logger.trace(\u0026#34;trace信息\u0026#34;); logger.debug(\u0026#34;debug信息\u0026#34;); logger.info(\u0026#34;info信息\u0026#34;); logger.warn(\u0026#34;warn信息\u0026#34;); logger.error(\u0026#34;error信息\u0026#34;); } 日志实现和对应的日志门面 日志实现 日志门面 log4j（已经淘汰） JCL/SLF4J JUL（java.utils.logging) JCL log4j2 SLF4J logback SLF4J 提示\n记录日志不能直接使用日志实现框架，必须通过日志门面来实现\n日志实现 JUL JUL全称 Java Util Logging，核心类在java.util.logging包下，它是java原生的日志框架，使用时不需要另外引用第三方的类库，相对其他的框架使用方便，学习简单，主要是使用在小型应用中。\n组件构成\nLogger：被称为记录器，应用程序通过获取Logger对象，调用其API来发布日志信息。Logger通常被认为是访问日志系统的入口程序。 Handler：处理器，每个Logger都会关联一个或者是一组Handler，Logger会将日志交给关联的Handler去做处理，由Handler负责将日志做记录。Handler具体实现了日志的输出位置，比如可以输出到控制台或者是文件中等等。 Filter：过滤器，根据需要定制哪些信息会被记录，哪些信息会被略过。 Formatter：格式化组件，它负责对日志中的数据和信息进行转换和格式化，所以它决定了我们输出日志最终的形式。 Level：日志的输出级别，每条日志消息都有一个关联的级别。我们根据输出级别的设置，用来展现最终所呈现的日志信息。根据不同的需求，去设置不同的级别。 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 日志示例 public static void test02() { /* 日志的级别，总共七级 Level.SEVERE：（最高级）错误 Level.WARNING：警告 Level.INFO：（默认级别）消息 Level.CONFIG：配置级别 Level.FINE：详细信息（少） Level.FINER：详细信息（中） Level.FINEST：（最低级）详细信息（多） 两个特殊的级别： Level.OFF；可用来关闭日志记录 Level.ALL：启用所有日志记录 */ // Logger创建方式，参数为当前类全路径字符串com.demo.logger.jul.JULTest Logger logger = Logger.getLogger(JULTest.class.getCanonicalName()); logger.severe(\u0026#34;severe信息\u0026#34;); logger.warning(\u0026#34;warning信息\u0026#34;); logger.info(\u0026#34;info信息\u0026#34;); logger.config(\u0026#34;config信息\u0026#34;); logger.fine(\u0026#34;fine信息\u0026#34;); logger.finer(\u0026#34;finer信息\u0026#34;); logger.finest(\u0026#34;finest信息\u0026#34;); /* 输出内容：我们看到，默认是输出info及比info信息级别高的信息 三月 20, 2023 9:47:27 下午 com.demo.logger.jul.JULTest test02 严重: severe信息 三月 20, 2023 9:47:27 下午 com.demo.logger.jul.JULTest test02 警告: warning信息 三月 20, 2023 9:47:27 下午 com.demo.logger.jul.JULTest test02 信息: info信息 */ } SpringBoot日志框架 SpringBoot框架底层使用slf4j+logback的方式进行日志记录同时对于其他日志实现都提供了slf4j日志门面的集成\nSpringBoot日志使用 日志级别 trace：日志追踪信息 debug：日志详细信息 info：日志的关键信息 默认打印级别 warn：日志警告信息 error：日志错误信息 只有级别大于日志核心配置文件的 rootlevel 的信息才会输出，SpringBoot默认的 rootlevel 是info\n可以在application.yml中进行 rootlevel 的修改\n1 2 3 4 5 6 7 8 9 10 #修改全局的rootlevel logging: level: root: #可以只修改某个包下日志的rootlevel #示例 logging: level: com: example: 日志记录器声明 方法一：Java语句声明\n1 2 //1.声明日志记录器 Logger logger=LoggerFactory.getLogger(全类名) 方法二：使用注解@Slf4j(这个注解基于lombok依赖)\n1 2 3 4 @Slf4j public class userController{ } ​\n日志格式 默认格式 日期和时间：毫秒精度，易于排序 日志级别：ERROR，WARN，INFO，DEBUG，或TRACE 进程ID \u0026mdash;：分离器来区分实际日志消息的开始。 线程名称:用方括号括起来(对于控制台输出可能会被截断) 记录器名称:这通常是源类名称(通常缩写)。 日志消息。 修改默认格式 可以在application.yml中修改logging.pattern.console属性来修改格式详情常见SpringBoot官方文档\n1 2 3 logging: pattern: console: SpringBoot官方文档\n日志输出 日志默认在控制台输出，可以通过修改applicaiton.yml中的logging.file.name和logging.file.path来输出日志文件\n1 2 3 4 5 6 7 8 logging: file: #只指定name属性不指定path属性则默认日志文件输出在项目的根目录中 #name属性可以同时指定输出路径和日志文件名例如D:/mylog.log name:日志文件名 #不可以指定文件名，只能指定一个物理文件夹路径，默认文件名为spring.log path:日志文件的输出路径 日志的归档和迭代 在application.yml中可以设置相关参数实现日志的归档和迭代\n名称 描述 logging.logback.rollingpolicy.file-name-pattern 归档的文件名 logging.logback.rollingpolicy.clean-history-on-start 是否在应用程序启动时进行日志归档清理。 logging.logback.rollingpolicy.max-file-size 归档前日志文件的最大大小。 logging.logback.rollingpolicy.total-size-cap 删除日志档案之前可以使用的最大大小 logging.logback.rollingpolicy.max-history 保留日志存档的天数(默认为7) 示例代码\n1 2 3 4 5 6 logging: file: name: 日志文件名 path: 日志文件的输出路径 max-file-size: 日志文件的最大大小(日志文件超出该大小则生成归档的压缩包) max-history: 日志文件保留的时间 切换日志框架 将SpringBoot底层默认日志框架logback修改为log4j2\n排除logback的场景启动器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;!‐‐starter‐web里面自动添加starter‐logging 也就是logback的依赖‐‐\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring‐boot‐starter‐web\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;!‐‐排除starter‐logging 也就是logback的依赖‐‐\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;spring‐boot‐starter‐logging\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 添加log4j2的场景启动器\n1 2 3 4 5 \u0026lt;!‐‐Log4j2的场景启动器‐‐\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring‐boot‐starter‐log4j2\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; ","date":"2024-11-09T19:20:26+08:00","permalink":"https://Tyritic.github.io/p/springboot%E7%83%AD%E9%83%A8%E7%BD%B2%E5%92%8C%E6%97%A5%E5%BF%97/","title":"SpringBoot热部署和日志"},{"content":"分模块设计与开发 将项目的不同业务功能划分为不同的Maven模块\n优点\n方便项目的维护拓展 方便模块的相互调用 继承 概念：继承描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。 作用：简化依赖配置、统一管理依赖（所有子工程共有的依赖配置在父工程中）\n所有的SpringBoot项目都继承一个统一的父工程spring-boot-starter-parent\n具体实现： 创建maven模块，该工程为父工程，设置打包方式pom(默认jar)\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.itheima\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.8-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; 在子工程的pom.xml文件中，配置继承关系。\n1 2 3 4 5 6 \u0026lt;parents \u0026lt;groupId\u0026gt;com.itheima\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;../ tlias-parent/pom,xml\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; 提示\n在子工程中，配置了继承关系之后，坐标中的groupId是可以省略的，因为会自动继承父工程的 relativePath指定父工程的pom文件的相对位置(如果不指定，将从本地仓库/远程仓库查找该工程)。 在父工程中配置各个工程共有的依赖(子工程会自动继承父工程的依赖)。 提示\n若子工程和父工程的依赖版本不同，以子工程的为准 打包方式 pom：父工程，该模块无代码只进行依赖管理 jar：内嵌Tomcat服务器 war：普通web程序，部署在在外部Tomcat服务器 版本锁定 在maven中，可以在父工程的pom文件中通过\u0026lt;dependencyManagement \u0026gt;来统一管理依赖版本。\n在父工程的pom文件中指定依赖版本后，子工程引入依赖时不需要指定依赖版本，变更依赖版本时在父工程的pom文件中统一更改\n示例\n1 2 3 4 5 6 7 8 9 10 11 #父工程 \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--JWT令牌--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 1 2 3 4 5 6 7 #子工程 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 提示\n\u0026lt; dependencies \u0026gt;和\u0026lt; dependencyManage \u0026gt;的区别\n\u0026lt; dependencies \u0026gt;是直接依赖，子工程的pom无须引入 \u0026lt; dependencyManage \u0026gt;是版本管理，子工程的pom依然需要引入 自定义属性/引用属性 可以在pom文件中使用标签\u0026lt;properties\u0026gt;标签来自定义属性\n1 2 3 4 \u0026lt;properties\u0026gt; \u0026lt;lombok.versiqn\u0026gt;1.18.24\u0026lt;/lombok.version\u0026gt; \u0026lt;jjwt.version\u0026gt;8.9.0\u0026lt;/jjwt.version\u0026gt; \u0026lt;/properties\u0026gt; 然后使用${}来引用自定义属性\n1 2 3 4 5 6 7 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 聚合 概述：将多个模块组织成一个整体，同时进行项目的构建。 聚合工程：一个不具有业务功能的“空”工程(有且仅有一个pom文件)通常是继承中的父工程 具体实现：在父工程中使用标签\u0026lt;module\u0026gt;指定子模块\n1 2 3 4 5 \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;../tlias-pojo\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;,./tlias-utils\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../tlias-web-management\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; 提示\n聚合工程中所包含的模块，在构建时，会自动根据模块间的依赖关系设置构建顺序，与聚合工程中模块的配置书写位置无关。\n继承和聚合的区别 作用\n聚合用于快速构建项目 继承用于简化依赖配置、统一管理依赖 相同点\n聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中 聚合与继承均属于设计型模块，并无实际的模块内容 不同点\n聚合是在聚合工程中配置关系，聚合可以感知到参与聚合的模块有哪些 继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己 ","date":"2024-11-09T12:27:38+08:00","permalink":"https://Tyritic.github.io/p/maven%E9%AB%98%E7%BA%A7/","title":"Maven高级"},{"content":"起步依赖 原理：SpringBoot框架提供的起步依赖通过Maven的依赖传递集成了开发中常见的依赖\n自动配置 概念 当spring容器启动后，一些配置类、bean对象就自动存入到了I0C容器中，不需要手动去声明，从而简化了开发，省去了繁琐的配置操作。\n实现方案 方案一：@ComponentScan 组件扫描依赖 1 2 3 4 @SpringBootApplication @ComponentScan({\u0026#34;com.alibaba\u0026#34;,\u0026#34;com.google\u0026#34;,\u0026#34;org.springframework\u0026#34;,\u0026#34;org.mybatis\u0026#34;,...} public class springbootWebconfig2Application{ } 方案二：@lmport 导入 使用@lmport导入的类会被Spring加载到I0C容器中，导入形式主要有以下几种:\n导入 普通类 导入 配置类 导入 ImportSelector 接口实现类 @EnableXXX注解，封装了@Import 1 2 3 4 5 @Import({TokenParser.class,Headerconfig.class}) @SpringBootApplication public class springbootWebconfig2Application{ } 源码分析 查看启动类的注解**@SpringBootApplication**的源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //自定义组件所需的元注解 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited //表示启动类也是一个配置类 @SpringBootConfiguration //自动配置功能 @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) 提示\n问：为什么在启动类中可以声明第三方Bean对象？\n答：@SpringBootApplication中封装了@SpringBootConfiguration，表明启动类也是一个配置类\n问：为什么启动类只会扫描启动类所在包及其子包的组件\n答：@SpringBootApplication中封装了@ComponentScan的注解\n由 @SpringBootApplication 的注解源码可知自动配置由注解 @EnableAutoConfiguration 提供，查看 @EnableAutoConfiguration的注解\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import({AutoConfigurationImportSelector.class}) public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = \u0026#34;spring.boot.enableautoconfiguration\u0026#34;; Class\u0026lt;?\u0026gt;[] exclude() default {}; String[] excludeName() default {}; } 可以看出 @EnableAutoConfiguration 注解通过 @Import注解导入 ImportSelector 接口实现类来实现自动配置\n查看AutoConfigurationImportSelector.class 的源码\n1 2 3 4 5 6 7 8 public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!this.isEnabled(annotationMetadata)) { return NO_IMPORTS; } else { AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); } } selectImports方法返回要导入的Bean对象的全类名\n从 AutoConfigurationImportSelector.class 的源码可以知道返回值从 autoConfigurationEntry.getConfigurations() 获得而autoConfigurationEntry 由 AutoConfigurationImportSelector.getAutoConfigurationEntry方法获得。查看 getAutoConfigurationEntry 的源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) { if (!this.isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } else { AnnotationAttributes attributes = this.getAttributes(annotationMetadata); List\u0026lt;String\u0026gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); configurations = this.removeDuplicates(configurations); Set\u0026lt;String\u0026gt; exclusions = this.getExclusions(annotationMetadata, attributes); this.checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = this.getConfigurationClassFilter().filter(configurations); this.fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); } } 从 AutoConfigurationImportSelector.getAutoConfigurationEntry看出 configuration是一个List\u0026lt;String\u0026gt;对象，从AutoConfigurationImportSelector.getCandidateConfigurations(annotationMetadata, attributes) 中获得。查看AutoConfigurationImportSelector.getCandidateConfigurations(annotationMetadata, attributes) 的源码\n1 2 3 4 5 protected List\u0026lt;String\u0026gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List\u0026lt;String\u0026gt; configurations = ImportCandidates.load(AutoConfiguration.class, this.getBeanClassLoader()).getCandidates(); Assert.notEmpty(configurations, \u0026#34;No auto configuration classes found in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you are using a custom packaging, make sure that file is correct.\u0026#34;); return configurations; } SpringBoot框架会自动加载 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 的配置文件并封装到 configurations 这个List集合中\n实现过程 @SpringBootApplication注解封装了 @EnableAutoConfiguration 来实现自动配置\n@EnableAutoConfiguration 封装了 @Import 注解，该注解以引入 ImportSelector接口的实现类AutoConfigurationImportSelector 来完成自动装配\nAutoConfigurationImportSelector 获取 AutoConfigurationEntry 对象，该对象具有成员变量Configurations用于存储Bean对象的全类名\nAutoConfigurationEntry 使用 getCandidateConfigurations方法，SpringBoot框架会自动加载 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 配置文件并封装到 configurations 这个List集合中\nMETA-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 中封装了Bean对象的声明\n条件配置 @Conditional 作用：按照一定的条件进行判断，在满足给定条件后才会注册对应的bean对象到SpringIOC容器中。\n位置：方法、类\n@Conditional 本身是一个父注解，派生出大量的子注解:\n@Conditional0nClass：判断环境中是否有对应字节码文件，才注册bean到IOC容器。 @ConditionalOnMissingBean：判断环境中没有对应的bean(类型或名称)，才注册bean到IOC容器。 @ConditionalOnProperty：判断配置文件中有对应属性和值，才注册bean到IOC容器。 ","date":"2024-11-08T18:47:12+08:00","permalink":"https://Tyritic.github.io/p/springboot%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","title":"SpringBoot底层原理"},{"content":"Bean对象的获取 默认情况下，Spring项目启动时，会把bean都创建好放在IOC容器中\n提示\n上述所说的【Spring项目启动时，会把其中的bean都创建好】还会受到作用域及延迟初始化影响，这里主要针对于默认的单例非延迟加载的bean而言。\n但可以主动获取Bean对象\n具体实现\n注入IOC容器对象：ApplicationContext 1 2 3 根据name获取bean: Object getBean(String name) 根据类型获取bean：\u0026lt;T\u0026gt;T getBean(class\u0026lt;T\u0026gt; requiredType) 根据name获取bean(带类型转换)：\u0026lt;T\u0026gt;T getBean(String name,Class\u0026lt;T\u0026gt;requiredType) Bean对象的作用域 Spring支持五种作用域，后三种在web环境才生效\n作用域 说明 singleton 容器内同 名称 的 bean 只有一个实例(单例)(默认) prototype 每次使用该 bean 时会创建新的实例(非单例) request 每个请求范围内会创建新的实例(web环境中，了解) session 每个会话范围内会创建新的实例(web环境中，了解) application 每个应用范围内会创建新的实例(web环境中，了解) 使用@Scope注解来指定作用域\n1 2 3 4 5 @Scope(\u0026#34;prototype\u0026#34;) @RestController @RequestMapping(\u0026#34;/depts\u0026#34;) public class DeptController { } 警告\n注意事项\n默认singleton的bean，在容器启动时被创建，可以使用@Lazy注解来延迟初始化(延迟到第一次使用时)prototype的bean，每一次使用该bean的时候都会创建一个新的实例。 实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性。 第三方Bean对象 如果要管理的bean对象来自于第三方(不是自定义的)，是无法用 @Component及衍生注解声明bean的，就需要用到 @Bean注解。\n具体实现\n​\t方法一：在启动类中使用@Bean注解修饰一个返回值为Bean对象的方法（不推荐）\n1 2 3 4 5 6 @springBootApplication public class springbootWebconfig2Application { @Bean/将方法返回值交给I0C容器管理,成为IOC容器的bean对象 public SAXReader saxReader(){ return new SAXReader(); } 方法二：创建一个配置类（使用@Configuration)集中配置Bean对象\n1 2 3 4 5 6 @Configuration public class commonconfig{ @Bean/将方法返回值交给I0C容器管理,成为IOC容器的bean对象 public SAXReader saxReader(){ return new SAXReader(); } 提示\n通过@Bean注解的name或value属性可以声明bean的名称，如果不指定，默认bean的名称就是方法名 如果第三方bean需要依赖其它bean对象，直接在bean定义方法中设置形参即可，容器会根据类型自动装配。 ","date":"2024-11-08T17:05:51+08:00","permalink":"https://Tyritic.github.io/p/bean%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%AE%A1%E7%90%86/","title":"Bean对象的管理"},{"content":"配置方式 文件配置 properties文件 yml文件 yaml文件 Java系统属性 设置方法 执行maven打包指令package\n执行java指令，运行jar包，在执行java命令时添加参数\n参数格式\n1 -Dxxx=xxx 命令行参数 执行maven打包指令package\n执行java指令，运行jar包，在执行java命令时添加参数\n参数格式\n1 --xxx=xxx 配置优先级 优先级从低到高\napplication.yam](忽略) application.yml application.properties java系统属性(-Dxxx=xxx) 命令行参数(\u0026ndash;xxx=xxx) ","date":"2024-11-08T16:37:30+08:00","permalink":"https://Tyritic.github.io/p/springboot%E9%85%8D%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7/","title":"SpringBoot配置优先级"},{"content":"概述 AOP就是是Aspect Oriented Programming(面向切面编程、面向方面编程)，其实就是面向特定方法编程\n底层实现：动态代理是面向切面编程最主流的实现。而SpringAOP是Spring框架的高级技术，旨在管理bean对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程。\n应用场景\n记录操作日志 权限控制 事务管理 具体实现 导入相关依赖\n编写AOP程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Component @Aspect public class TimeAspect { @Around(\u0026#34;execution()”) public Object recordTime(ProceedingJoinPoint proceedingJoinPoint)throws Throwable { long begin=System.currentTimeMillis(); 0bject object=proceedingJoinPoint.proceed();//调用原始方法运行 long end=System.currentTimeMillis(); log.info(proceeding]oinPoint.getsignature()+\u0026#34;执行耗时:{}ms\u0026#34;,end - begin); return object; } } AOP核心概念 连接点（JoinPoint）：可以被AOP控制的方法(暗含方法执行时的相关信息)\n通知（Advice）：指哪些重复的逻辑，也就是共性功能\n体现为被@Around()修饰的方法 切入点（PointCut）：匹配连接点的条件，通知仅会在切入点方法执行时被应用\n相关注解：@Around(\u0026ldquo;execution()”) 切面（Aspect）：描述通知与切入点的对应关系(通知+切入点)\n相关注解：@Aspect用于修饰类 目标对象（Target）：通知所应用的对象\nAOP执行流程 底层为目标对象生成代理对象 在代理对象中使用通知对目标对象的连接点做功能增强 在依赖注入时注入代理对象 AOP通知 通知类型 @Around:环绕通知，此注解标注的通知方法在目标方法前、后都被执行 @Before:前置通知，此注解标注的通知方法在目标方法前披执行 @After :后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行 @AfterReturning: 返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行 @AfterThrowing: 异常后通知，此注解标注的通知方法发生异常后执行 提示\n@Around环绕通知需要自己调用 ProceedingJoinPoint.proceed()来让原始方法执行，其他通知不需要考虑目标方法 执行@Around环绕通知方法的返回值，必须指定为Object，来接收原始方法的返回值。 通知顺序 当有多个切面的切入点都匹配到了目标方法，目标方法运行时，多个通知方法都会被执行\n不同切面类的通知顺序 目标方法前的通知方法：字母排名靠前的先执行 目标方法后的通知方法：字母排名靠前的后执行 用注解@Order(数字) 加在切面类上来控制顺序 目标方法前的通知方法:数字小的先执行 目标方法后的通知方法:数字小的后执行 同一个切面类的通知顺序 Around-Before Before Around-after after 切入点表达式 切入点表达式：描述切入点方法的一种表达式 作用：主要用来决定项目中的哪些方法需要加入通知\nexecution(….)根据方法的签名来匹配 execution 主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配\n语法：execution(访问修饰符? 返回值 包名.类名.?方法名(方法参数)throws 异常?)\n带?的部分可以省略\n访问修饰符:可省略(比如:public、protected) 包名.类名: 可省略 throws 异常:可省略(注意是方法上声明抛出的异常，不是实际抛出的异常) 通配符\n*：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分\n1 execution(* com.*.service.*.update*(*)) :：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数\n1 execution(* com.itheima..Deptservice.*(..)) @annotation(.):根据注解匹配 @annotation切入点表达式，用于匹配标识有特定注解的方法\n语法：@annotation(全类名)\n1 2 3 4 @Before(\u0026#34;@annotation(com.itheima.anno.Log)\u0026#34;) public void before(){ log.info(\u0026#34;before ....\u0026#34;); } 提示\n@PointCut 该注解的作用是将公共的切点表达式抽取出来，需要用到时引用该切点表达式即可\n1 2 3 4 5 6 @Pointcut(\u0026#34;execution()\u0026#34;) public void pt(){) @Around(\u0026#34;pt()\u0026#34;) public Object recordrime(ProceedingjoinPoint joinPoint) throws Throwable { } 注意事项\nprivate:仅能在当前切面类中引用该表达式 public:在其他外部的切面类中也可以引用该表达式 连接点 在Spring中用JoinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等。\n对于 @Around 通知，获取连接点信息只能使用ProceedingJoinPoint\n对于其他四种通知，获取连接点信息只能使用JoinPoint，它是ProceedingJoinPoint 的父类型\n相关方法\n1 2 3 4 5 6 7 8 9 @Around(\u0026#34;execution()\u0026#34;) public object around(Proceeding)oinPoint joinPoint)throws Throwable { String className=joinPoint.getTarget().getc1ass().getName(); //获取目标类名 Signature signature=joinPoint.getsignature();//获取目标方法签名 String methodName= joinPoint.getsignature().getName();//获取目标方法名 0bject[]args = joinPoint.getArgs();//获取目标方法运行参数 0bject res= joinPoine.proceed();/执行原始方法,获取返回值(环绕通知) return res; } 1 2 3 4 5 6 7 8 @Before(\u0026#34;execution(\u0026#34;\u0026#34;)) public void befored(JoinPoint joinPoint) { String className=joinPoint.getTarget().getclass().getName();//获取目标类名 Signature signature=joinPoint.getsignature();//获取目标方法签名 String methodName =joinPoint.getsignature().getName();//获取目标方法名 0bject[]args= joinPoint.getArgs();//获取目标方法运行参数 } ","date":"2024-11-07T18:38:05+08:00","permalink":"https://Tyritic.github.io/p/aop/","title":"AOP"},{"content":"数据库中的事务 概念：事务是一组操作的集合，它是一个不可分割的工作单位，这些操作 要么同时成功，要么同时失败。\n操作\n开启事务(一组操作开始前，开启事务)\n1 start transaction; 提交事务(这组操作全部成功后，提交事务)\n1 commit; 回滚事务(中间任何一个操作出现异常，回滚事务)\n1 rollback; Spring中的事务管理 @Transactional 注解\n位置：service层的方法，类，接口上\n修饰方法\n1 2 3 4 5 6 @Transactional @Override public void delete(Integer id){ deptMapper.delete(id); empMapper.deleteByDeptId(id); } 修饰类\n1 2 3 4 @Transactional @Service public class DeptServiceImpl implements DeptService{ } 修饰接口\n1 2 3 4 @Transactional public interface DeptService { } 作用：将当前方法交给spring进行事务管理\n方法执行前，开启事务; 成功执行完毕，提交事务; 出现异常，回滚事务 事务属性 回滚 默认情况下，只有出现 RuntimeException 才回滚异常。rollbackFor 属性用于控制出现何种异常类型，回滚事务。\n示例代码\n1 2 3 4 5 6 @Transactional(rollbackFor=Exception.class) @Override public void delete(Integer id)throws Exception { deptMapper.deleteById(id); empMapper.deleteByDeptId(id); } 传播行为 传播行为：指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制。\n常见的传播行为属性\n属性值 含义 REQUIRED 【默认值】需要事务，有则加入，无则创建新事务 REQUIRES_NEW 需要新事务，无论有无，总是创建新事务 SUPPORTS 支持事务，有则加入，无则在无事务状态中运行 NOT_SUPPORTED 不支持事务，在无事务状态下运行,如果当前存在已有事务,则挂起当前事务 MANDATORY 必须有事务，否则抛异常 NEVER 必须没事务，否则抛异常 使用场景\nREQUIRED：大部分情况下都是用该传播行为即可。 REOUIRES NEW：当我们不希望事务之间相互影响时，可以使用该传播行为。比如:下订单前需要记录日志，不论订单保存成功与 否，都需要保证日志记录能够记录成功。 ","date":"2024-11-07T16:51:41+08:00","permalink":"https://Tyritic.github.io/p/springboot%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/","title":"SpringBoot事务管理"},{"content":"项目开发过程中会遇到异常问题\n全局异常处理器 @RestControllerAdvice：用于修饰类表示全局异常处理器\n@ExceptionHandler：用于修饰异常处理方法\n示例代码\n1 2 3 4 5 6 @RestControllerAdvice puhlic class GlobalExceptionHandler { @ExceptionHandler(Exception.class) public Result ex(Exception ex){ex.printstackTrace(); return Result.error(”对不起,操作失败,请联系管理员\u0026#34;); } 全局异常 在common包下定义基本异常BaseException，其余的异常为这个类的子类\n示例代码\n1 2 3 4 5 6 7 8 9 10 public class BaseException extends RuntimeException { public BaseException() { } public BaseException(String msg) { super(msg); } } ","date":"2024-11-07T16:33:35+08:00","permalink":"https://Tyritic.github.io/p/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","title":"异常处理"},{"content":"简介 Spring框架中提供的，用来动态拦截控制器方法的执行。 作用:拦截请求，在指定的方法调用前后，根据业务需要执行预先设定的代码。\n具体实现 定义Interceptor类，实现HandlerInterceptor接口并重写方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Component public class LoginCheckInterceptor implements HandlerInterceptor { @0verride //目标资源方法执行前执行，放回true:放行，返回false:不放行 public boolean prehandle(HttpServletRequest reg, HttpServletResponse resp, object handler) throws Exception { System.out.println(\u0026#34;preHandle ...\u0026#34;); return true; } @Override //目标资源方法执行后执行 public void postHandle(HttpservletRequest req, HttpServletResponse resp, object handler, ModelAndview modelAndview){ System.out.println(\u0026#34;postHandle..\u0026#34;); } @0verride //视图渲染完毕后执行，最后执行 public void afterCompletion (HttSservietReguest reg, HttpServletResponse resp, Object handler, Exception ex) { System.out.println(\u0026#34;aftercompletion ...\u0026#34;); } } 注册拦截器\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class webConfig implements WebMvcConfigurer { @Autowired private LoginCheckInterceptor logincheckInterceptor; @Override public void addInterceptors(InterceptorRegistry registry){ registry.addInterceptor (logincheckInterceptor) .addPathPatterns(\u0026#34;拦截路径\u0026#34;) .excludePathPatterns(\u0026#34;放行路径\u0026#34;) } } 拦截路径 拦截器可以根据需求，配置不同的拦截路径:\n拦截路径 含义 示例 /* 所有的一级路径 /depts /** 任意级路径 /depts，/depts/1 /depts/* /depts下的一级路径 /depts/1 /depts/** /depts下的任意级路径 /depts/emp/1 执行流程 请求先进入过滤器还未进入Spring容器中 经过过滤器的校验后进入DispatcherServlet 请求到达拦截器进行校验 提示\n接口规范不同: 过滤器需要实现Filter接口 拦截器需要实现Handlerinterceptor接口。 拦截范围不同: Filter会拦截所有的资源 Interceptor只会拦截Spring环境中的资源。 ","date":"2024-11-07T15:49:32+08:00","permalink":"https://Tyritic.github.io/p/interceptor/","title":"Interceptor"},{"content":"概述 Filter 过滤器是JavaWeb 三大组件(Servlet、Filter、Listener)之一。\n作用：过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。\n使用场景：过滤器一般完成一些通用的操作，比如:登录校验、统一编码处理、敏感字符处理等。\n具体实现 定义Filter类：实现 Filter接口，并重写其所有方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @WebFilter(urlPatterns =\u0026#34;/*\u0026#34;) public class DemoFilter implements Filter { //初始化方法,Web服务器启动,创建Filter时调用，只调用一次 public void init (Filterconfig filterconfig)throws ServletException { Filter.super.init(filterConfig); } ///拦截到请求时,调用该方法,可调用多次 public void doFilter (ServletRequest request, servletResponse response, Filterchain chain){ System.out.println(\u0026#34;拦截方法执行，拦截到了请求...\u0026#34;); System.out.println(\u0026#34;执行放行前的逻辑...\u0026#34;); chain.doFilter(request,response);// 放行请求 System.out.println(\u0026#34;执行放行后的逻辑...\u0026#34;); } //销毁方法，服务器关闭时调用，只调用一次 public void destroy(){ Filter.super.destroy(); } } 配置Filter：使用@WebFilter注解，配置拦截资源的路径。\n引导类上加 @ServletComponentScan 开启Servlet组件支持。\n1 2 3 4 5 @ServletComponentScan @SpringBootApplication public class TliasWebManagementApplication{public static void main(stringl] args){ SpringApplication.run(TliasWebManagementApplication.class, args); } 执行流程 过滤器拦截到请求 过滤器执行doFilter()之前的部分作为放行前的逻辑 过滤器执行doFilter()放行请求 过滤器执行doFilter()之后的部分作为放行后的逻辑 提示\n放行后访问对应资源，资源访问完成后，还会回到Filter中 回到Filter中执行放行后的逻辑 拦截路径 Filter 可以根据需求，配置不同的拦截资源路径\n拦截路径 urlPattern 含义 拦截具体路径 /login 只有访问/login才被拦截 目录拦截 /emp/* 访问emp目录下的资源都被拦截 拦截所有 /* 访问所有资源都被拦截 过滤器链 一个web应用中，可以配置多个过滤器，这多个过滤器就形成了一个过滤器链\n顺序：注解配置的Filter，优先级是按照过滤器类名(字符串)的自然排序\n","date":"2024-11-07T14:50:40+08:00","permalink":"https://Tyritic.github.io/p/filter/","title":"Filter"},{"content":"登录功能实现的基本思路 登录标记 用户登录成功之后，每一次请求中，都可以获取到该标记，\n常见技术\n会话技术 JWT令牌 登录校验 对接收到的请求进行统一拦截\n常见技术\n过滤器（Filter） 拦截器（Interceptor） 登录标记 会话技术 用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。\n会话跟踪 一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。\n会话跟踪方案\n客户端会话跟踪技术：Cookie 服务端会话跟踪技术：Session Cookie 什么是 Cookie\nCookie 是存储在用户浏览器端的一个小型数据文件，用于跟踪和保存用户的状态信息。\n主要用于保持用户登录状态、跟踪用户行为、存储用户偏好等。\n存储在浏览器端。\n基本流程\n浏览器第一次向服务端发出请求时服务端设置 Cookie 服务端给浏览器响应并设置响应头的 Set-Cookie 浏览器解析 Cookie 值并保存在浏览器本地 后续的每次请求中浏览器会将 Cookie 数据放入请求头中 优点：HTTP协议支持的技术\n缺点\n移动端APP不支持 Cookie，\n状态管理： Session 基于服务器端的状态管理，而移动端应用通常是无状态的。移动设备的连接可能不稳定或中断，因此难以维护长期的会话状态。如果使用 Session 进行身份认证，移动应用需要频繁地与服务器进行会话维护，增加了网络开销和复杂性; 兼容性:：移动端应用通常会面向多个平台。每个平台对于 Session 的管理和存储方式可能不同，可能导致跨平台兼容性的问题; 安全性：移动设备通常处于不受信任的网络环境，存在数据泄露和攻击的风险。将敏感的会话信息存储在移动设备上增加了被攻击的潜在风险。 不安全，用户可以自己禁用 Cookie\nCookie不能跨域\n提示\n跨域被分为三个维度：协议，IP，端口，三者有一个不同就是跨域\nSession 什么是 Session\nSession 是服务器端保存用户状态的机制，每个用户会话都有一个唯一的 Session ID。\n主要用于跟踪用户在服务器上的状态信息，例如登录状态和购物车内容。\n存储在服务器端，然后对应的 Session ID 通过 Cookie 保存在客户端浏览器中。\n基本流程\n浏览器第一次向服务器端发出请求，此时服务器端没有 Session 对象 服务器端生成 Session 对象并将 Session 对象的 ID 放入响应的响应头（Set-Cookies） 浏览器保存 Session 对象并且此后浏览器的每次请求中以请求头的 Cookie 数据附带 Session 对象以维持会话状态 服务器会寻找到请求 Cookie 中的 Session 对象从而实现数据共享 优点 ：存储在服务器端更加安全\n缺点\n服务器集群中无法直接使用 Session 技术 Session 技术基于Cookie 技术，继承了Cookies的全部缺点 令牌技术 基本流程\n浏览器发出请求后，服务端生成令牌作为身份凭证放入响应 此后的客户端每一次的请求会在请求头（通常是 Authorization 头）携带令牌 服务端则会该令牌的有效性以进行用户身份验证 优点:\n支持PC端、移动端 解决集群环境下的认证问题 减轻服务器端存储压力 Session-Cookie 方案 用户向服务器发送用户名、密码、验证码用于登陆系统。 服务器验证通过后，服务器为用户创建一个 Session，并将 Session 信息存储起来。 服务器向用户返回一个 SessionID，写入用户的 Cookie 。 当用户保持登录状态时，Cookie 将与每个后续请求一起被发送出去。 服务器可以将存储在 Cookie 上的 SessionID 与存储在内存中或者数据库中的 Session 信息进行比较，以验证用户的身份，返回给用户客户端响应信息的时候会附带用户当前的状态 JWT令牌技术 简介：JSON Web Token(https://jwt.io/) 定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。\n令牌结构 Header (头)：描述 JWT 的元数据，定义了生成签名的算法以及 Token 令牌的类型。Header 被 Base64Url 编码后成为 JWT 的第一部分。\ntyp（Type）：令牌类型。 alg（Algorithm）：签名算法。 Payload(有效载荷)：携带所传递的数据。Payload 被 Base64Url 编码后成为 JWT 的第二部分。\nSignature (签名)：防止Token被篡改、确保安全性。服务器通过 Payload、Header 和一个密钥(Secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。生成的签名会成为 JWT 的第三部分。\nHeader + Payload 存放在服务端的密钥(一定不要泄露出去)。 签名算法。 优点 自包含： JWT 中包含了所有必要的信息，因此在验证时不需要查询数据库，提升了性能。 跨语言：由于 JWT 是基于JSON的，几乎所有编程语言都支持它的生成和解析。 无状态 ：JWT 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 JWT 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。 提示\nJWT与Session的对比\n无状态认证：JWT 通常用于无状态认证，即服务器不存储会话数据。相比之下，Session 认证通常需要服务器存储用户的会话信息。 扩展性：由于 JWT 不依赖服务器存储，因此在分布式系统中更具扩展性。Session 认证在多服务器环境中需要依赖共享存储或会话粘性（Session Stickiness），从而增加了系统复杂度。 拓展知识：如何废除一个未过期的令牌\n因为 JWT 是无状态的，一般服务器并不保存已签发的 JWT ，所以服务器无法主动撤销一个已经签发的 JWT 。\n不过可以通过以下思路实现\n使用黑名单（Blacklist） 实现思路：在服务器端维护一个黑名单（或者叫作废列表），该列表包含所有已被废除的 JWT 标识符（通常使用 JWT 的jti声明）。每次服务器验证 JWT 时，除了验证签名和其他标准信息外，还需要检查该 JWT 是否在黑名单中。 优点：可以精确废除特定的 JWT ，不影响其他合法的 JWT 。 缺点：需要在服务器端存储和管理黑名单，违背了 JWT 的无状态特性，增加了系统复杂度。如果黑名单列表变大，查询效率可能成为问题。 使用版本控制（Token Versioning） 实现思路：在用户信息中引入一个“Token 版本号”的字段，每次生成 JWT 时，将这个版本号作为 JWT 的一部分（可以放在 Payload 的自定义声明中）。当需要废除某个用户的 JWT 时，只需将用户的版本号递增。在服务器验证 JWT 时，检查 JWT 中的版本号与用户当前的版本号是否匹配，若不匹配，则视为无效。 优点：无需维护黑名单，可以较容易地废除特定用户的所有 JWT 。 缺点：在多用户、多设备情况下，如果一个设备上的 JWT 被废除，所有设备上的 JWT 都会失效。需要在服务器端存储和管理用户的版本号。 具体实现 引入 JWT 相关依赖 将 JWT 数字签名的相关部分放入Properties文件中以备引用 书写 JWT 工具类的生成方法和解析方法 生成JWT令牌 具体思路\n指定签名算法 使用令牌持续时间来计算令牌的过期时间 生成 JWT 令牌函数 Jwts.builder() 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * 创建jwt * 加密算法：HS256 * 私钥使用jwtProperties中的userSecretKey * @param claims 载荷 * @return jwt */ public String createJwt(Map\u0026lt;String, Object\u0026gt;claims) { String userSecretKey = jwtProperties.getUserSecretKey(); //自定义密钥 long userTtl = jwtProperties.getUserTtl(); //令牌持续时间 SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; //指定签名算法 long nowMillis = System.currentTimeMillis(); Date exp = new Date(nowMillis + userTtl); //令牌过期时间 JwtBuilder builder = Jwts.builder() //生成JWT令牌 .setClaims(claims) //设置载荷 .signWith(signatureAlgorithm, userSecretKey.getBytes()) //设置数字签名（签名算法，过期时间） .setExpiration(exp); //设置过期时间 return builder.compact(); } 解析JWT令牌 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * 解密jwt * @param token jwt * @return jwt中的数据 */ public Claims parseJwt(String token) { //获取jwtProperties中的userSecretKey String userSecretKey = jwtProperties.getUserSecretKey(); return Jwts.parser() .setSigningKey(userSecretKey.getBytes(StandardCharsets.UTF_8)) .parseClaimsJws(token) .getBody(); } JWT身份认证方案 在基于 JWT 进行身份验证的的应用程序中，服务器通过 Payload、Header 和 Secret(密钥)创建 JWT 并将 JWT 发送给客户端。客户端接收到 JWT 之后，会将其保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。\n![ JWT 身份验证示意图](jwt-authentication process.png)\n用户向服务器发送用户名、密码以及验证码用于登陆系统。\n如果用户用户名、密码以及验证码校验正确的话，服务端会返回已经签名的 Token，也就是 JWT。\n用户以后每次向后端发请求都在 Header 中带上这个 JWT 。\n服务端检查 JWT 并从中获取用户相关信息。\n登录校验 过滤器（Filter） 参见博客Filter\n拦截器（interceptor） 参见博客Interceptor\n","date":"2024-11-07T13:11:16+08:00","permalink":"https://Tyritic.github.io/p/%E7%99%BB%E5%BD%95%E9%89%B4%E6%9D%83%E6%9C%BA%E5%88%B6/","title":"登录鉴权机制"},{"content":"配置文件的种类 SpringBoot提供了多种属性配置方式\napplication.properties\n1 2 server.port=8080 server.address=127.0.0.1 application.yml\n1 2 3 server: port:8080 address:127.0.0.1 application.yaml\n1 2 3 server: port:8080 address:127.0.0.1 配置文件优先级 优先级从高到低：properties\u0026gt;yml\u0026gt;yaml\n外部配置文件的优先级（从低到高）\nclasspath（resource文件夹） classpath根config 项目根目录（对于存在继承/聚合关系的maven项目项目根目录是父工程的根目录） 项目根目录/config 直接子目录/config 多配置文件的加载 Profile意思是配置，不同环境可能需要不同的配置需要\nSpringBoot框架提供了多profile的管理功能，我们可以使用profile文件来区分不同环境的配置\n基本语法 如果需要创建自定义的yml文件时，可以用application-{profile}.yml的命名方式\n切换不同环境的yml文件时在application.yml中配置\n1 2 3 spring: profiles: active: profile yml文件语法 基本语法 大小写敏感 数值前边必须有空格，作为分隔符 使用缩进表示层级关系，缩进时，不允许使用Tab键，只能用空格(idea中会自动将Tab转换为空格) 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 #表示注释，从这个字符一直到行尾，都会被解析器忽略 数据格式 对象/Map集合\n1 2 3 4 user: name: zhangsan age: 18 password:123456 数组/List集合\n1 2 3 4 hobby: -java -game -sport 参数配置化 利用注解进行参数配置化 @Value 注解通常用于外部配置的属性注入，具体用法为: @Value(\u0026quot;${配置文件中的key}\u0026quot;)\n示例代码\n1 2 3 4 aliyun.oss.endpoint=https://oss-cn-hangzhou.aliyuncs.com aliyun.oss.accessKeyId=LTAI4GCHlvX6DKqJWxdбnEuW aliyun.oss.accessKeySecret=yBshYweHOpqDuhCArrVHwIiBKPYqSL aliyun.oss.bucketName=web-tlias 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Component pubiic class AliossUti1s{ @Value(\u0026#34;${aliyun.oss.endpoint}\u0026#34;) private string endpoint; @Value(\u0026#34;${aliyun.oss.accessKeyId}\u0026#34;) private string accesskeyId; @Value(\u0026#34;${aliyun.oss.accessKeySecret}\u0026#34;) private String accessKeySecret; @Value (\u0026#34;${aliyun.oss.bucketName } \u0026#34;) private String bucketName } 使用自定义配置类进行参数配置化 自定义properties文件使用@Component注册为Bean对象，使用 @ConfigurationProperties 注解批量的将yml配置文件的属性和Bean对象属性绑定，@ConfigurationProperties 的prefix属性指定application.yml的子节点，该节点中的子节点将自动和属性进行绑定\n示例代码\n1 2 3 4 5 6 7 8 9 10 @Data @Component @ConfigurationProperties(prefix = \u0026#34;operator.aliyun.oss\u0026#34;) public class AliyunOSSProperties { String endpoint; String accessKeyId; String accessKeySecret; String bucketName; String region; } @ConfigurationProperties 支持jsr-300数据校验使用 @Validate\n提示\n​\tjsr-300数据校验\n@Null：被注释的元素必须为 null @NotNull：被注释的元素必须不为nu11 @AssertTrue：被注释的元素必须为true @AssertFalse：被注释的元素必须为false @Min(value)：被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value)：被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value)：被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value)：被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max，min)：被注释的元素的大小必须在指定的范围内 @Digits (integer,fraction)：被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past：被注释的元素必须是一个过去的日期 @Future：被注释的元素必须是一个未来的日期 ","date":"2024-11-07T10:19:39+08:00","permalink":"https://Tyritic.github.io/p/springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","title":"SpringBoot配置文件"},{"content":"简介 文件上传，是指将本地图片、视频、音频等文件上传到服务器，供其他用户浏览或下载的过程。\n实现要点 前端页面 表单项 type=“file” 表单提交方式 post 表单的enctype属性 multipart/form-data 后端controller类 使用MultipartFile接收文件 实现方式 上传到本地 常见方法\n1 2 3 4 5 - String getOriginalFilename(); //获取原始文件名 - void transferTo(File dest); //将接牧的文件转存到磁盘文件中 - long getSize(); //获取文件的大小，单位:字节 - byte[] getBytes();//获取文件内容的字节数组 - InputStream getinputStream(); //获取接收到的文件内容的输入流 具体实现\n1 2 3 4 5 6 7 8 9 10 11 12 @RestController public class UploadController { @PostMapping(\u0026#34;/upload\u0026#34;) public Result upload(MultipartFile image) throws IOException //获取原始文件名 String originalFilename =image.getOriginalFilename(): //构建新的文件名 String newfileName = UUID.,randomUUID.toString()+originalFilename.substring(originalFilename.lastindexOf(\u0026#34;.\u0026#34;)); //将文件保存在服务器端 E:/images目景下 image.transferTo(new File(\u0026#34;E:/images/\u0026#34;+newFileName)): return Result,success(); } 提示\n在SpringBoot中，文件上传，默认单个文件允许最大大小为1M。如果需要上传大文件，可以进行在application.yml如下配置:\n1 2 3 4 spring: servlet: multipart.max-file-size=10MB #配置单个文件最大上传大小 max-request-size=100MB #配置单个请求最大上传大小(一次请求可以上传多个文件) 阿里云OSS存储 基本概念\nBucket：存储空间是用户用于存储对象(0bject，就是文件)的容器，所有的对象都必须隶属于某个存储空间。 SDK:Software Development Kit 的缩写，软件开发工具包，包括辅助软件开发的依赖(jar包)、代码示例等，都可以叫做SDK。 具体实现\n创建bucket并获取AccessKey\n在pom.xml中引入相关依赖\n将aliyunOSS服务所需的相关参数写入配置文件application.yml中，并专门建立一个properties配置文件\n将相关方法写入工具类中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 public String upload(MultipartFile file) throws ClientException { if(file==null||file.isEmpty()){ return null; } String endpoint = aliyunOSSProperties.getEndpoint(); String bucketName = aliyunOSSProperties.getBucketName(); String region = aliyunOSSProperties.getRegion(); String accessKeyId = aliyunOSSProperties.getAccessKeyId(); String accessKeySecret = aliyunOSSProperties.getAccessKeySecret(); // 创建OSSClient实例 ClientBuilderConfiguration clientBuilderConfiguration = new ClientBuilderConfiguration(); CredentialsProvider defaultCredentialProvider = new DefaultCredentialProvider(accessKeyId, accessKeySecret); OSS ossClient= OSSClientBuilder.create() .endpoint(endpoint) .credentialsProvider(defaultCredentialProvider) .clientConfiguration(clientBuilderConfiguration) .region(region) .build(); String originalFilename = file.getOriginalFilename(); String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(\u0026#34;.\u0026#34;)); try { InputStream fileInputStream = file.getInputStream(); ossClient.putObject(bucketName, fileName, fileInputStream); String url=endpoint.split(\u0026#34;//\u0026#34;)[0]+\u0026#34;/\u0026#34;+bucketName+\u0026#34;.\u0026#34;+endpoint.split(\u0026#34;//\u0026#34;)[1]+\u0026#34;/\u0026#34;+fileName; return url; } catch (Exception e) { log.error(\u0026#34;上传文件失败\u0026#34;, e); throw new ClientException(\u0026#34;上传文件失败\u0026#34;); } finally { ossClient.shutdown(); } } public void deleteExhibitImage(String d_url) { String endpoint = aliyunOSSProperties.getEndpoint(); String bucketName = aliyunOSSProperties.getBucketName(); String region = aliyunOSSProperties.getRegion(); String accessKeyId = aliyunOSSProperties.getAccessKeyId(); String accessKeySecret = aliyunOSSProperties.getAccessKeySecret(); String fileName=d_url.substring(d_url.lastIndexOf(\u0026#34;/\u0026#34;)+1);//从url中获取bucket中的文件名 // 创建OSSClient实例 ClientBuilderConfiguration clientBuilderConfiguration = new ClientBuilderConfiguration(); CredentialsProvider defaultCredentialProvider = new DefaultCredentialProvider(accessKeyId, accessKeySecret); OSS ossClient= OSSClientBuilder.create() .endpoint(endpoint) .credentialsProvider(defaultCredentialProvider) .clientConfiguration(clientBuilderConfiguration) .region(region) .build(); try { ossClient.deleteObject(bucketName, fileName); } catch (Exception e) { log.error(\u0026#34;删除文件失败\u0026#34;, e); } finally { ossClient.shutdown(); } } ","date":"2024-11-07T09:52:26+08:00","permalink":"https://Tyritic.github.io/p/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","title":"文件上传"},{"content":"BigInteger类和BigDecimal类 BigInteger类支持任意精度的整数，表示任何大小的整数\nBigDecimal类支持任意长度的小数\nBigInteger类和BigDecimal都是不可变类，一旦创建其值无法更改，只要产生计算操作就会产生新的对象\nBigInteger创建方法 通过有参构造器 BigInteger(String val) BigInteger(byte[] val) 通过valueOf()静态方法 BigInteger.valueOf(long val)\n1 2 3 4 5 6 7 8 9 10 import java.math.BigInteger; public class BigIntegerExample { public static void main(String[] args) { // 从 long 值创建 BigInteger 对象 BigInteger bigInt2 = BigInteger.valueOf(123456789L); System.out.println(bigInt2); // 输出：123456789 } } BigDecimal创建方法 通过有参构造器 类 创建方式 示例 注意事项 BigDecimal new BigDecimal(String val) new BigDecimal(\u0026quot;123.456789\u0026quot;) 推荐通过字符串创建，精度不会丢失。 new BigDecimal(double val) new BigDecimal(123.456) 精度可能丢失，尽量避免使用。 new BigDecimal(long val) new BigDecimal(123) 使用 long 值创建。 new BigDecimal(int val) new BigDecimal(123) 使用 int 值创建。 new BigDecimal(byte[] val) new BigDecimal(byteArray) 用字节数组创建。 通过静态方法valueOf() 1 2 3 4 5 6 7 8 9 import java.math.BigDecimal; public class BigDecimalExample { public static void main(String[] args) { // 从 long 值创建 BigDecimal 对象 BigDecimal decimal1 = BigDecimal.valueOf(123456789L); System.out.println(decimal1); // 输出：123456789 } } 创建 BigDecimal 时优先使用字符串类型的构造方法，以避免 double 转换时精度丢失。\n计算方法 操作 BigInteger 方法 BigDecimal 方法 加法 add() add() 减法 subtract() subtract() 乘法 multiply() multiply() 除法 divide() divide() 取余 mod() remainder() 幂运算 pow() pow() 比较 compareTo() compareTo() 相反数 negate() negate() BigDecimal保证精度不丢失的机制 BigDecimal 能够保证精度，是因为它使用了任意精度的整数表示法，而不是浮动的二进制表示。\nBigDecimal 内部使用两个字段存储数字，一个是整数部分 intVal，另一个是用来表示小数点的位置 scale，避免了浮点数转化过程中可能的精度丢失。\n计算时通过整数计算，再结合小数点位置和设置的精度与舍入行为，控制结果精度，避免了由默认浮点数舍入导致的误差。\n源码展示\n1 2 3 4 5 6 7 8 9 10 public class BigDecimal extends Number implements Comparable\u0026lt;BigDecimal\u0026gt; { private final BigInteger intVal; // 存储整数部分 private final int scale; // 存储小数点的位置 public BigDecimal(String val) { // 使用 BigInteger 来表示数值 intVal = new BigInteger(val.replace(\u0026#34;.\u0026#34;, \u0026#34;\u0026#34;)); scale = val.contains(\u0026#34;.\u0026#34;) ? val.length() - val.indexOf(\u0026#34;.\u0026#34;) - 1 : 0; } } ","date":"2024-11-06T23:18:11+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/","title":"Java中的高精度运算"},{"content":"包装类简介 包装类将基本数据类型包装成对象，用于集合操作等操作\n常见包装类 基本数据类型与包装类对照表： 基本数据类型 包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 创建方法 通过有参构造器创建 包装类不存在无参构造方法，\n通过valueOf()创建 一个常用静态方法，它用于将给定的基本数据类型或字符串转换为对应的包装类对象\n1 2 3 4 5 6 7 8 9 // 语法格式：包装类名.valueOf() public class ValueOfExample { public static void main(String[] args) { String str = \u0026#34;100\u0026#34;; Integer integerValue = Integer.valueOf(str); // 将字符串 \u0026#34;100\u0026#34; 转换为 Integer int i = 200; Integer integerValue = Integer.valueOf(i); // 将 int 200 转换为 Integer } } 自动装箱和自动拆箱 自动装箱（Autoboxing）：指的是 Java 编译器自动将基本数据类型转换为它们对应的包装类型。比如，将 int 转换为 Integer。\n自动拆箱（Unboxing）：指的是 Java 编译器自动将包装类型转换为基本数据类型。比如，将 Integer 转换为 int。\n主要作用：\n它在 Java 5 中引入，主要是为了提高代码的可读性，减少手动转换操作，简化了代码编写，开发者可以更方便地在基本类型和包装类型之间进行转换。 常见于：\n集合类如 List\u0026lt;Integer\u0026gt; 中无法存储基本类型，通过自动装箱，可以将 int 转换为 Integer 存入集合。\n1 2 3 4 int i = 99; //声明基础数据类型int变量 ArrayList list = new ArrayList(); list.add(i); //触发自动装箱，int类型自动转换成 Integer System.out.println(list); 自动装箱和拆箱经常在算术运算中出现，尤其是包装类型参与运算时。\n计算方法 Java 允许包装类和基本数据类型之间的自动转换，因此你可以直接对包装类对象进行算术运算，Java 会自动进行拆箱和装箱。\n缓存机制 包装类型中的 Byte、Short、Integer 和 Long 对某些范围内的值（例如 Integer，Long,Byte 缓存 -128 到 127）会使用对象缓存来提升性能。因此，同一数值的包装类型对象可能是同一个实例。\n在 -128 到 127 范围内的 Integer 对象会被缓存和复用。\n包装类的存在意义 存在意义就是将基本数据类型封装成对象\n对象封装的好处\n可以把属性也就是数据跟处理这些数据的方法结合在一起，比如Integer就有parseInt()等方法来专门处理int型相关的数据。 Java中绝大部分方法或类都是用来处理类类型对象的，如ArrayList集合类就只能以类作为他的存储对象， 在Java中，泛型只能使用引用类型，而不能使用基本类型。 包装类和基本数据类型的对比 基本类型和引用类型：基本数据类型是Java中最基本的数据类型，它们是预定义的，不需要实例化就可以使用。而引用类型则需要通过实例化对象来使用。这意味着，使用基本数据类型来存储一个整数时，不需要任何额外的内存分配，而使用包装类时，必须为对象分配内存。在性能方面，基本数据类型的操作通常比相应的引用类型快。 自动装箱和拆箱：包装可以实现自动装箱和拆箱。自动装箱是指将基本类型转化为相应的包装类类型，而自动拆箱则是将包装类类型转化为相应的基本类型。这使得Java程序员更加方便地进行数据类型转换。 空指针异常：另外，int变量可以直接赋值为0，而Integer变量必须通过实例化对象来赋值。如果对一个未经初始化的Integer变量进行操作，就会出现空指针异常。这是因为它被赋予了null值，而null值是无法进行自动拆箱的。 ","date":"2024-11-06T22:46:11+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB/","title":"Java中的包装类"},{"content":"在Mapper接口中基于注解书写sql语句 设置动态参数 1 #{参数名} 如果mapper接口中的方法参数名和mapper.xml中sql语句中的字段名一致，spring会自动进行封装\n设置mappper接口方法参数名和mapper.xml中的sql语句中的字段一致 如果mapper接口中的方法参数名和mapper.xml中sql语句中的字段名不一致，需要通过注解@Param来指定对应关系\n1 @Param(Sql语句中的字段名) 方法参数名 示例\n1 User selectUser(@param(“name”)String personName); 1 2 3 \u0026lt;select id=\u0026#34; selectUser\u0026#34; resultMap=\u0026#34;BaseResultMap\u0026#34;\u0026gt; select * from user where user_name = #{name} \u0026lt;/select\u0026gt; 删除操作 sql语句 1 delete from emp where id=#{id} 接口方法 1 2 3 4 5 @Mapper public interface EmpMapper //根据ID删除数据 @Delete(\u0026#34;delete from emp where id=#{id}\u0026#34;) public void delete(Integer id): 添加操作 sql语句 1 2 insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) values(#{username), #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptld}, #{createTime}, #{updateTime} 接口方法 1 2 3 4 5 @Mapper public interface EmpMapper //根据ID添加数据 @Insert(\u0026#34;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time)\u0026#34; +\u0026#34;values(#{username), #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptld}, #{createTime}, #{updateTime}\u0026#34;) public void insert(Emp emp); 主键返回 描述：在数据添加成功后，需要获取插入数据库数据的主键。\n实现：在@Insert上添加注解 @Options(keyProperty = \u0026ldquo;id\u0026rdquo;, useGeneratedKeys = true) 会自动将生成的主键值赋给id属性\n更新操作 sql语句 1 update emp set username=#{username),name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_Id=#{deptld}, create_time=#{createTime}, update_time=#{updateTime} where id=#{id} 接口方法 1 2 3 4 @Mapper public interface EmpMapper @Update(\u0026#34;update emp set username=#{username), name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_Id=#{deptld}, create_time=#{createTime}, update_time=#{updateTime} where id=#{id}\u0026#34;) public void update(Emp emp); 提示\n数据封装\n实体类属性名和数据库表查询返回的字段名一致，mybatis会自动封装。 如果实体类属性名 和 数据库表查询返回的字段名不一致，不能自动封装。 解决方案\n方案一：给字段起别名与实体类属性名相同\n方案二：使用@Results注解手动指定映射，@Result封装映射\ncolumn属性指定数据库字段 property属性指定实体类属性 1 2 3 @Results({ @Result(column=\u0026#34;数据库字段\u0026#34;,property=\u0026#34;实体类属性\u0026#34;) }) 查询操作 sql语句 1 2 3 select * from emp where name like \u0026#39;%李%\u0026#39; 接口方法 1 2 3 4 @Mapper public interface EmpMapper @Select(\u0026#34;select * from emp where name like \u0026#39;%#{name}%\u0026#39;\u0026#34;) public List\u0026lt;User\u0026gt; list(String name) 警告\n在模糊匹配中%#{name}%不建议使用（不是预编译sql语句）\n可以使用concat(‘%\u0026rsquo;,\u0026rsquo;#{name}\u0026rsquo;,\u0026rsquo;%')\n在Mapper.xml中基于映射文件属性sql语句 使用规范 XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下(同包同名)。\nXML映射文件的namespace属性为Mapper接口全限定名一致。\nXML映射文件中sql语句的id与Mapper 接口中的方法名一致，并保持返回类型一致。\n编写sql语句的格式\n1 2 3 \u0026lt;操作名 id=\u0026#34;函数名\u0026#34; resultType=\u0026#34;单条记录的实体类全类名\u0026#34;\u0026gt; sql语句 \u0026lt;/操作名\u0026gt; 提示\n只有select操作需要resultType\n动态SQL语句 \u0026lt; if \u0026gt;标签 ​\t描述：用于判断条件是否成立。使用test属性进行条件判断，如果条件为true，则拼接SQL\n​\t示例代码\n1 2 3 4 5 6 7 8 \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.itheima.pojo.Emp\u0026#34;\u0026gt; select * from omp where \u0026lt;if test=\u0026#34;name !=null\u0026#34;\u0026gt; name like concat(\u0026#34;%\u0026#34;,#{name},\u0026#34;%\u0026#34;) \u0026lt;/if\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;where\u0026gt;标签 ​\t描述：动态生成where子句，若子标签的条件都不满足则不会生成where子句，同时会删除子句开头的条件运算符\n​\t示例代码\n1 2 3 4 5 6 7 8 9 \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.itheima.pojo.Emp\u0026#34;\u0026gt; select * from emp \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name !=null\u0026#34;\u0026gt; name like concat(\u0026#34;%\u0026#34;,#{name},\u0026#34;%\u0026#34;) \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;set\u0026gt;标签 描述：动态生成set子句\n示例代码\n1 2 3 4 5 6 7 8 9 \u0026lt;update id=\u0026#34;update\u0026#34;\u0026gt; update emp \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;name !=null\u0026#34;\u0026gt; name=#{name} \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id=#{id} \u0026lt;/update\u0026gt; \u0026lt;foreach\u0026gt;标签 描述：用于遍历元素\n属性\ncollection：遍历的集合 item：集合中的元素 separator：分隔符 open：遍历开始前的SQL语句 close：遍历结束后的SQL语句 示例代码\n1 2 3 4 5 6 \u0026lt;delete id=\u0026#34;delete\u0026#34;\u0026gt; delete from emp where id in \u0026lt;foreach collection=\u0026#34;遍历的集合\u0026#34;,item=\u0026#34;集合中的元素\u0026#34;,separator=\u0026#34;分隔符\u0026#34;,open=\u0026#34;(\u0026#34;,close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; \u0026lt;sql\u0026gt;标签和\u0026lt;include\u0026gt;标签 \u0026lt;sql\u0026gt;:定义可重用的 SQL片段。 \u0026lt;include\u0026gt;:通过属性refid，指定包含的sql片段。 示例代码\n1 2 3 4 5 6 7 8 9 10 \u0026lt;sql id=\u0026#34;commonSelect\u0026#34;\u0026gt; select id, username from emp \u0026lt;/sql\u0026gt; \u0026lt;select id=\u0026#34;getById\u0026#34; resultTypea\u0026#34;com.itheima.pojo.Emp\u0026#34;\u0026gt; \u0026lt;include refid=\u0026#34;commonselect\u0026#34;/\u0026gt; where id = #{id} \u0026lt;/select\u0026gt; \u0026lt; trim \u0026gt;标签 prefix：将trim标签中内容前面添加指定内容 suffix：将trim标签中内容前面添加指定内容 prefixOverride：将trim标签中内容前面去除指定内容 suffixOverride：将trim标签中内容后面去除指定内容 \u0026lt;choose\u0026gt;,\u0026lt;when\u0026gt;,\u0026lt;otherwise\u0026gt; 相当于switch，if，else\n1 2 3 4 5 6 \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;满足的条件\u0026#34;\u0026gt; \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; 字段名和属性名的映射关系 通常情况下当数据表中的字段名和实体类的属性名对应相等时，MyBatis会将查询出的字段数据自动赋值给实体类\n当字段名和属性名不一致时 在sql语句中给字段名起别名使得字段名与属性名相同\n通过resultMap解决，其他的sql语句设置resultMap属性来确定映射关系\n1 2 3 4 \u0026lt;resultMap id=\u0026#34;resultMap_name\u0026#34;,type=\u0026#34;实体类\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;属性名\u0026#34;,column=\u0026#34;主键字段名\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;属性名\u0026#34;,column=\u0026#34;其他字段名\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultMap\u0026gt; 多对一的映射关系 示例：查询员工及其对应部门信息时，将员工的did和dname合并为一个dept对象，作为emp对象的成员变量\n通过resultMap中的级联属性解决，其他的sql语句设置resultMap属性来确定映射关系\nresultMap使用级联属性对应成员对象名\n1 2 3 4 5 6 7 8 9 \u0026lt;resultMap id=\u0026#34;empAndDeptResultMapone\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34;column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;dept.did\u0026#34; column=\u0026#34;did\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;dept.deptName\u0026#34; column=\u0026#34;dept_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultMap\u0026gt; 通过resultMap中的association标签解决，其他的sql语句设置resultMap属性来确定映射关系\nassociation具有两个属性，property对应实体类中的成员对象名，javaType对应该成员对象的java类型\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;resultMap id=\u0026#34;empAndDeptResultMapone\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34;column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;association property=\u0026#34;dept\u0026#34; javaType=\u0026#34;Dept\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;did\u0026#34; column=\u0026#34;did\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;dept.deptName\u0026#34; column=\u0026#34;dept_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; 一对多的映射方式 示例：查询部门及其下属员工时，一个部门作为实体类具有一个员工对象的集合作为成员变量\n通过resultMap的collection标签解决，其他的sql语句设置resultMap属性来确定映射关系\ncollection具有两个属性，property对应实体类中的成员对象名，ofType对应该成员对象的java类型\n1 2 3 4 5 6 7 8 9 \u0026lt;resultMap id=\u0026#34;empAndDeptResultMapone\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;collection property=\u0026#34;成员变量名\u0026#34; ofType=\u0026#34;集合内的泛型\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34;column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; ","date":"2024-11-06T17:26:14+08:00","permalink":"https://Tyritic.github.io/p/mybatis%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","title":"MyBatis基本使用"},{"content":"Lombok简介 Lombok是一个实用的java类库，能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法 并可以自动化生成日志变量，简化iava开发\n常见注解 注解 作用 @Getter/@Setter 为所有的属性提供get/set方法 @ToString 会给类自动生成易阅读的toString 方法 @EqualsAndHashCode 根据类所拥有的非静态字段自动重写 equals方法和 hashcode 方法 @Data 提供了更综合的生成代码功能(@Getter+@Setter+@ToString+@EqualsAndHashCode) @NoArgsConstructor 为实体类生成无参的构造器方法 @AllArgsConstructor 为实体类生成除了static修饰的字段之外带有各参数的构造器方法 ","date":"2024-11-06T17:19:27+08:00","permalink":"https://Tyritic.github.io/p/lombok/","title":"Lombok"},{"content":"什么是MyBatis MyBatis是一款优秀的 持久层框架，用于简化JDBC的开发。 MyBatis本是 Apache的一个开源项目iBatis,2010年这个项目由apache迁移到了google code，并且改名为MyBatis。2013年11月迁移到Github。 官网:https://mybatis.org/mybatis-3/zh/index.html MyBatis的配置 在pom.xml中配置相关依赖\n在application.yml中的spring.database属性下配置相关数据库连接信息\n指定驱动类名称：driver-class-name 数据库连接的url：url 连接数据库的用户名 连接数据库的密码 编写sql语句\n在mapper文件夹下编写接口，用@Mapper修饰\n在每一个函数上根据操作名使用对应的注解修饰sql语句\n1 2 3 4 5 @Mapper public interface UserMapper{ @Select(\u0026#34;select * from user\u0026#34;) public List\u0026lt;User\u0026gt;list(); } 或者在resource文件夹下创建和接口全名（包名.接口名）一致的xml，在xml文件中根据具体的接口函数编写对应的sql语句\n1 2 3 4 5 6 7 8 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34; \u0026gt; \u0026lt;mapper namespace=\u0026#34;org.example.operator.mapper.userMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;list\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 数据库连接池 什么是数据连接池 数据库连接池是个容器，负责分配、管理数据库连接(Connection) 它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个 释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏 优势 资源重用 提升系统响应速度 避免数据库连接遗漏 常见产品 C3PO DBCP Druid Hikari(springboat默认) ","date":"2024-11-06T16:50:26+08:00","permalink":"https://Tyritic.github.io/p/mybatis%E7%AE%80%E4%BB%8B/","title":"MyBatis简介"},{"content":"基本概念 索引(index)：帮助数据库 高效获取数据的数据结构\n优点\n提高数据查询的效率，降低数据库的I0成本， 通过索引列对数据进行排序，降低数据排序的成本，降低CPU消耗。 缺点\n索引会占用存储空间。 索引大大提高了查询效率，同时却也降低了insert、 update、delete的效率。 索引结构 MySQL数据库支持的索引结构有很多，如:Hash索引、B+Tree索引、Full-Text索引等。我们平常所说的索引，如果没有特别指明，都是指默认的 B+Tree 结构组织的索引。\n索引操作 创建索引\n1 create [unique] index index_name on table_name(字段名,...) 查看索引\n1 show index from table_name 删除索引\n1 drop index index_name on table_name 提示\n主键字段，在建表时，会自动创建主键索引。 添加唯一约束时，数据库实际上会添加唯一索引。 ","date":"2024-11-04T19:18:04+08:00","permalink":"https://Tyritic.github.io/p/mysql%E7%B4%A2%E5%BC%95/","title":"MySQL索引"},{"content":"概念 事务是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作 要么同时成功，要么同时失败。\n提示\nMySQL会立即隐式的提交事务。默认MySQL的事务是自动提交的，\n事务控制语句 开启事务\n1 start transaction； 提交事务\n1 commit; 回滚事务\n1 rollback; 四大特性 原子性（Atomicity）：事务是不可分割的最小单元，要么全部成功，要么全部失败 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态 隔离性（lsolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的 并发事务问题 脏读：一个事务读到另外一个事务还没有提交的数据。 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了幻影”。 事务隔离级别 隔离级别 脏读 不可重复度 幻读 Read uncommitted √ √ √ Read committed × √ √ Repeatable Read(默认) × × √ Serializable × × × 其中 Serializable 数据安全性更好但是性能最差，Read uncommitted反之\n相关SQL语句 查看事务隔离级别 1 select @@transaction isolation; 设置事务隔离级别 1 set [ session | global] transaction isolation level { read uncommitted | read committed | repeatable read | serializable } ","date":"2024-11-04T19:06:51+08:00","permalink":"https://Tyritic.github.io/p/mysql%E4%BA%8B%E5%8A%A1/","title":"MySQL事务"},{"content":"基本查询 基本语法\n1 2 3 4 5 6 7 8 9 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from table_name where condition #条件列表 #以下均为可选选项 group by 聚合函数（字段列表） having 对分组条件的过滤操作 order by 对字段列表的排序 #（ASC升序，DESC降序） limit 分页参数 (起始索引，查询记录数) #索引从0开始，起始索引=（查询页码-1)*每页记录数 条件查询 常见条件运算符 比较运算符 功能 \u0026gt; 大于 \u0026gt;= 大于等于 \u0026lt; 小于 \u0026lt;= 小于等于 \u0026lt;\u0026gt;或!= 不等于 常见逻辑运算符 逻辑运算符 功能 and 或 \u0026amp;\u0026amp; 与 or 或 || 或 not 或 | 非 单表查询 1 2 3 4 5 6 7 8 9 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from table_name where condition #条件列表 #以下均为可选选项 group by 聚合函数（字段列表） having 对分组条件的过滤操作 order by 对字段列表的排序 #（ASC升序，DESC降序） limit 分页参数 (起始索引，查询记录数) #索引从0开始，起始索引=（查询页码-1)*每页记录数 select子句：指定所需的属性，对应关系代数中的投影操作\n默认允许重复的元组\n显式指示使用all关键字\n强制去除重复使用distinct关键字\n查询所有属性可以简写为*\nfrom子句：确定查询中需要访问的表\nwhere子句：指定结果满足的特定条件\n附加的基本操作 更名运算 作用 长命名改为短命名 比较同一个关系的元组 放置位置：位置灵活，无限制 1 2 3 4 5 6 7 8 9 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from old_name as new_name where condition #条件列表 #以下均为可选选项 group by 聚合函数（字段列表） having 对分组条件的过滤操作 order by 对字段列表的排序 #（ASC升序，DESC降序） limit 分页参数 (起始索引，查询记录数) #索引从0开始，起始索引=（查询页码-1)*每页记录数 显示顺序 在查询语句的结尾使用order by子句来决定显示按顺序还是倒序，默认为顺序\ndes：降序 asc：升序（默认） 1 2 3 select columns from table order by column_name [asc | desc]; 字符串相关操作 放置位置\nwhere子句中充当条件 select子句中充当元素 常见操作\n标识一个字符串\n1 \u0026#39;字符串\u0026#39; 模式匹配\nlike关键字\n1 2 3 4 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from table_name as s where s.name like %|_% escape \u0026#39;|\u0026#39; #匹配任何包含_的字符串 百分号%：匹配任意子串\n例如以substring开头：substring%\n匹配任何包含substring的字符串：%substring%\n下划线_：匹配任意字符\n定义转义字符：escape\u0026rsquo;转义字符'\nregexp：正则表达式匹配\n1 2 3 select * from users where name regexp \u0026#39;^张.$\u0026#39;; 字符串串联\nconcat(str1, str2, \u0026hellip;)\n1 2 select concat(first_name, \u0026#39; \u0026#39;, last_name) as full_name from users; str1|| str2\n1 2 select first_name || \u0026#39; \u0026#39; || last_name as full_name from users; concat_ws(separator, str1, str2, \u0026hellip;)：允许指定分隔符\n1 2 select concat_ws(\u0026#39;, \u0026#39;, first_name, last_name) as full_name from users; 大小写以及首尾去除空格\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #转小写 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from table_name as s where s.name =lower(\u0026#39;hEllO world\u0026#39;) #与hello world匹配的字符串 #转大写 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from table_name as s where s.name =upper(\u0026#39;hEllO world\u0026#39;) #与HELLO WORLD匹配的字符串 #去除首尾空格 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from table_name as s where s.name =upper(\u0026#39; hEllO world \u0026#39;) #与hEllO world匹配的字符串 大写：upper(str) 小写：lower(str) 去除空格：trim(str) where子句谓词 between min_value and max_value：说明一个值位于某个范围,大于等于min_value，小于等于max_value\n1 2 3 select columns from table as t where t.age between 10 and 100 #年龄在10岁到100岁 元组比较：元组之间使用字典序进行比较\n1 2 3 select name, course_id from instructor, teaches where (instructor.ID, dept_name) = (teaches.ID, ’Biology’); 集合运算 所有的集合运算默认去除重复，若保留重复则在集合运算符后面加上关键字all\n查找在 2009 年秋季或 2010 年春季开设的课程（使用并运算）\n1 2 3 (select course_id from section where sem = ‘Fall’ and year = 2009) union (select course_id from section where sem = ‘Spring’ and year = 2010) 查找在 2009 年秋季和2010 年春季开设的课程（使用交运算）\n1 2 3 (select course_id from section where sem = ‘Fall’ and year = 2009) intersect (select course_id from section where sem = ‘Spring’ and year = 2010) 查找在 2009 年秋季开课但未在 2010 年春季开课的课程（使用差运算）\n1 2 3 (select course_id from section where sem = ‘Fall’ and year = 2009) except (select course_id from section where sem = ‘Spring’ and year = 2010) 分组查询 基本聚合函数 函数 功能 sum 求和 avg 平均值 count 计数 max 最大值 min 最小值 提示\nnull不参与聚合函数的运算\n使用关键字*指代所有\n可以在聚集表达式中使用关键字distinct修饰被聚合的属性来删除重复的元组如count (distinct id)\ngroup by子句 将聚集函数用于一组元组集上而利用属性进行的分组操作\n1 2 3 4 #正确示范 select dept_name, avg(salary)as avg_salary) from instructor group by dept_name; 提示\nselect子句中的字段为用于分组的字段（group by中的属性，当只有一个聚合函数时可以不存在）和聚合函数（保证select子句中非聚集的属性只能是出现在group by子句）\n1 2 3 4 5 #错误查询，select子句中的非聚合属性ID #没出现在group by子句中 select dept_name, ID, avg(salary) from instructor group by dept_name ; 在默认情况下，系统按照group by子句中指定的列升序排列，但是可以使用order by子句指定新的排列顺序。\nhaving子句 对group by后的分组进行过滤操作\n可以使用聚集函数\n1 2 3 4 5 select course_id,semester,year,sec_id,avg(tot_cred) from takes natural join student where year = 2009 group by course_id,semester,year,sec_id having count(ID)\u0026gt;=2; 提示\nhaving和where的区别\n执行时机不同:where是分组之前进行过滤，不满足where条件，不参与分组;而having是分组之后对结果进行过滤。\n判断条件不同:where不能对聚合函数进行判断，而having可以。\n保证出现在having子句中的非聚集的属性只能出现在group by子句中\n1 2 3 4 5 6 # 错误示范 having子句中非聚集的属性salary # 没有出现在group by中 select department,AVG(salary)AS avg_salary from employees group by department having salary \u0026gt;5000; 查询的执行顺序 根据from子句计算出关系 若出现了where子句则将where子句中的谓词应用到from子句的结果关系上 若出现了group by子句，满足where子句的元组通过group by子句形成分组，若没有group by子句则满足where子句谓词的整个元组集被当成一个分组 若出现了having子句，将被应用到每一个分组，不满足子句谓词的分组将被抛弃 select子句利用剩下的分组产生出查询结果中的元组，在每个分组上应用聚集函数来得到单个结果元组 多表查询 连接查询 笛卡尔积\n描述：输出两个关系中输出所有的元组对（无论在共同属性上的取值是否相同）\n若关系r中属性和关系s中的属性相同则区分命名\n属性名不相同 属性名相同 示例代码：\n1 2 3 4 #隐式笛卡尔积 table a,table b #显式笛卡尔积 table a join table b 内连接\n描述：查询A表和B表相交的部分（有条件的笛卡尔积）\n性质：不保留未匹配元组的连接运算（合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行）\n语法：\n1 2 3 4 5 6 7 8 9 #隐式内连接 select 字段列表 from table a,table b where condition #显式内连接 select 字段列表 from table a join table b on 连接条件 外连接：\n描述：通过在表中创建包含空值元组的方式保留未匹配元组的连接运算\n左外连接：只保留出现在左外连接运算之前（左边）的关系中的元组。 右外连接：只保留出现在右外连接运算之后（右边）的关系中的元组。 全外连接：保留出现在两个关系中的元组。 语法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #左外连接 select 字段列表 from table a left join table b on 连接条件 #右外连接 select 字段列表 from table a right join table b on 连接条件 #mysql不直接支持全外连接,可以通过左外连接和右外连接union操作后实现 select 字段列表 from table a left join table b on 连接条件 union select 字段列表 from table a right join table b on 连接条件 自然连接\n描述：从A表和B表中输出在具有相同名字的所有属性上取值相同的元组对，基于两个表中共同属性的值相等的元组进行合并。\n1 2 3 4 #自然连接 select 字段列表 from table a natural join table b on 连接条件 提示\n自然连接和内连接的区别\n若两张表具有同名的属性，自然连接会删除重复的属性而内连接不会删除而是保留重复的属性\n嵌套子查询 子查询：SQL语句中嵌套select语句\n类别\n标量子查询：子查询返回的结果为单个值 列子查询：子查询返回的结果为一列 行子查询：子查询返回的结果为一行 表子查询：子查询返回的结果为多行多列 子查询的位置\nselect后面：标量子查询（作为所需要的一个字段） from后面：表子查询 where/having（作为条件的一部分）：标量子查询/列子查询/行子查询 with子句 with定义了临时关系，只对with子句所在的查询有效 其中as子句内定义临时关系，后面紧跟查询语句 可以使用多个as对应多个临时关系 1 2 3 4 5 6 7 8 9 10 with it department as( select department,AVG(salary) as avg_salary from employees where department =IT group by department ) select e.name,e.salary,it.avg_salary from employees e join it department it on e.department = it.department where e.salary \u0026gt;it.avg_salary; where子句中的子查询 子查询类型\n行子查询：子查询返回的结果为一行 列子查询：子查询返回的结果为一列 检测集合的成员资格（列子查询）\nin连接字检测元组是否是集合中的成员\n1 2 3 4 5 6 7 #查找 2009 年秋季和 2010 年春季提供的课程 select distinct course_id from section where semester = ’Fall’ and year= 2009 and course_id in (select course_id from section where semester = ’Spring’ and year= 2010); not in连接检测元组是否不是集合中的成员\n1 2 3 4 5 6 7 #查找 2009 年秋季提供的课程，但不在2010 年春季提供的课程 select distinct course_id from section where semester = ’Fall’ and year= 2009 and course_id not in (select course_id from section where semester = ’Spring’ and year= 2010); 空关系测试（行子查询）\nexist结构在作为参数的子查询非空时返回true，not exist在作为参数的子查询为空时返回true\n关系A包含关系B可以写为not exists (B except A)\n1 2 3 4 5 6 7 8 9 10 # 查找所有参加过生物系提供的所有课程的学生。 select distinct S.ID, S.name from student as S where not exists ( (select course_id from course where dept_name = ’Biology’) except (select T.course_id from takes as T where S.ID = T.ID)); 测试重复元组（行子查询）\nunique结构：如果作为参数的子查询结果中没有重复的元组，则返回true\n1 2 3 4 5 6 select T.course_id from course as T where not unique (select R.course_id from section as R where T.course_id= R.course_id and R.year = 2009); 集合的比较（列子查询）\nall:指代集合中的每一个元素\n1 2 3 4 5 6 # 查找薪水大于 Biology 系中所有教员薪水的所有教员的姓名。 select name from instructor where salary \u0026gt; all (select salary from instructor where dept_name = ’Biology’); some：指代集合中的其中一个元素\n1 2 3 4 5 6 # 查找薪水高于 Biology 系中某些（至少一名）讲师的讲师的姓名。 select name from instructor where salary \u0026gt; some (select salary from instructor where dept_name = ’Biology’); 视图 描述 ​\t一种虚拟表，它基于 SQL 查询结果创建。视图并不存储数据，而是动态地从基础表中提取数据。这使得视图像一个窗口，可以用来查看和操作表的数据。\n特点 虚拟表： 视图本身不存储数据，它的内容来自于定义视图时的查询语句。 每次访问视图时，都会动态执行查询以生成视图的数据。 逻辑隔离： 视图是基础表的一种逻辑表示，对视图的操作不会直接修改基础表。 安全性： 通过视图，可以限制用户访问表的部分数据，而不是直接授予表的访问权限。 可简化复杂查询： 视图可以封装复杂的 SQL 查询逻辑，从而简化对数据的访问。 创建过程 ​\t视图关系在概念上包含查询结果中的元组， 但并不进行预计算和存储（数据库系统存储视图的定义本身， 而不存储定义该视图的查询表达式的执行结果）。相反， 数据库系统存储与视图关系相关联的查询表达式。 当视图关系被访问时， 其中的元组是通过计算查询结果而被创建出来的。 从而，视图关系是在需要的时候才被创建的。\n在查询中使用视图 ​\t在任何给定时刻， 视图关系中的元组集是该时刻视图定义中的查询表达式的计算结果。当我们定义一个视图时， 数据库系统存储视图的定义本身， 而不存储定义该视图的查询表达式的执行结果。一旦视图关系出现在查询中，它就被已存储的查询表达式代替。因此， 无论我们何时执行这个查询， 视图关系都被重新计算。\n物化视图 定义：创建一个物理表，其中包含定义视图的查询结果中的所有元组\n如果查询中使用的关系已更新，则物化视图结果将过时，因此需要维护视图，通过在底层关系更新时更新视图\n语法 1 2 3 # 创建视图（可以通过其他视图进行创建） create view view_name as \u0026lt;查询表达式\u0026gt; ","date":"2024-11-04T15:07:25+08:00","permalink":"https://Tyritic.github.io/p/mysql%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C/","title":"MySQL表数据查询操作"},{"content":"插入元组 指定字段添加元组\n1 insert into table_name (字段1,子段2,...子段n) values(值1,..值n); 全部字段添加元组\n1 insert into table_name values(值1,值2,...值n); 批量添加指定子段的元组\n1 insert into table_name (子段1,子段2,...子段n) values(值1,...值n),..(值1,...值n); 全部数据批量添加\n1 insert into table_name values(值1,...值n),..(值1,...值n); 更新元组 更新符合指定条件的元组\n1 update table_name set 字段1=值1,..字段n=值n [where condition] 删除元组 删除表中的元组但是不删除表（当不存在条件时为删除所有元组\n1 delete from table_name [where condition] 删除表中的所有元组但是保留表结构（同时按照原来的建表语句重新建立表）\n1 truncate table table_name ","date":"2024-11-04T14:57:14+08:00","permalink":"https://Tyritic.github.io/p/mysql%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/","title":"MySQL表数据操作"},{"content":"创建表结构 代码结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 创建一个新的表 create table table_name( 字段1 字段类型[约束] [comment \u0026#39;关于字段的描述\u0026#39;], ... 字段n 字段类型[约束] [comment \u0026#39;关于字段的描述\u0026#39;] \u0026lt;完整性约束\u0026gt;, ... \u0026lt;完整性约束\u0026gt; )[comment 关于表的描述] #创建与现有的某个表的模式相同的表 create table new_table like old_name #将查询结果保存为一张表,默认插入数据 create table new_table as \u0026lt;查询表达式\u0026gt;; 约束 概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据\n目的：保证数据库中数据的正确性、有效性和完整性。\n常见约束参考\n约束 描述 关键字 非空约束 限制该字段不能为null not null 唯一约束 保证该字段的所有数据都是唯一，不存在重复 unique 主键约束 主键是一个元组的唯一标识，要求非空且唯一 primary key 默认约束 保存数据时要是未指定该字段值则存入默认值 default 谓词约束 保证所有数据都满足条件谓词 check 外键约束 通过外键建立两张表的联系，保证数据的一致性和完整性 foreign key 示例代码\n1 2 3 4 5 6 7 8 9 10 create table student (ID varchar (5) comment[\u0026#39;唯一标识符\u0026#39;], name varchar (20) not null,unique dept_name varchar (20), tot_cred numeric (3,0) check (tot_cred \u0026gt;= 0), age int default 18 #默认约束 primary key (ID), #主键约束 foreign key (dept_name) references department(dept_name) #外键约束 on delete set null) #违反约束的方法：置为null unique(name,age); #多列唯一约束 数据类型 数值类型 类型 大小（byte) 有符号范围 无符号范围 描述 备注 tinyint 1 (-128,127) (0,255) 小整数 smallint 2 (-32768,32767) (0,65535) 大整数 mediumint 3 (-8388608,8388607) (0,1677215) 大整数 int 4 (-2^31 ,2^31-1) (0,2^32-1) 大整数 bigint 8 (-2^63 ,2^63-1) (0,2^64-1) 极大整数 float 4 单精度浮点值 float(5,2)，其中5为数字长度，2为小数位数 double 8 双精度浮点值 double(5,2)，其中5为数字长度，2为小数位数 decimal 小数值（精度最高） 字符类型 类型 大小（byte） 描述 备注 char 0~255 定长字符串 char(10),最多只能存10个字符，不足10个字符也占有10个字符空间 varchar 0~63315 变长字符串 varchar(10),最多只能存10个字符，不足10个字符按实际长度存储 tinyblob 0~255 不超过255个字符的二进制数据 tinytext 0~255 短文本字符串 blob 0~65535 二进制形式长文本数据 text 0~65535 长文本数据 mediumblob 0~16777215 二进制形式中等长文本数据 mediumtext 0~16777215 中等长度文本数据 longblob 0~4294967295 二进制形式的极大文本数据 longtext 0~4294967295 极大文本数据 日期类型 类型 大小（byte） 格式 范围 描述 date 3 YYYY-MM-DD 1000-01-01到 9999-12-31 日期值 time 3 HH:MM:SS -838:59:59 到 838:59:59 时间值或持续时间 year 1 YYYY 1901到2155 年份值 datetime 8 YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00到 9999-12-31 23:59:59 混合日期和时间值 timestamp 4 YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00到 9999-12-31 23:59:59 混合日期和时间值，时间戳 时间域的提取\n1 2 3 extract(unit from date) ## unit为所提取的时间域 ## date为字符串 字符串转时间类型\n1 cast(\u0026#39;2024-12-21\u0026#39; as date) 大对象类型 大对象类型\n字符数据：clob\n二进制数据：blob\n查询表结构 查询当前数据库的所有表\n1 show tables 查询指定表的表结构\n1 desc table_name 查询建表语句\n1 show create table table_name 修改表结构 添加字段\n1 2 alter table table_name add 字段名 字段类型（长度） [comment \u0026#39;关于字段的描述\u0026#39;] [约束]; 修改字段类型\n1 2 alter table table_name modify 字段名 新字段类型（长度）; 修改字段名和字段类型\n1 2 alter table table_name change 旧字段名 新字段名 新类型（长度）[comment \u0026#39;关于字段的描述\u0026#39;] [约束]; 删除字段\n1 2 3 4 5 alter table table_name drop column 字段名; #column可以不填写 alter table table_name drop 字段名; 修改表名\n1 rename table 旧表名 to 新表名; 删除表结构 删除表中所有元组以及表的结构\n1 drop table 表名; ","date":"2024-11-03T18:46:17+08:00","permalink":"https://Tyritic.github.io/p/mysql%E8%A1%A8%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C/","title":"MySQL表结构操作"},{"content":"切换数据库 1 use database_name; 创建数据库 1 create database[if not exists] database_name; 查询数据库 查询所有的数据库\n1 show databases; 查询当前正在使用的数据库\n1 select database(); 删除数据库 1 drop database [if exist] database_name 授权机制 权限类型 数据库各部分的授权形式 Read：允许读取数据，但不允许修改数据。 Insert - 允许插入新数据，但不允许修改现有数据。 Update：允许修改数据，但不允许删除数据。 Delete：允许删除数据。 修改数据库架构的授权形式 Index - 允许创建和删除索引。 Resource - 允许创建新关系。 Alteration - 允许在关系中添加或删除属性。 Drop - 允许删除关系。 用户与角色 用户是指可以连接到数据库并执行操作的实体。每个用户有一个唯一的用户名和密码，通过这些凭证来认证和识别该用户。用户具有访问数据库和执行某些操作的权限。通常情况下，用户是直接与权限绑定的。\n每个用户可以拥有一个或多个权限，这些权限控制用户能在数据库中执行哪些操作（如查询、插入、更新、删除等）。 用户可以是数据库的实际操作实体，如开发人员、管理员、应用程序等。 创建用户\n1 2 3 4 create user \u0026#39;username\u0026#39;@\u0026#39;host\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; # username：用户名 # host：主机名，\u0026#39;%\u0026#39; 代表任何主机 # password：密码 角色是一种逻辑上的权限集合，它允许将多个权限组合在一起并赋予用户。角色是权限的集合，用户可以通过赋予某个角色来间接获得角色所包含的权限。这样，通过角色管理权限比直接授予权限给用户更简洁和灵活，尤其是当多个用户需要相同权限时。\n角色是一个权限集合，可以包含多个权限，用户通过赋予角色来获得这些权限。 角色并不直接与具体的数据库操作实体（如用户）绑定，而是充当权限的管理和分配工具。 创建角色\n1 create role \u0026#39;developer\u0026#39;; 授权规范 授予权限 代码语法\n1 2 3 4 grant \u0026lt;权限列表\u0026gt; #all privileges表示全部权限 on \u0026lt;视图名/关系名\u0026gt; to \u0026lt;角色/用户列表\u0026gt; with grant option #可选表示被授予权限的用户／角色可以把得到的权限再授予给另外的用户／角色 注意事项\n权限的授予者必须已经拥有指定项目的权限（或者是数据库管理员）。 授予对视图的特权并不意味着授予对基础关系的任何特权。 默认情况下， 被授予权限的用户／角色无权把此权限授予其他用户／角色，除非使用with grant option子句 视图的授权\n创建视图的用户不需要获得该视图上的所有权限。他得到的那些权限不会为他提供超越他已有权限的额外授权。例如，如果一个创建视图的用户在用来定义视图的关系上没有update 权限的话，那么他不能得到视图上的update权限。 如果用户创建一个视图， 而此用户在该视图上不能获得任何权限，系统会拒绝这样的视图创建请求 模式的授权\n默认情况：只有模式的拥有者才能够执行对模式的任何修改， 诸如创建或删除关系， 增加或删除关系的属性， 以及增加或删除索引 referrence权限允许用户在创建关系时声明外码，例如你有两个表：orders 和 customers，其中 orders表中的 customer_id列引用了 customers 表中的 id 列作为外键。这时，在创建外键约束时，用户需要拥有对 customers 表的 REFERENCES 权限。 一个用户/角色的权限\n所有直接授予用户／角色的权限。\n所有授予给用户／角色所拥有角色的权限。\n收回权限 代码语法\n1 2 3 revoke \u0026lt;权限列表\u0026gt; on \u0026lt;视图名/关系名\u0026gt; from \u0026lt;角色/用户列表\u0026gt; 注意事项\n若权限列表中包含public,所有用户都将失去该权限，但明确授予该权限的用户除外。 如果不同的授权者两次向同一用户授予相同的权限，则用户在权限撤销后可以保留该权限 所有依赖于被撤销的权限的权限也将被撤销。 收回权限的方式 cascade：级联收回，从一个用户／角色那里收回权限可能导致其他用户／角色也失去该权限 restrict：不需要级联收回 可以收回grant option ","date":"2024-11-03T18:26:36+08:00","permalink":"https://Tyritic.github.io/p/mysql%E5%BA%93%E6%93%8D%E4%BD%9C/","title":"MySQL库操作"},{"content":"MySQL配置使用 启动服务：\n1 net start mysql 停止服务：\n1 net stop mysql 登录MySQL\n1 mysql -u[用户名] -p[密码] [-h 数据库服务器IP -p 端口号] 退出MySQL\n1 exit MySQL数据模型 关系型数据库(RDBMS)：建立在关系模型基础上，由多张相互连接的二维表组成的数据库\n特点\n使用表存储数据，格式统一，便于维护 使用SQL语言操作，标准统一，使用方便，可用于复杂查询 SQL简介 SQL：一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准。\n通用语法 SOL语句可以单行或多行书写，以分号结尾。 SOL语句可以使用空格/缩进来增强语句的可读性。 MySQL数据库的SQL语句不区分大小写。 注释 单行注释：\u0026ndash;注释内容或者#注释内容**（MySQL特有）** 多行注释：/* 注释内容 */ 分类 分类 全称 说明 DDL Data Definition Language 数据定义语言，用来定义数据库对象(数据库，表，字段) DML Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改 DQL Data Query Lanquage 数据查询语言，用来查询数据库中表的记录 DCL Data Control Language 数据控制语言，用来创建数据库用户、控制数据库的访问权限 ","date":"2024-11-03T17:02:26+08:00","permalink":"https://Tyritic.github.io/p/mysql%E7%AE%80%E4%BB%8B/","title":"MySQL简介"},{"content":"什么是控制反转（IOC) IOC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。以右图为例\nIOC容器作为中间位置“第三方”，也就是，使得A、B、C、D这四个对象没有了耦合关系，齿轮之间的传动全部依靠IOC容器，全部对象的控制权上交给IOC容器，所以IOC容器成了整个系统的关键核心，它起到一个“粘合剂”的作用，把系统中所有对象粘合在一起发挥作用。\nIOC的关键点 谁控制谁： 传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象； 而IOC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建； 控制了什么 那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 什么是反转： 传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转； 而反转则是由容器来帮忙创建及注入依赖对象 为什么是反转：因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象。 哪些方面反转了：依赖对象的获取被反转了。 IOC的过程 所有的类都会在Spring容器中登记，告诉spring你是个什么东西，你需要什么东西， 然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。 所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。 对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。 Bean对象的声明 注解 说明 位置 @Component 声明Bean对象的基本注解 不属于以下三类时使用该注解 @Service @Component的衍生注解 标注在ServiceImpl类上 @Controller @Component的衍生注解 标注在Controller类上 @Repository @Component的衍生注解 标注在数据访问类上（现在有mybatis，使用评论少） 注意事项\n声明bean的时候，可以通过value属性指定bean的名字，如果没有指定，默认为类名首字母小写 使用以上四个注解都可以声明bean，但是在springboot集成web开发中，声明控制器bean只能用@Controller. Bean组件扫描 声明bean的四大注解，要想生效，还需要被组件扫描注解 @ComponentScan 扫描。 @ComponentScan 注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解 @SpringBootApplication 中，默认扫描的范围是启动类所在包及其子包。\n","date":"2024-11-03T15:06:44+08:00","permalink":"https://Tyritic.github.io/p/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/","title":"控制反转"},{"content":"String类型是不可变的 不可变的实现方式 String类本身被final修饰表示该类不允许被继承 从JDK1.9开始String类底层已经不再使用char[]存储而是使用byte[]加上并一个字段 coder 来指示编码方式，同时这个byte[]数组被private final修饰，保证初始化后不再被更改 不可变性的体现 当对字符串重新赋值的时候，需要重新指定内存区域赋值，不能使用原来的内存区域 String类是线程安全的 当对现有字符串进行修改的时候，需要重新指定内存区域赋值，不能使用原来的内存区域 String对象的创建方式 通过构造函数创建（new+构造器） 构造函数 public String()：创建空白字符串 public String(String input)：根据输入字符串input创建字符串 public String(char[] input)：根据输入char数组input创建字符串 public String(byte[] input)：根据输入byte数组input创建字符串 底层实现 使用构造函数创建String对象的时候，先在堆区中创建一个新的String对象（引用常量池中的字面量），同时在字符串常量池中保存其字面量，在栈中保存字符串对象的引用。若常量池中存在相同的字面值则只会在堆区中创建新的String对象\n参考补充材料\n在堆区中创建一个新的String对象 若常量池中不存在所需的字面量则在常量池中创建新的字面量并将堆区中的对象指向常量池中的字面量 若存在则将堆区中的对象指向常量池中的字面量 通过字面量创建 语法格式 1 String s=\u0026#34;abc\u0026#34; 底层实现 使用字面量创建String对象的时候，会将在常量池中创建字面量。而不会在堆区创建String对象。若使用了相同的字面值则直接复用常量池中的字面量\nJVM检查该字符串的字面是否存在于常量池中 若不存在则在常量池中创建新的字面量 若存在则复用常量池中的字面量 两者创建方式的比较 使用字面量创建String对象不会在堆区创建对象 使用构造函数创建String对象会在堆区创建对象 示例比较 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class StringExercise01 { public static void main(String[] args) { //字面量创建对象 String s1 = \u0026#34;abc\u0026#34;; String s2 = \u0026#34;abc\u0026#34;; //通过new+构造器的方式: 此时s3,s4保存的地址值，是数据在堆空间中开辟以后对应的地址值 String s3 = new String(\u0026#34;abc\u0026#34;); String s4 = new String(\u0026#34;abc\u0026#34;); //s1 首先看常量池有没有abc //s2 首先看常量池有没有abc 有，就将b直接指向abc //所以地址值是一样的 System.out.println(s1==s2);//true //s1在常量池中，s3和s4在堆区中，指向地址不同 System.out.println(s1==s3);//false System.out.println(s1==s4);//false //s3和s4在堆区中，但是两个对象指向地址不同 System.out.println(s3==s4);//false } } String对象的拼接操作 常量与常量的拼接结果在常量池，且常量池中不会存在相同内容的常量 只要其中有一个结果是变量，结果就在堆中 如果拼接的结果调用intern()方法，返回值就在常量池中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 String s1 = \u0026#34;Java\u0026#34;; String s2 = \u0026#34;Android\u0026#34;; String ss =\u0026#34;JavaAndroid\u0026#34;; String s3 = \u0026#34;Java\u0026#34;+\u0026#34;Android\u0026#34;; String s4 = s1 + \u0026#34;Android\u0026#34;; String s5 = \u0026#34;Java\u0026#34; + s2; String s6 = s1 + s2; System.out.println(ss==s3);//true System.out.println(ss==s4); //false System.out.println(ss==s5);//false System.out.println(ss==s6);//false System.out.println(s4==s5);//false String s7=s4.intern(); System.out.println(ss==s7);//true String的常见操作 字符串查找 查找字符串中的字符 charAt(int index) 方法：用于返回字符串指定位置的字符，返回值为 char 类型，参数为 int 类型\n1 2 3 4 String str = new String(\u0026#34;Hello World\u0026#34;); for (int i = 0; i \u0026lt; str.length(); i++) { System.out.println(\u0026#34;下标为\u0026#34; + i + \u0026#34;的元素为：\u0026#34; + str.charAt(i));//打印的是每个字母 } 查找字符串中下标 int indexOf(int ch)\t用于返回当前字符串中参数 ch 指定的字符第一次出现的下标 int indexOf(int ch, int fromIndex)\t用于从 fromIndex(包含) 位置开始查找ch指定的字符 int indexOf(String str)\t在字符串中检索 str 返回其第一次出现的位置，若找不到返回-1 int indexOf(String str, int fromIndex)\t表示从字符串的 fromIndex(包含) 位置开始检索str第一次出现的位置 int lastIndexOf(int ch)\t用于返回参数 ch 指定的字符最后一次出现的下标 int lastIndexOf(int ch, int fromIndex)\t用于从 fromIndex(包含) 位置开始反向查找 ch 指定字符出现的下标，若找不到返回-1 int lastIndexOf(String str)\t返回 str 指定字符串最后一次出现的下标 int lastIndexOf(String str, int fromIndex)\t用于从 fromIndex(包含) 位置开始反向搜索的第一次出现的下标 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 String str = \u0026#34;Good Good Study, Day Day Up!\u0026#34;; System.out.println(str.indexOf(\u0026#39;g\u0026#39;)); // -1 代表查找失败 System.out.println(str.indexOf(\u0026#39;G\u0026#39;)); // 0 该字符第一次出现的索引位置 System.out.println(str.indexOf(\u0026#39;G\u0026#39;, 0)); // 0 System.out.println(str.indexOf(\u0026#39;G\u0026#39;, 1)); // 5 // 查找字符串 System.out.println(str.indexOf(\u0026#34;day\u0026#34;)); // -1 System.out.println(str.indexOf(\u0026#34;Day\u0026#34;)); // 17 字符串中第一个字符的下标 System.out.println(str.indexOf(\u0026#34;Day\u0026#34;, 17)); // 17 字符串中第一个字符的下标 System.out.println(str.indexOf(\u0026#34;Day\u0026#34;, 18)); // 21 字符串中第一个字符的下标 // 字符串内容的反向查找 System.out.println(str.lastIndexOf(\u0026#34;Day\u0026#34;)); // 21 System.out.println(str.lastIndexOf(\u0026#34;Day\u0026#34;, 21)); // 21 System.out.println(str.lastIndexOf(\u0026#34;Day\u0026#34;, 20)); // 17 System.out.println(str.lastIndexOf(\u0026#34;Day\u0026#34;, 15)); // -1 字符串截取 substring(int beginIndex, int endIndex) 方法：返回字符串中从下标 beginIndex(包括) 开始到 endIndex(不包括) 结束的子字符串，返回值为 String 类型，参数为 int 类型 substring(int beginIndex) 方法：返回字符串中从下标 beginIndex(包括) 开始到字符串结尾的子字符串，返回值为 String 类型，参数为 int 类型 字符串比较 判定是否相等 equals(Object anObject) 方法：比较字符串内容是否相等并返回，返回值为 boolean 类型 equalsIgnoreCase(String anotherString)方法：比较字符串内容是否相等并返回，返回值为 boolean 类型，不考虑大小写， 如：\u0026lsquo;A’和’a’是相等 比较大小 compareTo(String anotherString) 方法：比较调用对象和参数对象的大小关系，返回值为 int 类型 compareToIgnoreCase(String str) 方法：比较调用对象和参数对象的大小关系，返回值为 int 类型，不考虑大小写，也就是’a’和’A’是相等的关系 比较方法\n方法调用者的字符依次与方法参数的字符作比较，即用 A 的 ASCII码减去 B 的ASCII码；结果有三种：负整数、正整数、零。负整数即按字典顺序 A 在 B 之前，正整数即 A 在 B 之后，零则为字符串相等。注意：比较出大小就不往后进行，即从第一个字符串开始比较，相同则比较下一个，直到比较出大小或比较到最后一个字符。\n判定前缀/后缀 startsWith(String prefix) 方法：判断字符串是否以参数字符串开头，返回值为 boolean 类型，参数为 String 类型 startsWith(String prefix, int toffset) 方法：从指定位置开始是否以参数字符串开头，返回值为 boolean 类型，参数 prefix 为 String 类型，toffset 为 int 类型 endsWith(String suffix) 方法：判断字符串是否以参数字符串结尾，返回值为 boolean 类型，参 数为 String 类型 示例代码\n1 2 3 4 5 6 String str = \u0026#34;Give you some color to see see\u0026#34;; System.out.println(str.startsWith(\u0026#34;G\u0026#34;));//true System.out.println(str.startsWith(\u0026#34; \u0026#34;));//false System.out.println(str.startsWith(\u0026#34;you\u0026#34;, 5));//true System.out.println(str.endsWith(\u0026#34; \u0026#34;));//false System.out.println(str.endsWith(\u0026#34;see\u0026#34;));//true 判定子串 contains(CharSequence s) 方法：判断当前字符串是否包含参数指定的内容，返回值为 boolean 类型\n1 2 3 String str = \u0026#34;Give you some color to see see\u0026#34;; System.out.println(str.contains(\u0026#34;some\u0026#34;));//true System.out.println(str.contains(\u0026#34;Some\u0026#34;));//false 字符串替换 replace(char oldChar, char newChar) 方法：使用参数newChar替换此字符串中出现的所有参数oldChar，返回值为 String 类型，参数为 char 类型 replace(CharSequence target, CharSequence replacement) 方法：用新字符串replacement替换所有的旧字符串target，返回值为 String 类型，参数为 CharSequence 接口 字符串拆分 split(String regex)：根据给定的正则表达式分割此字符串，并返回一个String数组。 split(String regex,int limit)：根据给定的正则表达式分割此字符串分割成limit组，并返回一个String数组。 字符串与其他类型的相互转换 数字和字符串之间相互转换 数字转字符串：String.valueOf(var var_name) 字符串转数字 Integer.valueOf(String var) Integer.parseInt(String var) 字符串和char数组的相互转换 字符串转字符数组：char[] toCharArray() 方法： 字符串转byte数组 byte[] getBytes() ","date":"2024-11-03T14:22:08+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84string%E7%B1%BB/","title":"Java中的String类"},{"content":"什么是依赖注入（DI） 组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。\n关键点分析 谁依赖于谁：当然是应用程序依赖于IoC容器； 为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源； 谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象； 注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据） Bean注入方式 @Autowired注入 使用@Autowired注解修饰要注入的对象\n1 2 @Autowired userMapper mapper; 注意事项 @Autowired注解默认按Bean对象的类型进行自动装配，若存在多个相同类型的Bean对象会报错 可以使用注解@Primary指定Bean对象的优先级，对优先级高的Bean对象使用 @Primary 注解 可以使用注解@Qualifier和@Autowired配合使用，@Qualifier的value属性用于按名字指定Bean对象 提示\nBean对象的默认名称是类名首字母小写\n@Resource ​\t使用 @Resource 注解修饰要注入的对象,@Resource 注解按照Bean对象名注入对象\n1 2 @Resource(name=\u0026#34;Bean_name\u0026#34;) userMapper mapper; 提示\n@Resource 和 @Autowired 的区别\n@Autowired 是Spring框架提供的注解，而 @Resource 是IDK提供的注解 @Autowired 默认是按照类型注入，而 @Resource 默认是按照名称注入。 ","date":"2024-11-03T13:37:35+08:00","permalink":"https://Tyritic.github.io/p/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/","title":"依赖注入"},{"content":"Scanner类 java.utils包中用于获取输入的类，用于解析基本类型和字符串类型的输入。它可以从控制台、文件、字符串等不同的数据源读取数据，并将其解析为适当的类型。\n基本构造函数 Scanner可以接收控制台的键盘输入（标准输入流），文件和字符串\n从控制台输入读取\n1 Scanner scanner = new Scanner(System.in); 从文件输入读取\n1 2 File file = new File(\u0026#34;input.txt\u0026#34;); Scanner scanner = new Scanner(file); 从字符串中读取\n1 2 String input = \u0026#34;Hello World!\u0026#34;; Scanner scanner = new Scanner(input); 基本用法 读取基本类型 nextInt()：读取int类型 nextShort()：读取short类型 nextLong()：读取long类型 nextFloat()：读取float类型 nextDouble()：读取double类型 读取字符串 next()：读取下一个字符串，遇到空白符（如空格、制表符、换行符等）停止 nextLine()：读取下一行文本，遇到回车停止 提示\nnext()和 nextLine()的区别\nnext()\n一定要读取到有效字符后才可以结束输入。 对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。 只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 next() 不能得到带有空格的字符串。 nextLine( )\n以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 可以获得空白。 先使用nextLine()再使用next()、nextInt()等没问题，但是先使用next()和nextInt()等之后就不可以再紧跟nextLine()使用。\n原因：因为next()等这些方法读取结束后会紧跟一个回车符，而nextLine()会直接读取到这个回车符，这就导致出现我们还没有来得及输入我们想要输入的数据，nextLine()就以为我们已经输入完了\n解决方法：我们直接在next()使用后加两个nextLine()即可了，这样第一个nextLine()就会当一个‘替死鬼’读取前一个next()遗留的空白符，第二个nextLine()就可以输入自己想要输入的数据啦！\n检验输入 hasNext()方法会检查输入中是否还有下一个单词，即是否存在非空白字符。这意味着，只要输入中还有非空白字符，无论是在当前行还是在下一行，hasNext()都会返回true。通常配合next()使用 hasNextLine()方法则会检查输入中是否还有下一行。如果输入中存在换行符，或者如果输入中至少还有一个字符（即使这个字符是空白字符），hasNextLine()都会返回true。但是如果输入已经到达结尾，或者输入中的下一个字符是输入流的结尾，hasNextLine()就会返回阻塞。 设置分隔符 Scanner类默认使用空白字符（空格、制表符、换行符等）作为分隔符，但可以自定义分隔符。\ndelimiter()用于查看当前分隔符\nuseDelimiter()方法用于修改分隔符\n示例代码 1 2 3 4 5 6 7 Scanner scanner = new Scanner(System.in); scanner.useDelimiter(\u0026#34;,\u0026#34;); // 使用逗号作为分隔符 System.out.print(\u0026#34;Enter comma-separated values: \u0026#34;); while (scanner.hasNext()) { String value = scanner.next(); System.out.println(\u0026#34;Value: \u0026#34; + value); } 关闭扫描器 使用完Scanner后，一定要记得将它关闭！因为使用Scanner本质上是打开了一个IO流，如果不关闭的话，它将会一直占用系统资源。\nclose()方法\n","date":"2024-11-03T12:09:48+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/","title":"Java中的键盘输入操作"},{"content":"Math类的简介 Java在Math类中封装了相关的数学函数，位于Java.lang包中\n构造方法是private的，且所有方法都是静态方法，可以不依赖实例进行调用\n静态常量 自然对数$e$：Math.E（double数据类型）\n圆周率$π$：Math.PI（double数据类型）\n三角函数 Math.toRadians()：角度 \u0026ndash;\u0026gt; 弧度 Math.toDegrees()：弧度 \u0026ndash;\u0026gt; 弧度 正切值：Math.sin() 余弦值：Math.cos() 反正弦值：Math.asin() 反余弦值：Math.acos() 正切值：Math.tan() 反正切值：Math.atan() 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* 三角函数 */ // 角度 --\u0026gt; 弧度 toRadians() double x = 45; // 45° 45° --\u0026gt; PI / 4 System.out.println(\u0026#34;45°转换为弧度：\u0026#34; + Math.toRadians(x)); System.out.println(Math.PI / 4); double y = 180; System.out.println(\u0026#34;180°转换为弧度：\u0026#34; + Math.toRadians(y)); System.out.println(Math.PI); // 弧度 --\u0026gt; 弧度 toDegrees() double z = 0.7853981633974483; // PI / 4 --\u0026gt; 45° System.out.println(\u0026#34;0.7853981633974483转换为角度\u0026#34; + Math.toDegrees(z)); // 正弦函数sin() double degrees = 45.0; double radians = Math.toRadians(degrees); System.out.println(\u0026#34;45° 的正弦值: \u0026#34; + Math.sin(radians)); // 余弦函数cos() System.out.println(\u0026#34;45° 的余弦值: \u0026#34; + Math.cos(radians)); // 反正弦值asin() System.out.println(\u0026#34;45° 的反正弦值: \u0026#34; + Math.asin(radians)); // 反余弦值acos() System.out.println(\u0026#34;45° 的反余弦值: \u0026#34; + Math.acos(radians)); // 正切值tan() System.out.println(\u0026#34;45° 的正切值: \u0026#34; + Math.tan(radians)); // 反正切值atan() atan2() double m = 45; double n = 30; System.out.println(\u0026#34;45° 的反正切值1: \u0026#34; + Math.atan(radians)); // atan() System.out.println(\u0026#34;反正弦值2: \u0026#34; + Math.atan2(m, n)); // atan2() 坐标系表示角的反正切值 指数函数 Math.exp()：自然对数e的幂函数 Math.pow()：幂函数 Math.sqrt()：平方根 Math.cbrt()：立方根 Math.log()：ln函数 Math.log 10()：log_10函数 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* 指数函数 */ double p = 8; double q = 3; // exp() System.out.println(\u0026#34;e的6次幂: \u0026#34; + Math.exp(p)); // e^8 // pow() System.out.println(\u0026#34;8的3次幂: \u0026#34; + Math.pow(p, q)); // 8^3 // sqrt() System.out.println(\u0026#34;8的平方根: \u0026#34; + Math.sqrt(p)); // cbrt() System.out.println(\u0026#34;8的立方根: \u0026#34; + Math.cbrt(p)); // 2 // log() System.out.println(\u0026#34;ln(8): \u0026#34; + Math.log(p)); // ln(8) // log10() System.out.println(\u0026#34;log10(8): \u0026#34; + Math.log10(p)); // log10(8) 取整函数 Math.ceil()：上取整 Math.floor()：下取整 Math.rint()：最近的整数，0.5返回0 Math.round()：四舍五入的整数，0.5返回1 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 取整 */ double d = 100.675; double e = 100.500; // \u0026gt;=的整数 ceil() System.out.println(\u0026#34;ceil(100.675): \u0026#34; + Math.ceil(d)); // \u0026lt;=的整数 floor() System.out.println(\u0026#34;floor(100.675): \u0026#34; + Math.floor(d)); // 最近的整数 rint() System.out.println(\u0026#34;rint(100.675): \u0026#34; + Math.rint(d)); System.out.println(\u0026#34;rint(100.500): \u0026#34; + Math.rint(e)); // 四舍五入的整数 round() System.out.println(\u0026#34;round(100.675): \u0026#34; + Math.round(d)); System.out.println(\u0026#34;round(100.500): \u0026#34; + Math.round(e)); 比较函数 Math.min()：最小值 Math.max()：最大值 Math.abs()：绝对值 示例代码\n1 2 3 4 5 6 7 8 9 /* 其他 */ // min() 最小 System.out.println(\u0026#34;min(): \u0026#34; + Math.min(2, 10)); // max() 最大 System.out.println(\u0026#34;max(): \u0026#34; + Math.max(2, 10)); // abs() 绝对值 System.out.println(\u0026#34;abs(): \u0026#34; + Math.abs(-5)); 随机数生成 Math.random()：随机产生一个数 random()，随机数范围为 0.0 =\u0026lt; Math.random \u0026lt; 1.0 a+Math.random()+b生成[a,a+b)\n","date":"2024-11-03T11:35:06+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E5%AD%A6%E6%93%8D%E4%BD%9C/","title":"Java中的基本数学操作"},{"content":"一维数组的声明与创建 声明数组 1 2 ElementType[] array_name; // 一维数组 ElementType[][] array_name; // 二维数组 创建数组 除非数组被创建否则不能分配任何元素\n1 array_name=new ElementType[size]; 初始化数组 静态初始化 指定数组内的元素而不指定数组的长度\n1 ElementType array_name={x1,x2,..xn}; 动态初始化 指定数组的长度而不指定数组的元素，系统自动赋默认值\n1 ElementType[]array_name=new ElementType[size]; 获取一维数组长度 1 int length=array_name.length; 访问一维数组元素 通过数组下标访问，数组下标从0开始\n数组元素的默认值 整型：0 浮点型：0.0 布尔：false 字符：’\\u000' 字符串：null 引用数据类型：null 一维数组的处理 遍历数组 不通过数组下标可以完成数组的遍历\n1 2 3 4 for(数据类型 引用名:数组名) { // 循环体 } 复制数组 使用for循环/for-each循环逐一复制元素\n使用system类中的静态方法arraycopy复制数组\n1 2 3 4 System.arraycopy(sourceArray,srcPos,targetArray,tarPos,length); // srcPos：源数组中的起始位置 // tarPos：目标数组的起始位置 // length：决定复制数组的元素个数 提示\n数组的复制不能简单使用赋值号，赋值号只是将引用的地址值赋值，此时两个变量指向同一个数组\n可变长参数列表 可以将类型相同但是数目可变的参数作为方法的形参\n语法形式 1 TypeName... parameterName 示例代码 1 2 3 4 5 6 // 定义一个带有可变参数的方法 public static void printAll(String... strings) { for (String s : strings) { System.out.println(s); } } 注意事项 可变参数必须是方法参数列表中的最后一个参数。 一个方法只能有一个可变参数。 当你调用一个带有可变参数的方法时，你可以直接传入逗号分隔的参数列表，也可以传入一个数组（数组会自动被拆分成单独的参数）。 在调用方法时同时传入了一个数组和一个或多个单独的参数，那么数组必须被明确地作为最后一个参数传入（即它不能被单独的可变参数分隔开） 二维数组的声明和创建 初始化二维数组 静态初始化 1 ElementType[][]array_name=new ElementType[][]{{var1,var2,..varN},{var1,var2,..varN}}; 动态初始化 1 ElementType[][]array_name=new ElementType[m][n]; m表示这个二维数组存放了多少个一维数组 n表示这个一维数组存放多少个元素 二维数组的存储方式 二维数组本质上是一个一维数组，这个一维数组的存储元素是其他一维数组的地址值\n例如\n1 int[][]arr={{11,22},{33,44}}; 其中arr的地址为0x0011\narr的元素为\narr[0]为0x0022（对应arr[0][])\narr[1]为0x0033(对应arr[1][])\n访问二维数组元素 1 array_name[m][n]; m索引指定访问哪个一维数组 n索引指定访问这个一维数组的哪个元素 获取二维数组的长度 对应二维数组array_name[m][n]\n通过array_name.length获取二维数组中包含多少个一维数组 通过array_name[0].length获取一维数组的长度 ","date":"2024-11-03T00:27:14+08:00","permalink":"https://Tyritic.github.io/p/java%E6%95%B0%E7%BB%84/","title":"Java数组"},{"content":"请求响应过程 基本流程 浏览器向SpringBoot项目中内置的Tomcat服务器发送请求 SpringBoot项目中的controller类接收浏览器发出的请求并发送响应 请求参数的接收 简单参数 方法一：设置controller类中的函数形参名和请求的参数名相同 1 2 3 4 5 @RequsetMapping(\u0026#34;/simpleParam\u0026#34;) public String getParam(String param) { return param; } 方法二：参数名和形参名不匹配使用@RequestParam 注解的name属性将参数名映射到形参 1 2 3 4 5 @RequestMapping(\u0026#34;/simpleParam\u0026#34;) public String getParam(@RequestParam(name=“username\u0026#34;)String param) { return param; } 提示\n@RequestParam\n作用：建立请求参数和controller形参的映射关系\n属性\nvalue/name：请求的参数名 required：参数是否必需。默认为true 实体对象参数 简单实体对象 请求参数与形参对象属性名相同\n1 2 3 4 5 @RequestMapping(\u0026#34;/objectParam\u0026#34;) public User getParam(User user) { return user; } 复杂实体对象（对象的成员变量是对象） 请求参数与形参对象属性名相同，按对象层次关系接收\n数组集合参数 数组参数 请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数\n1 2 3 4 5 @RequestMapping(\u0026#34;/arrayParam\u0026#34;) public User getParam(String[]array) { return array; } 集合参数 请求参数名与形参数组名称相同且请求参数为多个，@RequestParam 绑定参数关系\n1 2 3 4 5 @RequestMapping(\u0026#34;/listParam\u0026#34;) public User getParam(@RequestParam List\u0026lt;String\u0026gt;param) { return param; } 日期参数 使用 @DateTimeFormat 注解完成日期格式转换\n1 2 3 4 5 @RequestMapping(\u0026#34;/dateParam\u0026#34;) public String getParam(@DateTimeFormat(pattern=\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;) LocalDateTime param) { return param.toString(); } 提示\n@DateTimeFormat\npattern属性用于指定时间格式\nJson参数 JSON数据键名与形参对象属性名相同，定义pojo类型形参即可接收参数，需要使用 @RequestBody 标识\n1 2 3 4 5 @RequestMapping(\u0026#34;/jsonParam\u0026#34;) public String getParam(@RequestBody User user) { return user.toString(); } 路径参数 通过请求URL直接传递参数，使用{..}来标识该路径参数，需要使用 @PathVariable 获取路径参数\n1 2 3 4 5 @RequestMapping(\u0026#34;/path/{id}\u0026#34;) public String getParam(@PathVariable Integer id) { return id; } 响应报文的回写 @RequestBody 类型：方法注解，类注解 位置：controller类/方法上 作用：将方法返回值直接响应，如果返回值类型是 实体对象/集合，将会转换为JSON格式响应 说明：@RequestController=@RequestBody+@Controller ","date":"2024-11-03T00:05:27+08:00","permalink":"https://Tyritic.github.io/p/%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/","title":"请求与响应"},{"content":"方法的定义 1 2 3 修饰符 返回值类型 方法名(形参列表){ // 方法体 } 修饰符 访问修饰符 Java 中的访问修饰符用于控制类、字段、方法和构造函数的访问权限。通过使用访问修饰符，可以实现封装，保护数据，并控制不同部分之间的访问范围。\npublic 定义：被public修饰的成员可以被外界访问\n作用域：在一个Java源文件（.java文件）中只有一个类被声明为public，且这个源文件的文件名要与这个公共类的类名相同\npublic修饰类成员时可以在所有类中被访问\n在继承中public修饰的所有成员都被继承\nprotect 定义：受保护的，受该类所在包保护，只能被同一个包内的类或者不同包的子类访问\n作用域：被protect修饰的成员可以被同一个包内的所有类访问，同时也会被该类的所有子类继承\ndefault 定义：只对同一个包中的类友好，只能被同一个包中的类访问\n作用域：同一个包中的所有类可以访问，被default修饰的成员只能被同一个包中的子类继承\nprivate 定义：私有的，只能被同一个类中的成员访问\n作用域：同一个类\n表格整理如下\n修饰符 当前类 同一包内 子类（不同包） 其他包 public 是 是 是 是 protected 是 是 是 否 default 是 是 否 否 private 是 否 否 否 静态修饰符 static 被static修饰的成员是静态方法，静态方法属于整个类，非静态方法属于单个对象\n静态方法的生命周期与类一样长，随着类的消亡而消亡\n非静态方法的生命周期与对象一样长，随着对象的消亡而消亡\n静态方法和非静态方法的对比参考补充资料\n方法调用 main方法作为程序入口先压入栈区 执行main方法中的代码，遇到方法后，将该方法压入栈区，执行完毕后出栈 方法重载 方法重载（Overloading） ：在同一个类中，允许有多个同名方法，只要它们的参数列表不同（参数个数、类型或顺序）。主要关注方法的签名变化，适用于在同一类中定义不同场景下的行为。\n判定依据 方法在同一个类中，且具有相同的方法名 具有不同的形参列表（满足以下其中之一即可） 形参个数不同 形参类型不同 形参顺序不同 提示\n方法重载与返回值无关\n方法重载与方法重写的区别见补充材料\n方法的参数传递 在 Java 中，参数传递只有按值传递，不论是基本类型还是引用类型。\n方法传递基本数据类型 具体类型见往期博客\n基本数据类型的特点 基本数据类型在栈空间中存储的是真实的数据字面值，在堆区中不开辟空间\n具体表现 方法中对参数的改变不会影响原始变量的值\n示例代码 1 2 3 4 5 6 7 8 9 10 public static void main(String [] args) { int nums=100; change(nums); //change(100) System.out.println(nums); //nums=100; } public static void change(int nums) { nums=110; } 内存解释 每个方法压入栈区中，都会有独立的栈空间，在该方法的栈空间中传入的实际上是参数值的副本（参数的字面值）来对形参进行初始化，在这个栈区中形参值发生了改变。方法执行完成后出栈，原来栈区中的变量不受影响\n方法传递引用数据类型 除基本数据类型以外的所有数据类型包括数组，字符串，类都是引用数据类型\n特点 引用数据类型在栈空间中存储的是其地址值，在堆区中开辟空间，真实的数据保存在堆区中\n具体表现 方法中对参数的改变会影响原始变量的值\n示例代码 1 2 3 4 5 6 7 8 9 10 public static void main(String [] args) { int[] nums={0,1,2}; change(nums); //change(nums) System.out.println(nums); //nums={0,3,2}; } public static void change(int[] nums) { nums[1]=3; } 内存解释 每个方法压入栈区中，都会有独立的栈空间，在该方法的栈空间中传入的实际上是参数值的副本（参数的地址值）对形参进行初始化。\n在这个栈区中形参和原始变量指向同一块内存区域，对形参的修改会通过引用影响原始变量。\n方法执行完成后出栈，原来栈区中的变量指向的内存区域已经受到影响\n总结 方法参数传递的本质是值传递（引用数据类型被视为地址值） 函数调用时在函数作用域创建栈区空间，再使用实参对形参进行初始化（形参作为实参的副本） 基本数据类型：形参改变不影响实参，形参在方法结束后弹出栈区 引用数据类型：形参是地址值，形参地址值的改变不影响实参地址值，此时形参和实参指向同一个地址 特殊的例子String类 具体表现 作为一个单独的数据类型，传递效果与传递基本数据类型相同\n作为对象的成员，传递效果与传递引用数据类型相同\n特点 String对象一旦创建就不可更改（String是不可变类） String类的所有方法都不会改变String的内容 示例代码（作为单独的数据类型） 1 2 3 4 5 6 7 8 public static void main(String[] args) { String s1=new String(\u0026#34;张三\u0026#34;); change(s1); System.out.println(s1); // s1=\u0026#34;张三\u0026#34; } public static void change(String s2){ s2=\u0026#34;李四\u0026#34;; } 解析过程 方法调用前\n首先 String s=new String(\u0026quot;张三\u0026quot;)，在堆中开辟内存放对象，变量s1在栈中，存放的是堆的地址 将地址0x11传入change方法复制一份用于初始化s2，此时s2放的是地址0x11 方法调用时\ns2=\u0026quot;李四\u0026quot;；通过=赋值是直接先去常量池寻找是否存在与“李四”相同的值，有的话直接将其地址返回。否则创建一个值，再返回其地址。这里改变的是s2在栈区 方法调用后\ns1和s2最终存储的地址不同\n示例代码（作为类的成员变量） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Person { String name; public Person(String name){ this.name=name; } } public static void main(String[] args) { Person p1 = new Person(\u0026#34;张三\u0026#34;); change(p1); System.out.println(p1.name); // 李四 } public static void change(Person p2){ p2.name=\u0026#34;李四\u0026#34;; } 解析过程 方法调用前\n首先 Person s=new Person(\u0026quot;张三\u0026quot;)，在堆中开辟内存放对象，变量p1在栈中，存放的是堆的地址 将地址0x11复制一份给s2用于初始化，此时s2放的是地址0x11 方法调用时\np2.name=\u0026quot;李四\u0026quot;；要知道通过=赋值是直接先去常量池寻找是否存在与“李四”相同的值，有的话直接将其地址返回。否则创建一个值，再返回其地址。与上一问题不同的是，这里我们改变的是name，而name在堆中，所以常量池中地址是复制给了name 方法调用后\np1.name和p2.name最终存储的地址相同\n","date":"2024-11-02T20:30:52+08:00","permalink":"https://Tyritic.github.io/p/java%E6%96%B9%E6%B3%95/","title":"Java方法"},{"content":"如何读懂SpringBoot项目结构 SpringBoot项目本质上是一个Maven项目，大体骨架与普通的Maven项目相同\n普通Maven项目结构\n1 2 3 4 5 6 7 8 9 10 Maven-name/ |--src（源代码） |\t|--main（项目实际资源） |\t|--java（java代码） |\t|--resource（资源文件） |\t|--test（测试代码资源） |\t|--java |\t|--resource |--pom.xml（依赖配置文件） |--target（打包后的jar包存放地） 开发者的代码都存放到src/main/java文件夹中\n代码层 根目录：src/main/java\n作用：该目录下存放入口启动类及程序的开发目录。在这个目录下进行业务开发、创建实体层、控制器层、数据连接层等。\n注解\n入口启动类：运行整个项目main方法的类\n1 2 3 4 5 6 @SpringBootApplication public class UserApplication { public static void main(String[] args) { SpringApplication.run(UserApplication.class, args); } } 其中 @SpringBootApplication 用于标识SpringBoot项目的入口类\n控制器层（controller) 根目录：src/main/java/controller\n作用：主要负责具体业务模块的流程控制，负责前后端交互，接受前端请求，调用service层，接收service层返回的数据，最后返回具体的页面和数据到客户端\n功能实现：通过实现controller类来实现\n1 2 3 4 5 6 7 @RequestMapping(\u0026#34;/user\u0026#34;) @RestController // @RestController=@RequestMapping + @ResponseBody public class UserController { @RequestMapping(\u0026#34;/映射资源\u0026#34;) public List\u0026lt;User\u0026gt; findAll(){ return userService.findAll(); } 业务逻辑层(service) 根目录：src/main/java/service\n作用：主要负责业务逻辑应用设计\n功能实现：首先设计service接口，然后再设计其实现该接口的类(serviceImpl)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Service public class UserRegisterServiceImpl implements UserRegisterService { @Autowired UserMapper userMapper; @Override public void register(UserRegisterDTO userRegisterDTO) { //判断用户是否已存在 User tempUser=userMapper.getByUsername(userRegisterDTO.getUsername()); if(tempUser!=null){ log.error(\u0026#34;用户{}已存在\u0026#34;,userRegisterDTO.getUsername()); throw new UsernameHasBeenRegisteredException(\u0026#34;用户名已存在\u0026#34;); } //注册 User user=new User(); BeanUtils.copyProperties(userRegisterDTO,user); userMapper.register(user); log.info(\u0026#34;用户{}注册成功\u0026#34;,userRegisterDTO.getUsername()); } } 常量层(common) 根目录：src/main/java/common\n作用：主要存放工具类（utils)，常量类（constant），统一响应模板（result），统一异常处理（exception)\n数据库实体层(pojo) 根目录：src/main/java/pojo\n作用：存放数据库的实体类，通常一个实体类对应一张数据库表\n数据持久层（mapper) 根目录：src/main/java/mapper\n作用：访问数据库，向数据库发送sql语句，完成数据的增删改查任务\n功能实现：通过 @Mapper 注解接口来建立java方法和sql语句的映射关系\n1 2 3 4 5 6 7 8 9 10 @Mapper public interface DistrictMapper { List\u0026lt;District\u0026gt;searchAll(String tname); boolean deleteDistrict(String dname); District getDistrictByName(String dname); void insertDistrict(DistrictDTO districtDTO); void updateDistrictTdid(DistrictDTO districtDTO); boolean deleteAll(Long tid); void updateDistrictDetail(DistrictDTO districtDTO); } 数据传输对象（dto） 根目录：src/main/java/dto（或者放入pojo层中）\n作用：对entity进行封装，不破坏实体类结构，进行层与层之间的数据传输\n提示\n​\tDTO通常用于\n控制器（Controller）与服务层（Service）之间的数据传输：控制器通过 DTO 将请求参数传递给服务层，服务层返回 DTO 对象给控制器。 服务层与持久层（Mapper）之间的数据传输：服务层通过 DTO 将实体对象转换为需要的数据结构传递给持久层，持久层返回 DTO 对象给服务层。 视图包装对象（vo） 根目录：src/main/java/vo（或者放入pojo层中）\n作用：用于封装客户端请求的数据同时不破坏原有的实体类结构\n提示\nVO在实际开发中通常作为controller类方法的形参从而起到封装客户端请求数据的作用\n配置类（config) 根目录：src/main/java/config\n作用：以java类代替yaml文件进行Bean对象配置\n功能实现：通过 @Configuration 注解一个java类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration public class WebMvcConfiguration implements WebMvcConfigurer { @Autowired JwtTokenUserInterceptor jwtTokenUserInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { log.info(\u0026#34;开始注册拦截器\u0026#34;); log.info(\u0026#34;注册Jwt令牌拦截器：{}\u0026#34;,jwtTokenUserInterceptor); registry.addInterceptor(jwtTokenUserInterceptor) .addPathPatterns(\u0026#34;/Operator/**\u0026#34;) .excludePathPatterns(\u0026#34;/Operator/user/login\u0026#34;) .excludePathPatterns(\u0026#34;/Operator/user/register\u0026#34;); } } 参数配置类（properties） 根目录：src/main/java/properties\n作用：以java实体类代替yaml文件进行参数配置\n功能实现：通过 @ConfigurationProperties 注解一个java类\n1 2 3 4 5 6 7 8 9 10 @Data @Component @ConfigurationProperties(prefix = \u0026#34;operator.aliyun.oss\u0026#34;) public class AliyunOSSProperties { String endpoint; String accessKeyId; String accessKeySecret; String bucketName; String region; } 过滤器（filter） 根目录：src/main/java/filter\n作用：在Servlet 处理请求之前或响应之后对数据进行某些处理，实现诸如日志记录、请求数据修改、响应数据修改、权限控制等功能\n提示\n过滤器工作在 Servlet 容器容中，它拦截客户端的请求和服务器的响应。过滤器链（Filter Chain）是多个过滤器按照一定的顺序执行的集合，一个请求可以依次通过多个过滤器，然后到达目标 Servlet，响应也会按相反的顺序经过这些过滤器返回给客户端。\n生命周期管理\nServlet 容器负责过滤器的生命周期管理。过滤器的生命周期方法包括 init（初始化）、doFilter（执行过滤操作）和 destroy（销毁）。 请求处理流程\n当一个请求到达 Servlet 容器时，容器会根据部署描述符（web.xml）或注解配置，决定是否以及如何调用过滤器链。 过滤器链是多个过滤器按照一定的顺序执行的集合。容器按照这个顺序依次调用每个过滤器的 doFilter 方法。 doFilter 方法\n在 doFilter 方法中，开发者可以实现自定义的处理逻辑，比如修改请求头、记录日志等。 doFilter 方法中必须调用 FilterChain 的 doFilter 方法，这样请求才能继续传递给下一个过滤器或目标资源（如 Servlet）。如果不调用，请求处理流程将会停止。 工作机制\n过滤器可以修改请求和响应，但它们通常不会生成响应或结束请求，因为这通常是 Servlet 或其他资源的职责 参考文章：\nFilter（过滤器）和 Interceptor（拦截器）详解_过滤器和拦截器-CSDN博客 功能实现\n创建过滤器类\n实现 javax.servlet.Filter 接口。 重写 init()、doFilter() 和 destroy() 方法。 配置过滤器\n使用注解 @WebFilter 进行声明和配置。 或者在 web.xml 文件中配置。 编写过滤逻辑：\n在 **doFilter()**方法中实现具体的过滤逻辑。 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import javax.servlet.*; import javax.servlet.annotation.WebFilter; import java.io.IOException; @WebFilter(\u0026#34;/example/*\u0026#34;) // 过滤器应用于 URL 模式 \u0026#34;/example/*\u0026#34; public class ExampleFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { // 初始化代码，例如资源加载 } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { // 在请求处理之前执行的代码 System.out.println(\u0026#34;Before Servlet processing\u0026#34;); chain.doFilter(request, response); // 将请求传递给下一个过滤器或目标资源 // 在请求处理之后执行的代码 System.out.println(\u0026#34;After Servlet processing\u0026#34;); } @Override public void destroy() { // 清理代码，例如释放资源 } } 拦截器（interceptor） 根目录：src/main/java/interceptor\n作用：是 Spring MVC 框架中的一个核心组件，用于在处理 HTTP 请求的过程中进行拦截和处理。拦截器主要用于实现跨切面（cross-cutting）的逻辑，如日志记录、性能统计、安全控制、事务处理等。\n功能实现\n创建拦截器类：\n实现 **HandlerInterceptor**接口或继承 **HandlerInterceptorAdapter**类。 重写 preHandle()、postHandle() 和 afterCompletion() 方法。 注册拦截器：\n创建一个配置类，实现 WebMvcConfigurer接口。 重写 addInterceptors 方法来添加拦截器。 编写拦截逻辑：\n在 preHandle()、postHandle() 和 **afterCompletion()**方法中实现具体的拦截逻辑。 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { // 请求处理前的逻辑 return true; // 返回 true 继续流程，返回 false 中断流程 } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) { // 请求处理后的逻辑，但在视图渲染前 } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { // 请求处理完毕后的逻辑 } } @Configuration public class WebMvcConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new MyInterceptor()).addPathPatterns(\u0026#34;/**\u0026#34;); // 应用于所有路径 } } 项目配置层 根目录：src/main/resource\napplication.yml：项目的整体配置文件\nmapper：数据库映射文件\n","date":"2024-11-02T19:26:08+08:00","permalink":"https://Tyritic.github.io/p/springboot%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/","title":"SpringBoot项目结构"},{"content":"顺序结构 代码逐行执行，执行逻辑为线性逻辑\n选择结构 代码遇到选择结构根据关系表达式的不同计算结果执行不同的操作\nif语句 语法结构 1 2 3 if(关系表达式){ //语句体 } 执行流程 计算关系表达式 若为 true 执行语句体内的语句，若为 false 则跳过语句体内的语句 继续执行语句体外的语句 if-else语句 语法结构 1 2 3 4 5 if(关系表达式){ //语句体1 }else{ //语句体2 } 执行流程 计算关系表达式 若为 true 执行语句体1内的语句，若为 false 则执行语句体2内的语句 继续执行语句体外的语句 if-else if语句 语法结构 1 2 3 4 5 6 7 8 9 if(关系表达式 1){ //语句体1 }else if(关系表达式 2){ //语句体2 } ... else{ //语句体n+1 } 执行流程 计算关系表达式1 若为 true 执行语句体1内的语句，若为 false 则计算关系表达式2 若为 true 执行语句体2内的语句，若为 false 则计算关系表达式3 以此类推 若所有的关系表达式为 false 则执行语句体n+1 switch语句 语法结构 1 2 3 4 5 6 7 8 9 10 11 12 switch(表达式){ case 值1: 语句体1; break; case 值2: 语句体2; break; ...... default: 语句体 n+1 break; } 执行流程 计算表达式的值 依次与case后面的值比较。若有对应的值就会执行对应的语句体，在执行过程中遇到break结束整个switch语句 若与所有的case后面的值不匹配，便会执行default内的语句体 格式说明 表达式取值只能为byte，short，int，char，enum，string case后面是与关系式匹配的值，只能是字面量不能说变量且不允许重复 注意事项 default 可以放在任意位置，也可以省略不写 不写 break会发生case穿透问题，在case匹配过程中若没有break会执行下一个case的语句体，直到遇到 break/大括号 JDK12的新特性 语法格式 1 2 3 4 5 6 7 8 9 10 11 12 13 switch(表达式) case 值1 -\u0026gt; { //语句体1 } case 值2 -\u0026gt; { //语句体2 } .... default -\u0026gt;{ //语句体n+1 } 循环结构 for循环 语法格式 1 2 3 4 for(初始化语句;终止条件判断语句;条件控制语句) { //循环体结构 } 执行流程 执行初始化语句 执行条件判断语句，检验其结果 若为 false，循环结束 若为 true，执行循环体语句 执行条件控制语句 单次循环结束后继续执行条件判断语句 while循环 语法格式 1 2 3 4 5 6 // 初始化语句 while(条件判断语句) { // 循环体语句 // 条件控制语句 } 执行流程 执行初始化语句 执行条件判断语句，检验其结果 若为 false，循环结束 若为 true，执行循环体语句 执行条件控制语句 单次循环结束后继续执行条件判断语句 提示\nfor和while的对比\n相同点：运行规则相同\n不同点\nfor循环中控制循环的变量在循环结束后无法被访问，while循环中可以继续使用 for循环限定循环次数和范围，while循环不知道循环次数 do-while循环 语法结构 1 2 3 4 5 // 初始化语句 do{ // 循环体语句 // 条件控制语句 }while(条件判断语句) 执行流程 执行初始化语句 先执行条件判断语句 执行条件控制语句 单次循环结束后继续执行条件判断语句 若为 false，循环结束 若为 true，执行循环体语句 循环控制语句 break：立即终止当前所在的循环\ncontinue：跳过当前循环的剩余部分，直接进入下一次循环\n在嵌套循环中，break 和 continue 仅影响它所在的最近一层循环\n","date":"2024-11-02T15:41:14+08:00","permalink":"https://Tyritic.github.io/p/java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%84/","title":"Java程序运行结构"},{"content":"算术运算符 一般运算符 $+$：加法 $-$：减法 $*$：乘法 $/$：除法 $%$：取余数 注意事项 整数之间相除只会得到结果的整数部分 小数直接参与运算结果可能不准确 至少有一个操作数需要是浮点类型才能得到浮点数结果 字符串的拼接操作 使用$+$让字符串前后拼接，拼接操作从左向右连续执行\n字符的加法 字符和字符的加法以及字符和整型的加法是通过将字符转换成ASCII码来进行的加法\n自增自减运算符 符号 作用 等效语句 ++ 变量加一 $a++ \\iff a=a+1$ \u0026ndash; 变量减一 $a\u0026ndash; \\iff a=a-1$ 前置与后置的区别 $$ var++ \\iff ++var \\iff var=var+1 \\\\ var-- \\iff --var \\iff var=var-1 $$ 参与计算是有区别\n后置时先使用变量的原始值计算，然后对变量加一\n1 2 3 4 5 6 int a=10; int b=a++; //结果 //a：10 //b：11 前置时先对变量加一，再使用变量的新值进行计算\n1 2 3 4 5 6 int a=10; int b=++a; //结果 //a：11 //b：11 赋值运算符 分类 符号 作用 说明 = 直接赋值 int a=10; 将10赋值给变量a += 加后赋值 a+=b; 将a+b赋值给变量a -= 减后赋值 a-=b; 将a-b赋值给变量a *= 乘后赋值 a*=b; 将a*b赋值给变量a /= 除后赋值 a/=b; 将a/b赋值给变量a %= 余后赋值 a%=b; 将a%b赋值给变量a 注意事项 底层实现中包含了强制类型转换 在表达式中所有其他运算符完成后再进行计算 关系运算符 分类 $\u0026gt;$ 大于 $\u0026lt;$ 小于 $\\leq$ 小于等于 $\\geq$ 大于等于 $==$ 等于 $!=$ 不等于 运算结果为 boolean\n逻辑运算符 一般逻辑运算符 \u0026amp; 逻辑与 全真为真 | 逻辑或 一真为真 ! 逻辑非 取反 ^ 逻辑异或 相同为假，不同为真 短路逻辑运算符 \u0026amp;\u0026amp; 逻辑与 结果与\u0026amp;相同但是具有短路效果 || 逻辑或 结果与|相同但是具有短路效果 短路效果指的是当左边的表达式可以确定最终结果那么就不会执行右边的表达式\n三元运算符 语法格式 1 (关系表达式)?(表达式1):(表达式2) 计算规则 计算关系表达式的值 判断关系表达式的运算结果 若为 true 执行表达式1 若为 false 执行表达式2 ","date":"2024-11-02T12:23:34+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6/","title":"Java的运算符"},{"content":"字面量 数据在程序中的运行格式\n字面量类型 整数类型：不带小数点的数字 浮点数类型：带小数点的数字 字符串类型：用双引号括起来的多个字符 字符类型：用单引号括起来的单个字符 布尔类型：true/false 空类型：null 基本数据类型 整型\n整型 取值范围 内存占用 byte $-2^7 到 2^7-1 $ 1 short $-2^{15} 到 2^{15}-1 $ 2 int $-2^{31} 到 2^{31}-1 $ 4 long（字面量之后加上大写L） $-2^{63} 到 2^{63}-1 $ 8 浮点数\n浮点数 取值范围 内存占用 float（字面量之后加上大写F） 4 double 8 字符\n字符 取值范围 内存占用 char 2 布尔\n布尔 取值范围 内存占用 boolean 数据类型转换 数据类型不同不能直接参与运算，需要进行类型转换后再进行运算\n隐式类型转换 将取值范围小的数据赋值给取值范围大的数据类型时，程序自动进行类型转换\n提升规则 取值范围小的数据类型和取值范围大的数据类型大的进行运算，取值范围小的数据类型先提升为取值范围大的数据类型大的再进行运算 byte，short，char在运算时直接提升为int再运算 显式类型转换 不允许直接将取值范围大的数据赋值给取值范围小的数据类型，需要开发者进行强制类型转换\n语法格式 1 目标格式 变量名 = (目标格式) 被强制类型转换的变量名 注意事项 将 double/float 强制转为 int 时会截断小数部分 Java具有常量优化机制，编译器在编译过程中，将能够在编译期确定的常量表达式直接计算并替换成结果 ","date":"2024-11-02T11:20:03+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E5%AD%97%E9%9D%A2%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","title":"Java的字面量和基本数据类型"},{"content":"执行过程 开发者编写Java源代码（ .java 文件） 编译源代码（.java文件）使用javac命令编译器将源代码转化成字节码（.class文件） 在虚拟机（JVM）上运行字节码（.class 文件），将字节码解释成机器码 在程序运行时，JVM 会监控哪些字节码被频繁调用（热点代码）。一旦识别出热点代码，JVM 会将这些代码交给 JIT 编译器进行编译，并缓存编译后的机器码。 字节码中不经常调用的部分（非热点代码）用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的 提示\n解释执行比编译执行效率差\n解释执行：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢。（类比每次给你英语让你翻译阅读）\n编译执行：在程序执行之前，整个源代码会被编译成机器码或者字节码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性较差。（类比直接给你看中文）\nJava同时具有解释性和编译性\n编译性 Java源代码首先被编译成字节码，JIT 会把编译过的机器码保存起来,以备下次使用。 JVM 加载并执行 Java 字节码文件，在执行过程中，JVM 会发现一些高频次执行的代码（热点代码），然后将这些字节码交给 JIT 编译器进行编译，生成平台相关的机器码。这样，Java 程序的性能就能得到优化，因为热点代码被 JIT 编译成了机器码，可以直接运行，而不需要每次都解释执行。 解释性：字节码中非热点部分（不经常调用的部分）用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的 跨平台性 Java程序具有在任意操作系统平台上运行\n实现原理 在运行Java程序程序的操作系统上安装一个与操作系统对应的Java虚拟机。源代码会被编译成相同的字节码，然后虚拟机根据操作系统将字节码解释成不同的机器码\nJava的运行环境 JVM（Java虚拟机） Java虚拟机用于解释Java源代码，加载Java程序。针对不同的操作系统设计有不同的Java虚拟机\nJRE（Java运行时环境） JRE全称**（Java Runtime Environment）是Java运行时环境，包含了 JVM, Java核心类库和其他支持Java程序的文件，但是不包含任何开发工具**\n组成部分 JVM（Java Virtual Machine）：执行由源代码编译后得到的Java字节码，提供了Java程序的运行环境 核心类库：标准的类库（java.lang,java.utils）供Java程序使用 其他文件：配置文件，库文件，支持JVM的运行 JDK（Java开发包） JDK全称 **（Java Development Kit）**是一组独立程序构成的集合，是用于开发Java 程序的完整开发环境，它包含了JRE，以及用于开发、调试和监控 Java 应用程序的工具。\n组成部分 JRE：JDK包含了完整的JRE，可以运行java程序 开发工具：包含编译器（javac），打包工具（jar） 附加库和文件：支持开发，文档生成 常见开发工具 javac ：Java 编译器，用于将 Java 源代码（.java 文件）编译成字节码（.class 文件）。 java ：Java 应用程序启动器，用于运行 Java 应用程序。 javadoc：文档生成器，用于从 Java 源代码中提取注释并生成 HTML 格式的 API 文档。 jar ：归档工具，用于创建和管理 JAR（Java Archive）文件。 jdb：Java 调试器，用于调试 Java 程序。 jps：Java 进程状态工具，用于列出当前所有的 Java 进程。 jstat：JVM 统计监视工具，用于监视 JVM 统计信息。 jstatd：JVM 统计监视守护进程，用于在远程监视 JVM 统计信息。 jmap：内存映射工具，用于生成堆转储（heap dump）、查看内存使用情况。 jhat：堆分析工具，用于分析堆转储文件。 jstack：线程栈追踪工具，用于打印 Java 线程的栈追踪信息。 javap：类文件反汇编器，用于反汇编和查看 Java 类文件。 jdeps：Java 类依赖分析工具，用于分析类文件或 JAR 文件的依赖关系 相互关系 JDK JRE JVM 核心类库 开发工具 ","date":"2024-11-02T10:46:06+08:00","permalink":"https://Tyritic.github.io/p/java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/","title":"Java程序的编译执行过程"},{"content":"文章存储位置 本博客的所有文章都存放在E/MyBlog/content/post文件夹中\n如何添加文章 在 content/tags/文章名 下新建文件 index.md\n命令行操作 在MyBlog主文件夹的cmd中运行以下命令\n1 hugo new content post/\u0026lt;FileName\u0026gt;/index.md 参数解释 post：所有文章保存的文件路径\nFileName为当前文章所在的文件夹名\nindex.md为当前文章的markdown文件\nindex.en.md：英文文章 index.zh-cn.md：中文文章 文章内修改 插入照片 将需要的图片放入文章的文件夹中即可\n头文字参数 data：创建时间\ndraft：是否草稿\ntitle：文章标题\nimage：博客网站的开头图片\ncategories：文章的分类\ntags：文章的标签\ndescription：文章的描述\n短代码 文章引用 在markdown文件中插入以下短代码，使用时将{}改为{{}}\n1 2 3 {\u0026lt; quote author=\u0026#34;作者\u0026#34; url=\u0026#34;作品的来源（可不填）\u0026#34; source=\u0026#34;作品名\u0026#34; \u0026gt;} 引用内容 {\u0026lt; /quote \u0026gt;} 插入B站视频 在markdown文件中插入以下短代码，使用时将{}改为{{}}\n1 {\u0026lt; bilibili VIDEO_ID PART_NUMBER \u0026gt;} 可以在B站视频的url中找到Video_ID``https://www.bilibili.com/video/BV1BPSdYHEbj/?spm_id_from=333.1007.tianma.1-2-2.click\u0026amp;vd_source=7db50a55b19a59c42ee778836913c04f\n其中VIDEO_ID：BV1BPSdYHEbj\n插入hugo notice hugo notice有以下几个类别\ntip：提示 info：引言 warning：警告 note：注解 创建方法为在markdown文件中插入短代码，使用时将{}改为{{}}\n创建Tip 1 2 3 {\u0026lt; notice tip \u0026gt;} This is a very good tip. {\u0026lt; /notice \u0026gt;} 提示\nThis is a very good tip.\n创建Info 1 2 3 {\u0026lt; notice info \u0026gt;} This is a very good info. {\u0026lt; /notice \u0026gt;} 引言\nThis is a very good info.\n创建Warning 1 2 3 {\u0026lt; notice warning \u0026gt;} This is a very bad warning. {\u0026lt; /notice \u0026gt;} 警告\nThis is a very bad warning.\n创建Note 1 2 3 {\u0026lt; notice note \u0026gt;} This is a very good note. {\u0026lt; /notice \u0026gt;} 注解\nThis is a very bad note.\n插入参考博客 直接将参考博客的网址复制到markdown文件中\nTyritic的个人博客\n创建分组（categories） 在 content/categories/分类名 下新建文件 _index.md\n可以使用命令行工具\n1 hugo new content categories/\u0026lt;分组名\u0026gt;/_index.md 参数解释 categories：所有分组的所在目录 _index.md：分组的配置文件 _ndex.en.md：英文分组 _index.zh-cn.md：中文分组 创建标签（Tags) 在 content/tags/分类名 下新建文件 _index.md\n可以使用命令行工具\n1 hugo new content tags/\u0026lt;标签名\u0026gt;/_index.md 参数解释 tags：所有标签所在的目录 _index.md：分组的配置文件 index.en.md：英文标签 index.zh-cn.md：中文标签 创建友情链接（Links) 在 content/page/links 下修改文件 _index.md，创建与GitHub同级的元素\n参数列表 title：博客显示该网站的名字 description：博客对该网站的描述 website：网站链接 image：网站的icon ","date":"2024-11-01T15:28:47+08:00","permalink":"https://Tyritic.github.io/p/%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"博客使用指南"},{"content":"Maven的作用 依赖管理：方便快捷地管理依赖\n统一项目结构：提供标准的项目结构\n项目构建：提供了标准的跨平台项目构建方式\nMaven项目的结构 1 2 3 4 5 6 7 8 9 10 Maven-name/ |--src（源代码） |\t|--main（项目实际资源） |\t|--java（java代码） |\t|--resource（资源文件） |\t|--test（测试代码资源） |\t|--java |\t|--resource |--pom.xml（依赖配置文件） |--target（打包后的jar包存放地） Maven项目模型 仓库：用于存储资源以及各种JAR包\n本地仓库：计算机上的目录 中央仓库：由Maven团队维护的仓库 私服：公司团队搭建的私有仓库 依赖管理 什么是依赖 依赖就是项目所需要的jar包\nMaven坐标 ​\tMaven坐标是依赖资源的唯一标识，可以唯一定位资源的位置，使用Maven坐标可以引入项目依赖\n组成结构 groupId：项目所属的组织名 artifactId：项目名称/模块名称 version：版本号 依赖配置 配置方法 在pom.xml文件中使用标签\u0026lt; dependencies \u0026gt; 单个依赖在\u0026lt; dependencies \u0026gt;中被\u0026lt; dependency \u0026gt; 包围 定义依赖的坐标 刷新Maven文件 提示\n若本地仓库不存在依赖则会连接私服或者中央仓库进行下载\n依赖传递 ​\t依赖具有传递性\n​\t直接依赖：在当前项目中通过依赖配置建立的依赖关系\n​\t间接依赖:被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源\n​\t依赖的传递关系可能出现冲突\n路径优先：当依赖中出现相同的资源时：层级越深优先级越低 声明优先：当资源在相同的层级被依赖，配置靠前的覆盖配置靠后的 特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的 依赖排除 ​\t依赖可以被开发者手动排除\n​\t实现形式\n在pom.xml文件中使用标签\u0026lt; exclusions \u0026gt;包围\n对于要排除的单个依赖使用标签\u0026lt; exclusion \u0026gt;包围\n提示\n排除依赖的时候无须指定版本号\n依赖范围 ​\t依赖的jar包，默认情况下，可以在任何地方使用。但是可以通过\u0026lt; scope \u0026gt; 手动指定其使用范围\n作用范围 主程序范围有效。(main文件夹范围内) 测试程序范围有效。(test文件夹范围内) 是否参与打包运行。(package指令范围内) \u0026lt;scope\u0026gt;标签的取值 scope的取值 主程序 测试程序 打包运行 举例 compile(默认) Y Y Y log4j（日志框架） test X Y X junit（单元测试） provided Y Y X servlet（三大组件） runtime X Y Y jdbc（数据库连接依赖） 生命周期 ​\tMaven中有三套独立的生命周期\nclean：清理工作 default：核心工作包括（编译，测试，打包，变更，部署） site：生成报告，发布站点 生命周期的阶段 ​\n​\t提示\n​\t同一套生命周期，后面的阶段要依托前面的阶段来执行\n​\n重要阶段 clean:移除上一次构建生成的文件 compile:编译项目源代码 test:使用合适的单元测试框架运行测试(junit) package:将编译后的文件打包，如:jar、war等 install:安装项目到本地仓库 ","date":"2024-11-01T15:28:45+08:00","permalink":"https://Tyritic.github.io/p/maven%E5%9F%BA%E7%A1%80/","title":"Maven基础"},{"content":"网络应用程序的常见架构 客户端—服务器结构（CS结构） 设置一台或多台高性能计算机（服务器集群）作为服务端，接受其他主机（客户端）的请求 服务端总是打开，并具有固定的地址 客户端之间 不能直接通信 需要安装特定的客户端软件，该客户端需要承担部分业务逻辑 浏览器—服务器结构（BS结构） 客户端仅使用浏览器（Browser）作为访问入口，完成不需要安装额外的软件。 所有的业务逻辑和数据处理都在服务器端（Server） 点对点结构（P2P结构） P2P（Peer-to-Peer）架构是一种去中心化的网络架构，每个节点（Peer）既可以作为客户端（请求资源），也可以作为服务器（提供资源），节点之间可以直接通信、共享资源，而无需依赖中央服务器。\n对服务器具有最小依赖 具有自拓展性 ：网络能够随着节点（Peer）数量的增加，自主扩展计算能力、存储容量和带宽，而不依赖中央服务器。每个对等节点都由于接受请求产生工作负荷，但是每个对等节点向其他对等节点分发文件也为系统增加服务能力 进程与网络之间的接口（Socket） Socket（套接字） 是计算机网络中用于 进程间通信（IPC, Inter-Process Communication） 的一种机制，它可以让不同计算机上的进程通过网络进行通信。Socket 提供了一种标准化的接口，使应用程序能够发送和接收数据，而不需要关心底层网络协议的实现细节。\n超文本传输协议（HTTP） HTTP（超文本传输协议，HyperText Transfer Protocol） 是一种 无状态、基于请求-响应模式 的 应用层协议 ，用于在 Web 浏览器和服务器之间 传输数据，如 HTML 页面、图片、视频等。\nHTTP 是 互联网的基础协议，它构建在 TCP/IP 协议 之上，使得客户端（如浏览器）和服务器可以相互通信。默认端口为 80\nURI和URL URI(Uniform Resource Identifier) 全称是统一资源标志符，可以唯一标识一个资源。 URL(Uniform Resource Locator) 全称是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。 基本工作模型 基于 请求—响应 模型进行工作，客户端向服务器发送 HTTP Request（请求），服务器响应请求并返回 HTTP Response（响应）\nHTTP客户端先建立与服务端的TCP连接\n浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。 服务器接收来自浏览器的 TCP 连接。 客户端进程和服务器进程通过 Socket 访问网络连接\n客户端从 Socket 发出请求并接受响应 服务端从 Socket 接受请求并发送响应 协议特点 无状态协议 ：HTTP 协议是 无状态 的协议，它无法记录客户端用户的状态，一般我们都是通过 Session 来记录客户端用户的状态。 明文传输 ：默认情况下数据不加密，容易被监听（可用 HTTPS 加密）。 基于请求—响应机制 ：客户端发送请求，服务器返回响应。 可靠传输 ：HTTP 通过 TCP协议（三次握手） 确保可靠传输。 HTTP状态码 状态码由 3 位数字组成，第一位定义 响应的类别\n1xx: 信息响应\n100 Continue：服务器已接收请求的初步部分，客户端应继续请求。\n101 Switching Protocols：服务器同意切换协议，如从 HTTP 切换到 WebSocket。\n2xx: 成功\n200 OK：请求成功，服务器返回所请求的资源或数据。\n201 Created：请求成功并创建了新的资源，常用于 POST 请求。\n204 No Content：请求成功但服务器不返回任何内容，常用于删除操作。\n206 Partial Content ：应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。\n3xx: 重定向\n301 Moved Permanently：资源已永久移动到新的 URL，客户端应使用新 URL 访问。\n302 Found：资源临时移动到新的 URL，客户端应继续使用原来的 URL。搜索引擎会抓取新的内容而保存旧的网址并认为新的网址只是暂时的。\n304 Not Modified：资源未修改，客户端可以使用缓存版本。\n4xx: 客户端错误\n400 Bad Request：请求无效或语法错误，服务器无法处理。\n401 Unauthorized：请求需要身份验证，客户端未提供有效的凭证。\n403 Forbidden：服务器理解请求但拒绝执行，通常是权限问题。\n404 Not Found：请求的资源在服务器上未找到。\n5xx: 服务器错误\n500 Internal Server Error：服务器内部错误，无法完成请求。\n501 Not Implemented ：客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。\n502 Bad Gateway：服务器作为网关或代理，从上游服务器接收到无效响应。\n503 Service Unavailable：服务器暂时无法处理请求，通常是因为过载或维护。\n提示\n重定向机制的区别 301 Moved Permanently ：用于临时重定向，不会更新书签。 302 Found ：用于永久重定向，通常会更新客户端的书签 HTTP请求方法 GET ：用于请求获取指定资源，通常用于获取数据。 GET 请求的参数位置一般是写在 URL 中，但是浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。 POST ：用于向服务器提交数据，通常用于提交表单数据或进行资源的创建。 POST 请求携带数据的位置一般是写在报文请求体 body 中，请求体中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对请求体大小做限制。 PUT ：用于向服务器更新指定资源，通常用于更新已存在的资源。 DELETE ：用于请求服务器删除指定资源。 HEAD ：类似于GET请求，但只返回资源的头部信息，用于获取资源的元数据而不获取实际内容。 提示\nGET 和 POST 的区别\n定义 GET：用于获取资源，通常用于请求数据而不改变服务器状态。 POST：用于提交数据到服务器，通常会改变服务器的状态或产生副作用（如创建或更新资源）。 参数传递方式 GET：参数通过 URL 拼接传递，暴露在请求 URL 中，具有可见性，长度有限（取决于浏览器和服务器）。 POST：参数放在请求体中，通常不可见且长度理论上没有限制，更适合传递大量数据或敏感信息（但是注意，POST 也可以在 URL 上放参数！）。 安全性 数据安全性 GET：参数可见，数据容易暴露在浏览器历史记录、日志和缓存中，不适合传递敏感信息。 POST：数据放在请求体中，相对安全，但需要 HTTPS 才能保证数据加密传输。 HTTP定义：在 HTTP 协议里，所谓的 安全 是指请求方法不会 破坏 服务器上的资源。 GET ：是 只读 操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。 POST ：是 新增或提交数据 的操作，会修改服务器上的资源 幂等性：多次执行相同的操作，结果都是相同的 GET ：GET 具有幂等性，GET 是 只读 操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。（重复请求不会改变服务器状态）。 POST ：POST 具有非幂等，POST 是 新增或提交数据 的操作，会修改服务器上的资源（多次请求可能导致重复创建资源或执行多次相同操作） 缓存机制 GET ：可以对 GET 请求的数据做缓存，当请求同一个 URL 时可以直接返回缓存内容，减少服务器负载。适用于不频繁变动的资源，比如图片、静态页面。 缓存可以做到浏览器本身上（彻底避免浏览器发请求） 缓存可以做到代理上，而且在浏览器中 GET 请求可以保存为书签。 POST ：POST 请求默认不缓存，大部分浏览器和缓存服务器不缓存 POST 请求，主要因为 POST 请求通常会对服务器数据产生影响（如创建、修改数据），需要确保请求每次都传递到服务器。 HTTP报文格式 请求报文 HTTP 请求报文由三个部分组成(请求行+请求头+请求体)\n请求行 （红色部分） ：请求报文的第一行 请求方法（如GET、POST ） 请求的资源路径 URI HTTP协议版本（如HTTP/1.1）。 请求头（深黄色部分）：以键值对的形式表现，用于传递客户端环境、请求内容、认证信息等。 实体头部 ：描述请求体的头部 Content-Length ：表明本次请求的数据长度。用于服务端进行拆包 当客户端发送一个HTTP请求时，会在请求头中添加 Content-Length 字段，该字段的值表示请求正文的字节数。服务器在接收到请求后，会根据 Content-Length 字段的值来确定请求的长度，并从请求中读取相应数量的字节，直到读取完整个请求内容。这种基于 Content-Length 字段的拆包机制可以确保服务器正确接收到完整的请求，避免了请求的丢失或截断问题。 Content-Type ：请求体的多媒体类型（用于 POST 和 PUT 请求中） 通用头部：适用于请求和响应 Cache-Control ：用来指定在这次的请求/响应链中的所有缓存机制都必须 遵守的指令 Connection ：该浏览器想要优先使用的连接类型（持久连接还是非持久连接） 请求头部：特定于请求的头部 Host ：客户端发送请求时，用来指定服务器的域名。 User-Agent ：浏览器的浏览器身份标识字符串 Accept ：能够接受的回应内容类型（Content-Types）。 Accept-Encoding ：能够接受的编码方式列表 Accept-Language ：能够接受的回应内容的自然语言列表。 Cookie ：服务器通过 Set-Cookie发送的一个超文本传输协议 Cookie Authorization ：用于超文本传输协议的认证的认证信息 空行：用于分隔请求头和请求体。 请求体：仅在POST、PUT等方法中存在，包含需要发送到服务器的数据。 表单数据（Form Data）：application/x-www-form-urlencoded，用于提交表单数据。 多部分数据（Multipart Data）：multipart/form-data，用于上传文件或复杂表单数据。 JSON数据：application/json ，用于提交JSON格式的数据。 XML数据：application/xml ，用于提交XML格式的数据。 文本数据：text/plain ，用于提交纯文本数据。 请求解析过程\n请求行解析：根据 HTTP 请求的第一行（请求行），服务器首先解析出请求方法、请求 URI 和协议版本。 请求头解析：请求头的格式为 key: value，可以通过换行符来分隔每一行的头部信息。头部信息指示了客户端的行为、首选内容类型、缓存控制等。 请求体解析：对于包含请求体的请求（如 POST 或 PUT），服务器需要解析请求体的内容。通常，内容类型会告知服务器如何解析请求体。 请求路由与处理：HTTP 请求中的 URI 部分会被用来进行路由匹配，决定请求应该被哪个资源或处理程序处理。 生成 HTTP 响应：服务器处理请求后，会生成一个 HTTP 响应 发送 HTTP 响应：服务器将构造好的 HTTP 响应通过 TCP 连接返回给客户端。客户端接收到响应后，会根据状态码和响应头判断如何处理响应体 响应报文 HTTP响应报文由三个部分组成(响应行,响应头,响应体)\n响应行（红色部分）：响应报文的第一行 HTTP协议版本 状态码：用于描述响应结果 描述 响应头（黄色部分）：以键值对形式表现 Set-Cookie ：服务端可以设置客户端的cookie Connection ：该浏览器想要优先使用的连接类型 响应体（绿色部分）：存放响应数据 HTTP缓存技术 对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都缓存在本地，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。\n强制缓存 强制缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存。由浏览器决定是否使用缓存的主动性。\n实现方式\n强制缓存是利用HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：\nCache-Control ：是一个相对时间 Expires ：是一个绝对时间 工作流程\n当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在请求头部加上 Cache-Control ，Cache-Control 中设置了过期时间大小； 浏览器再次请求访问服务器中的该资源时，会先 通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期 ，如果没有，则使用该缓存，否则重新请求服务器； 服务器再次收到请求后，会再次更新请求头的 Cache-Control。 协商缓存 通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。\n实现方式\n响应头部中 Etag ：唯一标识响应资源 请求头部中的 If-None-Match ：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304（允许使用本地缓存），如果资源变化了返回 200。 工作流程\n当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在请求头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的 当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期： 如果没有过期，则直接使用本地缓存； 如果缓存过期了，会在请求头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识； 服务器再次收到请求后，会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较 如果值相等代表服务器中的资源未被修改，则返回 304 Not Modified，不会返回资源 如果不相等代表服务器中的资源被修改，则返回 200 状态码和返回资源，并在请求头部加上新的 ETag 唯一标识； 如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。 HTTP版本 HTTP1.0版本 无状态协议：HTTP 1.0 是无状态的，每个请求之间相互独立，服务器不保存任何请求的状态信息。 非持久连接：默认情况下，每个 HTTP 请求/响应对之后，连接会被关闭，属于短连接。这意味着对于同一个网站的每个资源请求，如 HTML 页面上的图片和脚本，都需要建立一个新的 TCP 连接。可以设置 Connection: keep-alive 强制开启长连接。 HTTP1.1版本 新增特性\n默认使用长连接即 keep—alive ，允许持久连接。只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。\n支持 pipeline，在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以 减少整体的响应时间。 但是服务器必须按照接收请求的顺序发送对这些管道化请求的响应（队尾堵塞）。\n允许响应数据分块（chunked)，即响应的时候不标明 Content-Length ，客户端就无法断开连接，直到收到服务端的 EOF ，利于传输大文件。\n新增缓存的控制和管理。\n请求头中加入了 Host 字段：解决了域名系统（DNS）允许多个主机名绑定到同一个 IP 地址上，而请求报文无法指出所请求的主机名的问题\n范围请求：HTTP/1.1 引入了范围请求（range request）机制，以避免带宽的浪费。当客户端想请求一个文件的一部分，或者需要继续下载一个已经下载了部分但被终止的文件，HTTP/1.1 可以在请求中加入 Range 头部，以请求（并只能请求字节型数据）数据的一部分。\n性能瓶颈\n请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分； 发送冗长的首部。每次互相发送相同的首部造成的浪费较多； 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞； 没有请求优先级控制； 请求只能从客户端开始，服务器只能被动响应。 优化思路\n避免发送HTTP请求 实现方案：采用缓存技术，对于一些具有重复性的 HTTP 请求，可以把这对请求-响应的数据都缓存在本地，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了 减少HTTP响应数据大小 实现方案 无损压缩（适合用在文本文件、程序可执行文件、程序源代码）、 有损压缩（压缩多媒体数据） 减少 HTTP 请求的次数 实现方案 减少重定向请求：将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数 合并请求：将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输，再来减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗 HTTP2.0版本 新增特性\n二进制帧：相较于HTTP/1.1 则使用文本格式的报文，HTTP 2.0 使用二进制而不是文本格式来传输数据，解析更加高效。 多路复用：一个 TCP 连接上可以同时进行多个 HTTP 请求/响应，解决了 HTTP 1.x 的队头阻塞问题。 头部压缩：HTTP 协议不带状态，所以每次请求都必须附上所有信息。HTTP 2.0 引入了头部压缩机制，可以使用 gzip 或 compress 压缩后再发送，减少了冗余头部信息的带宽消耗。 服务端推送：服务器可以主动向客户端推送资源，而不需要客户端明确请求。 优先级设置 ：HTTP2.0支持优先级设置 底层实现\nStream ：一个TCP连接中包含多条 Stream ，一个 Stream中包含一对请求响应报文 Message ：请求或响应报文 Frame ：Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体） 在 HTTP/2 连接上，不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ），因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，而同一 Stream 内部的帧必须是严格有序的。\n客户端和服务器双方都可以建立 Stream ，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。\nHTTP/2 还可以对每个 Stream 设置不同 优先级\nHTTP3.0版本 传输协议：HTTP/2.0 是基于 TCP 协议实现的，HTTP/3.0 新增了 QUIC（Quick UDP Internet Connections） 协议来实现可靠的传输，提供与 TLS/SSL 相当的安全性，具有较低的连接和传输延迟。你可以将 QUIC 看作是 UDP 的升级版本，在其基础上新增了很多功能比如加密、重传等等。HTTP/3.0 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。 连接建立：HTTP/2.0 需要经过经典的 TCP 三次握手过程（由于安全的 HTTPS 连接建立还需要 TLS 握手，共需要大约 3 个 RTT）。由于 QUIC 协议的特性（TLS 1.3，TLS 1.3 除了支持 1 个 RTT 的握手，还支持 0 个 RTT 的握手）连接建立仅需 0-RTT 或者 1-RTT。这意味着 QUIC 在最佳情况下不需要任何的额外往返时间就可以建立新连接。 队头阻塞：HTTP/2.0 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。由于 QUIC 协议的特性，HTTP/3.0 在一定程度上解决了队头阻塞问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。 连接迁移：HTTP/3.0 支持连接迁移，因为 QUIC 使用 64 位 ID 标识连接，只要 ID 不变就不会中断，网络环境改变时（如从 Wi-Fi 切换到移动数据）也能保持连接。而 TCP 连接是由（源 IP，源端口，目的 IP，目的端口）组成，这个四元组中一旦有一项值发生改变，这个连接也就不能用了。 安全性：在 HTTP/2.0 中，TLS 用于加密和认证整个 HTTP 会话，包括所有的 HTTP 头部和数据负载。TLS 的工作是在 TCP 层之上，它加密的是在 TCP 连接中传输的应用层的数据，并不会对 TCP 头部以及 TLS 记录层头部进行加密，所以在传输的过程中 TCP 头部可能会被攻击者篡改来干扰通信。而 HTTP/3.0 的 QUIC 对整个数据包（包括报文头和报文体）进行了加密与认证处理，保障安全性。 HTTPS协议 HTTP 是明文传输的，存在数据窃听、数据篡改和身份伪造等问题。而 HTTPS 通过引入 SSL/TLS 解决安全性问题，HTTPS 默认端口号是 443\n信息加密：交互信息无法被窃取。 校验机制：无法篡改通信内容，篡改了就不能正常显示。 身份证书：证明身份。 加密机制 混合加密 HTTPS 采用的是对称加密和非对称加密结合的混合加密方式实现消息的机密性，保证消息不被窃听\n在通信建立前（TLS四次握手）采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。 在通信过程（后续加密通信）中全部使用对称加密的「会话秘钥」的方式加密明文数据。 提示\n非对称加密和对称加密\n对称加密：双方用会话密钥加密通信内容。 非对称加密：服务器向客户端发送公钥，然后客户端用公钥加密自己的随机密钥，也就是会话密钥，发送给服务器，服务器用私钥解密，得到会话密钥。 密钥类型 公钥：负责加密 私钥：负责解密 用公钥加密过的密文只有私钥才能解密，用私钥加密过的密文只有公钥才能解密 公钥加密，私钥解密。这个目的是为了保证内容传输的安全，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容； 私钥加密，公钥解密。这个目的是为了保证消息不会被冒充，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。 相较于对称加密，非对称加密的速度慢 数字签名和摘要算法 HTTPS 采用的是 数字签名 和 摘要算法 实现消息的完整性，保证消息不被篡改\n摘要算法 用于保证消息的 完整性\n计算机里会 用摘要算法（哈希函数）来计算出内容的哈希值 ，也就是内容的摘要，这个哈希值是唯一的，且无法通过哈希值推导出内容，然后将内容和哈希值一同发送。对方收到后，先是对内容也计算出一个摘要，然后跟发送方发送的摘要做一个比较，如果摘要相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。\n数字签名 用于保证消息保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）\n数字签名算法利用非对称加密的机制，服务器用私钥对内容的哈希值进行加密，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。\n数字证书 由于客户端的公钥可以被替换或者伪造，导致在通信时攻击者可以使用与自己私钥配对的公钥替换客户端的公钥然后与客户端进行通信\n数字证书 用于保证公钥无法被伪造或者替换\n服务器将自己的公钥注册到数字证书认证机构（CA） CA 使用自己的私钥将服务器的公钥进行加密 客户端拿到服务器的数字证书后，使用CA的公钥确认服务器的数字证书的真实性 客户端从数字证书获取服务器公钥后，使用已被验证的公钥进行加密后发送 服务器用私钥对报文解密 生活例子解释 你想向老师请假，一般来说是要求由家长写一份请假理由并签名，老师才能允许你请假\n这里的老师对应于客户端，家长对应服务端，你对应一名攻击者。\n为什么需要数字签名？\n假设你有模仿家长字迹的能力，你用家长的字迹写了一份请假条然后签上你爸爸的名字，老师一看到这个请假条，查看字迹和签名，就误以为是家长写的，就会允许你请假。\n引入了数字签名算法后，你就无法模仿家长的字迹来请假了，家长手上持有着私钥，老师持有着公钥。\n其中请假条中的签名对于数字签名，字迹对应内容\n这样只有用家长手上的私钥才对请假条进行签名，老师通过公钥看能不能解出这个签名，如果能解出并且确认内容的完整性，就能证明是由家长发起的请假条，这样老师才允许你请假，否则老师就不认。\n为什么需要数字证书？\n虽然家长持有私钥，老师通过是否能用公钥解密来确认这个请假条是不是来源你父亲的。但是我们还可以自己伪造出一对公私钥啊！\n你找了个夜晚，偷偷把老师桌面上和你爸爸配对的公钥，换成了你的公钥，那么下次你在请假的时候，你继续模仿你爸爸的字迹写了个请假条，然后用你的私钥做个了「数字签名」。\n但是老师并不知道自己的公钥被你替换过了，所以他还是按照往常一样用公钥解密，由于这个公钥和你的私钥是配对的，老师当然能用这个被替换的公钥解密出来，并且确认了内容的完整性，于是老师就会以为是家长写的请假条，又允许你请假了。\n通信过程 第一阶段是TLS四次握手，这一阶段主要是利用非对称加密的特性各种交换信息，最后得到一个\u0026quot;会话秘钥\u0026quot;。\n第二阶段是则是在第一阶段的\u0026quot;会话秘钥\u0026ldquo;基础上，进行对称加密通信。\n第一次握手：由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。 客户端支持的 TLS 协议版本，如 TLS 1.2 版本。 客户端生产的随机数 （Client Random） ，后面用于生成「会话秘钥」条件之一。 客户端支持的密码套件列表，如 RSA 加密算法。 第二次握手：服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello 响应 确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。 服务器生产的随机数 （Server Random） ，也是后面用于生产「会话秘钥」条件之一。 确认的密码套件列表，如 RSA 加密算法。 服务器的数字证书，包含被CA私钥加密过的服务器公钥。 第三次握手：客户端收到服务器的回应之后，通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息： 一个随机数 （pre-master key） ：该随机数由客户端生成，并被服务器公钥加密。 会话密钥： 客户端这边已经拥有三个随机数：客户端随机数，服务器随机数和 pre_master_key ，用这三个随机数进行计算得到一个会话秘钥\u0026quot;。此时客户端通知服务端，后面会用这个会话秘钥进行对称机密通信。 内容摘要：客户端会把迄今为止的通信数据内容生成一个摘要，用 会话秘钥 加密一下，发给服务器做校验，此时客户端这边的握手流程就结束了，因此也叫Finished报文。 第四次握手：服务器收到客户端的第三个随机数 （pre-master key） 之后，通过协商的加密算法，计算出本次通信的 会话秘钥 。 会话密钥：服务端此时拿到客户端传来的 pre_master_key（虽然被服务器公钥加密过，但服务器有私钥，能解密获得原文），集齐三个随机数，跟客户端一样，用这三个随机数通过同样的算法获得一个\u0026rdquo;会话秘钥\u0026quot;。此时服务器告诉客户端，后面会用这个\u0026quot;会话秘钥\u0026quot;进行加密通信。 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。 DNS（域名解析协议） DNS的全称是Domain Name System（域名系统），它是互联网中用于将域名转换为对应IP地址的分布式数据库系统。\nDNS 是应用层协议，基于 UDP 协议之上，端口为 53 。\nDNS服务器 根 DNS 服务器：根 DNS 服务器提供 TLD 服务器的 IP 地址。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。 顶级域 DNS 服务器（TLD 服务器）：顶级域是指域名的后缀，如com、org、net和edu等。国家也有自己的顶级域，如uk、fr和ca。TLD 服务器提供了权威 DNS 服务器的 IP 地址。 权威 DNS 服务器：在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。 本地 DNS 服务器：每个 ISP（互联网服务提供商）都有一个自己的本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 层次结构中。严格说来，不属于 DNS 层级结构 域名解析过程 域名解析请求：用户在浏览器中输入一个域名，浏览器首先检查本地缓存（如果有的话）是否存有该域名的 IP 地址。 本地DNS解析：如果本地缓存中没有所需的 IP 地址，浏览器会向配置的 本地 DNS 服务器 发送请求。若存在则直接返回 根DNS解析 ：如果 本地DNS服务器 中没有所需的 IP 地址，本地 DNS 服务器 向 根DNS服务器 发出请求，查询 根DNS 以获取 顶级域（TLD）的 DNS 地址。 根DNS 负责将 顶级域DNS 的IP地址发回到 本地DNS 。 顶级域DNS解析 ：本地DNS 向 顶级域DNS 发出请求，查询 顶级域DNS 以获取 权威DNS 地址。 顶级域DNS 负责将 权威DNS 的IP地址发回到 本地DNS 。 权威DNS解析 ：本地DNS 向 权威DNS 发出请求，查询 权威DNS 以获取 域名对应的IP地址 。 权威DNS 负责将 域名对应的IP地址 发回到 本地DNS 。 浏览器缓存该 IP 地址以供后续请求使用，并通过 IP 地址连接到目标服务器以访问网站内容 RPC（远程过程调用） RPC（Remote Procedure Call），又叫做远程过程调用。它本身并不是一个具体的协议，而是一种调用方式。\n服务发现 在 HTTP 中，你知道服务的域名，就可以通过 DNS 服务去解析得到它背后的 IP 地址，默认 80 端口。\n而 RPC 的话，就有些区别，一般会有专门的中间服务去保存服务名和IP信息，比如 Consul 或者 Etcd，甚至是 Redis。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 DNS 也是服务发现的一种，所以也有基于 DNS 去做服务发现的组件，比如CoreDNS。\n底层连接形式 主流的 HTTP/1.1 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（Keep Alive），之后的请求和响应都会复用这条连接。\n而 RPC 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个连接池，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。\nWebSocket WebSocket 适用于需要实时通信和双向数据流的场景，而 HTTP 更适合于传统的客户端与服务器之间的短时请求响应场景。\nWebSocket 是一种基于 TCP 连接的全双工通信协议，即客户端和服务器可以同时发送和接收数据。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。\n提示\n全双工和半双工的概念\n全双工 ：同一时间里，双方都可以主动向对方发送数据。 半双工 ：同一时间里，客户端和服务器只能有一方主动发数据 与HTTP的区别 WebSocket 是一种双向实时通信协议，客户端和服务器建立持久连接后，双方可以随时发送消息，直到主动关闭连接 HTTP 是一种单向通信协议。HTTP 协议基于请求/响应模型，下的通信只能由客户端发起，服务器无法主动通知客户端 HTTP轮询和长轮询 为了实现类似服务器主动发送消息给客户端的场景，有HTTP轮询和长轮询两种实现方案\nHTTP轮询 网页的前端代码里不断定时发 HTTP 请求到服务器，服务器收到请求后给客户端响应消息。。这是一种伪实现。本质上并不是服务器主动发消息到客户端，而是客户端自己不断偷偷请求服务器，只是用户无感知而已。\n缺点\n消耗带宽，同时也会增加下游服务器的负担。 使用体验上会出现 明显的卡顿 ，用户需要等个 1~2 秒，正好才触发下一次 HTTP 请求 长轮询 将HTTP 请求的 超时时间设置的很大 ，比如 30 秒，在这 30 秒内只要服务器收到了请求，就立马返回给客户端。如果超时，那就立马发起下一次请求。\n这样就减少了 HTTP 请求的个数，并且由于大部分情况下，响应也是及时的。\nWebSocket握手过程 客户端向服务器发送一个 HTTP 请求，请求头中包含 Upgrade: websocket 和 Sec-WebSocket-Key 等字段，表示要求升级协议为 WebSocket ； Upgrade: websocket ：请求升级协议到 WebSocket Sec-WebSocket-Key ：随机生成的 base64 码 服务器收到这个请求后，会进行升级协议的操作，如果支持 WebSocket，它将回复一个 HTTP 101 状态码，响应头中包含 ，Connection: Upgrade 和 Sec-WebSocket-Accept: xxx 等字段、表示成功升级到 WebSocket 协议。 Connection: Upgrade ：支持协议切换 Sec-WebSocket-Accept ：根据客户端生成的 Sec-WebSocket-Key ，用 公开的 算法变成另一段字符串 客户端也用同样的公开算法将 Sec-WebSocket-Key 转成另一段字符串，如果这段字符串跟服务器传回来的 Sec-WebSocket-Accept 一致，那验证通过。客户端和服务器之间建立了一个 WebSocket 连接，可以进行双向的数据传输。 数据以帧（frames）的形式进行传送，WebSocket 的每条消息可能会被切分成多个数据帧（最小单位）。发送端会将消息切割成多个帧发送给接收端，接收端接收消息帧，并将关联的帧重新组装成完整的消息。 客户端或服务器可以主动发送一个关闭帧，表示要断开连接。另一方收到后，也会回复一个关闭帧，然后双方关闭 TCP 连接。 Tomcat服务器 基本使用 启动Tomcat服务器：双击Tomcat服务器目录下的bin\\startup.bat\n关闭Tomcat服务器\nCTRL+C：正常关闭 直接关闭运行窗口：强制关闭 双击Tomcat服务器目录下的bin\\shutdown.bat：正常关闭 部署项目：将应用放入webapps目录下\nTomcat服务器的目录结构 1 2 3 4 5 6 7 8 Tomcat/ |--bin（可执行文件） |--conf（配置文件） |--lib（Tomcat依赖的jar包） |--logs（日志文件） |--temp（测试代码资源） |--webapps（应用发布目录） |--resource（工作目录） ","date":"2024-06-09T10:51:40+08:00","permalink":"https://Tyritic.github.io/p/%E5%BA%94%E7%94%A8%E5%B1%82%E5%92%8Chttp%E5%8D%8F%E8%AE%AE/","title":"应用层和HTTP协议"},{"content":"网络中的常见设备 主机（host） 主机（Host） 是指连接到网络并能够发送或接收数据的设备。\n常见的主机类型 个人计算机（PC）\n普通用户使用的台式机或笔记本电脑。\n通过有线（以太网）或无线（Wi-Fi）方式连接到网络。\n服务器（Server）\n提供网络服务的计算机，如Web服务器、数据库服务器、云服务器等。\n运行稳定性和计算能力较强，可同时为多个客户端提供服务。\n常见操作系统：Windows Server、Linux（Ubuntu、CentOS等）。\n物联网设备（IoT Devices）\n连接到互联网的智能设备，如智能家居、传感器、工业控制系统等。\n资源有限，通常使用轻量级协议（如MQTT、CoAP）进行通信。\n移动设备（Mobile Devices）\n智能手机、平板电脑等设备，也可以作为主机接入网络。\n主要通过Wi-Fi或蜂窝网络（4G/5G）访问互联网。\n交换机（Switch） 交换机（Switch） 是一种二层（数据链路层）或三层（网络层）网络设备，用于在局域网（LAN）中连接多个设备，并根据MAC地址或IP地址高效地转发数据。交换机没有MAC地址\n主要功能 数据转发：接收数据帧，并根据目标MAC地址决定将其发送到哪个端口，而不是像集线器（Hub）那样广播给所有设备。 流量管理：通过 全双工通信 ，同时支持数据的发送和接收，减少网络冲突，提高带宽利用率。 地址学习（MAC表）：存储设备的MAC地址和端口映射关系，智能决定数据流向。 常见交换机类型 二层交换机（L2 Switch）：依据MAC地址转发数据，不具备IP路由功能，适用于小型局域网 三层交换机（L3 Switch）：结合路由功能，能根据IP地址转发数据包，适用于大型网络。 路由器（Router） 路由器（Router） 是一种 网络层（第三层）设备 ，用于连接不同的网络，并根据 IP地址 确定数据包的最佳传输路径。它是互联网通信的核心设备，负责数据的转发和寻址。\n主要功能 IP地址转发：根据数据包的目标IP地址，选择最佳路径进行转发。 网络隔离：不同的网络（如家庭网络和外部互联网）通过路由器进行连接和隔离。 NAT（网络地址转换）：允许多个设备共享一个公网IP上网。 DHCP（动态主机配置协议）：自动分配IP地址，简化网络配置。 集线器（Hub） 集线器（Hub） 是一种 物理层（第一层） 的网络设备，用于在局域网（LAN）内连接多个设备。它的主要作用是广播（Broadcast）数据，即收到数据后，会将其发送到所有端口，而不进行智能转发或流量管理。作为接收方的主机发现Mac地址不是自己会忽略该数据包\n主要功能 信号复制：收到数据后，将其广播到所有端口。 物理连接：提供多个端口，用于连接计算机、打印机等设备。 放大信号（部分型号）：用于延长网络传输距离（称为中继器集线器） 分组交换技术 分组交换（Packet Switching） 是一种将数据拆分成多个小数据包，并独立传输到目标地址的通信方式。它不需要建立固定的通信路径，而是根据网络的实时状态选择最优路径，从而提高资源利用率和网络可靠性。\n存储转发机制 交换机或路由器开始向链路传输该分组的第一个比特之前必须接受整个分组\n工作流程 数据拆分：将大数据拆分为多个小的数据包（Packet）。 数据打包：每个数据包包含源地址、目标地址和序列号，确保数据按顺序重组。 动态路由：每个数据包独立选择路径，可能走不同的路。 数据包重组：接收端根据序列号重新组装数据，恢复原始信息。 优缺点 优点\n无建立时延 ：通信前无须建立间接，用户可以随时发送分组 线路利用率高 ：分组在哪段链路上传送时才占用这段链路的通信资源。相比采用电路交换传送突发式的计算机数据，分组交换的通信线路利用率大大提高。 简化了存储管理（相对于报文交换）：因为分组的长度固定，相应缓冲区的大小也固定，在交换结点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易。 加速传输 ：分组是逐个传输的，可以使后一个分组的存储操作与前一个分组的转发操作并行，这种流水线方式减少了报文的传输时间。此外，传输一个分组比传输一次报文所需的缓冲区小得多，这样，因缓冲区不足而等待发送的概率及时间必然也少得多。 减小了出错概率和重发数据量 ：因为分组较短，其出错概率必然减小，所以每次重发的数据量也就大大减少，这样不仅提高了可靠性，而且减小了传输时延。 缺点\n存在存储转发时延 ：尽管分组交换比报文交换的传输时延小，但相对于电路交换仍存在存储转发时延，且其结点交换机必须具有更强的处理能力。 需要传输额外的信息量 ：每个小数据段都要加上控制信息以构成分组，这使得传送的信息量增大，进而使得控制复杂，降低了通信效率，增大了处理的时延。 当分组交换网采用数据报服务时，可能出现失序、丢失或重复分组的情况 ：分组到达目的结点时，要对分组按编号进行排序等工作， 应用场景 互联网通信（如网页浏览、电子邮件、社交网络） VoIP（网络电话） 视频流（如YouTube、Netflix） 无线通信（4G/5G） 电路交换技术 电路交换（Circuit Switching） 是指在通信开始前，必须建立一个固定的端到端通信路径（电路），预留好了通信所需资源，并在整个通信过程中保持该路径。\n复用技术 在电路交换中，复用指的是将多个用户或通信流的信号合并到一个物理路径上，并根据需要将其分开进行通信。在通信过程中，虽然多个通信流共享同一条物理线路，但每个用户都能获得一个独占的虚拟通道，在会话期间保持通道的占用。\n常见的复用技术\n时分复用（TDM, Time Division Multiplexing） 时分复用技术将一个物理信道按时间划分为多个时隙，每个通信会话在不同的时隙内传输数据。这样，多个用户或信号可以交替使用同一通道，但每个用户在其专有的时间段内使用该通道。 频分复用（FDM, Frequency Division Multiplexing） 频分复用技术将可用的传输带宽划分为多个频带，每个通信会话被分配到一个独立的频带上进行传输。每个频带相当于一个独立的虚拟信道，每个用户在自己分配的频带内进行通信。 工作流程 建立连接（拨号和呼叫建立阶段）：系统为通信双方预留一条专用电路。 数据传输（通信阶段）：数据沿固定路径传输，保证稳定性。 释放连接（挂断阶段）：通话结束后，释放电路资源。 优缺点 优点\n通信质量稳定：由于通话期间通道被独占，不会有其他用户占用带宽。 延迟低：不需要数据包排序或重组，数据按固定路径流动，时延较小。 适用于实时通信：如传统电话、专线通信等。 缺点\n资源利用率低，即使通话双方没有发送数据，通信通道仍然被占用 通信时延 节点总时延=节点处理时延+排队时延+传输时延+传播时延\n节点处理时延 检查分组首部以及决定分组导向何处所需时间\n排队时延 分组在链路上等待传输所需的时间\n传输时延 将所有分组推向链路的时延\n传播时延 从链路的起点到交换机所需的时间\nOSI七层协议模型 协议：定义了在两个或多个通信实体之间交换的报文格式和顺序，以及报文发送或接受报文或其他事件所采取的动作\n计算机网络的协议采用分层架构。每一层都依赖于上层提供的服务并向下层提供服务。（通常以物理层为第一层，作为最下层）\n当数据从设备发出时，数据从应用层逐层向下传递，每一层会对数据进行封装，增加自己的头部信息，以便下一层能够正确地识别、处理和传输数据。\n当数据到达目标设备时，数据从物理层逐层向上传递，每一层会进行 解封装，提取出属于该层的数据部分，并将其传递给上一层，直到最终到达应用层。\n每一层分工明确\n应用层 ：为计算机用户提供服务，给应用程序提供统一的接口 表示层 ：数据处理(编解码、加密解密、压缩解压缩)，使得通信的应用程序能够解释交换数据的含义 会话层 ：管理（建立、维护、重连）表示层实体之间的会话 传输层 ：负责端到端的数据传输，为两台主机进程之间的通信提供通用的数据传输服务 网络层 ：负责数据的路由、转发、分片，决定数据在网络的游走路径 数据链路层 ：负责数据的封帧和差错检测，以及 MAC 寻址 物理层 ：负责在物理网络中传输数据帧，透明地传送比特流传输 提示\n网络模型为什么要采用分层模型\n各层之间相互独立：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）。这个和我们对开发时系统进行分层是一个道理。 提高了灵活性和可替换性：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。并且，每一层都可以根据需要进行修改或替换，而不会影响到整个网络的结构。这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。 问题分解：分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 这个和平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。 应用层 应用层 是OSI模型的最高层，它为用户提供直接的网络服务。它是应用程序与网络之间的接口，它定义了信息交换的格式，消息会交给下一层传输层来传输，是应用程序以及应用层协议存在的地方，负责用户与计算机的交互。\n应用层是不用去关心数据是如何传输的，而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。\n应用层的信息分组称为 报文\n常用协议 常见的应用层协议\nHTTP（Hypertext Transfer Protocol，超文本传输协议）：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载 SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）：基于 TCP 协议，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。 FTP（File Transfer Protocol，文件传输协议）：基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。 SSH（Secure Shell Protocol，安全的网络传输协议）：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务 DNS（Domain Name System，域名管理系统）: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。 表示层 表示层 负责数据格式的转换，确保不同系统之间的数据能够互相理解。它通常包括数据的编码、加密、解密和压缩功能。\n例如：Linux 给 WIndows 发包，不同系统语法不一致，如 exe 不能在 Linux 下执行，shell 不能在 Windows 不能直接运行。因此需要表示层。解决不同系统之间通信语法问题\n会话层 会话层 负责建立、管理和终止会话，它提供了在应用程序之间的会话管理功能，保证数据的同步、恢复以及多次通信的管理。它确保数据传输的秩序性，如恢复中断的连接。\n常见的协议有 ADSP、RPC 等\n传输层 传输层 负责在通信的两端提供 端到端的可靠性（不同主机上不同进程的通信） ，它确保数据的可靠传输和流量控制。它将数据从应用层交给网络层，然后将接收到的数据传递给应用层。传输层还负责错误检测与修正。\n报文段 传输层的数据分组称为 报文段\n常用协议 在传输层会有两个传输协议，分别是 TCP 和 UDP。\nTCP 的全称叫传输控制协议（Transmission Control Protocol），具有以下功能\n流量控制 超时重传 拥塞控制等 通过提供面向连接的服务保证报文段可靠地传输给对方\nUDP 相对来说就很简单，提供无连接服务，只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。\n当设备作为接收方时，传输层则要负责把报文段传给应用进程，但是一台设备上可能会有很多应用进程在接收或者传输数据，因此需要用一个 端口号 将应用进程区分开来。\n网络层 随着网络节点的不断增加，点对点通讯需要通过多个节点，如何找到目标节点，如何选择最佳路径成为首要需求。\n网络层主要功能是将 网络地址转化为对应的物理地址（寻址） ，并 决定如何将数据从发送方路由到接收方（路由选择） 。\n数据报 位于网络层的数据分组称为 数据报\n网络层最常使用的是 IP 协议（Internet Protocol），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会再次进行分片，得到一个即将发送到网络的 IP 报文。\nIP地址 IP地址 用于区分不同的物理设备\n网络号：负责标识该 IP 地址是属于哪个「子网」的； 主机号：负责标识同一「子网」下的不同主机； 子网掩码 ：用于计算网络号和主机号\n将 子网掩码 和 IP地址 进行按位与操作即可计算出网络号\n将 子网掩码 取反后与 IP地址 进行进行按位与运算，就可以得到主机号\n常见协议 IP（Internet Protocol，网际协议）：TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。 ARP（Address Resolution Protocol，地址解析协议）：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。 ICMP（Internet Control Message Protocol，互联网控制报文协议）：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除 NAT（Network Address Translation，网络地址转换协议）：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。 RIP(Routing Information Protocol，路由信息协议）：一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。 数据链路层 在物理连接中提供可靠的传输（ 点到点的传输 ），负责建立和维护两个相邻节点间的链路。包括数据帧的封装与解封装，以及错误检测与校正。它还负责处理物理地址（MAC地址），管理局域网的访问控制。\n链路层中的数据分组为 帧\n物理层 物理层是OSI模型的最底层，负责将数据以电气信号、光信号或无线信号的形式传输到物理媒介上。它定义了硬件设备的接口、传输媒介的电气特性、连接器的标准等。\n网卡工作在这层\nTCP/IP模型 TCP/IP 四层模型 是目前被广泛采用的一种模型,可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：\n应用层 传输层 网络层 网络接口层 网络接口层 网络接口层（Network Access Layer）：可以把网络接口层看作是数据链路层和物理层的合体。负责将数字信号在物理通道（网线）中准确传输，定义了如何在单一网络链路上传输数据，如何处理数据帧的发送和接收，包括物理地址（MAC 地址）的解析。\nMAC地址 Mac地址 是一个全球唯一的物理地址，由设备制造商在生产时烧录到网卡的固件中。MAC 地址用于局域网（LAN）中的设备识别和通信。\nIP 网络使用 IP 地址 进行通信，但在局域网内，设备最终依靠 MAC 地址 进行数据传输。\nARP（Address Resolution Protocol） 负责将 IP 地址转换为 MAC 地址。\n数据封装过程 网页显示过程 工作流程 浏览器解析 URL：浏览器会解析 URL 并根据解析结果和缓存分析生成对应的HTTP请求报文 浏览器分析 URL 所需要使用的传输协议和请求的资源路径。 如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。 如果没有问题，浏览器会检查 URL 中是否出现了非法字符，则对非法字符进行转义后在进行下一过程。 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里且没有失效，那么就直接使用，否则向服务器发起新的请求。 浏览器通过 DNS 做域名解析从而获取域名对应的IP地址：请求需要知晓服务器域名对应的 IP 地址才能通信，浏览器会检查本地缓存、操作系统缓存，甚至路由器缓存。如果未命中缓存，浏览器向配置的 DNS 服务器发送查询请求，DNS 服务器递归查询 最终返回 IP 地址。 通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈。 浏览器会调用 Socket 库委托协议栈工作，并得到了封装了 HTTP 数据的 TCP 数据包, TCP协议指定了指定源端口号和目的端口号，然后下发给网络层 在 TCP 数据包的基础上，再封装源地址 IP 和前面 DNS 解析出来目标地址 IP 等信息，得到网络包。并多个网络节点中确定数据包的传输路径，最终能找到目标服务器。然后将下发给数据链路层 数据链路层的发送需要封装通信双方的 MAC 地址。 本机的 MAC 地址作为源 MAC 地址。 接收方目标 MAC 地址的获取方式是通过将 IP 地址与本机的子网掩码相结合，可以判断是否与请求主机在同一个子网里 如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址 如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。 网卡驱动获取网络包之后，会将其复制到网卡内的缓存区中。网卡会将包转为电信号，通过网线发送出去 建立TCP连接：主机将使用目标 IP地址和目标MAC地址发送一个TCP SYN包，请求建立一个TCP连接，然后交给路由器或者交换机 交换机：它会根据数据包中的 MAC 头来查找MAC表来找到另一个设备连接在交换机的哪个端口，然后传输。 路由器：路由器进行跨子网的转发，通过查找路由表中IP地址和端口的映射关系来决定从路由器的哪个端口发出 发送HTTP请求：连接建立后，浏览器会向服务器发送HTTP请求。请求中包含了用户需要获取的资源的信息，例如网页的URL、请求方法（GET、POST等）等。 服务器处理请求并返回响应：服务器收到请求后，会根据请求的内容进行相应的处理。例如，如果是请求网页，服务器会读取相应的网页文件，并生成HTTP响应。 数据封装过程 数据包传递过程 路由器1的路由表\n目的地址 下一跳 端口 192.168.0.0/24 0 192.168.0.254/32 0 192.168.1.0/24 1 192.168.1.254/32 1 192.168.2.0/24 192.168.100.5 2 192.168.100.0/24 2 192.168.100.4/32 2 以主机A发送给主机F数据包为例\nA （192.168.0.1） 通过子网掩码 （255.255.255.0） 计算出自己与 F （192.168.2.2） 并不在同一个子网内，于是决定发送给默认网关 （192.168.0.254） A 通过 ARP 找到 默认网关 192.168.0.254 的 MAC 地址 （ABAB） 。 A 封装数据包 数据链路层头部 源 MAC 地址设置为A的MAC地址 （AAAA） 目标MAC地址为网关 MAC 地址 （ABAB） 网络层头部 源 IP 地址设置为A的IP地址 （192.168.0.1） 目的 IP 地址设置为F的IP地址 （192.168.2.2）（从始至终这个数据包的两个 IP 地址都是不变的，只有 MAC 地址在不断变化） 交换机 1 收到数据包后，查询MAC地址表，目标 MAC 地址是 ABAB ，从MAC地址表的指定端口转发给路由器1 数据包来到了路由器 1，发现其目标 IP 地址是 192.168.2.2 ，查看其路由表，发现了下一跳的地址是 192.168.100.5 ，从映射端口发出数据包到路由器2 源MAC设置为路由器1的映射端口的MAC地址 （D1D1） 目标MAC设置为下一跳的MAC地址 （D2D2） 此时路由器 2 收到了数据包，看到其目标IP地址是 192.168.2.2 ，查询其路由表，准备从映射端口把数据包送出去。 但此时路由器 2 需要知道 192.168.2.2 的 MAC 地址了，于是查看其 arp 缓存，找到其 MAC 地址为 FFFF ，将其封装在数据链路层头部，并从映射端口把包发出去。 源MAC设置为路由器2的映射端口的MAC地址 （EFEF） 目标MAC设置为F的MAC地址 （FFFF） 交换机 3 收到了数据包，发现目的 MAC 地址为 FFFF ，查询其 MAC 地址表，从映射端口把数据包发出去。 F 最终收到了数据包并且发现目的 MAC 地址就是自己，于是收下了这个包 ","date":"2024-06-06T21:09:15+08:00","permalink":"https://Tyritic.github.io/p/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/","title":"网络分层模型"}]