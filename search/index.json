[{"content":"传统的BIO模式（同步阻塞模式） 在计算机网络中，BIO (Blocking I/O) 是一种同步的 I/O 模型。它的工作原理是：在 BIO 模式下，服务器为每个客户端连接创建一个独立的线程，每个线程负责处理一个I/O操作。线程在进行I/O操作时，如果数据未准备好，会阻塞，直到操作完成后才继续。\n例如，在Java中，使用ServerSocket和Socket进行网络通信时，accept()、read()、write()等操作都是阻塞的，直到请求或数据到来。 它通常用于基于传统 TCP/IP 协议的客户端和服务器通信。\nBIO模式的特点 阻塞模式：在进行读取或写入操作时，线程会被阻塞，直到数据准备好或操作完成。对于每个客户端请求，都会分配一个线程来处理，直到请求完成后，线程才会释放。 简单易用：因为阻塞 I/O 模型非常直观，它不需要复杂的线程管理或事件驱动机制，对于小型应用或简单的服务器来说，BIO 是一个相对简洁的选择。 性能瓶颈：由于每个连接都需要单独的线程进行处理，BIO 会消耗更多的系统资源，并且当连接数增加时，会导致性能下降。特别是在并发量很大的情况下，BIO 的效率就变得较低。 适用于低并发的应用场景：BIO 最适合用在连接数较少且并发请求量不大的应用中，比如传统的客户端-服务器模型，或者早期的网络服务。 BIO 的缺点 线程资源浪费：每个连接都需要一个单独的线程，线程管理和上下文切换会导致系统资源浪费，尤其在连接数较多时，会对系统性能产生负面影响。 不适合高并发应用：对于高并发的场景，BIO 模型的性能会大幅下降，因为线程数过多时会导致线程切换和内存消耗过大，甚至可能导致服务器崩溃。 改进后的模式——NIO模式（同步非阻塞模式） NIO (New Input/Output) 是 Java 1.4 引入的一种非阻塞式 I/O 模型，它相较于传统的 BIO (Blocking I/O) 模型，提供了更高效的 I/O 操作，特别是在处理大量并发连接时。NIO 通过支持非阻塞 I/O 操作、缓冲区、选择器等机制，N基于I/O多路复用实现的，它可以只用一个线程处理多个客户端I/O，线程不会在执行读取或写入操作时被阻塞。线程可以在等待数据时继续做其他事情，当数据准备好时，NIO 会通过回调机制告知应用程序，显著提高了系统的性能，尤其适用于高并发的网络编程。\nNIO的特点 非阻塞 I/O：NIO 中的 I/O 操作是非阻塞的。也就是说，在进行读写操作时，线程不会被阻塞，线程可以继续处理其他任务，直到数据准备好。 双向读写：channel作为I/O 操作的数据流通道，可以用于读写数据。 线程的多路复用：选择器（Selector） 使得一个线程可以同时监控多个通道，检测哪些通道可以进行 I/O 操作。允许一个线程在多个通道之间进行多路复用。 缓冲机制：NIO 中的所有数据读写操作都通过 缓冲区（Buffer） 来完成。缓冲区是一个在内存中临时存储数据的区域 NIO 的主要组成部分 选择器（Selector）： 选择器是 NIO 的核心组件之一，它允许单个线程同时监控多个 I/O 通道，检测哪些通道准备好进行读写操作。 通过选择器，NIO 可以避免为每个连接创建一个线程，而是利用单个线程同时处理多个连接，提高了并发处理能力。 缓冲区（Buffer）： 在 NIO 中，数据读写通过 缓冲区（Buffer）进行操作。缓冲区是一个内存区域，它用于在数据与通道（Channel）之间传递数据。 数据总是从通道读到缓冲区，或者从缓冲区写到通道。缓冲区是 NIO 中的一个重要概念，类似于传统 I/O 的字节流和字符流。 通道（Channel）： 通道是 NIO 中与数据源或数据目的地之间的连接通道，用于读取或写入数据。Channel 与传统的流不同，它是双向的，即既可以读，也可以写。 NIO 提供了多个具体的通道类，如 FileChannel（文件通道）、SocketChannel（套接字通道）和 ServerSocketChannel（服务器套接字通道）。 内存映射文件（Memory-mapped Files）： NIO 支持内存映射文件，可以通过 MappedByteBuffer 来将文件的部分或整个内容映射到内存中，允许程序像访问数组一样操作文件内容，提升了文件操作的效率。 SelectionKey： SelectionKey 是选择器与通道之间的桥梁，它表示通道在选择器上的注册状态，并且它指示通道准备好进行的操作（如读、写、连接等）。 NIO的工作流程 创建通道并设置为非阻塞模式：在 NIO 中，所有的数据读取和写入操作都是通过 通道（Channel） 完成的。通道是一个连接 I/O 设备（如文件、网络套接字等）的双向数据传输通道。 将通道注册到选择器（Selector）：通道需要注册到 选择器（Selector） 上。选择器是一个核心组件，它允许单个线程监控多个通道的 I/O 状态。 轮询选择器（Selector）：在应用程序中，调用选择器的 select() 方法来阻塞并等待事件的发生。当至少一个通道准备好进行指定的 I/O 操作时，选择器会返回并且唤醒线程。 处理就绪的通道：一旦选择器检测到某些通道已经准备好进行 I/O 操作，就会返回这些通道的集合。 处理IO操作：在通道准备好后，应用程序通过 ByteBuffer 来读取或写入数据。 继续轮询并处理其他通道的 I/O 事件 关闭通道与选择器 核心组件 Channel接口 是双向的，可以同时支持读取和写入（读/写），与传统的I/O流相比更灵活。传统的流只能单向，要么是输入流要么是输出流。 常用于非阻塞I/O操作，可以结合Selector来实现多路复用，从而处理多个并发连接。 种类\nSocketChannel：用于基于TCP的网络通信，可以与服务器或客户端进行连接。 ServerSocketChannel：用于监听TCP连接，类似于传统I/O中的ServerSocket。 DatagramChannel：用于基于UDP的网络通信。 FileChannel：用于从文件中读取或向文件中写入数据。 常用方法\nSelectionKey register(Selector sel, int ops) throws ClosedChannelException sel：选择器对象，通道将会注册到该选择器上。 ops：感兴趣的操作，可以是 SelectionKey.OP_READ、SelectionKey.OP_WRITE、SelectionKey.OP_CONNECT 等。 返回值：返回一个 SelectionKey，表示通道在选择器中的状态。 创建对象 public static FileChannel open(Path path, OpenOption... options) throws IOException; path: 要操作的文件路径，类型为 Path。 options: 文件打开选项，例如 StandardOpenOption.READ、StandardOpenOption.WRITE 等，可以传入多个选项。 public static SocketChannel open() throws IOException; public static ServerSocketChannel open() throws IOException; public static DatagramChannel open() throws IOException; 读取数据 int read(ByteBuffer dst) throws IOException; Selector类 Selector 是Java NIO（New I/O）中用于实现I/O多路复用的组件，它可以通过一个单独的线程同时监视多个通道（Channel）的事件。\nSelector的作用：\n管理多个Channel：通过一个Selector实例，程序可以同时监听多个通道的I/O事件（如可读、可写、连接就绪等），从而使一个线程管理多个连接变得高效。 非阻塞I/O：Selector通常与非阻塞通道（如SocketChannel）配合使用，实现高效的非阻塞I/O操作。它使得程序无需为每个连接创建一个线程，减少了线程的开销。 Selector的事件类型：\nOP_READ：表示通道中有数据可读。 OP_WRITE：表示通道可以向其中写入数据。 OP_CONNECT：表示通道完成连接操作。 OP_ACCEPT：表示通道可以接受新的连接 Selector的常见方法\nint selectNow()：不论是否有无事件发生，立即返回 int select(long timeout)：至多阻塞 timeout 时间（或被唤醒），如果提早有事件发生，提早返回 int select()：一直阻塞着，直到有事件发生（或被唤醒） 返回值就是就绪的通道数，一般判断大于 0 即可进行后续的操作。\n","date":"2025-01-20T15:22:04+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84bionioaio/","title":"Java的BIO,NIO,AIO"},{"content":"什么是注解 注解（Annotation） 是一种元数据，它为代码提供了附加的信息，注解本身不直接影响代码的逻辑执行，但可以通过工具、编译器或运行时反射等机制对代码进行处理。\n注解的定义方式 1 2 3 4 public @interface MyAnnotation { String value() default \u0026#34;default value\u0026#34;; // 带有默认值的元素 int number(); // 没有默认值的元素 } 注解的目标对象 ElementType.TYPE：类、接口（包括注解类型）或枚举。 ElementType.FIELD：字段（包括枚举常量）。 ElementType.METHOD：方法。 ElementType.PARAMETER：方法参数。 ElementType.CONSTRUCTOR：构造方法。 ElementType.LOCAL_VARIABLE：局部变量。 ElementType.ANNOTATION_TYPE：注解类型。 ElementType.PACKAGE：包。 定义在 ElementType 枚举中，使用元注解@Target指定目标对象\n注解的生命周期 RetentionPolicy.SOURCE：注解仅在源码中存在，编译时被丢弃。 RetentionPolicy.CLASS：注解存在于编译后的 .class 文件中，但运行时不可用。 RetentionPolicy.RUNTIME：注解在运行时可用，可以通过反射机制访问。 定义在 RetentionPolicy 枚举中，使用元注解@Retention指定生命周期\n示例 1 2 3 4 5 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface JsonField { public String value() default \u0026#34;\u0026#34;; } JsonField 注解的生命周期是 RUNTIME，也就是运行时有效。 JsonField 注解装饰的目标是 FIELD，也就是针对字段的。 创建注解需要用到 @interface 关键字。 JsonField 注解有一个参数，名字为 value，类型为 String，默认值为一个空字符串。 ","date":"2025-01-20T09:40:41+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86/","title":"Java的注解原理"},{"content":"动态代理的定义 动态代理（Dynamic Proxy） 是 Java 提供的一种机制，它允许在运行时创建实现指定接口的代理类，而不需要在编译时编写实现类。\n动态代理主要用途 简化代码：通过代理模式，可以减少重复代码，尤其是在横切关注点（如日志记录、事务管理、权限控制等）方面。 增强灵活性：动态代理使得代码更具灵活性和可扩展性，因为代理对象是在运行时生成的，可以动态地改变行为。 实现 AOP：动态代理是实现面向切面编程（AOP, Aspect-Oriented Programming）的基础，可以在方法调用前后插入额外的逻辑 动态代理的工作原理 接口与代理： 代理类并不是通过继承或实现接口来定义的，而是通过 Proxy 类在运行时动态创建。代理类会在运行时被创建，并会实现与原接口相同的方法。 InvocationHandler 接口： 这个接口是动态代理的核心，它定义了 invoke() 方法，当代理对象调用任何方法时，都会触发 invoke() 方法，从而可以在其中执行增强逻辑。 Proxy.newProxyInstance() 方法： 这是 Java 提供的用于创建动态代理实例的工具方法。通过这个方法，可以创建实现指定接口的代理对象，并指定一个 InvocationHandler 来处理方法的调用。 动态代理的实现步骤 定义接口： 被代理对象必须实现一个接口。 处理器类实现 InvocationHandler 接口： 通过 InvocationHandler 接口来定义代理类的逻辑，重写invoke方法实现对方法的拦截。 Object proxy：代理对象 Method method：调用的方法 Object[] args：传递的实参 主类使用 Proxy.newProxyInstance() 创建代理对象： 通过 Proxy 类的 newProxyInstance() 方法创建代理对象。 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // 定义接口 public interface UserService { void addUser(String name); void deleteUser(String name); } // 实现接口 public class UserServiceImpl implements UserService { @Override public void addUser(String name) { System.out.println(\u0026#34;Adding user: \u0026#34; + name); } @Override public void deleteUser(String name) { System.out.println(\u0026#34;Deleting user: \u0026#34; + name); } } // 处理器实现InvocationHandler接口 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class LoggingHandler implements InvocationHandler { private final Object target; public LoggingHandler(Object target) { this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 在方法执行前添加日志 System.out.println(\u0026#34;Method \u0026#34; + method.getName() + \u0026#34; is called with arguments: \u0026#34; + args[0]); // 调用真实对象的方法 Object result = method.invoke(target, args); // 在方法执行后添加日志 System.out.println(\u0026#34;Method \u0026#34; + method.getName() + \u0026#34; execution completed.\u0026#34;); return result; } } // 创建代理对象 import java.lang.reflect.Proxy; public class ProxyExample { public static void main(String[] args) { UserService userService = new UserServiceImpl(); // 创建动态代理对象 UserService proxy = (UserService) Proxy.newProxyInstance( userService.getClass().getClassLoader(), userService.getClass().getInterfaces(), new LoggingHandler(userService) ); // 使用代理对象 proxy.addUser(\u0026#34;Alice\u0026#34;); proxy.deleteUser(\u0026#34;Bob\u0026#34;); } } ","date":"2025-01-19T20:10:12+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","title":"Java的动态代理"},{"content":"反射机制的定义 Java的反射机制是一种强大的特性，它允许在运行时动态地查询和操作类、方法、构造器、字段等信息，甚至可以在运行时创建对象、修改字段和调用方法。反射机制使得 Java 程序具备了更高的灵活性，可以编写更加通用和扩展性强的代码。\n反射机制的特性 运行时类信息访问：反射机制允许程序在运行时获取类的完整结构信息，包括类名、包名、父类、实现的接口、构造函数、方法和字段等。 动态对象创建：可以使用反射API动态地创建对象实例，即使在编译时不知道具体的类名。这是通过Class类的newInstance()方法或Constructor对象的newInstance()方法实现的。 动态方法调用：可以在运行时动态地调用对象的方法，包括私有方法。这通过Method类的invoke()方法实现，允许你传入对象实例和参数值来执行方法。 访问和修改字段值：反射还允许程序在运行时访问和修改对象的字段值，即使是私有的。这是通过Field类的get()和set()方法完成的。 反射的核心类 Class 类：Class 类是反射的核心，它表示一个类或接口的元数据。通过 Class 类，可以获取类的构造器、方法、字段等信息。 Constructor 类：表示类的构造器，可以通过反射动态创建对象。 Method 类：表示类的方法，可以调用指定的实例方法。 Field 类：表示类的字段（成员变量），可以访问和修改字段的值。 Modifier 类：用于解析和获取类、方法、字段等的访问修饰符。 反射的常见操作 类对象（class） 获取类的class的对象 Class.forName(\u0026quot;全类名\u0026quot;)：对应于Java的源代码阶段 类名.class：对应于加载阶段（将字节码文件加入到内存中） 对象.getClass()：对应于运行阶段 上述三个方法获取的class的对象是同一个对象\n获取类的构造器（Constructor） getConstructor(Class\u0026lt;?\u0026gt;... parameterTypes)：获取类的公共构造器，构造器的参数类型必须与传入的类型匹配。\n如果构造器不存在，会抛出 NoSuchMethodException。\n1 2 3 Class\u0026lt;?\u0026gt; clazz = Person.class; Constructor\u0026lt;?\u0026gt; constructor = clazz.getConstructor(String.class, int.class); // 传入构造器参数类型 Person person = (Person) constructor.newInstance(\u0026#34;John\u0026#34;, 25); getDeclaredConstructor(Class\u0026lt;?\u0026gt;... parameterTypes)：获取类的所有构造器（包括私有构造器、受保护的构造器等），与 getConstructor 方法不同，getDeclaredConstructor 会返回类的所有构造器，而不仅限于公共构造器。\n1 2 3 Constructor\u0026lt;?\u0026gt; constructor = clazz.getDeclaredConstructor(String.class, int.class); // 获取指定参数类型的构造器 constructor.setAccessible(true); // 如果是私有构造器，需要解除访问权限 Person person = (Person) constructor.newInstance(\u0026#34;Alice\u0026#34;, 30); getConstructors()：获取类的所有公共构造器，返回一个 Constructor 数组，包含该类及其父类的所有公共构造器。\n1 2 3 4 Constructor\u0026lt;?\u0026gt;[] constructors = clazz.getConstructors(); for (Constructor\u0026lt;?\u0026gt; constructor : constructors) { System.out.println(constructor.getName()); } getDeclaredConstructors()：获取类的所有构造器（包括私有构造器、受保护的构造器等），返回一个 Constructor 数组，包含该类的所有构造器（不包括父类的构造器）。\n1 2 3 4 Constructor\u0026lt;?\u0026gt;[] declaredConstructors = clazz.getDeclaredConstructors(); for (Constructor\u0026lt;?\u0026gt; constructor : declaredConstructors) { System.out.println(constructor.getName()); } 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 import java.lang.reflect.*; class Person { private String name; private int age; // 公共构造器 public Person(String name, int age) { this.name = name; this.age = age; } // 默认构造器 public Person() {} // 私有构造器 private Person(String name) { this.name = name; } public void display() { System.out.println(\u0026#34;Name: \u0026#34; + name + \u0026#34;, Age: \u0026#34; + age); } } public class ConstructorDemo { public static void main(String[] args) throws Exception { Class\u0026lt;?\u0026gt; clazz = Person.class; // 1. 获取公共构造器 (带有参数) Constructor\u0026lt;?\u0026gt; constructor1 = clazz.getConstructor(String.class, int.class); Person person1 = (Person) constructor1.newInstance(\u0026#34;John\u0026#34;, 25); person1.display(); // 2. 获取默认构造器 Constructor\u0026lt;?\u0026gt; constructor2 = clazz.getConstructor(); Person person2 = (Person) constructor2.newInstance(); person2.display(); // 3. 获取私有构造器 Constructor\u0026lt;?\u0026gt; constructor3 = clazz.getDeclaredConstructor(String.class); constructor3.setAccessible(true); // 解除访问限制 Person person3 = (Person) constructor3.newInstance(\u0026#34;Alice\u0026#34;); person3.display(); // 4. 获取所有公共构造器 Constructor\u0026lt;?\u0026gt;[] constructors = clazz.getConstructors(); System.out.println(\u0026#34;Public constructors:\u0026#34;); for (Constructor\u0026lt;?\u0026gt; constructor : constructors) { System.out.println(constructor.getName()); } // 5. 获取所有构造器（包括私有的） Constructor\u0026lt;?\u0026gt;[] declaredConstructors = clazz.getDeclaredConstructors(); System.out.println(\u0026#34;Declared constructors:\u0026#34;); for (Constructor\u0026lt;?\u0026gt; constructor : declaredConstructors) { System.out.println(constructor.getName()); } } } // 输出 // Name: John, Age: 25 // Name: null, Age: 0 // Name: Alice, Age: 0 // Public constructors: // Person // Person // Declared constructors: // Person // Person // Person 获取类的方法（Method） getMethod(String name, Class\u0026lt;?\u0026gt;... parameterTypes) 获取类的公共方法，包括继承自父类的公共方法。 如果指定的方法不存在，会抛出 NoSuchMethodException。 该方法的第一个参数是方法名，后续参数是方法的参数类型（可以是空参数）。 getDeclaredMethod(String name, Class\u0026lt;?\u0026gt;... parameterTypes) 获取类的所有方法（包括私有方法和受保护的方法）。 如果指定的方法不存在，会抛出 NoSuchMethodException。 getMethods() 返回类的所有公共方法（包括继承自父类的公共方法）。 返回的是一个 Method 数组，包含该类的所有公共方法。 getDeclaredMethods() 返回类的所有方法（包括私有方法、受保护的方法和公共方法），但不包括从父类继承的方法。 返回的是一个 Method 数组，包含该类的所有方法。 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import java.lang.reflect.*; class Person { private String name; private int age; // 公共构造器 public Person(String name, int age) { this.name = name; this.age = age; } // 公共方法 public void display() { System.out.println(\u0026#34;Name: \u0026#34; + name + \u0026#34;, Age: \u0026#34; + age); } // 私有方法 private void privateMethod() { System.out.println(\u0026#34;This is a private method.\u0026#34;); } // 受保护的方法 protected void protectedMethod() { System.out.println(\u0026#34;This is a protected method.\u0026#34;); } } public class MethodDemo { public static void main(String[] args) throws Exception { // 创建对象实例 Person person = new Person(\u0026#34;John\u0026#34;, 25); // 1. 获取公共方法 Class\u0026lt;?\u0026gt; clazz = person.getClass(); Method method1 = clazz.getMethod(\u0026#34;display\u0026#34;); // 获取公共方法 method1.invoke(person); // 调用方法 // 2. 获取私有方法 Method method2 = clazz.getDeclaredMethod(\u0026#34;privateMethod\u0026#34;); // 获取私有方法 method2.setAccessible(true); // 解除访问限制 method2.invoke(person); // 调用私有方法 // 3. 获取受保护的方法 Method method3 = clazz.getDeclaredMethod(\u0026#34;protectedMethod\u0026#34;); // 获取受保护的方法 method3.setAccessible(true); // 解除访问限制 method3.invoke(person); // 调用受保护的方法 // 4. 获取所有方法（包括私有、受保护方法） Method[] declaredMethods = clazz.getDeclaredMethods(); // 获取所有方法 System.out.println(\u0026#34;Declared methods:\u0026#34;); for (Method method : declaredMethods) { System.out.println(method.getName()); } } } // 输出结果： // Name: John, Age: 25 // This is a private method. // This is a protected method. // Declared methods: // display // privateMethod // protectedMethod 获取类的字段（Field） getField(String name) 获取类的公共字段，包括继承自父类的公共字段。 如果指定的字段不存在，会抛出 NoSuchFieldException。 只能获取公共字段。 getDeclaredField(String name) 获取类的所有字段（包括私有字段、受保护字段和公共字段）。 如果指定的字段不存在，会抛出 NoSuchFieldException。 getFields() 获取类的所有公共字段（包括继承自父类的公共字段）。 返回一个 Field 数组，包含该类的所有公共字段。 getDeclaredFields() 获取类的所有字段（包括私有、受保护和公共字段），但不包括从父类继承的字段。 返回一个 Field 数组，包含该类的所有字段。 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 import java.lang.reflect.*; class Person { public String name; private int age; protected String gender; // 公共构造器 public Person(String name, int age, String gender) { this.name = name; this.age = age; this.gender = gender; } } public class FieldDemo { public static void main(String[] args) throws Exception { // 创建对象实例 Person person = new Person(\u0026#34;John\u0026#34;, 25, \u0026#34;Male\u0026#34;); // 1. 获取公共字段 Class\u0026lt;?\u0026gt; clazz = person.getClass(); Field field1 = clazz.getField(\u0026#34;name\u0026#34;); // 获取公共字段 System.out.println(\u0026#34;Public field \u0026#39;name\u0026#39;: \u0026#34; + field1.get(person)); // 获取字段值 // 2. 获取私有字段 Field field2 = clazz.getDeclaredField(\u0026#34;age\u0026#34;); // 获取私有字段 field2.setAccessible(true); // 解除访问限制 System.out.println(\u0026#34;Private field \u0026#39;age\u0026#39;: \u0026#34; + field2.get(person)); // 获取字段值 // 3. 获取受保护的字段 Field field3 = clazz.getDeclaredField(\u0026#34;gender\u0026#34;); // 获取受保护字段 field3.setAccessible(true); // 解除访问限制 System.out.println(\u0026#34;Protected field \u0026#39;gender\u0026#39;: \u0026#34; + field3.get(person)); // 获取字段值 // 4. 获取所有公共字段（包括从父类继承的公共字段） Field[] fields = clazz.getFields(); // 获取所有公共字段 System.out.println(\u0026#34;Public fields:\u0026#34;); for (Field field : fields) { System.out.println(field.getName()); } // 5. 获取所有字段（包括私有、受保护和公共字段） Field[] declaredFields = clazz.getDeclaredFields(); // 获取所有字段 System.out.println(\u0026#34;Declared fields:\u0026#34;); for (Field field : declaredFields) { System.out.println(field.getName()); } } } // 输出： // Public field \u0026#39;name\u0026#39;: John // Private field \u0026#39;age\u0026#39;: 25 // Protected field \u0026#39;gender\u0026#39;: Male // Public fields: // name // Declared fields: // name // age // gender 字段（Field） 访问对象字段属性 获取对象的 Field 对象。 通过 Field 对象访问或修改字段的值。 对于 private、protected 或默认访问级别的字段，使用 setAccessible(true) 解除访问限制。 获取字段：public Object get(Object obj) throws IllegalAccessException 获取对象中某个字段的值。\n获取字段名：public String getName()\n获取字段的数据类型：public Class\u0026lt;?\u0026gt; getType()\n获取访问修饰符：public int getModifiers() 如果多个修饰符一起使用，它们的整数值是通过位 OR 运算得出的\npublic：1 private：2 protected：4 static：8 final：16 获取访问修饰符的字符串表示：Modifier.toString(int modifiers)\n修改访问性：setAccessible(Boolean T)\n示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import java.lang.reflect.Field; import java.lang.reflect.Modifier; class Person { public String name; // 公共字段 private int age; // 私有字段 protected String gender; // 受保护字段 static String country; // 静态字段 // 公共构造器 public Person(String name, int age, String gender) { this.name = name; this.age = age; this.gender = gender; } } public class FieldInfoDemo { public static void main(String[] args) throws Exception { // 创建一个 Person 对象 Person person = new Person(\u0026#34;John Doe\u0026#34;, 30, \u0026#34;Male\u0026#34;); // 获取 Person 类的 Class 对象 Class\u0026lt;?\u0026gt; clazz = person.getClass(); // 获取所有字段，包括私有、受保护和公共字段 Field[] fields = clazz.getDeclaredFields(); // 遍历所有字段 for (Field field : fields) { // 获取字段名 String fieldName = field.getName(); // 获取字段的修饰符 int modifiers = field.getModifiers(); // 获取修饰符的字符串表示 String modifierString = Modifier.toString(modifiers); // 获取字段的值 // 使用 setAccessible(true) 来允许访问私有字段 field.setAccessible(true); Object fieldValue = field.get(person); // 输出字段信息 System.out.println(\u0026#34;Field: \u0026#34; + fieldName + \u0026#34;, Modifier: \u0026#34; + modifierString + \u0026#34;, Value: \u0026#34; + fieldValue); } } } // 输出： // Field: name, Modifier: public, Value: John Doe // Field: age, Modifier: private, Value: 30 // Field: gender, Modifier: protected, Value: Male // Field: country, Modifier: static, Value: null 修改对象字段 修改字段：public void set(Object obj, Object value) throws IllegalAccessException, IllegalArgumentException 修改对象中某个字段的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import java.lang.reflect.Field; class Person { public String name; // 公共字段 private int age; // 私有字段 protected String gender; // 受保护字段 static String country; // 静态字段 // 公共构造器 public Person(String name, int age, String gender) { this.name = name; this.age = age; this.gender = gender; } } public class ModifyFieldDemo { public static void main(String[] args) throws Exception { // 创建一个 Person 对象 Person person = new Person(\u0026#34;John Doe\u0026#34;, 30, \u0026#34;Male\u0026#34;); // 获取 Person 类的 Class 对象 Class\u0026lt;?\u0026gt; clazz = person.getClass(); // 获取所有字段，包括私有、受保护和公共字段 Field[] fields = clazz.getDeclaredFields(); // 遍历所有字段 for (Field field : fields) { // 获取字段名 String fieldName = field.getName(); // 获取字段的修饰符 int modifiers = field.getModifiers(); String modifierString = java.lang.reflect.Modifier.toString(modifiers); // 输出字段信息 System.out.println(\u0026#34;Field: \u0026#34; + fieldName + \u0026#34;, Modifier: \u0026#34; + modifierString + \u0026#34;, Original Value: \u0026#34; + field.get(person)); // 修改字段的值 field.setAccessible(true); // 设置字段为可访问 if (field.getType() == String.class) { // 如果是 String 类型，修改字段值 field.set(person, \u0026#34;Jane Doe\u0026#34;); } else if (field.getType() == int.class) { // 如果是 int 类型，修改字段值 field.set(person, 35); } // 输出修改后的字段值 System.out.println(\u0026#34;Modified Field: \u0026#34; + fieldName + \u0026#34;, New Value: \u0026#34; + field.get(person)); } } } 方法（Method） 访问对象方法属性 获取方法名：public String getName()\n获取方法的返回值类型：public Class\u0026lt;?\u0026gt; getReturnType()\n获取访问修饰符：public int getModifiers() 如果多个修饰符一起使用，它们的整数值是通过位 OR 运算得出的\npublic：1 private：2 protected：4 static：8 final：16 获取访问修饰符的字符串表示：Modifier.toString(int modifiers)\n获取方法的形参类型： Class\u0026lt;?\u0026gt;[] getParameterTypes()\n获取方法的形参数组：public Parameter[] getParameters()\ngetName()：获取参数名称。 getType()：获取参数的类型。 修改访问性：setAccessible(Boolean T)\n示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import java.lang.reflect.Method; import java.lang.reflect.Parameter; class Person { public String greet(String name, int age) { return \u0026#34;Hello, \u0026#34; + name + \u0026#34;. You are \u0026#34; + age + \u0026#34; years old.\u0026#34;; } public void display() { System.out.println(\u0026#34;This is a display method.\u0026#34;); } } public class ReflectDemo { public static void main(String[] args) throws Exception { // 获取 Person 类的 Class 对象 Class\u0026lt;?\u0026gt; clazz = Person.class; // 获取 greet 方法 Method greetMethod = clazz.getMethod(\u0026#34;greet\u0026#34;, String.class, int.class); // 获取方法的参数信息 Parameter[] parameters = greetMethod.getParameters(); // 输出参数的详细信息 System.out.println(\u0026#34;Method: \u0026#34; + greetMethod.getName()); for (Parameter param : parameters) { System.out.println(\u0026#34;Parameter name: \u0026#34; + param.getName()); System.out.println(\u0026#34;Parameter type: \u0026#34; + param.getType().getName()); } } } // 输出： // Method: greet // Parameter name: name // Parameter type: java.lang.String // Parameter name: age // Parameter type: int 调用对象方法 public Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException\nobj:\n类型：Object 说明：调用方法的目标对象。对于实例方法，它是目标对象实例；对于静态方法，这个参数可以是 null（尽管最好传递 null）。 args:\n类型：Object... 说明：方法的实际参数（如果有）。这个参数是一个可变参数，表示调用方法时传入的参数值。如果方法没有参数，args 可以是空数组或者不传递任何值。 Object: 返回调用方法的结果。如果方法是 void，则返回 null。\n示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class Person { private String name; public Person(String name) { this.name = name; } // 有返回值的方法 public String greet(String greeting) { return greeting + \u0026#34;, \u0026#34; + name; } // 无返回值的方法 public void display() { System.out.println(\u0026#34;Hello, \u0026#34; + name); } } import java.lang.reflect.Method; public class ReflectDemo { public static void main(String[] args) throws Exception { // 创建 Person 对象 Person person = new Person(\u0026#34;Alice\u0026#34;); // 获取 Person 类的 Class 对象 Class\u0026lt;?\u0026gt; clazz = person.getClass(); // 获取 greet 方法（具有一个 String 参数） Method greetMethod = clazz.getMethod(\u0026#34;greet\u0026#34;, String.class); // 调用 greet 方法，传递参数 \u0026#34;Hello\u0026#34; String result = (String) greetMethod.invoke(person, \u0026#34;Hello\u0026#34;); System.out.println(\u0026#34;Result from greet method: \u0026#34; + result); // 获取 display 方法（没有参数） Method displayMethod = clazz.getMethod(\u0026#34;display\u0026#34;); // 调用 display 方法 displayMethod.invoke(person); } } // 输出： // Result from greet method: Hello, Alice // Hello, Alice 对象 创建对象 通过反射得到的构造器创建对象（ Constructor）\n1 2 Constructor\u0026lt;MyClass\u0026gt; constructor = MyClass.class.getConstructor(); MyClass obj = constructor.newInstance(); 通过类的字节码（Class）来创建对象\n1 MyClass obj = (MyClass) Class.forName(\u0026#34;com.example.MyClass\u0026#34;).newInstance(); 反射的使用场景 Spring 框架的 IOC（动态加载管理 Bean），Spring通过配置文件配置各种各样的bean，你需要用到哪些bean就配哪些，spring容器就会根据你的需求去动态加载，你的程序就能健壮地运行。\nSpring通过XML配置模式装载Bean的过程：\n将程序中所有XML或properties配置文件加载入内存 Java类里面解析xml或者properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息 使用反射机制，根据这个字符串获得某个类的Class实例 动态配置实例的属性 ","date":"2025-01-17T09:15:30+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/","title":"Java的反射机制"},{"content":"Optional类的定义 Optional 类是 Java 8 引入的一个容器类，用来解决可能出现的 NullPointerException 问题。它表示一个值可能存在也可能不存在，提供了一种优雅的方式来避免显式的 null 检查。\n核心思想 避免显式使用 null： 使用 Optional 代替直接返回 null，从而避免潜在的空指针异常。 增强代码可读性： 提供清晰的 API，表示值的存在或缺失，并能安全处理缺失的值。 函数式编程支持： 支持链式调用和流式操作，更适合在函数式编程中使用 创建对象方法 Optional.empty()：创建一个空的 Optional 对象。 1 Optional\u0026lt;String\u0026gt; emptyOpt = Optional.empty(); Optional.of(value)：根据非空值创建一个 Optional 对象。 1 Optional\u0026lt;String\u0026gt; nameOpt = Optional.of(\u0026#34;John\u0026#34;); 注意：传入 null 值会抛出 NullPointerException。\nOptional.ofNullable(value)：根据值创建 Optional，值可以是 null。 1 Optional\u0026lt;String\u0026gt; nullableOpt = Optional.ofNullable(null); 判断值是否存在 isPresent()：值存在返回 true，否则返回 false。 isEmpty()：值不存在返回 true（Java 11 引入）。 获取值 get()：返回值，如果值不存在会抛出 NoSuchElementException。\n1 String name = nameOpt.get(); orElse(defaultValue)：值存在则返回值，否则返回默认值。\n1 String name = nullableOpt.orElse(\u0026#34;Default Name\u0026#34;); 操作值 ifPresent(Consumer\u0026lt;? super T\u0026gt;)：值存在时执行给定的动作。\nmap(Function\u0026lt;? super T, ? extends U\u0026gt;)：值存在时对值进行映射操作。\n","date":"2025-01-16T20:56:03+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84optional%E7%B1%BB/","title":"Java中的Optional类"},{"content":"回答重点 主要是为了节省内存空间，提高内存利用率。\n在 JDK 9 之前，String 类是基于 char[] 实现的，内部采用 UTF-16 编码，每个字符占用两个字节。但是，如果当前的字符仅需一个字节的空间，这就造成了浪费。例如一些 Latin-1 字符用一个字节即可表示。\n因此 JDK 9 做了优化采用 byte[] 数组来实现，ASCII 字符串（单字节字符）通过 byte[] 存储，仅需 1 字节，减小了内存占用。\n并引入了 coder 变量来标识编码方式（Latin-1 或 UTF-16）。如果字符串中只包含 Latin-1 范围内的字符（如 ASCII），则使用单字节编码，否则使用 UTF-16。这种机制在保持兼容性的同时，又减少了内存占用。\n","date":"2025-01-14T22:32:10+08:00","permalink":"https://Tyritic.github.io/p/jdk9%E4%B8%AD%E5%B0%86string%E7%B1%BB%E5%BA%95%E5%B1%82%E7%9A%84char%E6%95%B0%E7%BB%84%E6%94%B9%E6%88%90byte%E6%95%B0%E7%BB%84/","title":"JDK9中将String类底层的char数组改成byte数组"},{"content":"回答重点 概念辨析 面向对象编程(Object Oriented Programming，OOP)是一种对象为中心的编程范式或者说编程风格。把类或对象作为基本单元来组织代码，并且运用提炼出的：封装、继承和多态来作为代码设计指导。\n面向过程编程是一种以过程或函数为中心的编程范式或者说编程风格，以过程作为基本单元来组织代码。过程其实就是动作，对应到代码中来就是函数，面向过程中函数和数据是分离的，数据就是成员变量。\n总结来看：面向对象编程注重对象之间的交互和模块化设计，而面向过程编程注重逻辑的分步实现。\n主要区别 数据与行为的关系：\n面向对象：数据和行为封装在对象内部，数据操作由对象方法进行管理。 面向过程：数据和函数是分离的，函数对数据进行操作。 3）可扩展性和复用性：\n面向对象：通过继承、接口、多态等机制支持代码的高复用性和扩展性。 面向过程：复用性较低，扩展需要修改已有代码，影响整体稳定性。 优缺点 面向对象的优缺点：\n优点：高复用性、扩展性、维护性强，适合复杂系统的开发。 缺点：开发和理解成本较高，对于简单项目可能显得繁琐。 面向过程的优缺点：\n优点：开发简单，代码执行速度快，适合小型项目。 缺点：可维护性差，代码复用性低，扩展性差。 ","date":"2025-01-14T10:59:01+08:00","permalink":"https://Tyritic.github.io/p/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/","title":"面向对象编程和面向过程编程的区别"},{"content":"回答重点 BigDecimal 能够保证精度，是因为它使用了任意精度的整数表示法，而不是浮动的二进制表示。\nBigDecimal 内部使用两个字段存储数字，一个是整数部分 intVal，另一个是用来表示小数点的位置 scale，避免了浮点数转化过程中可能的精度丢失。\n计算时通过整数计算，再结合小数点位置和设置的精度与舍入行为，控制结果精度，避免了由默认浮点数舍入导致的误差。\n1 2 3 4 5 6 7 8 9 10 public class BigDecimal extends Number implements Comparable\u0026lt;BigDecimal\u0026gt; { private final BigInteger intVal; // 存储整数部分 private final int scale; // 存储小数点的位置 public BigDecimal(String val) { // 使用 BigInteger 来表示数值 intVal = new BigInteger(val.replace(\u0026#34;.\u0026#34;, \u0026#34;\u0026#34;)); scale = val.contains(\u0026#34;.\u0026#34;) ? val.length() - val.indexOf(\u0026#34;.\u0026#34;) - 1 : 0; } } ","date":"2025-01-14T10:19:12+08:00","permalink":"https://Tyritic.github.io/p/bigdecimal%E4%BF%9D%E8%AF%81%E7%B2%BE%E5%BA%A6%E4%B8%8D%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%9C%BA%E5%88%B6/","title":"BigDecimal保证精度不丢失的机制"},{"content":"回答重点： 基本类型：Java 中有 8 种基本数据类型（int、long、float、double、char、byte、boolean、short），它们是直接存储数值的变量，位于栈上（局部变量在栈上、成员变量在堆上、静态（类）字段在方法区），性能较高，且不支持 null。\n包装类型：每个基本类型都有一个对应的包装类型（Integer、Long、Float、Double、Character、Byte、Boolean、Short）。包装类型是类，存储在堆中，可以用于面向对象编程，并且支持 null。\n区别总结： 1）性能区别：\n基本类型：占用内存小，效率高，适合频繁使用的简单操作。 包装类型：因为是对象，涉及内存分配和垃圾回收，性能相对较低。 2）比较方式不同：\n基本类型：比较用 ==，直接比较数值。 包装类型：比较时，== 比较的是对象的内存地址，而 equals() 比较的是对象的值。 3）默认值不同：\n基本类型：默认值是 0，false 等。 包装类型：默认为 null。 4）初始化的方式不同：\n基本类型：直接赋值。 包装类型：需要采用 new 的方式创建。 5）存储方式不同：\n基本类型：如果是局部变量则保存在栈上面，如果是成员变量则在堆中。 包装类型：保存在堆上（成员变量，在不考虑 JIT 优化的栈上分配时，都是随着对象一起保存在堆上的） ","date":"2025-01-13T23:15:14+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E6%AF%94/","title":"Java中包装类和基本数据类型的对比"},{"content":"后端架构的发展过程 ","date":"2025-01-08T20:56:25+08:00","permalink":"https://Tyritic.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E6%89%B9%E5%A4%84%E7%90%86%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E4%B8%89%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","title":"分布式批处理计算平台（三）架构设计"},{"content":"批处理算法组件的设计动机 异常处理：大多数算法开发人员在程序开发过程中通常只关注程序的正常逻辑，而忽视了程序在运行过程中可能遇到的异常情况以及如何处理这些异常故障。 缺乏生命周期管理：缺乏提供生命周期管理接口，用户无法方便地查询程序的运行状态，也无法进行必要的生命周期管理操作，例如暂停、恢复或停止程序的执行。若在程序执行过程中发现逻辑错误或需要优先执行其他任务，用户只能通过终止进程的方式停止程序的执行。 批处理算法组件的模型结构 批处理算法组件是面向海量数据批处理场景的具有生命周期管理和检查点恢复机制的功能软件单元\n属性 属性是组件内部维护的数据成员，包含以下两种类型：组件启动配置属性、组件运行过程属性以及数据处理属性。\n组件启动配置属性 在组件启动时，外部环境将参数传递给组件，随后组件进入初始化阶段，利用这些参数为组件的启动配置属性进行赋值\nmode：组件运行模式 算法执行模式 （algorithm）：正常执行算法过程 数据清理模式（clean）：若组件的算法逻辑有误导致错误的数据输出或中间输出结果没有业务价值，则需要清理这些数据，减轻集群节点机器的磁盘资源压力。 restore：检查点标志位 1：组件在运行之前，会尝试读取本地的检查点文件，并从检查点处恢复执行 0：组件此次运行会重新开始处理所有数据 properties_url：数据处理参数的配置文件地址 组件运行过程属性 组件运行过程属性是用于记录组件的运行状态、运行进度等相关信息的属性集合\nstatus：组件当前的运行状态 初始化 （init） 运行中 （running） 暂停 （paused） 停止 （stop） 运行完成 （finished） 运行失败 （failed） now：当前处理的数据块序号。 total：数据块总数 progress：组件的运行进度，计算公式：$progress=now/total$。 start_at：组件的开始运行时间，组件初始化完毕后设置该属性。 pause_at：组件的运行暂停时间，该属性记录组件运行的最近一次暂停时间。 pause_duration：组件运行暂停的总时长，组件在运行时可以被多次暂停。 remain_time：组件运行的剩余时长 数据处理属性 数据处理属性是组件进行数据处理时需要使用的属性\n输入数据地址 输出结果地址 可选的算法模型动态参数 接口 接口定义了组件的各项行为\n生命周期管理 组件运行时会启动一个HTTP服务，并提供生命周期管理接口给外界控制和获取组件运行状态\ninfo ：获取组件运行状态，包括组件运行进度、运行状态等信息 pause：暂停组件运行 restart：恢复运行处于暂停状态的组件 stop：停止组件运行 数据处理 数据处理接口是组件读取、处理以及写入数据的接口集合\ngetConfig：获取数据处理属性。 getGenerator：返回一个获取批处理任务所需数据的生成器。组件进行数据处理时，数据被分成块进行处理。开发人员实现该接口时，可以根据需要指定块的粒度。 readItem：从生成器中遍历得到数据的存放地址，并将数据读取至内存中。 beforeProcess：输入数据的预处理环节。 process：主要的数据分析处理环节，开发人员要在该接口内实现批处理算法逻辑。 afterProcess：收尾工作，例如可将处理完毕的图片从内存中移除，避免过多的图片将内存占满 clean：清理组件执行过程中生成的所有数据 handleFinish：当数据的批处理任务后，将要退出前调用此接口进行收尾工作 算法运行模式 通过getGenerator接口获取数据生成器，并遍历该生成器 在每次遍历时，按照以下步骤进行数据处理操作。 通过readItem接口将数据块读入内存。 将读入的数据传入beforeProcress接口进行预处理操作。 预处理完毕后，将处理结果传入process接口进行数据分析处理，执行具体的数据处理算法或操作。 处理完毕的数据会进入到afterProcess接口进行收尾工作，如释放内存等。 进入下一次循环之前，组件程序会判断当前的运行状态。 如果状态为暂停，线程将被阻塞，直到状态重新变为运行中。 如果状态为停止或生成器已遍历完成，则进入使用handleFinish接口进行程序的收尾工作。 数据清理模式 通过getGenerator接口获取待清理数据生成器，并遍历该生成器。 在每次遍历时 将数据块地址传入clean接口进行数据清理工作。 数据清理完毕后，在进入下一次循环之前，需要判断组件运行状态 如果状态为暂停，线程将被阻塞，直到状态重新变为运行中。 如果状态为停止或生成器已遍历完成，则进入使用handleFinish接口进行程序的收尾工作。 检查点管理 检查点接口是负责组件运行过程中检查点设置和读取的接口集合\nsetCheckpoint：设置检查点内容，保存组件当前的运行状态。 getCheckpoint：读取检查点内容，组件重新启动时，调用该接口恢复组件运行状态。 事件发布 lifeCycleEventPublish：发布组件运行生命周期事件。 runPorgressEventPublish：发布组件运行进度事件。 事件 事件是批处理算法组件具备的主动向外界传递信息的能力，采用发布/订阅机制。\n消息队列接受组件模型发布的事件\n订阅者通过订阅获取事件\n运行生命周期事件（Life Cycle Event） 组件运行过程中，向外界告知当前组件的运行状态。\n1 2 3 4 5 6 { \u0026#34;id\u0026#34;: \u0026#34;\u0026#34;, // 组件运行唯一标识 \u0026#34;status\u0026#34;: \u0026#34;\u0026#34;, // 运行状态, running/paused/stopped/finished/failed \u0026#34;msg\u0026#34;: \u0026#34;\u0026#34;, // 消息，如运行异常的原因 \u0026#34;occurAt\u0026#34;: \u0026#34;\u0026#34; // 事件发生时间 } 运行进度事件（Run Progress Event） 组件运行时首先获取待处理数据，再将待处理数据分批并以循环的方式进行重复的算法操作。每个循环执行结束后，向外界告知组件当前的执行进度\n1 2 3 4 5 6 7 { \u0026#34;id\u0026#34;: \u0026#34;\u0026#34;, // 组件运行唯一标识 \u0026#34;progress\u0026#34;: 0, // 运行进度 \u0026#34;startTime\u0026#34;: 0, // 开始时间，毫秒级时间戳 \u0026#34;usedTime\u0026#34;: 0, // 使用时间，秒 \u0026#34;remainTime\u0026#34;: 0, // 剩余时间，秒 } 自定义事件（Custom Event） 自定义事件允许用户根据业务需求发送事件，事件内容不做限制\n组件运行入口 组件的运行入口是一个main函数，外界通过调用组件的main函数启动组件运行。\n首先接收外界传递的参数，以进行组件的初始化阶段。 启动一个HTTP服务线程，以便外界可以与组件进行通信。 通过判断mode属性值来确定组件进入哪种运行模式 如果mode为algorithm，进入算法执行模式； 如果mode为clean，进入数据清理模式。 批处理算法组件的模型机制 生命周期管理机制 初始化 （init） ：处于该状态的组件进行必要的初始化操作。 运行中 （running） ：处于该状态的组件按照既定的算法逻辑处理数据。 运行暂停 （paused） ：一旦组件进入暂停状态，线程将会持续阻塞，无法继续执行下一步操作。 运行停止 （stopped） ：组件主动终止当前的执行进入停止状态，组件进程将会退出 运行完成 （finished） ：当组件处理完所有的数据后，进入运行完成状态，进行收尾工作并退出进程。 运行失败 （failed） ：运行失败状态表示组件在执行过程中遇到了错误、异常或不可恢复的问题，导致无法继续正常运行 检查点恢复机制 检查点恢复机制确保组件运行时，即使组件运行停止或突然遇到故障导致组件崩溃退出，也能够在下一次重新启动时恢复到最近一个检查点的状态继续执行\n设置检查点 在每次数据处理循环结束之前，调用设置检查点接口 setCheckpoint 将当前组件处理输入数据的进度作为检查点文件保存在本地文件系统中。组件模型内部维护一个检查点对象，在保存检查点时，会将该对象进行序列化并以 Json 文件格式持久到本地的文件系统\n一个粗粒度的检查点对象示例\n1 2 3 4 5 6 { \u0026#34;offset\u0026#34;: 50, // 循环执行偏移量 \u0026#34;total\u0026#34;: 100, // 循环总数 \u0026#34;startTime\u0026#34;: 1640966400000, // 组件运行开始时间 \u0026#34;usedTime\u0026#34;: 100 // 组件运行时长 } 后续开发人员可以增加检查点中的数据成员用于保存数据处理的中间处理结果，并在 setCheckpoint 和 getCheckpoint 接口实现相应代码逻辑\n读取检查点 当组件恢复运行时，若属性restore的值为1，则判断本地是否存在该组件运行的检查点文件，存在则读取检查点文件并进行反序列化得到检查点对象\n批处理算法组件的编排模型 由算法程序封装得到的批处理算法组件只能提供单一的算法功能，无法单独完成完整的数据处理任务。\n因此在完成各个组件的独立开发后，还需要允许用户根据具体需求选择组件，并对多个组件进行编排，通过复用已有组件，处理复杂的数据处理任务。\n组件编排模型的结构设计 在组件编排模型中，多个组件之间以有向无环图（DAG）的方式进行编排\n有向箭头表示组件之间的依赖关系，例如，组件A指向组件B的有向箭头表示组件B需要在组件A的运行结果的基础上进行数据处理和分析，即组件A的运行输出结果作为组件B的运行输入数据。\n组件编排模型的结构实现 组件编排信息通过规范化的 Json 语言进行描述\nconnections：组件执行顺序 fromIndex：起始组件序号 toIndex：结束组件序号 components：组件列表 componentId：组件唯一标识 index：组件序号 mode：组件运行模式 machine：执行组件的计算节点名称 args：组件数据处理参数 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 { \u0026#34;connections\u0026#34;: [ { \u0026#34;fromIndex\u0026#34;: 0, \u0026#34;toIndex\u0026#34;: 1 }, { \u0026#34;fromIndex\u0026#34;: 1, \u0026#34;toIndex\u0026#34;: 2 } ], \u0026#34;components\u0026#34;: [ { // 道路水平面切片生成组件 \u0026#34;componentId\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;index\u0026#34;: 0, \u0026#34;mode\u0026#34;: \u0026#34;algorithm\u0026#34;, \u0026#34;machine\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;input\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;secatt\u0026#34;: 1, \u0026#34;canvasrl\u0026#34;: 30, \u0026#34;canvasrw\u0026#34;: 30, \u0026#34;begins\u0026#34;: [ 30, 61, 90, 120 ], \u0026#34;ends\u0026#34;: [ 40, 71, 100, 130 ], \u0026#34;canvasstep\u0026#34;: 1, \u0026#34;interratiol\u0026#34;: 4, \u0026#34;interratiow\u0026#34;: 6, \u0026#34;centralFilepath\u0026#34;: \u0026#34;#\u0026#34;, } }, { // 道路裂缝识别组件 \u0026#34;componentId\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;index\u0026#34;: 1, \u0026#34;mode\u0026#34;: \u0026#34;algorithm\u0026#34;, \u0026#34;machine\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;input\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;alpha\u0026#34;:\u0026#34;0.3\u0026#34; } }, { // 裂缝线状形态拟合组件 \u0026#34;componentId\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;index\u0026#34;: 2, \u0026#34;mode\u0026#34;: \u0026#34;algorithm\u0026#34;, \u0026#34;machine\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;args\u0026#34;: { \u0026#34;input\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;output\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;rho\u0026#34;: 0.8, \u0026#34;theta\u0026#34;: 180, \u0026#34;threshold\u0026#34;: 40, \u0026#34;minLineLength\u0026#34;: 40, \u0026#34;maxLineGap\u0026#34;: 10, \u0026#34;delta1\u0026#34;: 0.1, \u0026#34;delta2\u0026#34;: 40 } } ] } ","date":"2025-01-07T15:43:24+08:00","permalink":"https://Tyritic.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E6%89%B9%E5%A4%84%E7%90%86%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E4%BA%8C%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9E%8B/","title":"分布式批处理计算平台（二）组件模型"},{"content":"项目背景 在数字经济时代，数据已经成为企业最重要的资产之一，如何有效地处理和分析这些数据以获取其潜在 价值，已经成为企业面临的重要任务。在进行数据处理和分析时，采用智能算法对数据进行批处理操作。处理过程 中，数据可被划分为适当大小的块，并通过循环逐块进行处理。\n业务场景分析 数据规模大：数字经济时代的数据规模可能以 TB 为单位 数据边缘存储 ：数据是企业的核心资产，通常情况下数据保存在企业内部服务器，即边缘端。在进行数据处理时，应避免将数据上传至云端，否则将占用大量的网络带宽，降低数据处理的效率，并且可能导致数据泄露的风险。 算法选择多样：在数据分析过程中，涉及的算法程序并没有一个统一的最优解，业务人员需要综合考虑业务需求、算法性能和特点等因素，从众多可行算法中选择最合适的算法来解决问题 项目目标 搭建分布式的批处理计算平台，将现有的批处理算法程序封装为可重用的批处理算法组件，通过平台实现组件的 构建与管理、任务编排与运行等功能。\n","date":"2025-01-07T15:05:51+08:00","permalink":"https://Tyritic.github.io/p/%E5%88%86%E5%B8%83%E5%BC%8F%E6%89%B9%E5%A4%84%E7%90%86%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E4%B8%80%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%AD%A5/","title":"分布式批处理计算平台（一）项目起步"},{"content":"体系结构 连接层：最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 服务层：第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。 引擎层：存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。 存储层：主要是将数据存储在文件系统之上，并完成与存储引擎的交互 存储引擎简介 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以不同表可以使用不同的存储引擎\n默认的存储引擎为 innoDB、\n查询当前数据库支持的存储引擎\n1 show engines 指定存储引擎\n1 2 create table table_name( )engine = 引擎名 存储引擎的特点 innoDB InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL5.5之后，InnoDB是默认的 MySOL存储引擎。\n特点 DML操作遵循ACID模型，支持事务 行级锁，提高并发访问性能 支持外键 FOREIGN KEY约束，保证数据的完整性和正确性 对应的磁盘文件 innoDB引擎的每张表都会对应这样一个表空间文件：xxx.ibd（xxx代表的是表名）\n存储该表的表结构（frm、sdi）、数据和索引\n参数：innodb_file_per_table\n","date":"2025-01-04T15:59:42+08:00","permalink":"https://Tyritic.github.io/p/mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/","title":"MySQL存储引擎"},{"content":"回答重点 方法重载（Overloading） ：在同一个类中，允许有多个同名方法，只要它们的参数列表不同（参数个数、类型或顺序）。主要关注方法的签名变化，适用于在同一类中定义不同场景下的行为。\n方法重写（Overriding）：子类在继承父类时，可以重写父类的某个方法（参数列表、方法名必须相同），从而为该方法提供新的实现。主要关注继承关系，用于子类改变父类的方法实现，实现运行时多态性。\n区别 重载 重写 发生的场所 在同一个类中 在继承关系的子类和父类之间 参数列表 必须不同（参数的数量、类型或顺序不同） 必须相同，不能改变参数列表 返回类型 可以不同 必须与父类方法的返回类型相同，或者是父类返回类型的子类（协变返回类型） 访问修饰符 不受访问修饰符影响 子类方法的访问修饰符不能比父类更严格，通常是相同或更宽泛 静态和非静态方法 可以是静态方法或非静态方法 只能重写非静态方法，静态方法不能被重写（静态方法可以被隐藏） 异常处理 方法的异常处理可以不同 子类的异常不能抛出比父类更多的异常（可以抛出更少的或相同类型的异常） 拓展知识 重载注意点 重载中提到的方法同名但参数列表不同（参数个数、类型或顺序），这里要注意和返回值没有关系，方法的签名仅是名字和参数列表，不包括返回值。\n重载通常用于提供同一操作的不同实现，例如构造函数的重载、不同类型输入的处理等。\n重写注意点 在重写时，子类方法不能使用比父类更严格的访问级别。例如，父类的方法是 protected，子类不能将其修改为 private，但可以改为 public。\n且子类方法抛出的异常必须与父类一致，或者是其父类异常的子类。\n重写通常用于在子类中提供父类方法的具体实现，以实现多态性。例如，子类对父类方法进行扩展或修改以适应特定需求。\n","date":"2025-01-03T16:05:05+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E5%92%8C%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/","title":"Java中的方法重载和方法重写"},{"content":"回答重点 概述 Java 中的继承机制是面向对象编程的核心特性之一，允许一个类（子类）继承另一个类（父类）的属性和方法。继承机制使得类之间可以形成层次结构，支持代码重用和扩展。它是实现多态、抽象和代码复用的关键机制。\n优缺点 优点：\n代码复用：子类可以复用父类的代码，减少重复实现。 易于维护：可以通过修改父类代码来影响所有子类。 缺点：\n紧耦合：子类依赖于父类的实现，父类的修改可能会影响子类。 灵活性差：继承层次结构可能会变得复杂，不易于调整或扩展。 基本概念 子类继承父类的字段和方法，可以重用和扩展父类的功能。Java 使用 extends 关键字来表示类的继承关系。\nJava 支持单继承，即一个类只能直接继承一个父类。子类可以继承父类的所有公共和受保护的成员，但不能继承父类的私有成员。\n子类构造方法首先调用父类的无参构造方法，如果父类没有无参构造方法，子类必须显式调用父类的其他构造方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 父类 public class Animal { protected String name; public Animal(String name) { this.name = name; } public void eat() { System.out.println(name + \u0026#34; is eating.\u0026#34;); } } // 子类 public class Dog extends Animal { public Dog(String name) { super(name); } public void bark() { System.out.println(name + \u0026#34; is barking.\u0026#34;); } } // 使用继承 public class Main { public static void main(String[] args) { Dog dog = new Dog(\u0026#34;Buddy\u0026#34;); dog.eat(); // 继承自 Animal dog.bark(); // Dog 自有的方法 } } super 关键字 super 关键字可以用来调用父类的方法或构造方法。\n1 2 3 public void eat() { super.eat(); // 调用父类的 eat 方法 } super 关键字也可以用来访问父类的字段。\n1 2 3 public void display() { System.out.println(super.name); // 访问父类的 name 字段 } 为什么不支持多继承 多继承会产生菱形继承的问题\nBC 继承了 A，然后 D 继承了 BC, 假设此时要调用 D 内定义在 A 的方法，因为 B 和 C 都有不同的实现，此时就会出现歧义，不知道应该调用哪个了\n为什么接口可以多实现？ 在 Java8 之前接口是无法定义具体方法实现的，所以即使有多个接口必须子类自己实现，所以并不会发生歧义。\nJava8 之后出了默认方法（default method），此时不就又出现的多继承的菱形继承问题了？\n所以 Java 强制规定，如果多个接口内有相同的默认方法，子类必须重写这个方法。\n","date":"2025-01-03T11:26:20+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6/","title":"Java的继承机制"},{"content":"回答重点 使用动机 抽象类的设计是 自下而上 的，当设计了很多类之后，发现类之间具有共性，有很多公共冗余的代码，于是设计抽象类将公共代码封装起来减少代码冗余\n接口的设计是 自上而下 的，我们事先知晓某一行为，基于这些行为约束定义了接口，一些类需要有这些行为，因此实现对应的接口。\n自上而下 指的是先约定接口，再实现。\n自下而上的 是先有一些类，才抽象了共同父类\n两者的区别 方法实现 接口中的方法默认是 public 和 abstract（但在 Java8 之后可以设置 default 方法或者静态方法，而且default方法可以被实现类重写）。 抽象类可以包含 abstract 方法（没有实现）和具体方法（有实现）。它允许子类继承并重用抽象类中的方法实现。 构造函数和成员变量 接口不能包含构造函数，接口中的成员变量默认为 public static final，即常量。 抽象类可以包含构造函数，成员变量可以有不同的访问修饰符（如 private、protected、public），并且包含实例变量和静态变量。 多继承 抽象类只能单继承 接口可以有多个实现。 ","date":"2025-01-03T11:13:40+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E8%BE%A8%E6%9E%90/","title":"Java中接口和抽象类的辨析"},{"content":"回答重点 访问修饰符的概念 Java 中的访问修饰符用于控制类、字段、方法和构造函数的访问权限。通过使用访问修饰符，可以实现封装，保护数据，并控制不同部分之间的访问范围。\nJava 主要有以下四种访问修饰符：\npublic：可以被任何类访问。 protected：可以被同一包中的其他类访问，也可以被子类（即使子类在不同包中）访问。 default：没有显式指定访问修饰符时，默认为包级别。只能被同一包中的其他类访问。 private：只能在定义它的类内部访问，外部无法直接访问。 表格整理如下\n修饰符 当前类 同一包内 子类（不同包） 其他包 public 是 是 是 是 protected 是 是 是 否 default 是 是 否 否 private 是 否 否 否 访问修饰符的选择动机 public：适用于需要被外部类广泛访问的成员。过多使用 public 可能导致封装性降低。 protected：适用于需要在继承关系中使用的成员。它提供了比 public 更严格的访问控制，但允许子类访问。 default：适用于仅在同一包内使用的类和成员。适当使用可以隐藏实现细节，减少类之间的耦合。 private：适用于内部实现细节，确保类的内部数据和方法不会被外部直接访问。最严格的访问控制，保护类的封装性。 ","date":"2025-01-03T11:06:24+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/","title":"Java中的访问修饰符"},{"content":"回答重点 静态方法 方法特点 由 static 关键字修饰 方法属于类，而不是类的某个实例 可以通过类名.方法名的格式直接调用，也可以通过对象调用（不推荐） 可以访问类的静态变量和其他静态方法（这些方法和变量属于类），但是不能访问类的实例方法和实例变量（实例方法和实例变量属于对象） 随着类的加载而加载，随着类的消亡而消失 典型使用场景 工具类 工厂方法 实例方法 方法特点 不使用 static 关键字声明的方法。 属于类的实例。 必须通过对象来调用。 可以访问实例变量和实例方法。也可以访问类的静态变量和静态方法。 随着对象的创建而存在，随着对象的销毁而消失。 典型使用场景 操作或修改对象的实例变量。 执行与对象状态相关的操作。 两者对比 特性 静态方法 实例方法 关键字 static 无 归属 类 对象 调用方式 通过类名或对象调用 通过对象调用 访问权限 只能访问静态变量和静态方法 可以访问实例变量、实例方法、静态变量和静态方法 典型用途 工具类方法、工厂方法 操作对象实例变量、与对象状态相关的操作 生命周期 类加载时存在，类卸载时消失 对象创建时存在，对象销毁时消失 拓展知识 静态方法中不能使用 this 关键字，因为 this 代表当前对象实例，而静态方法属于类，不属于任何实例。 静态方法可以被重载（同类中方法名相同，但参数不同），但不能被子类重写（因为方法绑定在编译时已确定）。实例方法可以被重载，也可以被子类重写。 实例方法中可以直接调用静态方法和访问静态变量。 静态方法不具有多态性，即不支持方法的运行时动态绑定。 ","date":"2025-01-03T10:56:32+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/","title":"Java中静态方法和实例方法的区别"},{"content":"回答重点 自动装箱（Autoboxing）：指的是 Java 编译器自动将基本数据类型转换为它们对应的包装类型。比如，将 int 转换为 Integer。\n自动拆箱（Unboxing）：指的是 Java 编译器自动将包装类型转换为基本数据类型。比如，将 Integer 转换为 int。\n主要作用：\n它在 Java 5 中引入，主要是为了提高代码的可读性，减少手动转换操作，简化了代码编写，开发者可以更方便地在基本类型和包装类型之间进行转换。 常见于：\n集合类如 List\u0026lt;Integer\u0026gt; 中无法存储基本类型，通过自动装箱，可以将 int 转换为 Integer 存入集合。\n1 2 3 4 int i = 99; //声明基础数据类型int变量 ArrayList list = new ArrayList(); list.add(i); //触发自动装箱，int类型自动转换成 Integer System.out.println(list); 自动装箱和拆箱经常在算术运算中出现，尤其是包装类型参与运算时。\n拓展知识 底层实现 自动装箱和拆箱并不是通过语法糖实现的，它是通过调用包装类型的 valueOf() 和 xxxValue() 方法实现的。\n自动装箱调用：Integer.valueOf(int i) 自动拆箱调用：Integer.intValue() 示例：\n1 2 Integer a = Integer.valueOf(10); // 自动装箱 int b = a.intValue(); // 自动拆箱 注意点 性能影响 自动装箱和拆箱虽然简化了编码，但在频繁使用的场景，可能导致性能开销，尤其是在循环中频繁发生装箱或拆箱时，容易引入不必要的对象创建和垃圾回收。\n所以尽量避免在性能敏感的代码中频繁使用自动装箱和拆箱。例如：\n1 2 3 4 Integer sum = 0; for (int i = 0; i \u0026lt; 10000; i++) { sum += i; // sum 是包装类型，导致多次装箱和拆箱 } NullPointerException 在进行拆箱操作时，如果包装类对象为 null，会抛出 NullPointerException。\n1 2 Integer num = null; int n = num; // 抛出 NullPointerException ","date":"2025-01-02T14:29:54+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1/","title":"Java中的自动装箱和自动拆箱"},{"content":"作用 Object类是Java所有类的父类，所有的Java类默认继承Object类，Object类中的所有方法都可以被Java类使用\n常见方法 以下是 Object 类中的主要方法及其作用：\n对象比较 public boolean equals(Object obj)\n作用：用于比较两个对象是否相等。默认实现比较对象的内存地址，即判断两个引用是否指向同一个对象。 使用：通常会重写此方法来比较对象的内容或特定属性，以定义对象的相等性。 public int hashCode()\n作用：返回对象的哈希码，是对象的整数表示。哈希码用于支持基于哈希的集合（如 HashMap 和 HashSet）。 使用：如果重写了 equals 方法，则通常也需要重写 hashCode 方法，以保证相等的对象具有相同的哈希码。 hashCode和equals的关系 equals决定了对象的逻辑相等性\nhashCode决定了对象的哈希存储方式。\nequals() 方法：\n用于判断两个对象是否相等。默认实现是使用 == 比较对象的内存地址，但可以在类中重写 equals() 来定义自己的相等逻辑。 hashCode() 方法：\n返回对象的哈希值，主要用于基于哈希的集合（如 HashMap、HashSet）。同一个对象每次调用 hashCode() 必须返回相同的值，且相等的对象必须有相同的哈希码。 equals 和 hashCode 的约定 相等对象的哈希值必须相等： 如果两个对象通过 equals 方法比较相等（a.equals(b) == true），那么它们的哈希值必须相同（a.hashCode() == b.hashCode()）。\n不相等的对象可以有相同的哈希值： 如果两个对象通过 equals 方法比较不相等（a.equals(b) == false），它们的哈希值不必不同，但为了提升性能，应尽量让不相等的对象有不同的哈希值。\n编码建议 重写 equals 方法的时候，也要重写 hashCode 方法，这样才能保持条件判断的同步。\n解释\n如果仅重写 equals 方法而不重写 hashCode，会违反 hashCode 与 equals 的约定，从而导致集合类行为异常。例如：HashSet 基于哈希值来判断对象是否相同，哈希值不同导致它们被视为不同的对象。\n对象转字符串 public String toString()\n作用：返回对象的字符串表示。默认实现返回对象的类名加上其哈希码的十六进制表示。 使用：通常会重写此方法以提供对象的更有意义的描述。 反射 public final Class\u0026lt;?\u0026gt; getClass()\n作用：返回对象的运行时类（Class 对象）。此方法是 Object 类中的一个 final 方法，不能被重写。 使用：可以用来获取对象的类信息，常用于反射操作。 多线程调度 public void notify()\n作用：唤醒在对象的监视器上等待的一个线程。该方法需要在同步块或同步方法中调用。 使用：用于在多线程环境中进行线程间的通信和协调。 public void notifyAll()\n作用：唤醒在对象的监视器上等待的所有线程。该方法需要在同步块或同步方法中调用。 使用：与 notify() 相似，但唤醒所有等待线程，用于处理多个线程之间的协作。 public void wait()\n作用：使当前线程等待，直到其他线程调用 notify() 或 notifyAll() 方法。此方法需要在同步块或同步方法中调用。 使用：用于线程间的通信，线程会等待直到被唤醒或超时。 public void wait(long timeout)\n作用：使当前线程等待，直到指定的时间到期或被唤醒。超时后线程会自动被唤醒。 使用：用于实现带有超时的等待机制。 public void wait(long timeout, int nanos)\n作用：使当前线程等待，直到指定的时间和纳秒数到期或被唤醒。 使用：用于实现更精细的等待控制，允许指定等待时间的精确到纳秒。 对象拷贝 protected Object clone()\n作用：创建并返回当前对象的一个副本。默认实现是进行浅拷贝。 使用：通常会重写此方法来实现深拷贝，以确保克隆对象的完整性。 垃圾回收 protected void finalize()\n作用：在垃圾回收器确定不存在对该对象的更多引用时调用，用于进行资源释放等清理工作。 使用：不建议使用，因为它依赖于垃圾回收器的实现，可能会导致不确定的性能问题。推荐使用 try-with-resources 和 AutoCloseable 接口进行资源管理 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } // 重写equals方法 @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null || getClass() != obj.getClass()) return false; Person person = (Person) obj; return age == person.age \u0026amp;\u0026amp; name.equals(person.name); } // 重写hashCode方法 @Override public int hashCode() { return Objects.hash(name, age); } // 重写toString方法 @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, age=\u0026#34; + age + \u0026#34;}\u0026#34;; } public static void main(String[] args) { Person p1 = new Person(\u0026#34;Alice\u0026#34;, 30); Person p2 = new Person(\u0026#34;Alice\u0026#34;, 30); System.out.println(p1.equals(p2)); // true System.out.println(p1.hashCode() == p2.hashCode()); // true System.out.println(p1); // Person{name=\u0026#39;Alice\u0026#39;, age=30} } } ","date":"2025-01-02T14:24:41+08:00","permalink":"https://Tyritic.github.io/p/object%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95/","title":"Object类的作用和相关方法"},{"content":"回答重点 Java 提供了 8 种基本数据类型（Primitive Types），用于处理不同类型的值：\n整型：\nbyte：占用 1 字节（8 位），取值范围为 -128 到 127。 short：占用 2 字节（16 位），取值范围为 -32,768 到 32,767。 int：占用 4 字节（32 位），取值范围为 -2^31 到 2^31-1。 long：占用 8 字节（64 位），取值范围为 -2^63 到 2^63-1。 浮点型：\nfloat：占用 4 字节（32 位），符合 IEEE 754 单精度标准。 double：占用 8 字节（64 位），符合 IEEE 754 双精度标准。 字符型：\nchar：占用 2 字节（16 位），存储单个 Unicode 字符，取值范围为 0 到 65,535。 布尔型：\nboolean：用于表示 true 或 false 两个值，具体存储大小依赖于虚拟机实现。 扩展知识 基本数据类型的特性：\n大小固定：每种基本类型在不同的操作系统和平台上占用的内存大小是固定的，保证了跨平台的一致性。 不支持 null：基本类型不能为 null，它们在声明时会有默认值，例如 int 的默认值是 0，boolean 的默认值是 false。 性能更高：基本类型直接存储在栈内存中，操作效率高于包装类型（如 Integer、Double）。 默认值：\nbyte、short、int、long 的默认值是 0。 float、double 的默认值是 0.0。 char 的默认值是 '\\u0000'。 boolean 的默认值是 false。 类型转换：\n隐式转换：当小类型赋值给大类型时（例如 int 到 long），会进行隐式转换，不会发生数据丢失。 强制类型转换：当大类型转换为小类型时（例如 double 到 float），需要显式进行强制类型转换，可能会造成精度丢失或溢出。 boolean 的存储：\n虽然 boolean 类型在逻辑上只占用 1 位，但 Java 的虚拟机对 boolean 的存储通常会根据系统架构分配 1 字节或更多位数的空间。这是因为 CPU 通常按字节操作内存，而非按位。 ","date":"2025-01-02T14:17:22+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","title":"Java的基本数据类型"},{"content":"回答重点 主要工具 javac：Java 编译器，负责将 Java 源代码编译成字节码（.class 文件）。 java：运行 Java 应用程序的命令，使用 JVM 来解释并执行编译后的字节码文件。 javadoc：生成 API 文档的工具，能够根据源代码中的注释生成 HTML 格式的文档。 jar：用于创建和管理 JAR 文件的工具，可以将多个 .class 文件打包为单一文件，便于分发和管理。 jdb：Java 调试工具，用于在命令行中调试 Java 应用程序，支持断点设置、变量查看等功能。 性能监控和分析工具 jps：Java 进程工具，显示所有正在运行的 Java 进程，便于监控和诊断。 jstack：生成线程堆栈信息的工具，常用于分析死锁和线程问题。 jmap：内存映射工具，可以生成堆转储（heap dump）文件，便于内存泄漏分析和垃圾回收优化。 jhat：堆分析工具，配合 jmap 使用，分析生成的堆转储文件，帮助开发者了解内存使用情况。 jstat：JVM 统计监控工具，实时监控垃圾回收、内存、类加载等信息，帮助开发者调优 JVM 性能。 jconsole：图形化的 JVM 监控工具，可以监控应用程序的内存、线程和类加载情况，常用于监控和调试。 jvisualvm：功能强大的性能分析工具，支持堆、线程、GC 的详细监控，还提供内存分析和 CPU 性能分析。 诊断工具 jinfo：用于查看和修改正在运行的 JVM 参数，便于动态调优和调整 JVM 行为。 jstatd：远程 JVM 监控工具，可以通过网络远程监控 JVM 的状态，适合分布式系统中的性能监控。 拓展知识 高级调试和性能优化工具 Java Mission Control (JMC)：一个功能强大的工具，用于分析和优化 Java 应用程序的性能，提供了基于飞行记录器（Java Flight Recorder，JFR）的性能分析功能，可以详细查看垃圾回收、线程活动、CPU 使用率等指标，是进行深度性能分析的利器。 Java Flight Recorder (JFR)：低开销的监控工具，能够记录 JVM 的运行时数据，适合生产环境中的性能分析，尤其是在高并发系统中使用频率较高。 GC 调优和内存分析 jmap 和 jhat 常用于排查内存泄漏或内存占用过高的问题。通过 jmap 生成堆转储文件后，开发者可以使用 jhat 或其他工具（如 Eclipse MAT）分析对象的引用链，从而发现潜在的内存问题。\n线程和死锁分析 jstack 是用于调试线程状态的利器，尤其是在分析线程死锁时。当应用卡死或响应时间异常时，通过 jstack 可以捕获应用的线程状态，并分析是否存在死锁情况。\n","date":"2025-01-02T14:03:21+08:00","permalink":"https://Tyritic.github.io/p/jdk%E5%B7%A5%E5%85%B7%E5%8C%85/","title":"JDK工具包"},{"content":"JRE JRE全称**（Java Runtime Environment）**是Java运行时环境，包含了 JVM, Java核心类库和其他支持Java程序的文件\n组成部分 JVM（Java Virtual Machine）：执行由源代码编译后得到的Java字节码，提供了Java程序的运行环境 核心类库：标准的类库（java.lang,java.utils）供Java程序使用 其他文件：配置文件，库文件，支持JVM的运行 JDK JDK全称 （Java Development Kit） 可以视为 JRE 的超集，是用于开发Java 程序的完整开发环境，它包含了JRE，以及用于开发、调试和监控 Java 应用程序的工具。\n组成部分 JRE：JDK包含了完整的JRE，可以运行java程序 开发工具：包含编译器（javac），打包工具（jar） 附加库和文件：支持开发，文档生成 拓展工具 javac：Java 编译器，用于将 Java 源代码（.java 文件）编译成字节码（.class 文件）。 java：Java 应用程序启动器，用于运行 Java 应用程序。 javadoc：文档生成器，用于从 Java 源代码中提取注释并生成 HTML 格式的 API 文档。 jar：归档工具，用于创建和管理 JAR（Java Archive）文件。 jdb：Java 调试器，用于调试 Java 程序。 jps：Java 进程状态工具，用于列出当前所有的 Java 进程。 jstat：JVM 统计监视工具，用于监视 JVM 统计信息。 jstatd：JVM 统计监视守护进程，用于在远程监视 JVM 统计信息。 jmap：内存映射工具，用于生成堆转储（heap dump）、查看内存使用情况。 jhat：堆分析工具，用于分析堆转储文件。 jstack：线程栈追踪工具，用于打印 Java 线程的栈追踪信息。 javap：类文件反汇编器，用于反汇编和查看 Java 类文件。 jdeps：Java 类依赖分析工具，用于分析类文件或 JAR 文件的依赖关系 ","date":"2025-01-02T12:10:06+08:00","permalink":"https://Tyritic.github.io/p/jdk%E5%92%8Cjre%E7%9A%84%E5%85%B3%E7%B3%BB/","title":"JDK和JRE的关系"},{"content":"回答重点 跨平台 垃圾回收 生态 面向对象 跨平台 Java 是跨平台的，通过 JVM 实现“一次编写，到处运行”。\nJava 源代码首先编译成字节码（.class 文件），然后由 JVM 将字节码转换成平台特定的机器码。只要在不同平台上安装相应的 JVM，字节码文件就能执行。\nJava 程序通过 JVM 这个“中间层”实现跨平台运行，编译生成的字节码文件是相同的，但不同平台的 JVM 会将其翻译成不同的机器码。尽管 Java 程序是跨平台的，但 JVM 本身是平台特定的，因此需要在每个平台上安装对应版本的 JVM 来支持执行。\nJVM 是跨平台的关键，它将字节码转换为机器码，因此 Java 程序能在不同平台上运行。即使将 Java 程序打包成可执行文件（.exe），仍然需要 JVM 的支持。\n提示\n解释执行比编译执行效率差\n解释执行：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢。（类比每次给你英语让你翻译阅读）\n编译执行：在程序执行之前，整个源代码会被编译成机器码或者字节码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性较差。（类比直接给你看中文）\nJava同时具有解释性和编译性\n编译性：Java源代码首先被编译成字节码，JIT 会把编译过的机器码保存起来,以备下次使用。 解释性：JVM中一个方法调用计数器通过统计发现一些高频次执行的代码（热点代码），然后将这些字节码交给 JIT 编译器进行编译，生成平台相关的机器码。下次执行时，JVM 会直接使用已编译的机器码，从而避免重新解释，提升性能。否则就是用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的 垃圾回收 Java 还提供垃圾自动回收功能，虽说手动管理内存意味着白由、精细化地掌控，但是很容易出错。 在内存较充裕的当下，将内存的管理交给 GC 来做，减轻了程序员编程的负担，提升了开发效率，更加划算!\n生态 Java 生态圈完善，丰富的第三方类库、企业级框架、各种中间件。\n面向对象 Java 是一种严格的面向对象编程语言，具有清晰的类、对象、继承、接口等概念，支持封装、继承、多态等 OOP 特性，有助于代码的可维护性和可扩展性。\n","date":"2025-01-02T10:53:37+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E7%89%B9%E7%82%B9/","title":"Java的优势与特点"},{"content":"Pojo类 pojo类在项目开发中用于标识实体类，该类在项目对应一个实际的业务对象，例如：user,student等\nPO/DO PO/DO类在项目中对应数据库中的一张表，数据库PO/DO是持久化对象，用于表示数据库中的一条记录映射成的Java对象，类中应该都是基本数据类型和String\nPO仅仅用于表示数据，不对数据进行操作，拥有get和set方法。对象类中的属性对应数据库表中的字段，有多少个字段就有多少个属性，完全匹配。\n命名规范：数据库表名+PO/DO\nDTO 全称（Data Transfer Object）用于后端接受前端的请求，将前端请求参数封装成对象\n通常用于将前端请求传递到控制层和控制层传递到业务逻辑层\nVO 全称（View Object）用于后端响应前端的过程中，作为视图对象\nBO 全称（Business Object）用于后端业务逻辑的处理\nBO是实际的业务对象，会参与业务逻辑的处理操作，里面可能会包含多个类，用于表示一个业务对象。遵循JavaBean规范，拥有get和set方法。\n","date":"2025-01-01T14:51:32+08:00","permalink":"https://Tyritic.github.io/p/bovopododto%E7%9A%84%E7%90%86%E8%A7%A3/","title":"BO、VO、PO、DO、DTO的理解"},{"content":"一维前缀和 题目描述 用于计算一维数组的区间和，将时间复杂度从$O(n * m) ,m 是查询的次数$简化到$O(n)$\n算法思想 前缀和的思想是重复利用计算过的子数组之和，从而降低区间查询需要累加计算的次数。\n例如，统计 vec[i] 这个数组上的区间和。\n先做累加，即 p[i] 表示 下标 0 到 i 的 vec[i] 累加 之和。 统计vec数组上 下标 i 到下标 j 之间的累加和时使用**p[j]-p[i-1]**即可 1 2 3 p[i] = vec[0] + vec[1] + ... vec[i]; p[j] = vec[0] + vec[1] + vec[2] + vec[3] + vec[4] + vec[5] + ..vec[j]; p[j] - p[i] = vec[i+1] + vec[i+2] + vec[i+3] + ... +vec[j]; 经典例题 题目描述 题目链接(opens new window)\n题目描述\n给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。\n输入描述\n第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间，直至文件结束。\n输出描述\n输出每个指定区间内元素的总和。\n输入示例\n1 2 3 4 5 6 7 8 5 1 2 3 4 5 0 1 1 3 输出示例\n1 2 3 9 数据范围：\n0 \u0026lt; n \u0026lt;= 100000\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int[] vec = new int[n]; int[] p = new int[n]; int presum = 0; for (int i = 0; i \u0026lt; n; i++) { vec[i] = scanner.nextInt(); presum += vec[i]; p[i] = presum; } while (scanner.hasNextInt()) { int a = scanner.nextInt(); int b = scanner.nextInt(); int sum; if (a == 0) { sum = p[b]; } else { sum = p[b] - p[a - 1]; } System.out.println(sum); } scanner.close(); } } ","date":"2024-12-31T20:35:31+08:00","permalink":"https://Tyritic.github.io/p/%E5%89%8D%E7%BC%80%E5%92%8C/","title":"前缀和"},{"content":"题目描述 通常用于在数组，链表中求解窗口的最值问题\n算法模板 最小滑动窗口 题目前提 给定数组 nums，定义滑窗的左右边界 i, j，求满足某个条件的滑窗的最小长度。\n思路解析 先固定左指针不动 一开始滑窗不满足条件，向右移动右指针直到窗口满足题目条件 迭代右移左指针同时更新结果（更新结果和移动左边界处于同一个while循环中） 代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class solution{ public result\u0026lt;T\u0026gt; search(int[]nums) { int left=0; for(int right=0;right\u0026lt;nums.length;right++) { calculate();// 计算约束条件 // 判断[i, j]是否满足条件 while 满足条件 { update(result); // 不断更新结果(注意在while内更新！) left++; //最大程度的压缩左边界，使得滑窗尽可能的小 } } return result; } } 最大滑动窗口 题目前提 给定数组 nums，定义滑窗的左右边界 i, j，求满足某个条件的滑窗的最大长度。\n思路解析 先固定左指针不动 一开始滑窗满足条件，向右移动右指针直到不满足条件 迭代右移右边界的过程中更新结果（更新结果和移动左边界不在一个while循环内） 最保守的压缩左边界，一旦满足条件了就退出压缩左边界的过程，使得滑窗尽可能的大 代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class solution{ public result\u0026lt;T\u0026gt; search(int[]nums) { int left=0; for(int right=0;right\u0026lt;nums.length;right++) { calculate();// 计算约束条件 // 判断[i, j]是否满足条件 while 不满足条件 { left++; //（最保守的压缩左边界，一旦满足条件了就退出压缩左边界的过程，使得滑窗尽可能的大） } update(result); } return result; } } 经典例题 leetcode 209. 长度最小的子数组 题目描述 力扣题目链接(opens new window)\n给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。\n示例：\n输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 提示：\n1 \u0026lt;= target \u0026lt;= 10^9 1 \u0026lt;= nums.length \u0026lt;= 10^5 1 \u0026lt;= nums[i] \u0026lt;= 10^5 思路解析 题目前提条件为\n给定数组 nums 求满足某个条件的滑窗的最小长度。 窗口一开始不满足条件 故采用最小滑动窗口策略\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int minSubArrayLen(int target, int[] nums) { int left=0; int sum=0; int result=Integer.MAX_VALUE; for(int right=0;right\u0026lt;nums.length;right++) {\t// 1.计算约束条件 sum+=nums[right]; // 2.当窗口满足条件 while(sum\u0026gt;=target) { // 3. 更新结果 result=Math.min(result,right-left+1); // 4. 右移右边界 sum-=nums[left]; left++; } } return result; } } leetcode 904. 水果成篮 题目描述 力扣题目链接\n你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。\n你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：\n你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。\n示例 1：\n1 2 3 输入：fruits = [1,2,1] 输出：3 解释：可以采摘全部 3 棵树。 示例 2：\n1 2 3 4 输入：fruits = [0,1,2,2] 输出：3 解释：可以采摘 [1,2,2] 这三棵树。 如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。 示例 3：\n1 2 3 4 输入：fruits = [1,2,3,2,2] 输出：4 解释：可以采摘 [2,3,2,2] 这四棵树。 如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。 示例 4：\n1 2 3 输入：fruits = [3,3,3,1,2,1,1,2,3,3,4] 输出：5 解释：可以采摘 [1,2,1,1,2] 这五棵树。 提示：\n1 \u0026lt;= fruits.length \u0026lt;= 105 0 \u0026lt;= fruits[i] \u0026lt; fruits.length 思路解析 本题可以抽象为求解一个滑动窗口，滑动窗口内只有两种数字，求解滑动窗口长度的最大值\n题目前提条件\n给定数组 nums 求满足某个条件的滑窗的最小长度。 窗口一开始满足条件 故采用最大滑动窗口策略\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public int totalFruit(int[] fruits) { int n=fruits.length; if(n==1)return 1; if(n==2)return 2; int left=0; int ans=0; int result=1; HashMap\u0026lt;Integer,Integer\u0026gt;map=new HashMap\u0026lt;\u0026gt;(); for(int right=0;right\u0026lt;fruits.length;right++) { // 1.计算约束条件（水果的种类数） map.put(fruits[right],map.getOrDefault(fruits[right],0)+1); // 2.若不满足条件 while(map.size()\u0026gt;2) { // 3.右移左边界 map.put(fruits[left],map.get(fruits[left])-1); if(map.get(fruits[left])==0) map.remove(fruits[left]); left++; } // 4.更新结果 result=Math.max(result,right-left+1); } return result; } } leetcode 76 最小覆盖子串 题目描述 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \u0026quot;\u0026quot; 。\n注意：\n对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。 如果 s 中存在这样的子串，我们保证它是唯一的答案。 示例 1：\n1 2 3 输入：s = \u0026#34;ADOBECODEBANC\u0026#34;, t = \u0026#34;ABC\u0026#34; 输出：\u0026#34;BANC\u0026#34; 解释：最小覆盖子串 \u0026#34;BANC\u0026#34; 包含来自字符串 t 的 \u0026#39;A\u0026#39;、\u0026#39;B\u0026#39; 和 \u0026#39;C\u0026#39;。 示例 2：\n1 2 3 输入：s = \u0026#34;a\u0026#34;, t = \u0026#34;a\u0026#34; 输出：\u0026#34;a\u0026#34; 解释：整个字符串 s 是最小覆盖子串。 示例 3:\n1 2 3 4 输入: s = \u0026#34;a\u0026#34;, t = \u0026#34;aa\u0026#34; 输出: \u0026#34;\u0026#34; 解释: t 中两个字符 \u0026#39;a\u0026#39; 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。 提示：\nm == s.length n == t.length 1 \u0026lt;= m, n \u0026lt;= 105 s 和 t 由英文字母组成 思路解析 本题可以将覆盖子串抽象为一个滑动窗口，求解该滑动窗口的最小值\n故采用最小滑动窗口策略\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Solution { public String minWindow(String s, String t) { int[]cnS=new int[128]; int[]cnT=new int[128]; char[]S=s.toCharArray(); char[]T=t.toCharArray(); for(char e:T) { cnT[e]++; } int left=0; int ansLeft=-1; int ansRight=s.length-1; for(int right=0;right\u0026lt;s.length;right++) { // 1.计算约束条件 cnS[S[right]]++; // 2.若满足条件 while(isCover(cnS,cnT)) { // 3.更新结果 if(right-left+1\u0026lt;ansRight-ansLeft+1) { ansLeft=left; ansRight=right; } // 4.右移左边界 cnT[S[left]]--; left++; } } return ansLeft\u0026lt;0?\u0026#34;\u0026#34;:s.substring(ansLeft,ansRight+1); } //通过统计子串中字符的出现次数来判断是否覆盖 public static boolean isCover(int[]cnS,int[]cnT) { for(int i=\u0026#39;a\u0026#39;;i\u0026lt;=\u0026#39;z\u0026#39;;i++) { if(cnS[i]\u0026lt;cnT[i]) { return false; } } for(int i=\u0026#39;A\u0026#39;;i\u0026lt;=\u0026#39;Z\u0026#39;;i++) { if(cnS[i]\u0026lt;cnT[i]) { return false; } } return true; } } ","date":"2024-12-30T15:29:22+08:00","permalink":"https://Tyritic.github.io/p/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%B3%95/","title":"双指针法-滑动窗口法"},{"content":"题目描述 通常当使用蛮力法需要两个for循环时，将两个for循环削减成一个for循环的优化方法。时间复杂度$O(n^2)$可以优化为$O(n)$\n同时数组排序为两端大，中间小\n算法模板 方法步骤 双指针法（左右指针法）： 通过一个左指针和右指针在一个for循环下完成两个for循环的工作。\n定义左右指针\n左指针：定义在数组左侧的指针 右指针：定义在数组尾部的指针 代码模板 1 2 3 4 5 6 7 8 9 10 11 class solution{ public int solution(int[]nums,int val) { int leftIndex=0; int rightIndex=nums.length-1; while(left\u0026lt;=right) { } } } 经典例题 leetcode 977. 有序数组的平方 题目描述 力扣题目链接(opens new window)\n给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n示例 1：\n输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100] 示例 2：\n输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] 思路解析 数组其实是有序的， 只不过负数平方之后可能成为最大数了。\n那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。\n此时可以考虑双指针法了，i指向起始位置，j指向终止位置。\n定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。比较左指针和右指针的平方大小\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int[] sortedSquares(int[] nums) { int leftIndex=0; int rightIndex=nums.length-1; int numsIndex=nums.length-1; int[]result=new int[nums.length]; while(leftIndex\u0026lt;=rightIndex) { if(nums[leftIndex]*nums[leftIndex]\u0026gt;=nums[rightIndex]*nums[rightIndex]) { result[numsIndex]=nums[leftIndex]*nums[leftIndex]; leftIndex++; } else{ result[numsIndex]=nums[rightIndex]*nums[rightIndex]; rightIndex--; } numsIndex--; } return result; } } ","date":"2024-12-30T11:44:58+08:00","permalink":"https://Tyritic.github.io/p/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95-%E5%B7%A6%E5%8F%B3%E6%8C%87%E9%92%88%E6%B3%95/","title":"双指针法 左右指针法"},{"content":"虚拟头节点 方法描述 设置一个虚拟头结点，这样原链表的所有节点就都可以按照统一的方式进行操作了。\n经典例题 leetcode 203. 移除链表元素 力扣题目链接(opens new window)\n题意：删除链表中等于给定值 val 的所有节点。\n示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]\n示例 2： 输入：head = [], val = 1 输出：[]\n示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * 时间复杂度 O(n) * 空间复杂度 O(1) * @param head * @param val * @return */ public ListNode removeElements(ListNode head, int val) { // 设置一个虚拟的头结点 ListNode dummy = new ListNode(); dummy.next = head; ListNode cur = dummy; while (cur.next != null) { if (cur.next.val == val) { cur.next = cur.next.next; } else { cur = cur.next; } } return dummy.next; } leetcode 24. 两两交换的节点 题目描述\n力扣题目链接(opens new window)\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n思路解析\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummy = new ListNode(-1); // 设置一个虚拟头结点 dummy.next = head; // 将虚拟头结点指向head，这样方便后面做删除操作 ListNode curr=dummy; ListNode temp; //保存两个节点后的节点 ListNode firstNode; //保存curr后的第一个节点 ListNode secondNode; //保存curr后的第二个节点 while(curr.next!=null\u0026amp;\u0026amp;curr.next.next!=null) { firstNode=curr.next; secondNode=firstNode.next; temp=secondNode.next; curr.next=secondNode; // 步骤一 secondNode.next=firstNode; //步骤二 firstNode.next=temp; // 步骤三 curr=firstNode; //重新设置为原先在secondNode位置上的节点 } return dummy.next; } } leetcode 19. 删除链表的倒数第N个节点 题目描述\n力扣题目链接(opens new window)\n给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n进阶：你能尝试使用一趟扫描实现吗？\n示例 1：\n输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5]\n示例 2：\n输入：head = [1], n = 1 输出：[]\n示例 3：\n输入：head = [1,2], n = 1 输出：[1]\n思路解析\n使用快慢指针和虚拟头节点，让快节点从虚拟头节点开始，提前移动n+1步。\n然后再让快节点和慢节点同时移动直到快节点移动到最后一个节点的后一个位置（null)\n此时快节点和慢节点之间间隔n个节点，慢节点位于要删除的节点的前一个节点位置\n直接删除即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { //新建一个虚拟头节点指向head ListNode dummyNode = new ListNode(0); dummyNode.next = head; //快慢指针指向虚拟头节点 ListNode fastIndex = dummyNode; ListNode slowIndex = dummyNode; // 快指针移动n+1步，使得快慢指针相差 n 个结点即可 for (int i = 0; i \u0026lt;= n; i++) { fastIndex = fastIndex.next; } // 两个指针同时移动，直到快指针移动到最后一个节点的后一个位置（null) while (fastIndex != null) { fastIndex = fastIndex.next; slowIndex = slowIndex.next; } // 检查 slowIndex.next 是否为 null，以避免空指针异常 if (slowIndex.next != null) { slowIndex.next = slowIndex.next.next; // 直接删除节点 } return dummyNode.next; } } 反转操作 思路解析 只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表\n定义节点\ncurr：当前节点 prev：当前节点的上一个节点 temp：当前节点的下一个节点 操作\n记录curr的下一个指针temp 将指针反转，让curr指向prev 将prev节点设置为curr 将curr设置为temp 经典例题 leetcode 206. 翻装链表 力扣题目链接(opens new window)\n题意：反转一个单链表。\n示例: 输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL 输出: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public ListNode reverseList(ListNode head) { ListNode prev=null; ListNode curr=head; ListNode temp=null; while(curr!=null) { temp=curr.next; curr.next=prev; prev=curr; curr=temp; } } } 判断链表是否相交 思路解析 求出A链表和B链表的长度 让currB到currA对齐的位置 此时比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。 经典例题 leetcode 160. 链表相交 力扣题目链接(opens new window)\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n图示两个链表在节点 c1 开始相交：\n题目数据 保证 整个链式结构中不存在环。\n注意，函数返回结果后，链表必须 保持其原始结构 。\n示例 1：\n示例 2：\n示例 3：\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode currA = headA; ListNode currB = headB; int lenA = 0, lenB = 0; while (currA != null) { // 求链表A的长度 lenA++; currA = currA.next; } while (currB != null) { // 求链表B的长度 lenB++; currB = currB.next; } // 将当前指针回到头节点 currA = headA; currB = headB; // 让currA为最长链表的头，lenA为其长度 if (lenB \u0026gt; lenA) { //1. swap (lenA, lenB); 交换长度 int tmpLen = lenA; lenA = lenB; lenB = tmpLen; //2. swap (currA, currB); 交换节点 ListNode tmpNode = currA; currA = currB; currB = tmpNode; } // 求长度差 int gap = lenA - lenB; // 让currA和currB在同一起点上（末尾位置对齐） for(int i=0;i\u0026lt;gap;i++) { currA=currA.next; } // 遍历currA 和 currB，遇到相同则直接返回 while (currA != null) { if (currA == currB) { return currA; } currA = currA.next; currB = currB.next; } return null; } } 环形链表 思路解析 判断是否是环形链表 使用快慢指针法，设置一个快指针和慢指针，让快指针一次移动两步，慢指针一次移动一步，若两个指针能相遇则该链表是环形链表\n证明过程\nfast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇\n其实相对于slow来说，fast是一个节点一个节点的靠近slow的\n如何找到环的入口 从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。\n经典例题 leetcode 142. 环形链表II 题目描述\n力扣题目链接(opens new window)\n题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。\n说明：不允许修改给定的链表。\n参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head; ListNode fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) {// 有环 ListNode index1 = fast; ListNode index2 = head; // 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口 while (index1 != index2) { index1 = index1.next; index2 = index2.next; } return index1; } } return null; } } ","date":"2024-12-29T17:25:11+08:00","permalink":"https://Tyritic.github.io/p/%E9%93%BE%E8%A1%A8/","title":"链表"},{"content":"题目描述 通常当使用蛮力法需要两个for循环时，将两个for循环削减成一个for循环的优化方法。时间复杂度$O(n^2)$可以优化为$O(n)$\n算法模板 方法步骤 双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。\n新数组指在旧数组的基础上修改后的数组\n定义快慢指针\n快指针：通过遍历旧数组来寻找新数组的元素 ，新数组就是不含有目标元素的数组 慢指针：指向更新后新数组下标的位置 代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 class solution{ public int solution(int[]nums,int val) { int slowIndex=0; for(int fastIndex=0;fastIndex\u0026lt;nums.length;fastIndex++) { //题目要求的操作,用于构建新数组，if条件内是符合新数组要求的谓词 //fastIndex用于遍历原数组 //slowIndex用于插入新数组 } return slowIndex; } } 结果分析 slowIndex是新数组的元素个数。\n经典例题 leetcode 27. 移除元素 题目描述 力扣题目链接(opens new window)\n给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。\n示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n你不需要考虑数组中超出新长度后面的元素。\n思路解析 题目条件中原地一词提示使用快慢指针法，将$O(n^2)$的操作转变为$O(n)$的操作\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int removeElement(int[] nums, int val) { int slowIndex=0; for(int fastIndex=0;fastIndex\u0026lt;nums.length;fastIndex++) { if(nums[fastIndex]!=val) { nums[slowIndex++]=nums[fastIndex]; } } return slowIndex; } } leetcode 26. 删除有序数组的重复项 题目描述 力扣题目链接\n给你一个 非严格递增排列 的数组 nums ，请你** 原地** 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。\n考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：\n更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。 返回 k 。 判题标准:\n系统会用下面的代码来测试你的题解:\n1 2 3 4 5 6 7 8 9 int[] nums = [...]; // 输入数组 int[] expectedNums = [...]; // 长度正确的期望答案 int k = removeDuplicates(nums); // 调用 assert k == expectedNums.length; for (int i = 0; i \u0026lt; k; i++) { assert nums[i] == expectedNums[i]; } 如果所有断言都通过，那么您的题解将被 通过。\n示例 1：\n1 2 3 输入：nums = [1,1,2] 输出：2, nums = [1,2,_] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2：\n1 2 3 输入：nums = [0,0,1,1,1,2,2,3,3,4] 输出：5, nums = [0,1,2,3,4] 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums 已按 非严格递增 排列 思路解析 题目条件中原地一词提示使用快慢指针法，将$O(n^2)$的操作转变为$O(n)$的操作\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int removeDuplicates(int[] nums) { int slowIndex=0; int fast=0; for(int fastIndex=0;fastIndex\u0026lt;nums.length-1;fastIndex++) { if(nums[fastIndex]!=nums[fastIndex+1]) { nums[slowIndex++]=nums[fastIndex]; } fast=fastIndex; // 1.跟踪快指针下标 } nums[slowIndex]=nums[fast+1]; // 2.slowIndex为下一个操作的数组下标，nums[fast+1]为数组最后一个元素（保证不与其他元素重复） return slowIndex+1; } } leetcode 283. 移动零 题目描述 力扣题目链接\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n示例 1:\n1 2 输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0] 示例 2:\n1 2 输入: nums = [0] 输出: [0] 提示:\n1 \u0026lt;= nums.length \u0026lt;= 104 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 思路解析 将所有不等于0的元素放入原先的数组中 在新数组的尾部全部置为零 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public void moveZeroes(int[] nums) { int slowIndex=0; for(int fastIndex=0;fastIndex\u0026lt;nums.length;fastIndex++) { if(nums[fastIndex]!=0) { nums[slowIndex++]=nums[fastIndex]; } } for(int i=slowIndex;i\u0026lt;nums.length;i++) { nums[i]=0; } } } leetcode 844. 比较含退格的字符串 题目描述 力扣题目链接\n给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。\n**注意：**如果对空文本输入退格字符，文本继续为空。\n示例 1：\n1 2 3 输入：s = \u0026#34;ab#c\u0026#34;, t = \u0026#34;ad#c\u0026#34; 输出：true 解释：s 和 t 都会变成 \u0026#34;ac\u0026#34;。 示例 2：\n1 2 3 输入：s = \u0026#34;ab##\u0026#34;, t = \u0026#34;c#d#\u0026#34; 输出：true 解释：s 和 t 都会变成 \u0026#34;\u0026#34;。 示例 3：\n1 2 3 输入：s = \u0026#34;a#c\u0026#34;, t = \u0026#34;b\u0026#34; 输出：false 解释：s 会变成 \u0026#34;c\u0026#34;，但 t 仍然是 \u0026#34;b\u0026#34;。 提示：\n1 \u0026lt;= s.length, t.length \u0026lt;= 200 s 和 t 只含有小写字母以及字符 '#' 思路解析 基本思路\n将s和t经过退格操作后的字符串求解出（封装成一个函数） 对比求解后的字符串来判断（主函数中进行） 退格操作的求解思路\n定义快慢指针fastIndex和slowIndex fastIndex从左往右遍历 当遇到非退格符号时slowIndex正常记录数组元素 当遇到退格符号时slowIndex向后退一位 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public boolean backspaceCompare(String s, String t) { String s1=checked(s); String s2=checked(t); if(s1.equals(s2)) { return true; } return false; } //求解退格处理后的字符串 public static String checked(String s) { char[]chars=s.toCharArray(s); int slowIndex=0; for(int fastIndex=0;fastIndex\u0026lt;chars.length;fastIndex++) { //遍历旧数组，不为退格符#的字符保留 if(chars[fastIndex]!=\u0026#39;#\u0026#39;) chars[slowIndex++]=chars[fastIndex]; //遍历旧数组，为退格符#的字符进行退格处理 else if(chars[fastIndex]==\u0026#39;#\u0026#39;) { //slowIndex是新数组的长度 if(slowIndex\u0026gt;0) slowIndex--; } } return new String(chars).substring(0,slow); } } ","date":"2024-12-29T16:21:01+08:00","permalink":"https://Tyritic.github.io/p/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E6%B3%95/","title":"双指针法——快慢指针法"},{"content":"题目特征 前提条件\n数组为有序数组 强调数组中无重复元素 题目的前提是数组为有序数组，同时题目还强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。\n算法模板 左闭右闭（推荐使用） 定义 target 是在一个在左闭右闭的区间里，也就是[left, right] 。\n临界条件的变化 while (left \u0026lt;= right) 要使用 \u0026lt;= ，因为left == right是有意义的，所以使用 \u0026lt;= if (nums[middle] \u0026gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1 代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class solution{ public int search(int[]nums,int target) { //定义target处于区间[left,right]中 int left=0; //左边界 int right=nums.length-1; //右边界 while(left\u0026lt;=right) { int mid=left+(right-left)/2; //防止溢出 等同于(left + right)/2 if(nums[mid]\u0026gt;target) right=mid-1; //查找区间为[left,mid-1] else if(nums[mid]\u0026lt;target) left=mid+1; //查找区间为[mid+1.right] else //nums[mid]==target return mid; } return -1; //若未找到返回-1，表示数组中不存在该元素 } } 结果分析 若数组中找不到元素此时满足条件\nleft=right+1 同时nums[left]是大于target的元素中最小的，nums[right]是小于target元素中最大的 左闭右开 定义 target 是在一个在左闭右开的区间里，也就是[left, right） 。\n临界条件的变化 while (left \u0026lt; right) 要使用 \u0026lt; ，因为left == right是没有意义的 if (nums[middle] \u0026gt; target) right 要赋值为 middle ，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle，下一个查询区间不会去比较nums[middle] 代码模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class solution{ public int search(int[]nums,int target) { //定义target处于区间[left,right)中 int left=0; //左边界 int right=nums.length; //右边界 while(left\u0026lt;right) { int mid=left+(right-left)/2; //防止溢出 等同于(left + right)/2 if(nums[mid]\u0026gt;target) right=mid; //查找区间为[left,mid-1] else if(nums[mid]\u0026lt;target) left=mid+1; //查找区间为[mid+1.right] else //nums[mid]==target return mid; } return -1; //若未找到返回-1，表示数组中不存在该元素 } } 结果分析 若数组中找不到元素此时满足条件\nleft=right 同时nums[left]=nums[right]是大于target的元素中最小的 经典例题 leetcode 704. 二分查找 题目描述 力扣题目链接(opens new window)\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n示例 1:\n1 2 3 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2:\n1 2 3 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示：\n你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 思路分析 直接嵌套算法模板即可\n参考代码 左闭右闭版本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int search(int[] nums, int target) { int left=0,right=nums.length-1; while(left\u0026lt;=right) { int mid=left+(right-left)/2; if(nums[mid]\u0026lt;target) left=mid+1; else if(nums[mid]\u0026gt;target) right=mid-1; else return mid; } return -1; } } 左闭右开版本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int search(int[] nums, int target) { int left=0,right=nums.length; while(left\u0026lt;right) { int mid=left+(right-left)/2; if(nums[mid]\u0026lt;target) left=mid+1; else if(nums[mid]\u0026gt;target) right=mid; else return mid; } return -1; } } leetcode 35. 搜索插入位置 题目描述 力扣题目链接(opens new window)\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n你可以假设数组中无重复元素。\n示例 1:\n输入: [1,3,5,6], 5 输出: 2 示例 2:\n输入: [1,3,5,6], 2 输出: 1 示例 3:\n输入: [1,3,5,6], 7 输出: 4 示例 4:\n输入: [1,3,5,6], 0 输出: 0 思路分析 注意这道题目的前提是数组是有序数组\n同时题目还强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的。\n分别处理四种可能情况\n目标值在数组所有元素之前 [0, -1] 目标值等于数组中某一个元素 return middle 目标值插入数组中的位置 [left, right]，return right + 1 目标值在数组所有元素之后的情况 [left, right]， 因为是右闭区间，所以 return right + 1 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int searchInsert(int[] nums, int target) { int left=0; int right=nums.length-1; while(left\u0026lt;=right) { int mid=left+(right-left)/2; if(nums[mid]\u0026lt;target) { left=mid+1; } else if(nums[mid]\u0026gt;target) { right=mid-1; } else{ return mid; } } // 2.目标值在数组所有元素之前 // 3.目标值插入数组中 // 4.目标值在数组所有元素之后 return right+1; } } leetcode 34. 在排序数组中查找元素的第一个和最后一个位置 题目描述 力扣链接(opens new window)\n给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n如果数组中不存在目标值 target，返回 [-1, -1]。\n进阶：你可以设计并实现时间复杂度为 $O(\\log n)$ 的算法解决此问题吗？\n示例 1：\n输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2：\n输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3：\n输入：nums = [], target = 0 输出：[-1,-1] 思路分析 题目条件\n给定一个按照升序排列的整数数组 nums 一个目标值 target。 符合二分查找的前提条件考虑使用二分查找\n具体思路如下\n首先，在 nums 数组中二分查找 target； 如果二分查找失败，则 binarySearch 返回 -1，表明 nums 中没有 target。此时，searchRange 直接返回 {-1, -1}； 如果二分查找成功，则 binarySearch 返回 nums 中值为 target 的一个下标。然后，通过左右滑动指针，来找到等于target的区间 参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public int[] searchRange(int[] nums, int target) { int index=BinarySearch(nums,target); // 1.先进行二分查找 if(index==-1) return new int[]{-1,-1}; int left=index; //左边界 int right=index; //右边界 // 2.移动左边界 while(left\u0026gt;0\u0026amp;\u0026amp;nums[left-1]==nums[index]) left--; // 3.移动右边界 while(right\u0026lt;nums.length-1\u0026amp;\u0026amp;nums[right+1]==nums[index]) right++; return new int[]{left,right}; } public static int BinarySearch(int[] nums, int target) { int left=0; int right=nums.length-1; while(left\u0026lt;=right) { int mid=left+(right-left)/2; if(nums[mid]\u0026lt;target) { left=mid+1; } else if(nums[mid]\u0026gt;target) { right=mid-1; } else{ return mid; } } return -1; } } leetcode 69. x的平方根 题目描述 力扣题目链接\n给你一个非负整数 x ，计算并返回 x 的 算术平方根 。\n由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。\n**注意：**不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\n示例 1：\n1 2 输入：x = 4 输出：2 示例 2：\n1 2 3 输入：x = 8 输出：2 解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 提示：\n0 \u0026lt;= x \u0026lt;= 231 - 1 思路分析 题目中隐含条件，平方根在[1,x]中且该区域为有序递增数组，考虑使用二分查找\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int mySqrt(int x) { if(x==0)return 0; if(x==1)return 1; int left=0,right=x/2; while(left\u0026lt;=right) { int mid=left+(right-left)/2; if(nums[mid]\u0026lt;target) left=mid+1; else if(nums[mid]\u0026gt;target) right=mid-1; else return mid; } return right; //结果为比x小的最大整数 } } leetcode 367. 有效的完全平方数 题目描述 力扣题目链接\n给你一个正整数 num 。如果 num 是一个完全平方数，则返回 true ，否则返回 false 。\n完全平方数 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。\n不能使用任何内置的库函数，如 sqrt 。\n示例 1：\n1 2 3 输入：num = 16 输出：true 解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。 示例 2：\n1 2 3 输入：num = 14 输出：false 解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。 提示：\n1 \u0026lt;= num \u0026lt;= 231 - 1 思路分析 同上一题，注意细节：mid*mid非常容易溢出，所以采取的策略是用除法代替乘法\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public boolean isPerfectSquare(int num) { int left=0; int right=num; if(num==0||num==1)return true;// 1.特殊值判断 while(left\u0026lt;=right) { int mid=left+(right-left)/2; if(mid==num/(mid*1.0)) return true; else if (mid\u0026gt;num/(mid*1.0)) right=mid-1; else left=mid+1; } return false; } } ","date":"2024-12-29T10:52:54+08:00","permalink":"https://Tyritic.github.io/p/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","title":"二分查找"},{"content":"ArrayList类 ArrayList 是 Java 集合框架中的一个类，属于 java.util 包，是一种 基于动态数组实现的可变长度集合。它实现了 List 接口，提供了一个可调整大小的数组，能够存储任意类型的对象（包括自定义类和基本类型的包装类）。\n特点 动态数组： ArrayList 的大小是可变的，默认容量为 10。当元素数量超过当前容量时，ArrayList 会自动扩容，通常以 1.5 倍的速度增长。 有序： 元素按照插入的顺序存储，可以通过索引访问，顺序不会改变（除非显式调整）。 允许重复元素： ArrayList 允许存储重复的元素。 支持随机访问： 因为底层是数组，ArrayList 支持快速随机访问，时间复杂度为$ O(1)$。 线程不安全： ArrayList 是非同步的，因此在多线程环境下需要手动同步（可以使用 Collections.synchronizedList() 或 CopyOnWriteArrayList 替代）。 常见方法 构造方法 public ArrayList()：创建一个默认初始容量为 10 的空 ArrayList public ArrayList(int initialCapacity)：创建一个具有指定初始容量的空 ArrayList public ArrayList(Collection\u0026lt;? extends E\u0026gt; c)：创建一个包含指定集合中所有元素的 ArrayList，按照集合的迭代器顺序。 添加元素 boolean add(E e)：将指定的元素添加到列表的末尾 void add(int index, E element)：将指定的元素插入到列表的指定位置 boolean addAll(Collection\u0026lt;? extends E\u0026gt; c)：将指定集合中的所有元素添加到当前列表的末尾 boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c)：将指定集合中的所有元素插入到当前列表的指定位置。 删除元素 void clear()：删除全部元素 E remove(int index)：删除列表中指定位置的元素 boolean remove(Object o)：删除列表中第一次出现的指定元素。如果列表中没有该元素，则不做任何操作。 boolean removeAll(Collection\u0026lt;?\u0026gt; c)：删除当前列表中所有与指定集合中的元素相同的元素 void removeRange(int from,int to):删除索引[from，to）之间的元素 判断元素 boolean contains(Object o)：判断列表中是否包含指定的元素 boolean containsAll(Collection\u0026lt;?\u0026gt; c)：判断列表是否包含指定集合中的所有元素 修改元素 E set(int index, E element)：用指定的元素替换列表中指定位置的元素 访问元素 E get(int index)：返回指定位置的元素 int indexOf(Object o)：返回指定元素在列表中的第一次出现位置的索引。如果列表中没有该元素，则返回 -1 int lastIndexOf(Object o)：返回指定元素在列表中的最后一次出现位置的索引。如果列表中没有该元素，则返回 -1 获取大小 int size()：返回列表中元素的数量 boolean isEmpty()：判断列表是否为空 void ensureCapacity(int minCapacity)：确保列表能够容纳至少指定数量的元素，不会导致扩容。 扩容机制 源码分析 往 ArrayList 中添加元素时会有 ensureCapacityInternal 的判断\n1 2 3 4 5 public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } ensureCapacityInternal 内部会调用 ensureExplicitCapacity 方法，若 minCapacity - elementData.length \u0026gt; 0 即容量不够了，则会调用 grow 方法：\n1 2 3 4 5 6 7 8 9 10 11 /** * 检查并确保集合容量足够，如果需要则增加集合容量。 * * @param minCapacity 所需最小容量 */ private void ensureExplicitCapacity(int minCapacity) { // 检查是否超出了数组范围，确保不会溢出 if (minCapacity - elementData.length \u0026gt; 0) // 如果需要增加容量，则调用 grow 方法 grow(minCapacity); } grow 扩容逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 扩容 ArrayList 的方法，确保能够容纳指定容量的元素 * @param minCapacity 指定容量的最小值 */ private void grow(int minCapacity) { // 检查是否会导致溢出，oldCapacity 为当前数组长度 int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); // 扩容至原来的1.5倍 if (newCapacity - minCapacity \u0026lt; 0) // 如果还是小于指定容量的最小值 newCapacity = minCapacity; // 直接扩容至指定容量的最小值 if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) // 如果超出了数组的最大长度 newCapacity = hugeCapacity(minCapacity); // 扩容至数组的最大长度 // 将当前数组复制到一个新数组中，长度为 newCapacity elementData = Arrays.copyOf(elementData, newCapacity); } 总结 当 ArrayList 中的元素数量超过其当前容量时，会触发扩容机制。\n默认情况下，ArrayList 的初始容量为 10。\n当发生扩容时，ArrayList 会创建一个新的数组，其容量为原数组的 1.5 倍（即 oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1)），若还是小于指定容量的最小值会直接扩容到指定容量的最小值\n然后将原数组中的元素复制到新数组中。复制过程是通过 Arrays.copyOf() 方法实现的。\n更新引用：将ArrayList内部指向原数组的引用指向新数组。\n完成扩容：扩容完成后，可以继续添加新元素。\n线程安全问题 为什么是线程不安全的 ArrayList不是线程安全的。ArrayList会暴露三个问题;\n部分值为null（我们并没有add null进去） 索引越界异常 线程1走到扩容那里发现当前size是n，数组容量是n+1不用扩容，cpu让出执行权 线程2也发现不用扩容，这时候数组的容量就是n+1 而线程1 set完之后size++，这时候线程2再进来size就是n+1，数组的大小只有n+1，而你要设置下标索引为n+1的就会越界（数组的下标索引size从0开始）； size与add的数量不符 因为size++本身不是原子操作，可以分为三步： 获取size的值 将size的值加1 将新的size值覆盖掉原来的 线程1和线程2拿到一样的size值加完了同时覆盖，就会导致一次没有加上，所以肯定不会与add的数量保持一致的； 解决方法 使用Collections类的synchronizedList方法将ArrayList包装成线程安全的List\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import java.util.ArrayList; import java.util.Collections; import java.util.List; public class SynchronizedListExample { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; list = Collections.synchronizedList(new ArrayList\u0026lt;\u0026gt;()); // 同步块中操作列表，保证线程安全 synchronized (list) { list.add(1); list.add(2); System.out.println(list); } } } 使用线程安全的替代类CopyOnWriteArrayList\n增删查改的机制 查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * 返回列表中指定位置的元素。 * * @param index 要返回的元素的索引 * @return 列表中指定位置的元素 * @throws IndexOutOfBoundsException 如果索引超出范围（index \u0026lt; 0 || index \u0026gt;= size()） */ public E get(int index) { rangeCheck(index); // 检查索引是否合法 return elementData(index); // 调用 elementData 方法获取元素 } /** * 返回列表中指定位置的元素。 * 此方法不进行边界检查，因此只应由内部方法和迭代器调用。 * * @param index 要返回的元素的索引 * @return 列表中指定位置的元素 */ E elementData(int index) { return (E) elementData[index]; // 返回指定索引位置上的元素 } 时间复杂度为$ O(1)$，因为 ArrayList 内部使用数组来存储元素，所以可以直接根据索引来访问元素。\n插入 添加一个元素（调用 add() 方法时）的时间复杂度最好情况为 $O(1)$，最坏情况为 $O(n)$。\n如果在列表末尾添加元素，时间复杂度为 $O(1)$。 如果要在列表的中间或开头插入元素，则需要将插入位置之后的元素全部向后移动一位，时间复杂度为 $O(n)$。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * 在指定位置插入一个元素。 * * @param index 要插入元素的位置 * @param element 要插入的元素 * @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常 */ public void add(int index, E element) { rangeCheckForAdd(index); // 检查索引是否越界 ensureCapacityInternal(size + 1); // 确保容量足够，如果需要扩容就扩容 System.arraycopy(elementData, index, elementData, index + 1, size - index); // 将 index 及其后面的元素向后移动一位 elementData[index] = element; // 将元素插入到指定位置 size++; // 元素个数加一 } 修改 修改一个元素（调用 set()方法时）可以直接根据索引来访问元素，时间复杂度为 $O(1)$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 用指定元素替换列表中指定位置的元素。 * * @param index 要替换元素的索引 * @param element 要放入列表中的元素 * @return 原来在指定位置上的元素 * @throws IndexOutOfBoundsException 如果索引超出范围（index \u0026lt; 0 || index \u0026gt;= size()） */ public E set(int index, E element) { rangeCheck(index); // 检查索引是否合法 E oldValue = elementData(index); // 获取原来在指定位置上的元素 elementData[index] = element; // 将指定位置上的元素替换为新元素 return oldValue; // 返回原来在指定位置上的元素 } 删除 删除一个元素（调用 remove(Object) 方法时）的时间复杂度最好情况 $O(1)$，最坏情况 $O(n)$。\n如果要删除列表末尾的元素，时间复杂度为 $O(1)$。 如果要删除列表中间或开头的元素，则需要将删除位置之后的元素全部向前移动一位，时间复杂度为 $O(n)$。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /** * 删除指定位置的元素。 * * @param index 要删除的元素的索引 * @return 先前在指定位置的元素 * @throws IndexOutOfBoundsException 如果索引超出范围，则抛出此异常 */ public E remove(int index) { rangeCheck(index); // 检查索引是否越界 E oldValue = elementData(index); // 获取要删除的元素 int numMoved = size - index - 1; // 计算需要移动的元素个数 if (numMoved \u0026gt; 0) // 如果需要移动元素，就用 System.arraycopy 方法实现 System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // 将数组末尾的元素置为 null，让 GC 回收该元素占用的空间 return oldValue; // 返回被删除的元素 } /** * 删除列表中第一次出现的指定元素（如果存在）。 * * @param o 要删除的元素 * @return 如果列表包含指定元素，则返回 true；否则返回 false */ public boolean remove(Object o) { if (o == null) { // 如果要删除的元素是 null for (int index = 0; index \u0026lt; size; index++) // 遍历列表 if (elementData[index] == null) { // 如果找到了 null 元素 fastRemove(index); // 调用 fastRemove 方法快速删除元素 return true; // 返回 true，表示成功删除元素 } } else { // 如果要删除的元素不是 null for (int index = 0; index \u0026lt; size; index++) // 遍历列表 if (o.equals(elementData[index])) { // 如果找到了要删除的元素 fastRemove(index); // 调用 fastRemove 方法快速删除元素 return true; // 返回 true，表示成功删除元素 } } return false; // 如果找不到要删除的元素，则返回 false } LinkedList类 LinkedList 是 Java 集合框架中的一个类，位于 java.util 包下，它同时实现了 List 和 Deque 接口，是一种基于双向链表的数据结构。\n特点 双向链表： 每个节点包含： 一个存储数据的字段。 两个指针，分别指向前一个节点和后一个节点。 动态容量： LinkedList 的大小可以动态变化，无需像数组那样预定义容量。 线程不安全： LinkedList 是非同步的，因此在多线程环境下需要手动同步 插入和删除效率高： 插入操作：在链表任意位置插入元素的时间复杂度为 O(1)，只需调整指针即可（如果已定位到插入点）。 删除操作：删除元素也只需调整相关指针，时间复杂度为 O(1)。 有序： 元素按照插入的顺序存储，可以通过索引访问，顺序不会改变（除非显式调整）。 允许重复元素： ArrayList 允许存储重复的元素。 常见方法 构造方法 public LinkedList()：创建一个空的 LinkedList 实例 public LinkedList(Collection\u0026lt;? extends E\u0026gt; c)：使用指定集合中的所有元素初始化 LinkedList 添加元素 boolean add(E e)：将指定的元素添加到链表的末尾 void add(int index, E element)：将指定的元素插入到链表的指定位置 void addFirst(E e)：在链表头部添加元素 void addLast(E e)：在链表尾部添加元素 访问元素 E get(int index)：返回指定位置的元素 E getFirst()：返回链表头部的第一个元素 E getLast()：返回链表尾部的最后一个元素 int indexOf(Object o)：返回指定元素在列表中的首次出现位置，如果列表中不包含该元素，返回 -1。 int lastIndexOf(Object o)：返回指定元素在列表中最后一次出现的位置，如果列表中不包含该元素，返回 -1。 删除元素 E remove(int index)：删除指定位置的元素，并返回被删除的元素 boolean remove(Object o)：删除链表中第一个匹配的元素 E removeFirst()：删除并返回链表头部的第一个元素 E removeLast()：删除并返回链表尾部的最后一个元素 void clear()：删除全部元素 判断元素 boolean contains(Object o)：判断列表中是否包含指定的元素 boolean containsAll(Collection\u0026lt;?\u0026gt; c)：判断列表是否包含指定集合中的所有元素 获取大小 int size()：返回列表中元素的数量 boolean isEmpty()：判断列表是否为空 修改元素 E set(int index, E element)：用指定的元素替换列表中指定位置的元素 源码解析 链表节点类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * 链表中的节点类。 */ private static class Node\u0026lt;E\u0026gt; { E item; // 节点中存储的元素 Node\u0026lt;E\u0026gt; next; // 指向下一个节点的指针 Node\u0026lt;E\u0026gt; prev; // 指向上一个节点的指针 /** * 构造一个新的节点。 * * @param prev 前一个节点 * @param element 节点中要存储的元素 * @param next 后一个节点 */ Node(Node\u0026lt;E\u0026gt; prev, E element, Node\u0026lt;E\u0026gt; next) { this.item = element; // 存储元素 this.next = next; // 设置下一个节点 this.prev = prev; // 设置上一个节点 } } 组成结构\n节点上的元素 下一个节点 上一个节点 插入节点 add 方法内部其实调用的是 linkLast 方法\n1 2 3 4 5 6 7 8 9 10 /** * 将指定的元素添加到列表的尾部。 * * @param e 要添加到列表的元素 * @return 始终为 true（根据 Java 集合框架规范） */ public boolean add(E e) { linkLast(e); // 在列表的尾部添加元素 return true; // 添加元素成功，返回 true } linkLast方法就是在链表的尾部添加元素（尾插法）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 在列表的尾部添加指定的元素。 * * @param e 要添加到列表的元素 */ void linkLast(E e) { final Node\u0026lt;E\u0026gt; l = last; // 获取链表的最后一个节点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(l, e, null); // 创建一个新的节点，并将其设置为链表的最后一个节点 last = newNode; // 将新的节点设置为链表的最后一个节点 if (l == null) // 如果链表为空，则将新节点设置为头节点 first = newNode; else l.next = newNode; // 否则将新节点链接到链表的尾部 size++; // 增加链表的元素个数 } linkFirst方法就是在链表的头部添加元素，把新的节点设为 first，并将新的 first 的 next 更新为之前的 first。（头插法）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 在列表的开头添加指定的元素。 * * @param e 要添加到列表的元素 */ private void linkFirst(E e) { final Node\u0026lt;E\u0026gt; f = first; // 获取链表的第一个节点 final Node\u0026lt;E\u0026gt; newNode = new Node\u0026lt;\u0026gt;(null, e, f); // 创建一个新的节点，并将其设置为链表的第一个节点 first = newNode; // 将新的节点设置为链表的第一个节点 if (f == null) // 如果链表为空，则将新节点设置为尾节点 last = newNode; else f.prev = newNode; // 否则将新节点链接到链表的头部 size++; // 增加链表的元素个数 } 删除节点 remove(int) 内部其实调用的是 unlink 方法\n1 2 3 4 5 6 7 8 9 10 11 /** * 删除指定位置上的元素。 * * @param index 要删除的元素的索引 * @return 从列表中删除的元素 * @throws IndexOutOfBoundsException 如果索引越界（index \u0026amp;lt; 0 || index \u0026amp;gt;= size()） */ public E remove(int index) { checkElementIndex(index); // 检查索引是否越界 return unlink(node(index)); // 删除指定位置的节点，并返回节点的元素 } unlink 方法就是更新当前节点的 next 和 prev，然后把当前节点上的元素设为 null。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * 从链表中删除指定节点。 * * @param x 要删除的节点 * @return 从链表中删除的节点的元素 */ E unlink(Node\u0026lt;E\u0026gt; x) { final E element = x.item; // 获取要删除节点的元素 final Node\u0026lt;E\u0026gt; next = x.next; // 获取要删除节点的下一个节点 final Node\u0026lt;E\u0026gt; prev = x.prev; // 获取要删除节点的上一个节点 if (prev == null) { // 如果要删除节点是第一个节点 first = next; // 将链表的头节点设置为要删除节点的下一个节点 } else { prev.next = next; // 将要删除节点的上一个节点指向要删除节点的下一个节点 x.prev = null; // 将要删除节点的上一个节点设置为空 } if (next == null) { // 如果要删除节点是最后一个节点 last = prev; // 将链表的尾节点设置为要删除节点的上一个节点 } else { next.prev = prev; // 将要删除节点的下一个节点指向要删除节点的上一个节点 x.next = null; // 将要删除节点的下一个节点设置为空 } x.item = null; // 将要删除节点的元素设置为空 size--; // 减少链表的元素个数 return element; // 返回被删除节点的元素 } 修改节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 将链表中指定位置的元素替换为指定元素，并返回原来的元素。 * * @param index 要替换元素的位置（从 0 开始） * @param element 要插入的元素 * @return 替换前的元素 * @throws IndexOutOfBoundsException 如果索引超出范围（index \u0026lt; 0 || index \u0026gt;= size()） */ public E set(int index, E element) { checkElementIndex(index); // 检查索引是否超出范围 Node\u0026lt;E\u0026gt; x = node(index); // 获取要替换的节点 E oldVal = x.item; // 获取要替换节点的元素 x.item = element; // 将要替换的节点的元素设置为指定元素 return oldVal; // 返回替换前的元素 } node()方法用于定位要替换的节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * 获取链表中指定位置的节点。 * * @param index 节点的位置（从 0 开始） * @return 指定位置的节点 * @throws IndexOutOfBoundsException 如果索引超出范围（index \u0026lt; 0 || index \u0026gt;= size()） */ Node\u0026lt;E\u0026gt; node(int index) { if (index \u0026lt; (size \u0026gt;\u0026gt; 1)) { // 如果索引在链表的前半部分 Node\u0026lt;E\u0026gt; x = first; for (int i = 0; i \u0026lt; index; i++) // 从头节点开始向后遍历链表，直到找到指定位置的节点 x = x.next; return x; // 返回指定位置的节点 } else { // 如果索引在链表的后半部分 Node\u0026lt;E\u0026gt; x = last; for (int i = size - 1; i \u0026gt; index; i--) // 从尾节点开始向前遍历链表，直到找到指定位置的节点 x = x.prev; return x; // 返回指定位置的节点 } } node 方法会对下标进行一个初步判断，如果靠近前半截，就从下标 0 开始遍历；如果靠近后半截，就从末尾开始遍历。\nStack类 Stack 是 Java 集合框架中的一个类，位于 java.util 包中，作为Vector的子类间接实现了List接口，用于实现**栈（Stack）**数据结构\n特点 Stack 类继承自 Vector 类，因此它是一种**同步的（线程安全的）**集合。 常用方法 入栈操作 public E push(E item)：将元素压入栈顶 出栈操作 public synchronized E pop() 移除并返回栈顶的元素。 如果栈为空，则抛出 EmptyStackException。 查看栈顶元素 public synchronized E peek() 返回栈顶的元素，但不移除。 如果栈为空，则抛出 EmptyStackException。 检查栈空 public boolean empty()：判断栈是否为空 搜索元素 public synchronized int search(Object o) 返回元素在栈中的位置（以 1 为基准）。 如果元素不存在，则返回 -1。 CopyOnWriteArrayList类 CopyOnWriteArrayList 是 Java 的一个线程安全的动态数组实现，属于 java.util.concurrent 包。\n它通过写时复制机制，即在每次修改（写入）操作时，复制原始数组的内容来保证线程安全。\n由于写操作涉及复制整个数组，所以它的写操作开销较大，但读取操作则完全无锁。这使得 CopyOnWriteArrayList 适合于读多写少的场景。\n特点 写时复制是一种保证数据一致性和线程安全的技术。核心思想是在进行写操作时，不直接修改原来的数据结构，而是先复制一份副本，在副本上进行修改，然后将修改后的副本替换原来的数据结构。 保证数据一致性和线程安全 常见方法 构造方法 public CopyOnWriteArrayList()：创建一个空的 CopyOnWriteArrayList public CopyOnWriteArrayList(Collection\u0026lt;? extends E\u0026gt; c)：使用指定的集合初始化 CopyOnWriteArrayList public CopyOnWriteArrayList(E[] toCopyIn)：使用指定的数组初始化 CopyOnWriteArrayList。 添加元素 boolean add(E e)：将指定的元素添加到链表的末尾 void add(int index, E element)：将指定的元素插入到链表的指定位置 void addFirst(E e)：在链表头部添加元素 void addLast(E e)：在链表尾部添加元素 访问元素 E get(int index)：返回指定位置的元素 E getFirst()：返回链表头部的第一个元素 E getLast()：返回链表尾部的最后一个元素 int indexOf(Object o)：返回指定元素在列表中的首次出现位置，如果列表中不包含该元素，返回 -1。 int lastIndexOf(Object o)：返回指定元素在列表中最后一次出现的位置，如果列表中不包含该元素，返回 -1。 删除元素 E remove(int index)：删除指定位置的元素，并返回被删除的元素 boolean remove(Object o)：删除链表中第一个匹配的元素 E removeFirst()：删除并返回链表头部的第一个元素 E removeLast()：删除并返回链表尾部的最后一个元素 void clear()：删除全部元素 判断元素 boolean contains(Object o)：判断列表中是否包含指定的元素 boolean containsAll(Collection\u0026lt;?\u0026gt; c)：判断列表是否包含指定集合中的所有元素 获取大小 int size()：返回列表中元素的数量 boolean isEmpty()：判断列表是否为空 修改元素 E set(int index, E element)：用指定的元素替换列表中指定位置的元素 源码分析 CopyOnWriteArrayList底层也是通过一个数组保存数据，使用volatile关键字修饰数组，保证当前线程对数组对象重新赋值后，其他线程可以及时感知到。\n1 private transient volatile Object[] array; 写操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public boolean add(E e) { //获取锁 final ReentrantLock lock = this.lock; //加锁 lock.lock(); try { //获取到当前List集合保存数据的数组 Object[] elements = getArray(); //获取该数组的长度（这是一个伏笔，同时len也是新数组的最后一个元素的索引值） int len = elements.length; //将当前数组拷贝一份的同时，让其长度加1 Object[] newElements = Arrays.copyOf(elements, len + 1); //将加入的元素放在新数组最后一位，len不是旧数组长度吗，为什么现在用它当成新数组的最后一个元素的下标？建议自行画图推演，就很容易理解。 newElements[len] = e; //替换引用，将数组的引用指向给新数组的地址 setArray(newElements); return true; } finally { //释放锁 lock.unlock(); } } 读取当前数组：首先读取当前的数组，这个数组是 CopyOnWriteArrayList 当前持有的数组。 复制数组：创建一个当前数组的副本（新的数组），这个副本会拷贝当前数组中的所有元素。 在副本上进行修改：在副本数组上进行写操作（如添加、删除元素）。 用新数组替换旧数组：将修改后的副本数组设置为 CopyOnWriteArrayList 持有的数组，旧数组将不再使用。 读操作 1 2 3 public E get(int index) { return get(getArray(), index); } 所有读操作都可以无锁地直接读取 CopyOnWriteArrayList 当前持有的数组，因为这个数组在读操作期间不会被修改。\nCopyOnWriteArrayList 和 Collections.synchronizedList 的区别（面试题） 回答要点 CopyOnWriteArrayList\n是一个线程安全的 List 实现，特性就是写时复制。\n每次对 List 的修改操作（如 add, set, remove）都会复制创建一个新的底层数组。读操作不需要加锁，写操作需要加锁。\n优点：\n读操作无锁：每次写操作都会创建并复制新数组，所以读写之间不冲突，因此读操作不需要加锁，能够提供非常高效的并发读性能。 缺点：\n写操作开销大：每次写操作都会创建并复制新数组，且要将数据复制到新的数组中，在写操作频繁的场景下性能会较低。 内存消耗大：每次写操作都会创建并复制新数组，在数据量大的情况下，同一时刻会存在两倍 List 大小的内存占用，开销较大。 Collections.synchronizedList：\n是一个包装方法，可以将任何 List 转换为线程安全的版本，它会对每个访问方法（如 get, set, add, remove）进行同步（加 synchronized 锁），从而保证线程安全。\n优点：\n方便：简单一个方法就可以将 List 变为线程安全版本，非常方便。 缺点：\n并发低：读写操作都需要加锁，高并发场景下性能不高。 Collections.synchronizedList 适用于简单将 List 转为线程安全版本临时使用的场景。特定的场景还需使用并发度高的 JUC 类。\n","date":"2024-11-21T16:00:25+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84list%E5%AE%9E%E7%8E%B0%E7%B1%BB/","title":"Java中的List实现类"},{"content":"集合体系结构 Collection接口：单列数据，所有集合类的根接口，提供基本的集合操作方法 List接口：元素有序（存储顺序与存放顺序一致），可重复有索引的集合 ArrayList：基于动态数组，查询速度快，插入、删除慢，线程不安全。 LinkedList：基于双向链表，插入、删除快，查询速度慢，线程不安全。 Vector：线程安全的动态数组，类似于 ArrayList，但开销较大。 Set接口：元素无序，不可重复，无索引的集合 HashSet：基于哈希表，元素无序，不允许重复。 LinkedHashSet：基于链表和哈希表，维护插入顺序，不允许重复。 TreeSet：基于红黑树，元素有序（元素是按照自然顺序或提供的比较器进行排序的），不允许重复。 Queue接口：表示一个先进先出的集合 PriorityQueue：基于优先级堆，元素按照自然顺序或指定比较器排序。 LinkedList：可以作为队列使用，支持 FIFO（先进先出）操作。 ArrayQueue：基于数组实现的双端队列 Map接口：双列数据，保存具有映射关系的键值对 HashMap：基于哈希表，键值对无序，不允许键重复，线程不安全。 LinkedHashMap：基于链表和哈希表，维护插入顺序，不允许键重复。 TreeMap：基于红黑树，键值对有序，不允许键重复。 Hashtable：线程安全的哈希表，不允许键或值为 null。 ConcurrentHashMap：线程安全的哈希表，适合高并发环境，不允许键或值为 null。 Collection接口 Collection 接口是 Java 集合框架的根接口，定义了集合类的基本操作方法。\n添加元素 boolean add(E e)：将指定的元素添加到集合中，如果集合允许该元素的添加（比如没有重复元素限制），则返回 true，如果集合已经包含该元素，则返回 false 向List集合中添加数据则方法将固定返回true，List集合中允许添加重复元素 向Set集合中添加数据若当前元素已经存在返回false，若当前元素不存在返回true boolean addAll(Collection\u0026lt;? extends E\u0026gt; c)：将指定集合中的所有元素添加到当前集合中 如果当前集合因为某些原因没有改变（例如集合为空或元素没有添加成功），则返回 false，否则返回 true。 删除元素 void clear()：移除集合中的所有元素，使集合为空。 boolean remove(Object o)：从集合中移除指定的元素。 如果集合中包含该元素并且成功移除，返回 true；如果元素不存在，返回 false。 boolean removeAll(Collection\u0026lt;?\u0026gt; c)：移除集合中与指定集合相同的所有元素。 如果集合因移除操作发生变化，则返回 true；如果没有任何元素被移除，则返回 false。 boolean retainAll(Collection\u0026lt;?\u0026gt; c)：只保留集合中与指定集合相同的元素，移除其他元素。 如果集合发生变化（即移除了某些元素），则返回 true；如果没有元素被移除，则返回 false。 判断元素 boolean contains(Object o)：判断集合是否包含指定元素 如果集合中包含该元素，返回 true；否则返回 false。 boolean containsAll(Collection\u0026lt;?\u0026gt; c)：判断当前集合是否包含指定集合中的所有元素。 boolean isEmpty()：判断集合是否为空 如果集合中没有元素，返回 true；否则返回 false。 遍历方法 迭代器 Iterator 是 Java 集合框架中用于遍历集合元素的接口，允许开发者依次访问集合中的每一个元素，而不需要关心集合的具体实现。它提供了一种统一的方式来遍历 List、Set 等集合类型，通常与 Collection 类接口一起使用。Iterator 只能单向遍历集合，不能向前遍历。\n核心方法 hasNext()：返回 true 表示集合中还有下一个元素，返回 false 则表示遍历完毕。 next()：返回集合中的下一个元素，如果没有更多元素则抛出 NoSuchElementException。 remove()：从集合中移除最近一次通过 next() 方法返回的元素，执行时只能在调用 next() 之后使用。这个方法是可选的，不是所有的实现都支持该操作。如果不支持，调用时会抛出 UnsupportedOperationException。 注意事项 迭代器越界会报错 迭代器遍历完毕，指针不会复位 迭代器遍历时不允许使用集合的方法进行添加和删除**（fail—fast）**， 在用迭代器遍历一个集合对象时，如果线程 A 遍历过程中，线程 B 对集合对象的内容进行了修改（增加、删除、修改），则会抛出 Concurrent Modification Exception。 原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用 hashNext()/next()遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class IteratorExample { public static void main(String[] args) { // 创建一个List集合并添加元素 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;Apple\u0026#34;); list.add(\u0026#34;Banana\u0026#34;); list.add(\u0026#34;Cherry\u0026#34;); // 获取集合的迭代器 Iterator\u0026lt;String\u0026gt; iterator = list.iterator(); // 使用迭代器遍历集合 while (iterator.hasNext()) { String element = iterator.next(); System.out.println(element); // 输出元素 // 删除元素（示例：删除“Banana”） if (element.equals(\u0026#34;Banana\u0026#34;)) { iterator.remove(); // 删除“Banana” } } // 打印修改后的集合 System.out.println(\u0026#34;Modified list: \u0026#34; + list); } } // 输出： // Apple // Banana // Cherry // Modified list: [Apple, Cherry] ListIterator（List 特有的迭代器） ListIterator 是 Iterator 的子接口，专门用于操作 List 类型集合。与 Iterator 不同，它支持双向遍历和元素修改。\n核心方法\nhasPrevious()：判断是否还有前一个元素。 previous()：返回前一个元素。 add(E e)：向当前遍历的位置插入元素。 set(E e)：修改当前元素。 for-each循环 语法格式 1 2 3 for (Type item : collection) { // 使用 item } 主要特点 简洁性：语法更简单，减少了初始化、条件检查和更新的样板代码。适合用于遍历数组和实现了 Iterable 接口的集合。 只读访问：不提供对当前索引的访问，因此不适合需要根据索引进行复杂操作的场景。 安全性：在遍历过程中不能修改集合的结构（例如，不能在遍历 List 的同时添加或删除元素），否则会抛出 ConcurrentModificationException。 底层实现 实际上是通过 Iterator 实现的。Java 编译器会将 for-each 循环转换为一个使用 Iterator 或索引的标准迭代过程。\nLambda表达式遍历（for-each循环） 集合类（如 List、Set）实现了 Iterable 接口，Iterable 接口提供了一个默认的 forEach 方法，可以直接与 Lambda 表达式结合，进行遍历。\n语法格式 1 2 3 4 5 6 7 8 foreach(new Consumer\u0026lt;? super T\u0026gt; action) { @Override public void accept(T s) { //重写 } } ","date":"2024-11-21T09:36:04+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E5%92%8C%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/","title":"Java中的集合体系和集合遍历方式"},{"content":"网络编程基础 IP地址 在互联网中，一个 IP 地址用于唯一标识一个网络设备。一台联入互联网的计算机肯定有一个 IP 地址，但也可能有多个 IP 地址。\nIP 地址又分为公网 IP 地址和内网 IP 地址。公网 IP 地址可以直接被访问，内网 IP 地址只能在内网访问。\n假设一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址127.0.0.1，还有一个 IP 地址，例如101.202.99.12，可以通过这个 IP 地址接入网络。\n假设路由器或者交换机有两个网卡，它有两个 IP 地址，分别接入不同的网络，让网络之间连接起来。\n如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的 IP 地址前段（网络号）是相同的。\n网络号是 IP 地址与子网掩码过滤后得到的。（子网掩码转换成二进制和IP地址转换成二进制后按位进行与操作）\n1 2 3 IP = 101.202.99.2 Mask = 255.255.255.0 Network = IP \u0026amp; Mask = 101.202.99.0 如果两台计算机计算出的网络号相同，说明两台计算机在同一个网络，可以直接通信。\n如果两台计算机计算出的网络号不同，那么两台计算机不在同一个网络，不能直接通信，它们之间必须通过路由器或者交换机这样的网络设备（网关）间接通信。\n网卡的关键配置\nIP 地址，例如：10.0.2.15 子网掩码，例如：255.255.255.0 网关的 IP 地址，例如：10.0.2.2 域名 直接记忆 IP 地址非常困难，所以通常使用域名访问某个特定的服务。\n域名解析服务器 DNS 负责把域名翻译成对应的 IP，客户端再根据 IP 地址访问服务器。\n端口号 用于标识计算机上的具体应用程序或进程。端口号与 IP 地址结合，共同用于标识一个主机上的具体服务或应用。\n协议 网络通信的规则\n网络套接字Socket Socket（套接字）：网络通信的基本单位，通过 IP 地址和端口号标识。\n套接字（Socket）是一个抽象层，应用程序可以通过它发送或接收数据；就像操作文件那样可以打开、读写和关闭。套接字允许应用程序将 I/O 应用于网络中，并与其他应用程序进行通信。网络套接字是 IP 地址与端口的组合。\nInetAddressIP地址类 InetAddress 是 Java 中用于表示一个 IP 地址的类，它提供了多种方法用于获取和处理与主机名或 IP 地址相关的信息。InetAddress 类位于 java.net 包中，常用于网络编程中。\n常用方法 public static InetAddress getByName(String host) throws UnknownHostException：该方法通过主机名或 IP 地址字符串返回一个 InetAddress 对象 public static InetAddress getByAddress(String host, byte[] addr) throws UnknownHostException：通过给定的 IP 地址（字节数组）和主机名，返回一个 InetAddress 对象。 public static InetAddress getLocalHost() throws UnknownHostException：该方法返回当前计算机的 InetAddress 对象。 public String getHostName()：获取与 InetAddress 对象相关联的主机名。 public String getHostAddress()：获取与 InetAddress 对象相关联的 IP 地址（以字符串形式返回） UDP协议传输 UDP 协议通过 DatagramSocket 和 DatagramPacket 类来实现。\n服务端 创建一个 DatagramSocket 来监听端口。 等待并创建 DatagramPacket 用于接收客户端发送的数据包。 处理数据并可能向客户端发送响应。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import java.net.*; public class UDPServer { public static void main(String[] args) { DatagramSocket socket = null; try { // 创建一个 DatagramSocket 并绑定到端口 9876 socket = new DatagramSocket(9876); System.out.println(\u0026#34;UDP Server is running...\u0026#34;); // 创建一个数据包来接收客户端的数据 byte[] receiveData = new byte[1024]; while (true) { // 创建 DatagramPacket 用于接收数据 DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length); // 接收客户端发送的数据 socket.receive(receivePacket); // 获取客户端的消息 String clientMessage = new String(receivePacket.getData(), 0, receivePacket.getLength()); System.out.println(\u0026#34;Received from client: \u0026#34; + clientMessage); // 创建并发送响应消息 String serverResponse = \u0026#34;Hello from UDP Server!\u0026#34;; byte[] sendData = serverResponse.getBytes(); // 获取客户端的地址和端口 InetAddress clientAddress = receivePacket.getAddress(); int clientPort = receivePacket.getPort(); // 创建一个数据包并发送给客户端 DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, clientAddress, clientPort); socket.send(sendPacket); } } catch (Exception e) { e.printStackTrace(); } finally { if (socket != null \u0026amp;\u0026amp; !socket.isClosed()) { socket.close(); } } } } 客户端 创建一个 DatagramSocket 用于发送数据。 创建一个 DatagramPacket，通过该包发送数据到服务器。 等待接收服务器的响应。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import java.net.*; public class UDPClient { public static void main(String[] args) { DatagramSocket socket = null; try { // 创建一个 DatagramSocket 用于发送数据 socket = new DatagramSocket(); // 服务器的地址和端口 InetAddress serverAddress = InetAddress.getByName(\u0026#34;localhost\u0026#34;); int serverPort = 9876; // 发送到服务器的消息 String message = \u0026#34;Hello, UDP Server!\u0026#34;; byte[] sendData = message.getBytes(); // 创建一个 DatagramPacket 发送消息到服务器 DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, serverAddress, serverPort); socket.send(sendPacket); System.out.println(\u0026#34;Sent to server: \u0026#34; + message); // 接收服务器的响应 byte[] receiveData = new byte[1024]; DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length); socket.receive(receivePacket); // 获取服务器响应并打印 String serverResponse = new String(receivePacket.getData(), 0, receivePacket.getLength()); System.out.println(\u0026#34;Received from server: \u0026#34; + serverResponse); } catch (Exception e) { e.printStackTrace(); } finally { if (socket != null \u0026amp;\u0026amp; !socket.isClosed()) { socket.close(); } } } } 核心类 DatagramSocket网络套接字 DatagramSocket 提供了发送和接收数据包的功能。\n构造方法\npublic DatagramSocket() throws SocketException public DatagramSocket(int port) throws SocketException public DatagramSocket(int port, InetAddress bindAddress) throws SocketException 收发数据\npublic void send(DatagramPacket packet) throws IOException：发送一个数据包到目标地址。 public void receive(DatagramPacket packet) throws IOException：接收来自远程主机的数据包 设置超时\npublic void setSoTimeout(int timeout) throws SocketException：设置超时时间，如果在指定的时间内没有数据到达，则会抛出 SocketTimeoutException。 关闭套接字\npublic void close()：关闭套接字 DatagramPacket数据包类 DatagramPacket 类提供了封装数据包的功能，常用于 UDP 协议的通信中。它可以用于存储接收到的数据或准备发送的数据。\n构造方法\npublic DatagramPacket(byte[] buf, int length) buf：用于存储数据的字节数组。 length：数据包的有效数据长度（在字节数组中的有效数据部分）。 public DatagramPacket(byte[] buf, int length, InetAddress address, int port) buf：用于存储数据的字节数组。 length：数据包的有效数据长度。 address：目标主机的 IP 地址。 port：目标主机的端口号。 获取数据\npublic byte[] getData() ：返回 DatagramPacket 中存储的数据字节数组。 public int getLength() ：返回 DatagramPacket 中有效数据的长度（字节数）。 public InetAddress getAddress() ：返回 DatagramPacket 中目标主机的 IP 地址。 public int getPort()：返回 DatagramPacket 中目标主机的端口号。 设置属性\npublic void setData(byte[] buf) public void setLength(int length) public void setAddress(InetAddress address) public void setPort(int port) TCP协议传输 服务端 创建一个 ServerSocket 来监听端口。 调用ServerSocket的accept()返回一个Socket对象监听客户端的套接字请求 获取连接通道的输入流读取来自客户端的数据 释放资源 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import java.io.*; import java.net.*; public class TCPServer { public static void main(String[] args) { try { // 创建 ServerSocket 监听端口 12345 ServerSocket serverSocket = new ServerSocket(12345); System.out.println(\u0026#34;Server is waiting for a client connection...\u0026#34;); // 接受客户端连接 Socket clientSocket = serverSocket.accept(); System.out.println(\u0026#34;Client connected!\u0026#34;); // 获取输入流读取客户端发送的数据 BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream())); PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true); // 读取客户端数据并响应 String clientMessage; while ((clientMessage = in.readLine()) != null) { System.out.println(\u0026#34;Received from client: \u0026#34; + clientMessage); if (clientMessage.equalsIgnoreCase(\u0026#34;bye\u0026#34;)) { out.println(\u0026#34;Goodbye!\u0026#34;); break; } // 向客户端返回消息 out.println(\u0026#34;Server received: \u0026#34; + clientMessage); } // 关闭连接 in.close(); out.close(); clientSocket.close(); serverSocket.close(); System.out.println(\u0026#34;Server closed.\u0026#34;); } catch (IOException e) { e.printStackTrace(); } } } 客户端 创建客户端的Socket对象 创建Socket对象时同时连接服务端 若服务端不可访问会发生阻塞直到抛出异常 获取连接通道的输出流，写入数据 释放资源 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import java.io.*; import java.net.*; public class TCPClient { public static void main(String[] args) { try { // 连接到服务器 (IP 地址和端口号) Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 12345); System.out.println(\u0026#34;Connected to server.\u0026#34;); // 获取输出流，发送数据 PrintWriter out = new PrintWriter(socket.getOutputStream(), true); // 获取输入流，接收服务器的数据 BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); BufferedReader userInput = new BufferedReader(new InputStreamReader(System.in)); String message; System.out.println(\u0026#34;Enter message to send to server (type \u0026#39;bye\u0026#39; to exit):\u0026#34;); while (true) { message = userInput.readLine(); // 读取用户输入 out.println(message); // 发送消息到服务器 String response = in.readLine(); // 从服务器接收响应 System.out.println(\u0026#34;Server response: \u0026#34; + response); if (message.equalsIgnoreCase(\u0026#34;bye\u0026#34;)) { break; } } // 关闭连接 userInput.close(); in.close(); out.close(); socket.close(); System.out.println(\u0026#34;Client closed.\u0026#34;); } catch (IOException e) { e.printStackTrace(); } } } 核心类 ServerSocket服务端套接字 ServerSocket 类是 Java 中用于实现 TCP 服务器端的类。它主要用于监听客户端的连接请求并接受连接。\n构造方法\npublic ServerSocket(int port) throws IOException public ServerSocket(int port, int backlog) throws IOException public ServerSocket(int port, int backlog, InetAddress bindAddr) throws IOException 接受连接\npublic Socket accept() throws IOException：接受客户端的连接请求。 此方法会阻塞，直到有客户端发起连接请求。 返回一个已连接的 Socket 实例，客户端可以通过该 Socket 与服务器通信。 状态检测\npublic boolean isBound() ：检查 ServerSocket 是否已经绑定到一个本地地址和端口。 public boolean isClosed()：检查 ServerSocket 是否已关闭 Socket客户端套接字 Socket 类是 Java 中用于实现 TCP 客户端通信的类，它提供了与服务器建立连接、发送和接收数据的功能。\n构造方法\npublic Socket(String host, int port) throws UnknownHostException, IOException：创建一个指定主机和端口的 Socket，并与目标主机建立连接。 host：目标主机的 IP 地址或域名。 port：目标主机的端口号。 public Socket(InetAddress address, int port) throws IOException：创建一个指定 IP 地址和端口号的 Socket，并与目标主机建立连接 address：目标主机的 IP 地址（InetAddress 类型）。 port：目标主机的端口号。 获取IO流\npublic InputStream getInputStream() throws IOException：返回与此 Socket 关联的输入流，客户端可以通过该流接收从服务器发送的数据 public OutputStream getOutputStream() throws IOException：返回与此 Socket 关联的输出流，客户端可以通过该流向服务器发送数据。 设置超时时间\npublic void setSoTimeout(int timeout) throws SocketException：设置读取数据的超时时间。如果在指定的时间内没有数据可读取，则会抛出 SocketTimeoutException。 ","date":"2024-11-20T10:04:34+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","title":"Java的网络编程"},{"content":"IO流的定义 Java 的 I/O（输入/输出）流是用于处理输入和输出数据的类库。通过流，程序可以从各种输入源（如文件、网络）读取数据，或将数据写入目标位置（如文件、控制台）。\nI/O 流分为两大类：字节流 和 字符流，分别用于处理字节级和字符级的数据：\n字节流：处理 8 位字节数据，适合于处理二进制文件，如图片、视频等。主要类是 InputStream 和 OutputStream 及其子类。 字符流：处理 16 位字符数据，适合于处理文本文件。主要类是 Reader 和 Writer 及其子类。 字符流和字节流的区别 字节流一般用来处理图像、视频、音频、PPT、Word等类型的文件。字符流一般用于处理纯文本类型的文件，如TXT文件等，但不能处理图像视频等非文本文件。用一句话说就是：字节流可以处理一切文件，而字符流只能处理纯文本文件。 字节流本身没有缓冲区，缓冲字节流相对于字节流，效率提升非常高。而字符流本身就带有缓冲区，缓冲字符流相对于字符流效率提升就不是那么大了。 编码和解码 输出流将缓冲区存储的字符通过查ASCII表转换为对应数字再进行编码\n输入流对文件进行解码转换为ASCII码对应的数字，然后通过查表转换为读取到的字符\n中文编码通常使用GBK字符集\n规则\n汉字使用两个字节进行存储 高位字节以1开头，转换成十进制后为负数 Unicode字符集（万国码）是国家标准字符集同时兼任ASCII码\nUTF-16编码：使用2-4个字节保存 UTF-32编码：固定4个字节保存 UTF-8编码：使用1-4个字节保存 ASCII码：1个字节 简体中文：3个字节 乱码的原因\n字符编码与解码不一致。乱码问题常常由字符编码（比如 UTF-8、GBK）和解码过程的不一致引起。如果在编码时使用了一种字符集，而在解码时使用了另一种，字符将无法正确显示，从而出现乱码。 文件流 一切文件（文本、视频、图片）的数据都是以二进制的形式存储的，传输时也是。所以，字节流可以传输任意类型的文件数据。\n文件字节流 FileOutputStream文件输出流 构造方法\npublic FileOutputStream(String s)：接收文件路径创建输出流，如果文件不存在，则创建一个新文件；如果文件已经存在，则覆盖原有文件。 public FileOutputStream(File file)：使用文件对象创建 FileOutputStream 对象 写入数据\npublic void write(int b)：写入一个ASCII码为b的字符 public void write(char b)：写入一个字符 public void write(byte[] b)：写入一个字节数组 public void write(byte[] b,int off,int len)：从指定的字节数组写入 len 字节到此输出流，从偏移量 off开始。 也就是说从off个字节数开始一直到len个字节结束 追加数据\n在构造方法中加入第二个Boolean类型参数指示是否继续读写\nFileInputStream文件输入流 构造方法\nFileInputStream(String name)：创建一个 FileInputStream 对象，并打开指定名称的文件进行读取。文件名由 name 参数指定。如果文件不存在，将会抛出 FileNotFoundException 异常。 FileInputStream(File file)：创建一个 FileInputStream 对象，并打开指定的 File 对象表示的文件进行读取。 读入数据\npublic int read()：read()方法会读取一个字节并返回其整数表示。如果已经到达文件的末尾，则返回 -1。如果在读取时发生错误，则会抛出 IOException 异常。 public int read(byte[] b) throws IOException：读取数据并将其存储在字节数组 b 中。返回实际读取的字节数。 public int read(byte[] b, int off, int len) throws IOException：从文件中读取最多 len 个字节的数据，存储到字节数组 b 中，从偏移量 off 开始。返回实际读取的字节数。 常见操作 文件拷贝\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class FileCopy { public static void main(String[] args) { String sourceFile = \u0026#34;source.txt\u0026#34;; // 源文件 String destFile = \u0026#34;destination.txt\u0026#34;; // 目标文件 try (FileInputStream fis = new FileInputStream(sourceFile); FileOutputStream fos = new FileOutputStream(destFile)) { byte[] buffer = new byte[1024]; // 缓冲区大小，可以根据需要调整 int length; // 读取源文件并写入目标文件 while ((length = fis.read(buffer)) \u0026gt; 0) { fos.write(buffer, 0, length); } System.out.println(\u0026#34;文件拷贝完成！\u0026#34;); } catch (IOException e) { e.printStackTrace(); } } } 文件夹拷贝\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; public class DirectoryCopy { public static void main(String[] args) { String sourceDir = \u0026#34;sourceDirectory\u0026#34;; // 源文件夹 String destDir = \u0026#34;destinationDirectory\u0026#34;; // 目标文件夹 try { copyDirectory(new File(sourceDir), new File(destDir)); System.out.println(\u0026#34;文件夹拷贝完成！\u0026#34;); } catch (IOException e) { e.printStackTrace(); } } // 递归复制文件夹 public static void copyDirectory(File sourceDir, File destDir) throws IOException { if (!sourceDir.exists()) { throw new IOException(\u0026#34;源文件夹不存在！\u0026#34;); } // 如果目标文件夹不存在，则创建它 if (!destDir.exists()) { destDir.mkdir(); } // 获取源文件夹中的所有文件和子文件夹 File[] files = sourceDir.listFiles(); if (files != null) { for (File file : files) { // 如果是文件，则直接拷贝 if (file.isFile()) { copyFile(file, new File(destDir, file.getName())); } else if (file.isDirectory()) { // 如果是文件夹，则递归调用 copyDirectory(file, new File(destDir, file.getName())); } } } } // 拷贝文件 private static void copyFile(File sourceFile, File destFile) throws IOException { try (InputStream in = new FileInputStream(sourceFile); OutputStream out = new FileOutputStream(destFile)) { byte[] buffer = new byte[1024]; // 缓冲区 int length; // 读取文件并写入目标文件 while ((length = in.read(buffer)) != -1) { out.write(buffer, 0, length); } } } } 文件字符流 字符流 = 字节流 + 编码表\nFileReader文件输入流 一次读取一个字节，遇到中文时一次读入多个字节\n构造方法\nFileReader(File file)：创建一个新的 FileReader，参数为File对象。 FileReader(String fileName)：创建一个新的 FileReader，参数为文件名。 FileReader(File file，Charset set)：创建一个新的 FileReader，参数为File对象和字符集。 读取数据\npublic int read()：每次可以读取一个字符，返回读取的字符（转为 int 类型），当读取到文件末尾时，返回-1 public int read(char[]buffer,int off,int len):读取多个字符到字符数组buffer，返回值为读入的字符数，读到文件末尾返回-1 释放资源\npublic int close()：释放字符流\nFileWriter文件输出流 构造方法\nFileWriter(File file)： 创建一个新的 FileWriter，参数为要读取的File对象。可以后跟Boolean参数指定是否追加数据 FileWriter(String fileName)： 创建一个新的 FileWriter，参数为要读取的文件的名称。可以后跟Boolean参数指定是否追加数据 写入数据\npublic void write(int b)：写入一个ASCII码为b的字符 public void write(String b)：写入字符串 public void write(String str, int off, int len) ：将指定字符串的一部分写入输出流 public void write(char[] cbuf) ：将指定字符数组写入输出流 public void write(char[] cbuf, int off, int len) ：将指定字符数组的一部分写入输出流 关闭和刷新\nflush() ：刷新缓冲区，将缓冲区中的数据强制写入目标设备或流中,流对象可以继续使用。 close() ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 缓冲流： 缓冲流是对基础流的包装，可以显著提高 I/O 性能。常见的缓冲流有 BufferedInputStream、BufferedOutputStream、BufferedReader 和 BufferedWriter，它们通过内部缓冲区减少实际 I/O 操作的次数。\n在处理大文件或频繁 I/O 操作时，使用缓冲流可以有效提高性能。\n字节缓冲流 底层自带8KB的缓冲区\nBufferedInputStream 字节缓冲输入流 构造方法\nBufferedInputStream(InputStream in) ：创建一个新的缓冲输入流，注意参数类型为InputStream。\n读入数据\npublic int read()：read()方法会读取一个字节并返回其整数表示。如果已经到达文件的末尾，则返回 -1。如果在读取时发生错误，则会抛出 IOException 异常。 public int read(byte[] b) throws IOException：读取数据并将其存储在字节数组 b 中。返回实际读取的字节数。 public int read(byte[] b, int off, int len) throws IOException：从文件中读取最多 len 个字节的数据，存储到字节数组 b 中，从偏移量 off 开始。返回实际读取的字节数。 BufferedOutputStream字节缓冲输出流 构造方法\nBufferedOutputStream(OutputStream in) ：创建一个新的缓冲输入流，注意参数类型为OutputStream。\n写入数据\npublic void write(int b)：写入一个ASCII码为b的字符 public void write(String b)：写入字符串 public void write(String str, int off, int len) ：将指定字符串的一部分写入输出流 public void write(char[] cbuf) ：将指定字符数组写入输出流 public void write(char[] cbuf, int off, int len) ：将指定字符数组的一部分写入输出流 关闭和刷新\nflush() ：刷新缓冲区，将缓冲区中的数据强制写入目标设备或流中,流对象可以继续使用。 close() ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。只用关闭高级流的流对象底层会自动关闭基本流 字符缓冲流 BufferedReader字符缓冲输入流 构造方法\nBufferedReader(Reader in) ：创建一个新的缓冲输入流，注意参数类型为Reader。 读取数据\npublic int read()：每次可以读取一个字符，返回读取的字符（转为 int 类型），当读取到文件末尾时，返回-1 public int read(char[]buffer,int off,int len):读取多个字符到字符数组buffer，返回值为读入的字符数，读到文件末尾返回-1 String readLine(): 读一行数据，读取到最后返回 null 释放资源\npublic int close()：释放字符流\nBufferedWriter字符缓冲输出流 构造方法\nBufferedWriter(Writer out)： 创建一个新的缓冲输出流，注意参数类型为Writer。 写入数据\npublic void write(int b)：写入一个ASCII码为b的字符 public void write(String b)：写入字符串 public void write(String str, int off, int len) ：将指定字符串的一部分写入输出流 public void write(char[] cbuf) ：将指定字符数组写入输出流 public void write(char[] cbuf, int off, int len) ：将指定字符数组的一部分写入输出流 public void newLine()：输出换行符 关闭和刷新\nflush() ：刷新缓冲区，将缓冲区中的数据强制写入目标设备或流中,流对象可以继续使用。 close() ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 转换流 将字符流和字节流进行连接，实现互相转换\nInputStreamReader ：将一个字节输入流转换为一个字符输入流，\nOutputStreamWriter ：将一个字节输出流转换为一个字符输出流。\n它们使用指定的字符集将字节流和字符流之间进行转换。常用的字符集包括 UTF-8、GBK、ISO-8859-1 等。\nInputStreamReader 作用 将字节流（InputStream）转换为字符流（Reader） 同时支持指定的字符集编码方式，从而实现字节流到字符流之间的转换。 构造方法 InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。 常用方法 read()：从输入流中读取一个字符的数据。 read(char[] cbuf, int off, int len)：从输入流中读取 len 个字符的数据到指定的字符数组 cbuf 中，从 off 位置开始存放。 ready()：返回此流是否已准备好读取。 close()：关闭输入流。 OutputStreamWriter 作用 将字符流（Writer）转换为字节流（OutputStream） 同时支持指定的字符集编码方式，从而实现字符流到字节流之间的转换。 构造方法 OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字节流。 OutputStreamWriter(OutputStream in, String charsetName)：创建一个指定字符集的字节流。 常用方法 write(int c)：向输出流中写入一个字符的数据。 write(char[] cbuf, int off, int len)：向输出流中写入指定字符数组 cbuf 中的 len 个字符，从 off 位置开始。 flush()：将缓冲区的数据写入输出流中。 close()：关闭输出流 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 try { // 从文件读取字节流，使用UTF-8编码方式 FileInputStream fis = new FileInputStream(\u0026#34;test.txt\u0026#34;); // 将字节流转换为字符流，使用UTF-8编码方式 InputStreamReader isr = new InputStreamReader(fis, \u0026#34;UTF-8\u0026#34;); // 使用缓冲流包装字符流，提高读取效率 BufferedReader br = new BufferedReader(isr); // 创建输出流，使用UTF-8编码方式 FileOutputStream fos = new FileOutputStream(\u0026#34;output.txt\u0026#34;); // 将输出流包装为转换流，使用UTF-8编码方式 OutputStreamWriter osw = new OutputStreamWriter(fos, \u0026#34;UTF-8\u0026#34;); // 使用缓冲流包装转换流，提高写入效率 BufferedWriter bw = new BufferedWriter(osw); // 读取输入文件的每一行，写入到输出文件中 String line; while ((line = br.readLine()) != null) { bw.write(line); bw.newLine(); // 每行结束后写入一个换行符 } // 关闭流 br.close(); bw.close(); } catch (IOException e) { e.printStackTrace(); } 序列化流 序列化\n是将对象转换为字节流的过程，这样对象可以通过网络传输、持久化存储或者缓存。Java 提供了 java.io.Serializable 接口来支持序列化，只要类实现了这个接口，就可以将该类的对象进行序列化。\n反序列化\n是将字节流重新转换为对象的过程，即从存储中读取数据并重新创建对象。\nObjectOutputStream序列化流 构造方法 ObjectOutputStream(OutputStream out)\n1 2 FileOutputStream fos = new FileOutputStream(\u0026#34;file.txt\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); 写入方法 public final writeObject (Object obj)：写入一个对象 public void write(int b) throws IOException public void write(byte[] b, int off, int len) throws IOException 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class ObjectOutputStreamDemo { public static void main(String[] args) { Person person = new Person(\u0026#34;沉默王二\u0026#34;, 20); try { FileOutputStream fos = new FileOutputStream(\u0026#34;logs/person.dat\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(person); oos.close(); } catch (IOException e) { e.printStackTrace(); } } } class Person implements Serializable { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } } ObjectInputStream反序列化流 ObjectInputStream 可以读取 ObjectOutputStream 写入的字节流，并将其反序列化为相应的对象（包含对象的数据、对象的类型和对象中存储的属性等信息）。\n构造方法 ObjectInputStream(InputStream in) 读入方法 public Object readObject()：读入对象 public void read()：读一个字节 Serializable序列化接口 定义\n1 2 public interface Serializable { } 注意事项\nstatic和 transient修饰的字段是不会被序列化的 被反序列化后，transient 字段的值被设为初始值 Java底层根据类的内容对实现了Serializable接口的类计算出类型为long的版本号serialVersionUID，若类的代码发生改变会使版本号改变导致无法反序列化 Java 虚拟机会把字节流中的 serialVersionUID 与被序列化类中的 serialVersionUID 进行比较，如果相同则可以进行反序列化，否则就会抛出序列化版本不一致的异常 通常使用private ，static ，final 来修饰serialVersionUID transient瞬态关键字 在实际开发过程中，不需要被序列化的字段，比如说用户的一些敏感信息（如密码、银行卡号等），为了安全起见，不希望在网络操作中传输或者持久化到磁盘文件中，那这些字段就可以加上 transient 关键字。\n被 transient 关键字修饰的成员变量在反序列化时会被自动初始化为默认值\n","date":"2024-11-19T16:32:57+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84io%E6%B5%81/","title":"Java中的IO流"},{"content":"File类 File类是文件的抽象表示，用于文件与目录的创建，查找，删除，只能对文件本身操作，不能对文件内容操作\n构造方法 public File(String pathname) // 根据路径创建文件对象 public File(String parent, String child) // 根据父路径和子路径创建文件对象 public File(File parent, String child) // 根据父目录 File 对象和子路径创建文件对象 注意事项\nFile对象代表硬盘中实际存在的文件和目录 File类的构造方法不检查是否存在该路径 常见操作 判断文件/目录 public boolean isFile()：判断是否是文件 public boolean isDirectory()：判断是否为目录 获取文件/目录的基本信息 public String getName()：获取文件名 public String getAbsolutePath()：获取绝对路径 public String getParent()：获取父目录 public long length()：获取文件大小（以B为单位） public long lastModified()：获取最后修改时间 检查读/写/可执行权限 public boolean canRead() public boolean canWrite() public boolean canExecute() 创建文件/目录 public boolean createNewFile() throws IOException：创建文件 原先文件不存在则创建成功返回true 原先文件存在则创建失败返回false 创建目录 public boolean mkdir()：创建单级目录，父目录不存在则创建失败 public boolean mkdirs()：创建多级目录，父目录不存在则一并创建 删除文件目录 public boolean delete() 列举目录文件 public String[] list()：列出目录中的文件名 public File[] listFiles()：列出目录中的File对象 ","date":"2024-11-17T15:48:33+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","title":"Java的文件操作"},{"content":"异常的定义 在 Java 中，异常（Exception） 是程序运行过程中发生的一种错误或意外情况，可能会中断程序的正常执行流程。异常机制通过捕获和处理错误，避免程序崩溃，提供了一种高效的错误管理方式。\n本质：异常是一个对象，表示程序运行中的问题。\n异常的继承结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 java.lang.Object └── java.lang.Throwable ├── java.lang.Error │ ├── VirtualMachineError │ │ ├── OutOfMemoryError │ │ ├── StackOverflowError │ │ └── InternalError │ ├── LinkageError │ └── AssertionError └── java.lang.Exception ├── IOException │ ├── FileNotFoundException │ └── EOFException ├── RuntimeException │ ├── NullPointerException │ ├── ArithmeticException │ ├── ArrayIndexOutOfBoundsException │ ├── ClassCastException │ └── IllegalArgumentException ├── SQLException ├── ParseException └── ClassNotFoundException Throwable类 所有错误和异常的超类。 定义了 printStackTrace()、getMessage() 和 toString() 等常用方法。 Error类 定义：表示程序运行时的严重问题，通常是 JVM 无法处理的情况。 特点 是 Throwable 的子类。 不受检查的异常，编译器不强制要求处理。 程序无法通过代码处理这些错误，通常由 JVM 抛出。 常见类型 OutOfMemoryError：JVM 堆内存耗尽。 StackOverflowError：递归调用过深导致栈溢出。 InternalError：JVM 内部错误。 Exception类 定义：表示程序中可预料的问题，可以通过代码进行捕获和处理。\n特点：\n是 Throwable 的子类。 包括两种子类： 受检异常（Checked Exception）：在源代码里必须显式地捕获或者抛出，否则编译器会提示你进行相应的操作。 非受检异常（Unchecked Exception，RuntimeException）：通常是由程序逻辑错误导致的，可以通过编码进行规避的，并不需要显式地捕获或者抛出。 Exception和Error的区别 Exception 和 Error 都是 Throwable 类的子类（在 Java 代码中只有继承了 Throwable 类的实例才可以被 throw 或者被 catch）它们表示在程序运行时发生的异常或错误情况。\n总结来看：Exception 表示可以被处理的程序异常，Error 表示系统级的不可恢复错误。\nException：是程序中可以处理的异常情况，表示程序逻辑或外部环境中的问题，可以通过代码进行恢复或处理。Exception 又分为 Checked Exception（编译期异常）和 Unchecked Exception（运行时异常）。\nChecked Exception：在编译时必须显式处理（如使用 try-catch 块或通过 throws 声明抛出）。如 IOException。\nUnchecked Exception：运行时异常，不需要显式捕获。常见的如 NullPointerException、IllegalArgumentException 等，继承自 RuntimeException。\nError：表示严重的错误，通常是 JVM 层次内系统级的、无法预料的错误，程序无法通过代码进行处理或恢复。例如内存耗尽（OutOfMemoryError）、栈溢出（StackOverflowError）。Error 不应该被程序捕获或处理，因为一般出现这种错误时程序无法继续运行。\n异常的处理方式 JVM默认处理方式 查找异常处理器：\nJVM 会尝试在当前方法调用栈中寻找匹配该异常的处理器（catch 块）。\n如果找到对应的处理器，程序会进入相应的 catch 块执行。\n未找到处理器：\n如果当前方法没有匹配的异常处理器，JVM 会将该异常抛给调用它的方法。\n这个过程会沿着方法调用栈向上查找，直到主方法 main()。\n异常到达 main() 方法：\n如果异常传播到 main() 方法仍然未被捕获，JVM 默认的异常处理机制会接管。 异常信息打印：\nJVM 会调用异常对象的\n1 printStackTrace() 方法，打印异常的堆栈跟踪信息，包括：\n异常类型（如 NullPointerException、ArithmeticException 等）。 异常的详细信息（如异常消息）。 异常发生的代码位置（方法名和行号）。 堆栈信息从异常发生的位置开始，逐步列出调用栈的各个方法。\n**终止程序：**打印完堆栈跟踪信息后，JVM 会终止程序的执行。\n捕获并处理异常 try-catch-finally块 使用 try-catch-finally 块捕获异常并对其进行处理。\n语法格式\n1 2 3 4 5 6 7 8 9 try { // 可能抛出异常的代码 } catch (ExceptionType1 e1) { // 处理 ExceptionType1 的异常 } catch (ExceptionType2 e2) { // 处理 ExceptionType2 的异常 } finally { // 可选：无论是否发生异常，都会执行的代码 } try块中包含可能抛出异常的代码 catch块用于捕获并处理特定类型的异常。可以有多个catch块来处理不同类型的异常。 finally块：用于定义无论是否发生异常都会执行的代码块。通常用于释放资源，确保资源的正确关闭。 执行流程\n没有异常\n当 try 块中没有发生异常时：\n执行 try 块中的代码（return之前的部分），将return中的返回值暂时保存。 跳过 catch 块。 执行 finally 块中的代码，如果finally中有return则覆盖之前的返回值。 return返回值并继续执行后续代码。 try中没有return的示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Main { public static void main(String[] args) { try { System.out.println(\u0026#34;try block executed\u0026#34;); } catch (Exception e) { System.out.println(\u0026#34;catch block executed\u0026#34;); } finally { System.out.println(\u0026#34;finally block executed\u0026#34;); } System.out.println(\u0026#34;program continues\u0026#34;); } } // 输出： // try block executed // finally block executed // program continues try中有return的示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Main { public static int test() { try { System.out.println(\u0026#34;try block executed\u0026#34;); return 1; // 返回值暂时保存 } catch (Exception e) { System.out.println(\u0026#34;catch block executed\u0026#34;); return 2; } finally { System.out.println(\u0026#34;finally block executed\u0026#34;); } } public static void main(String[] args) { System.out.println(\u0026#34;Return value: \u0026#34; + test()); } } // 输出： // try block executed // finally block executed // Return value: 1 异常发生且被捕获\n当 try 块中发生异常，并且异常被 catch 块捕获时：\n执行 try 块，直到发生异常的位置。 跳转到对应的 catch 块，执行return之前的代码，将返回值暂存。 执行 finally 块中的代码，如果finally中有return则覆盖之前的返回值。 返回之前的返回值或继续执行后续代码。 catch中没有return的示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Main { public static void main(String[] args) { try { System.out.println(\u0026#34;try block executed\u0026#34;); int result = 10 / 0; // 抛出异常 } catch (ArithmeticException e) { System.out.println(\u0026#34;catch block executed: \u0026#34; + e.getMessage()); } finally { System.out.println(\u0026#34;finally block executed\u0026#34;); } System.out.println(\u0026#34;program continues\u0026#34;); } } // 输出： // try block executed // catch block executed: / by zero // finally block executed // program continues catch中有return的示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Main { public static int test() { try { System.out.println(\u0026#34;try block executed\u0026#34;); int result = 10 / 0; // 抛出异常 } catch (ArithmeticException e) { System.out.println(\u0026#34;catch block executed: \u0026#34; + e.getMessage()); return 2; // 被暂存 } finally { System.out.println(\u0026#34;finally block executed\u0026#34;); return 3; // 覆盖之前的返回值 } } public static void main(String[] args) { System.out.println(\u0026#34;Return value: \u0026#34; + test()); } } // 输出： // try block executed // catch block executed: / by zero // finally block executed // Return value: 3 特点\n当不出现异常时，try块中的代码正常执行 当try块中可能出现多种异常时，书写多个对应的catch块捕获异常 一个catch只能处理一种异常 可以在catch块中同时捕获多种异常，异常之间用|隔开，表示多种异常采用相同的处理方式 当try中的异常没有被捕获则执行JVM默认异常处理方式 尽量将特定的异常放在前面，通用型的异常放在后面，不然编译器只会提示通用型的异常，其他的 catch 块永远也不会执行 finally块的特点 如果 finally 块中包含 return 语句，会覆盖 try 或 catch 块中的 return 值。 finally 块前面必须有 try 块，不要把 finally 块单独拉出来使用。编译器也不允许这样做。 finally 块不是必选项，有 try 块的时候不一定要有 finally 块。 如果 finally 块中的代码可能会发生异常，也应该使用 try-catch 进行包裹。 即便是 try 块中执行了 return、break、continue 这些跳转语句，finally 块也会被执行。 如果 catch 块抛出一个异常，而 finally 块中也抛出异常，那么最终抛出的将是 finally 块中的异常。catch 块中的异常会被丢弃，而 finally 块中的异常会覆盖并向上传递。 finally块中的逻辑一定被执行，无论是否出现异常，如果在 try 或 catch 块中调用了 System.exit() 方法，或者程序被强制终止，finally 块不会执行 try-with-resources 块 try-with-resources 是 Java 中的一种简洁方式，用于自动管理资源。资源在使用完成后会被自动关闭，而无需显式调用 close() 方法，从而减少资源泄漏的风险。\n它是在 Java 7 中引入的，资源必须实现 java.lang.AutoCloseable 接口（或其子接口 java.io.Closeable）。\n语法格式\n1 2 3 4 5 try (ResourceType resource = new ResourceType()) { // 使用资源的代码 } catch (ExceptionType e) { // 异常处理 } ResourceType：资源类型，例如文件流、数据库连接等。\n资源自动关闭：在 try 块结束后，resource 会自动调用 close() 方法。\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import java.io.BufferedReader; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; public class MultiResourceExample { public static void main(String[] args) { try ( BufferedReader reader = new BufferedReader(new FileReader(\u0026#34;input.txt\u0026#34;)); FileWriter writer = new FileWriter(\u0026#34;output.txt\u0026#34;) ) { String line; while ((line = reader.readLine()) != null) { writer.write(line + \u0026#34;\\n\u0026#34;); } } catch (IOException e) { System.out.println(\u0026#34;Error occurred: \u0026#34; + e.getMessage()); } } } 抛出异常 在方法声明中使用 throws 关键字\n在方法体中使用throw手动抛出异常\nthrows关键字 作用：声明一个方法可能抛出的异常，用于通知调用该方法的代码，必须处理这些异常 语法：放在方法签名中，位于参数列表和方法体之间。 适用范围：主要用于受检异常（Checked Exception）。 支持多个异常：可以在 throws 后列出多个异常类型，用逗号分隔。 语法格式\n1 method() throws ExceptionType { ... } 使用 throws 关键字，在方法签名上声明可能会抛出的异常，然后在调用该方法的地方使用 try-catch 进行处理。”\n示例\n1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String args[]){ try { myMethod1(); } catch (ArithmeticException e) { // 算术异常 } catch (NullPointerException e) { // 空指针异常 } } public static void myMethod1() throws ArithmeticException, NullPointerException{ // 方法签名上声明异常 } throw关键字 作用：在方法体或代码块中，实际抛出一个异常对象，用于在代码中触发异常处理逻辑 语法：后面必须紧跟一个异常对象的实例（new ExceptionType(...)）。 适用范围：可以抛出任何异常（受检异常和运行时异常）。 每次只能抛出一个异常：不能同时抛出多个异常。 自定义异常 在 Java 中，除了使用内置异常（如 IOException 或 NullPointerException），还可以根据具体需求定义自己的异常类。自定义异常通常用于表示应用程序中的特定错误场景，提供更清晰的错误语义。\n实现方法 定义异常类：根据业务逻辑定义异常类\n继承现有异常类：\n通常从 Exception 或 RuntimeException 类派生。 如果希望异常必须被显式捕获（受检异常），继承 Exception。 如果希望异常可以被选择性捕获（非受检异常），继承 RuntimeException。 提供构造函数：\n提供默认构造函数。 提供接受错误消息和/或原因（Throwable）的构造函数。 定义受检异常 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 自定义受检异常 class CustomCheckedException extends Exception { public CustomCheckedException() { super(); } public CustomCheckedException(String message) { super(message); } public CustomCheckedException(String message, Throwable cause) { super(message, cause); } public CustomCheckedException(Throwable cause) { super(cause); } } public class CheckedExceptionDemo { public static void main(String[] args) { try { throwCustomException(); } catch (CustomCheckedException e) { System.out.println(\u0026#34;Caught exception: \u0026#34; + e.getMessage()); } } public static void throwCustomException() throws CustomCheckedException { throw new CustomCheckedException(\u0026#34;This is a custom checked exception\u0026#34;); } } 定义非受检异常 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 自定义非受检异常 class CustomUncheckedException extends RuntimeException { public CustomUncheckedException() { super(); } public CustomUncheckedException(String message) { super(message); } public CustomUncheckedException(String message, Throwable cause) { super(message, cause); } public CustomUncheckedException(Throwable cause) { super(cause); } } public class UncheckedExceptionDemo { public static void main(String[] args) { try { throwCustomException(); } catch (CustomUncheckedException e) { System.out.println(\u0026#34;Caught exception: \u0026#34; + e.getMessage()); } } public static void throwCustomException() { throw new CustomUncheckedException(\u0026#34;This is a custom unchecked exception\u0026#34;); } } ","date":"2024-11-16T15:20:48+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","title":"Java中的异常处理"},{"content":"MyBatis-Plus对MyBatis的改进 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 MyBatis和MyBatis-Plus开发流程的区别 MyBatis开发流程 引入相关依赖\n定义被@Mapper注解修饰mapper接口以及相关方法\n1 2 3 4 @Mapper public interface DistrictMapper { List\u0026lt;District\u0026gt;searchAll(String tname); } 在对应mapper.xml文件中书写对应的SQL语句或者在mapper接口中使用注解书写SQL语句\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34; \u0026gt; \u0026lt;mapper namespace=\u0026#34;org.example.operator.mapper.DistrictMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;searchAll\u0026#34; resultType=\u0026#34;org.example.operator.pojo.entity.District\u0026#34;\u0026gt; select did,dname,tdid,content,d_url,district.tid from district left join theme on district.tid = theme.tid where theme.tname = #{tname} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 在Service层中创建对应的Service接口\n1 2 3 4 5 6 7 package org.example.operator.service; import org.example.operator.pojo.dto.District.DistrictDTO; public interface DistrictDetailService { public void updateDistrictDetail(DistrictDTO districtDTO,String oldName); } 以及Service接口的实现类注入Mapper对象实现业务逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package org.example.operator.service.impl; import org.example.operator.common.exception.District.DistrictNotFound; import org.example.operator.common.exception.Theme.ThemeNotFound; import org.example.operator.common.utils.AliyunOSSUtils; import org.example.operator.mapper.DistrictMapper; import org.example.operator.mapper.ThemeMapper; import org.example.operator.pojo.dto.District.DistrictDTO; import org.example.operator.pojo.entity.District; import org.example.operator.pojo.entity.Theme; import org.example.operator.service.DistrictDetailService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; @Service public class DistrictDetailServiceImpl implements DistrictDetailService { @Autowired private ThemeMapper themeMapper; @Autowired private DistrictMapper districtMapper; @Autowired private AliyunOSSUtils aliyunOSSUtils; @Transactional @Override public void updateDistrictDetail(DistrictDTO districtDTO, String oldName) { String tname = districtDTO.getTname(); Theme theme = themeMapper.getThemeByName(tname); if (theme == null) { throw new ThemeNotFound(\u0026#34;主题不存在\u0026#34;); } District district = districtMapper.getDistrictByName(oldName); if (district == null) { throw new DistrictNotFound(\u0026#34;展品不存在\u0026#34;); } String durl = district.getD_url(); aliyunOSSUtils.deleteExhibitImage(durl); Long did = district.getDid(); Long tid = themeMapper.getThemeIdByName(districtDTO.getTname()); districtDTO.setDid(did); districtDTO.setTid(tid); districtMapper.updateDistrictDetail(districtDTO); districtMapper.updateDistrictTdid(districtDTO); } } 在Controller层使用Service接口对象进行响应\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.multipart.MultipartFile; @RestController @Slf4j @RequestMapping(\u0026#34;Operator/productDetail\u0026#34;) public class DistrictDetailController { @Autowired private DistrictSummeryService districtSummeryService; @Autowired private AliyunOSSUtils aliyunOSSUtils; @Autowired private DistrictDetailService districtDetailService; @RequestMapping(\u0026#34;/getProduct\u0026#34;) public Result\u0026lt;DistrictDetailVO\u0026gt; getProduct(String dname) { try{ DistrictDetailVO districtDetailVO = districtSummeryService.getDistrictDetail(dname); log.info(\u0026#34;展品详情：{}\u0026#34;, districtDetailVO); return Result.success(\u0026#34;查询展品详情成功\u0026#34;,districtDetailVO); } catch (Exception e){ log.error(\u0026#34;查询展品详情失败\u0026#34;); return Result.error(\u0026#34;查询展品详情失败\u0026#34;); } } } MyBatis-Plus开发流程 引入相关依赖\n自定义Mapper继承MyBatis-Plus提供的接口BaseMapper，对于自定义SQL语句可以在对应mapper.xml文件中书写\n1 2 3 public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt;{ } 在Service层自定义Service接口继承IService接口\n1 2 3 public interface IUserService extends IService\u0026lt;User\u0026gt;{ } 自定义Service实现类，实现自定义接口并继承Servicelmpl类，注入Mapper对象实现业务逻辑（Wrapper条件构造器在这里使用）\n1 2 3 4 @Service public class UserServiceImpl extends ServiceImpl\u0026lt;UserMapper,User\u0026gt; implements IUserService{ } 在Controller层使用Service接口对象进行响应\n具体使用 引入依赖（参见官方文档 ），MyBatisPlus官方提供了starter，其中集成了Mybatis和MybatisPlus的所有功能，并且实现了自动装配效果。因此我们可以用MybatisPlus的starter代替Mybatis的starter:\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-spring-boot3-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 定义Mapper：自定义Mapper继承MyBatis-Plus提供的接口BaseMapper\n1 2 3 public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt;{ } 默认配置 MyBatis-Plus通过扫描实体类，利用反射机制获取实体类的信息作为数据库表的信息\n类名驼峰转下划线作为表名 名为id的字段作为主键 变量名驼峰转下划线作为表的字段名 1 2 3 public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt;{ } 1 2 3 4 5 6 7 8 9 10 11 public class User{ private Long id; private String username; private string password; private String phone; private string info; private Integer status; private Integer balance; private LocalDateTime createTime; //对应表的字段 create_time private LocalDateTime updateTime; //对应表的字段 update_time } 自定义配置 如果不符合Mybatis-Plus的约定就要使用自定义配置。\n基于注解的配置 @TableName：用来指定表名（该注解用于指定实体类对应的数据库表名。当实体类名与数据库表名不一致，或者实体类名不是数据库表名的驼峰写法时，您需要使用这个注解来明确指定表名。） @TableId：用来指定表中的主键字段信息 value：对应数据库表中的主键字段名 type：主键策略 AUTO：数据库自增长 INPUT：通过set方法自行输入 ASSIGN_ID：分配id @TableField ：用来指定表中的普通字段信息 使用场景 成员变量名与数据库字段名不一致 成员变量名以is开头，且是布尔值(经过反射处理，它会将is去掉作为数据库字段名) 成员变量名与数据库关键字冲突 成员变量名不是数据库字段(数据库中不存在该字段) 具体注解参考官方文档\n基于yml的注解 在SpringBoot项目中可以通过修改application.yml来配置\n1 2 3 4 5 6 7 8 9 10 11 mybatis-plus: type-aliases-package: com.gty.mp.domain.po #注册后，在 Mapper 对应的 XML 文件中可以直接使用类名，无需使用全限定类名。 mapper-locations: \u0026#34;classpath*:/mapper/**/*.xml\u0026#34; #mapper.xml文件地址, 默认值 configuration: map-underscore-to-camel-case: true #是否开启下划线和驼峰的映射 cache-enabled: true #是否开启二级映射 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl #开启mybatis打印日志 global-config: db-config: id-type: assign_id #id为雪花算法生成,注解配置大于全局配置 update-strategy: not_null # 更新策略:只更新非空字段 具体详细配置参考官方文档\n条件构造器（Wrapper） MyBatis-Plus 提供了一套强大的条件构造器（Wrapper），用于构建复杂的数据库查询条件。（BaseMapper实现简单的单表查询）\nWrapper 类允许开发者以链式调用的方式构造查询条件，无需编写繁琐的 SQL 语句，从而提高开发效率并减少 SQL 注入的风险。\n通常作为mapper方法（自定义在mapper接口或者MyBatis-Plus已经实现的）的参数在service层使用\n类的继承结构 AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件\nQueryWrapper ： Query条件封装 UpdateWrapper ： Update条件封装 AbstractLambdaWrapper ： 使用Lambda语法 LambdaQueryWrapper ：基于Lambda语法使用的查询Wrapper LambdaUpdateWrapper ： 基于Lambda语法使用的更新Wrapper QueryWrapper和LambdaQueryWrapper通常用来构建select、delete、update的where条件部分\nUpdateWrapper和LambdaUpdateWrapper通常只有在set语句比较特殊才使用\n具体使用 创建Wrapper对象 Wrappers静态方法： public static \u0026lt;T\u0026gt; QueryWrapper\u0026lt;T\u0026gt; query() 通过QueryWrapper对象的构造方法： public QueryWrapper() 通过lambda方法可以将普通Wrapper转换成lambdaWrapper 基于复杂条件构建wrapper，使用链式编程 示例方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package com.dfbz; import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper; import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper; import com.baomidou.mybatisplus.core.toolkit.Wrappers; import com.dfbz.entity.User; import com.dfbz.mapper.UserMapper; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import java.util.List; /** * @author lscl * @version 1.0 * @intro: */ @SpringBootTest(classes = MyBatisPlusApplication.class) @RunWith(SpringRunner.class) public class Demo06_LambdaQueryMapper { @Autowired private UserMapper userMapper; /** * 使用QueryWrapper * @throws Exception */ @Test public void test1() throws Exception { QueryWrapper\u0026lt;User\u0026gt; wrapper = Wrappers.query(); wrapper.eq(\u0026#34;id\u0026#34;,\u0026#34;1\u0026#34;); List\u0026lt;User\u0026gt; userList = userMapper.selectList(wrapper); for (User user : userList) { System.out.println(user); } } /** * 使用LambdaQueryWrapper * @throws Exception */ @Test public void test2() throws Exception { LambdaQueryWrapper\u0026lt;User\u0026gt; wrapper = Wrappers.lambdaQuery(); // id=1 // wrapper.eq(User::getId,1); // select id,name,age from user where id in (1,2,3) and name like \u0026#34;%a%\u0026#34; wrapper.in(User::getId,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;) .like(User::getName,\u0026#34;a\u0026#34;) .select(User::getId,User::getName,User::getAge); List\u0026lt;User\u0026gt; userList = userMapper.selectList(wrapper); for (User user : userList) { System.out.println(user); } } } 条件方法 方法名 解释 示例 eq 等于 = eq(“name”, “老王”)**---\u0026gt;** name = ‘老王’ ne 不等于 \u0026lt;\u0026gt; ne(“name”, “老王”)**---\u0026gt;** name \u0026lt;\u0026gt; ‘老王’ gt 大于 \u0026gt; gt(“age”, 18)**---\u0026gt;** age \u0026gt; 18 ge 大于等于 \u0026gt;= ge(“age”, 18)**---\u0026gt;** age \u0026gt;= 18 lt 小于 \u0026lt; lt(“age”, 18)**---\u0026gt;** age \u0026lt; 18 le 小于等于 \u0026lt;= le(“age”, 18)**---\u0026gt;** age \u0026lt;= 18 between between 值1 and 值2 between(“age”, 18, 30)**---\u0026gt;** age between 18 and 30 notBetween not between 值1 and 值2 notBetween(“age”, 18, 30)**---\u0026gt;** age not between 18 and 30 like LIKE ‘%值%’ like(“name”, “王”)**---\u0026gt;** name like ‘%王%’ notLike NOT LIKE ‘%值%’ notLike(“name”, “王”)**---\u0026gt;** name not like ‘%王%’ likeLeft LIKE ‘%值’ likeLeft(“name”, “王”)**---\u0026gt;** name like ‘%王’ likeRight LIKE ‘值%’ likeRight(“name”, “王”)**---\u0026gt;** name like ‘王%’ isNull 字段 IS NULL isNull(“name”)**---\u0026gt;** name is null isNotNull 字段 IS NOT NULL isNotNull(“name”)**---\u0026gt;** name is not null in 字段 IN (v0, v1, …) in(“age”, 1, 2, 3)**---\u0026gt;** age in (1,2,3) notIn 字段 NOT IN (v0, v1, …) notIn(“age”, 1, 2, 3)**---\u0026gt;** age not in (1,2,3) inSql 字段 IN ( sql语句 ) inSql(“id”, “select id from table where id \u0026lt; 3”)**---\u0026gt;** id in (select id from table where id \u0026lt; 3) notInSql 字段 NOT IN ( sql语句 ) notInSql(“id”, “select id from table where id \u0026lt; 3”)**---\u0026gt;** id not in (select id from table where id \u0026lt; 3) groupBy 分组：GROUP BY 字段, … groupBy(“id”, “name”)**---\u0026gt;** group by id,name orderByAsc 排序：ORDER BY 字段, … ASC orderByAsc(“id”, “name”)**---\u0026gt;** order by id ASC,name ASC orderByDesc 排序：ORDER BY 字段, … DESC orderByDesc(“id”, “name”)**---\u0026gt;** order by id DESC,name DESC orderBy 排序：ORDER BY 字段, … orderBy(true, true, “id”, “name”)**---\u0026gt;** order by id ASC,name ASC having HAVING ( sql语句 ) 例1：having(“sum(age) \u0026gt; 10”)**---\u0026gt;** having sum(age) \u0026gt; 10 例2：having(“sum(age) \u0026gt; {0}”, 11)**---\u0026gt;** having sum(age) \u0026gt; 11 func 主要解决条件拼接 func(i -\u0026gt; if(true) {i.eq(“id”, 1)} else {i.ne(“id”, 1)}) or 拼接 OR eq(“id”,1).or().eq(“name”,“老王”)**---\u0026gt;** id = 1 or name = ‘老王’ and AND 嵌套 and(i -\u0026gt; i.eq(“name”, “李白”).ne(“status”, “活着”))**---\u0026gt;** and (name = ‘李白’ and status \u0026lt;\u0026gt; ‘活着’) nested 用于多条件拼接时 nested(i -\u0026gt; i.eq(“name”, “李白”).ne(“status”, “活着”))**---\u0026gt;** (name = ‘李白’ and status \u0026lt;\u0026gt; ‘活着’) apply 用于拼接SQL语句 例1：apply(“id = 1”)**---\u0026gt;** id = 1 例2：apply(“id = {0}”,1)**---\u0026gt;** *id = 1 例3：apply(“name like {0} and age \u0026gt; {1}”,“%J%”,18) **\\*\\*---\u0026gt;\\*\\* *name like ‘%J%’ and age \u0026gt; 18 last 无视优化规则直接拼接到 sql 的最后 *last(“limit 1”) **\\*\\*---\u0026gt;\\*\\* *在SQL语句最后面拼接：limit 1 exists 拼接 EXISTS ( sql语句 ) exists(“select id from table where age = 1”)**---\u0026gt;** exists (select id from table where age = 1) notExists 拼接 NOT EXISTS ( sql语句 ) notExists(“select id from table where age = 1”)**---\u0026gt;** not exists (select id from table where age = 1) 具体参见官方文档\n自定义SQL 可以利用MyBatis-Plus的Wrapper来构建复杂的where条件，然后自己定义SQL语句中剩下的部分。\n基于Wrapper定义复杂的Where条件\n在mapper方法参数中用@Param注解声明wrapper变量名称，名称必须为ew或者使用注解 @Param(Constants.WRAPPER) 明确指定参数为 Wrapper 对象。\n1 2 3 4 5 6 7 8 import com.baomidou.mybatisplus.core.conditions.Wrapper; import com.baomidou.mybatisplus.core.toolkit.Constants; import org.apache.ibatis.annotations.Param; public interface UserMapper extends BaseMapper\u0026lt;User\u0026gt; { @Select(\u0026#34;SELECT * FROM user ${ew.customSqlSegment}\u0026#34;) List\u0026lt;User\u0026gt; selectByCustomSql(@Param(Constants.WRAPPER) Wrapper\u0026lt;User\u0026gt; wrapper); } 自定义SQL语句，使用${ew.customSqlSegment}来引用 Wrapper 对象生成的 SQL 片段。\n1 2 3 QueryWrapper\u0026lt;User\u0026gt; queryWrapper = new QueryWrapper\u0026lt;\u0026gt;(); queryWrapper.eq(\u0026#34;name\u0026#34;, \u0026#34;张三\u0026#34;); List\u0026lt;User\u0026gt; userList = userMapper.selectByCustomSql(queryWrapper); Service层接口（IService） MyBatis提供了Service层接口IService和默认实现类ServiceImpl\n使用流程 自定义Service接口继承IService接口（其中IService接口中的泛型为操纵的实体类）\n1 2 3 public interface IUserService extends IService\u0026lt;User\u0026gt;{ } 自定义Service实现类，实现自定义接口并继承Servicelmpl类（其中ServiceImpl中的泛型为对应的Mapper类和实体类）\n1 2 3 4 @Service public class UserServiceImpl extends ServiceImpl\u0026lt;UserMapper,User\u0026gt; implements IUserService{ } LambdaQuery和LambdaUpdate IService中还提供了Lambda功能来简化我们的复杂查询及更新功能。\n在Service层中可以代替Wrapper实现更加复杂的查询/更新\nlambdaQuery()和lambdaUpdate()方法直接获得一个Wrapper的子类通过链式编程简化\n在service层中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Override public List\u0026lt;User\u0026gt; queryUsers(UserQuery userQuery) { return lambdaQuery() .like(userQuery.getName() != null, User::getUsername, userQuery.getName()) .eq(userQuery.getStatus() != null, User::getStatus, userQuery.getStatus()) .ge(userQuery.getMinBalance() != null, User::getBalance, userQuery.getMinBalance()) .le(userQuery.getMaxBalance() != null, User::getBalance, userQuery.getMaxBalance()) .list(); } @Override public void deductionBalance(Long id, Integer money) { // 1.查询用户 User user = getById(id); // 2.校验用户状态 if (user == null || user.getStatus() == UserStatus.FREEZE) { throw new RuntimeException(\u0026#34;用户状态异常!\u0026#34;); } // 3.校验余额是否充足 if (user.getBalance() \u0026lt; money) { throw new RuntimeException(\u0026#34;用户余额不足\u0026#34;); } // 4.扣减余额 int remainBalance = user.getBalance() - money; lambdaUpdate() .set(User::getBalance, remainBalance) .set(remainBalance == 0, User::getStatus, UserStatus.FREEZE) .eq(User::getId, id) .eq(User::getBalance, user.getBalance()) //乐观锁 .update(); } 还需要在链式编程的最后添加一个list()，这是在告诉MP我们的调用结果需要是一个list集合。这里不仅可以用list()，可选的方法有：\n.one()：最多1个结果 .list()：返回集合结果 .count()：返回计数结果 批量插入 1 2 3 4 // 插入（批量） boolean saveBatch(Collection\u0026lt;T\u0026gt; entityList); // 插入（批量） boolean saveBatch(Collection\u0026lt;T\u0026gt; entityList, int batchSize); 效率一般：MybatisPlus的批处理是基于PrepareStatement的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。而想得到最佳性能，最好是将多条SQL合并为一条。\n提升效率的方式\nMySQL的客户端连接参数中有这样的一个参数：rewriteBatchedStatements。顾名思义，就是重写批处理的statement语句。这个参数的默认值是false，我们需要修改连接参数，将其配置为true。\n在配置文件中，在数据库连接配置中在url后面加上 rewriteBatchedStatements=true 的一个参数：\n分页插件 具体参见官方文档\n在配置类中注册MyBatis-Plus的核心插件。同时添加分页插件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Configuration @MapperScan(\u0026#34;scan.your.mapper.package\u0026#34;) public class MybatisPlusConfig { /** * 添加分页插件 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { //创建MyBatis-Plus拦截器 MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); //添加内部拦截器（插件） // 添加分页插件 PaginationInnerInterceptor paginationInnerInterceptor = new PaginationInnerInterceptor(DbType.MYSQL); //可以给分页插件添加属性 //overflow\tboolean\tfalse\t溢出总页数后是否进行处理 //maxLimit\tLong\t单页分页条数限制 //dbType\tDbType\t数据库类型 //dialect\tIDialect\t方言实现类 interceptor.addInnerInterceptor(paginationInnerInterceptor); // 如果配置多个插件, 切记分页最后添加 // 如果有多数据源可以不配具体类型, 否则都建议配上具体的 DbType return interceptor; } } 在Mapper方法使用分页相关API\n设置分页参数\n1 2 3 4 5 6 7 8 //方法一 int pageNo = 1; //页码 int pageSize = 2; //每页大小 Page\u0026lt;User\u0026gt; pageInfo = Page.of(pageNo, pageSize); Page\u0026lt;User\u0026gt;p=userMapper.page(pageInfo); //方法二 Page\u0026lt;User\u0026gt; pageInfo = new Page\u0026lt;\u0026gt;(page,pageSize); Page\u0026lt;User\u0026gt;p = userService.page(pageInfo); 进行分页查询\n1 2 Page\u0026lt;T\u0026gt; page_name=userMapper.selectPage(page, wrapper); //条件分页查询 Page\u0026lt;T\u0026gt; page_name=userMapper.page(page);//普通分页查询 使用相关API\n1 2 3 4 5 6 7 当前页数：page.getCurrent() 总页数： page.getPages() 记录数： page.getTotal() 是否有上一页： page.hasPrevious() 是否有下一页： page.hasNext() 分页数据：page.getRecords() 排序条件：page.addOrder(new OrderItem(\u0026#34;数据库字段名\u0026#34;,true)); //升序为true,降序为false ","date":"2024-11-16T10:56:19+08:00","permalink":"https://Tyritic.github.io/p/mybatis-plus/","title":"MyBatis Plus"},{"content":"泛型的定义 泛型是 Java 编程语言中的一个重要特性，它允许类、接口和方法在定义时使用一个或多个类型参数，这些类型参数在使用时可以被指定为具体的类型。\n泛型的主要目的是在编译时提供更强的类型检查，并且在编译后能够保留类型信息，避免了在运行时出现类型转换异常。\n泛型的作用 类型安全：泛型允许在编译时进行类型检查，确保在使用集合或其他泛型类时，不会出现类型不匹配的问题，减少了运行时的 ClassCastException 错误。 代码重用：泛型使代码可以适用于多种不同的类型，减少代码重复，提升可读性和维护性。 消除显式类型转换：泛型允许在编译时指定类型参数，从而消除了运行时需要显式类型转换的麻烦。 泛型的使用 泛型类 类的成员变量的类型不确定，可以使用泛型表示\n语法格式\n1 2 3 class className\u0026lt;T\u0026gt;{ } 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 泛型类的定义 public class Box\u0026lt;T\u0026gt; { private T value; public void setValue(T value) { this.value = value; } public T getValue() { return value; } } // 使用泛型类 Box\u0026lt;Integer\u0026gt; intBox = new Box\u0026lt;\u0026gt;(); intBox.setValue(10); Integer intValue = intBox.getValue(); System.out.println(intValue); // 输出: 10 Box\u0026lt;String\u0026gt; stringBox = new Box\u0026lt;\u0026gt;(); stringBox.setValue(\u0026#34;Hello, Generic!\u0026#34;); String strValue = stringBox.getValue(); System.out.println(strValue); // 输出: Hello, Generic! 泛型接口 用类型参数来参数化接口的方法和字段，泛型类和非泛型类都可以实现泛型接口，只是非泛型类给泛型接口提供具体类型\n示例代码\n泛型类实现泛型接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 泛型接口的定义 interface Pair\u0026lt;K, V\u0026gt; { K getKey(); V getValue(); } // 泛型接口的实现 class MyPair\u0026lt;K, V\u0026gt; implements Pair\u0026lt;K, V\u0026gt; { private K key; private V value; public MyPair(K key, V value) { this.key = key; this.value = value; } @Override public K getKey() { return key; } @Override public V getValue() { return value; } } // 使用泛型接口 Pair\u0026lt;String, Integer\u0026gt; pair = new MyPair\u0026lt;\u0026gt;(\u0026#34;Age\u0026#34;, 30); System.out.println(pair.getKey() + \u0026#34;: \u0026#34; + pair.getValue()); // 输出: Age: 30 非泛型类实现泛型接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 泛型接口 interface Pair\u0026lt;K, V\u0026gt; { K getKey(); V getValue(); } // 非泛型类实现泛型接口 class MyPair implements Pair\u0026lt;String, Integer\u0026gt; { private String key; private Integer value; public MyPair(String key, Integer value) { this.key = key; this.value = value; } @Override public String getKey() { return key; } @Override public Integer getValue() { return value; } } public class Main { public static void main(String[] args) { MyPair pair = new MyPair(\u0026#34;Age\u0026#34;, 30); System.out.println(pair.getKey() + \u0026#34;: \u0026#34; + pair.getValue()); // 输出: Age: 30 } } 泛型方法 泛型方法是指在方法的定义中，使用类型参数。与泛型类不同的是，泛型方法的类型参数只适用于该方法，而不影响整个类。\n语法格式\n1 2 3 访问控制符 \u0026lt;T\u0026gt; 方法返回值 方法名(形参列表){ } 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 泛型方法的定义 public class GenericMethodExample { public static \u0026lt;T\u0026gt; void printArray(T[] array) { for (T element : array) { System.out.print(element + \u0026#34; \u0026#34;); } System.out.println(); } public static void main(String[] args) { Integer[] intArray = {1, 2, 3}; String[] strArray = {\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;}; // 调用泛型方法 printArray(intArray); // 输出: 1 2 3 printArray(strArray); // 输出: Hello World } } 泛型的通配符 Java 泛型的上限定符 用于对泛型类型参数进行范围限制\n无界通配符 无界通配符表示泛型类型没有任何限制，可以接受任何类型。它适用于不关心具体类型的场景，常用于方法参数中。\n语法参数\n1 \u0026lt;?\u0026gt; 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.util.List; public class WildcardExample { public static void printList(List\u0026lt;?\u0026gt; list) { for (Object obj : list) { System.out.println(obj); } } public static void main(String[] args) { List\u0026lt;String\u0026gt; stringList = List.of(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); List\u0026lt;Integer\u0026gt; intList = List.of(1, 2, 3); printList(stringList); // 可以传递任何类型的 List printList(intList); } } 上界通配符 语法格式\n1 \u0026lt;? extends T\u0026gt; 上界通配符限制泛型类型必须是指定类型 T 或 T 的子类。这意味着，\u0026lt;? extends T\u0026gt; 可以接受 T 类型及其所有子类型。上界通配符通常用于读取操作，确保可以读取为 T 或 T 的子类的对象。。\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.util.List; public class UpperBoundWildcardExample { public static void printNumbers(List\u0026lt;? extends Number\u0026gt; list) { for (Number number : list) { System.out.println(number); } } public static void main(String[] args) { List\u0026lt;Integer\u0026gt; intList = List.of(1, 2, 3); List\u0026lt;Double\u0026gt; doubleList = List.of(1.1, 2.2, 3.3); printNumbers(intList); // 可以传递 List\u0026lt;Integer\u0026gt; printNumbers(doubleList); // 可以传递 List\u0026lt;Double\u0026gt; } } 下界通配符 语法格式\n1 \u0026lt;? super T\u0026gt; 下界通配符限制泛型类型必须是指定类型 T 或 T 的父类。\u0026lt;? super T\u0026gt; 适用于我们要往集合中添加元素的情况，它保证了能够安全地将 T 类型及其子类型的对象放入容器中。\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import java.util.List; public class LowerBoundWildcardExample { public static void addNumbers(List\u0026lt;? super Integer\u0026gt; list) { list.add(42); // 只允许添加 Integer 或其子类型的元素 } public static void main(String[] args) { List\u0026lt;Number\u0026gt; numberList = List.of(1, 2, 3); List\u0026lt;Object\u0026gt; objectList = List.of(\u0026#34;string\u0026#34;, 10.5); addNumbers(numberList); // 可以传递 List\u0026lt;Number\u0026gt; addNumbers(objectList); // 可以传递 List\u0026lt;Object\u0026gt; } } 使用规则 \u0026lt;? extends T\u0026gt; 的泛型集合中只能读取数据不能写入数据 示例\n1 2 3 4 5 6 7 8 9 10 11 import java.util.List; public class Test { public static void addToList(List\u0026lt;? extends Number\u0026gt; list) { for (Number num : list) { System.out.println(num); // 读取是安全的 } // list.add(1); // 编译错误 // list.add(3.14); // 编译错误 } } 解释\n当使用\u0026lt;? extends T\u0026gt; ,泛型集合中元素的类型是 T 类型或 T 的任意子类型 可读取性：\u0026lt;? extends T\u0026gt; 确保了集合中的每个元素至少是 T 类型或其子类，因此可以安全地以多态（向上转型）赋值给 T 类型的变量 。 不可写入性：List\u0026lt;? extends T\u0026gt; 限定了泛型上界为 T 的子类，但无法保证具体是哪种类型，因此不能添加元素（除了 null），否则会违反类型安全性。 \u0026lt;? super T\u0026gt; 的泛型集合中只能写入数据不能读取数据 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import java.util.List; import java.util.ArrayList; public class Test { public static void addToList(List\u0026lt;? super Integer\u0026gt; list) { list.add(10); // 可以添加 Integer 类型的数据 list.add(100); // 可以继续添加 Integer 类型的数据 } public static void main(String[] args) { List\u0026lt;Number\u0026gt; numberList = new ArrayList\u0026lt;\u0026gt;(); addToList(numberList); // 传入 List\u0026lt;Number\u0026gt; 是安全的 List\u0026lt;Object\u0026gt; objectList = new ArrayList\u0026lt;\u0026gt;(); addToList(objectList); // 传入 List\u0026lt;Object\u0026gt; 也是安全的 Object obj = list.get(0); // 可以读取为 Object 类型 // Integer num = list.get(0); // 编译错误，不能直接读取为 Integer } } 解释\n当使用 \u0026lt;? super T\u0026gt; 时，泛型集合中元素的类型是 T 类型或 T 的任意父类型 可写入性：\u0026lt;? super T\u0026gt; 确保了集合中的每个元素至少是 T 类型或其父类，因此可以安全地写入 T 类型及其子类的变量。 不可读取性：编译器并不知道集合实际存储的具体类型，因此无法确定返回的元素类型是什么，唯一可以确定的是，所有元素至少是 Object 类型，因此只能将读取的元素视为 Object。 PECS 原则 PECS 原则是 Producer Extends, Consumer Super 的缩写，帮助理解何时使用上界和下界限定符：\nProducer Extends：如果某个对象提供数据（即生产者），使用 extends（上界限定符）。 Consumer Super：如果某个对象接收数据（即消费者），使用 super（下界限定符）。 类型擦除和伪泛型 Java 中的泛型被称为 伪泛型（erasure），这是因为 Java 的泛型是通过 类型擦除（type erasure） 实现的\n类型擦除 实现方式 编译时：\n用原始类型替换泛型类型：所有泛型类和方法会被编译为使用原始类型的代码。例如，List\u0026lt;String\u0026gt; 会变成 List，T 会变成 Object。 类型边界：如果泛型类或方法有上界限制（如 T extends Number），那么在擦除时，T 会被替换为这个边界类型（例如 Number）。 类型参数的强制转换：在泛型类和方法中，编译器会插入强制类型转换，以确保在运行时正确转换类型。 运行时：在运行时，Java 并不保留泛型类型信息，所有泛型类型都被转换成了原始类型。\n示例说明\n编译前\n1 2 3 4 5 6 7 8 9 10 11 public class Box\u0026lt;T\u0026gt; { private T value; public void setValue(T value) { this.value = value; } public T getValue() { return value; } } 编译后\n1 2 3 4 5 6 7 8 9 10 11 public class Box { private Object value; public void setValue(Object value) { this.value = value; } public Object getValue() { return value; } } 作用和影响 作用：泛型擦除确保了 Java 代码的向后兼容性，但它也限制了在运行时对泛型类型的操作。\n影响：\n类型信息丢失：由于类型擦除，无法在运行时获取泛型的实际类型，导致无法进行以下操作 不能创建泛型类型的数组，不能实例化泛型类型的变量 对泛型类型使用 instanceof 检查 类型转换异常：在运行时，由于类型擦除的存在，可能会导致类型转换异常。例如，如果你错误地将 List\u0026lt;Integer\u0026gt; 和 List\u0026lt;String\u0026gt; 混用，编译时可能不会发现问题，而在运行时会导致 ClassCastException。 无法使用基本类型作为泛型：由于类型擦除的原因，Java 泛型无法直接使用基本数据类型（如 int、char 等），只能使用它们的包装类型（如 Integer、Character）。 利用反射获取泛型类型的情况 因为泛型信息保存在class文件中\n成员变量的泛型 方法入参的泛型 方法返回值的泛型 带来的问题 1 2 3 4 5 6 7 8 9 10 public class Cmower { public static void method(ArrayList\u0026lt;String\u0026gt; list) { System.out.println(\u0026#34;ArrayList\u0026lt;String\u0026gt; list\u0026#34;); } public static void method(ArrayList\u0026lt;Date\u0026gt; list) { System.out.println(\u0026#34;ArrayList\u0026lt;Date\u0026gt; list\u0026#34;); } } 在 Java 中，泛型是在编译时擦除的，这意味着 ArrayList\u0026lt;String\u0026gt; 和 ArrayList\u0026lt;Date\u0026gt; 在编译后会变成相同的类型 ArrayList。\n当方法重载时，如果两种方法的签名 在类型擦除后相同，就会发生冲突。 在这段代码中，ArrayList\u0026lt;String\u0026gt; 和 ArrayList\u0026lt;Date\u0026gt; 在类型擦除后都会变成 ArrayList，因此，编译器无法区分这两个方法，导致编译时发生冲突。 为什么是伪泛型 泛型只在编译时进行类型检查，运行时并不会保留泛型类型信息。\n在运行时泛型根本没有起作用！也就是说在运行的时候 JVM 获取不到泛型的信息，也会不对其做任何的约束。\n因此，虽然在 IDE 写代码的时候泛型生效了，而实际上在运行的时候泛型的类型是被擦除的。\n一言蔽之，Java的泛型只在编译时生效，JVM 运行时没有泛型。\n","date":"2024-11-16T09:46:03+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B/","title":"Java中的泛型"},{"content":"StringBuffer的定义 StringBuffer 是 Java 中用于创建可变字符串的类，提供了一个与 StringBuilder 类似的功能。它们都用于处理可变的字符串数据，不同之处在于 StringBuffer 是线程安全的，而 StringBuilder 不是。\nStringBuffer 的特点 可变字符串： StringBuffer 提供了修改字符串内容的方法，避免了每次修改字符串时创建新的 String 对象，从而提高了性能。 线程安全： StringBuffer 是线程安全的，意味着它可以在多个线程间安全地共享和操作。StringBuffer 中的方法通常都被同步（使用 synchronized），确保多线程环境下的线程安全。 效率较低： 由于线程安全的特性，StringBuffer 的性能通常比 StringBuilder 略差，因为 StringBuffer 的方法被加锁，而 StringBuffer 的方法没有锁定。 StringBuffer的构造函数 public StringBuffer() ：默认构造，初始化容量为 16 public StringBuffer(String str) ：以指定字符串初始化 public StringBuffer(int capacity)：以指定初始容量初始化 StringBuffer的常见操作 追加数据 public StringBuffer append(String str)：将字符串str追加到 StringBuffer 对象的末尾。 public StringBuffer append(int i)：将 i 转换为字符串并追加到 StringBuffer 对象的末尾。 public StringBuffer append(char c)：将 c 转换为字符串并追加到 StringBuffer 对象的末尾。 作用\nappend() 方法用于在 StringBuffer 对象的末尾追加指定的内容。 支持多种类型的参数，包括 String、int、char 等。调用时会将传入的内容转换为字符串后附加到原字符串的后面。 示例\n1 2 3 StringBuffer sb = new StringBuffer(\u0026#34;Hello\u0026#34;); sb.append(\u0026#34; World\u0026#34;).append(123).append(\u0026#39;!\u0026#39;); System.out.println(sb); // 输出：Hello World123! 插入内容 public StringBuffer insert(int offset, String str) public StringBuffer insert(int offset, int i) public StringBuffer insert(int offset, char c) 作用\ninsert() 方法将指定的内容插入到 StringBuffer 对象中指定位置。 offset 参数表示插入的位置，内容会从这个位置开始插入。 示例\n1 2 3 StringBuffer sb = new StringBuffer(\u0026#34;Hello!\u0026#34;); sb.insert(5, \u0026#34; Java\u0026#34;); System.out.println(sb); // 输出：Hello Java! 删除内容 public StringBuffer delete(int start, int end) 作用：\ndelete() 方法删除 StringBuffer 中从 start 到 end-1 位置的字符。 删除的是一个字符范围，start 是包含的起始位置，end 是不包含的结束位置。 示例：\n1 2 3 StringBuffer sb = new StringBuffer(\u0026#34;Hello Java!\u0026#34;); sb.delete(5, 10); System.out.println(sb); // 输出：Hello! 替换子串 public StringBuffer replace(int start, int end, String str) 作用：\nreplace() 方法将指定范围（start，end-1）内的字符替换为给定的字符串。 start 到 end 范围的字符被替换为 str。 示例：\n1 2 3 StringBuffer sb = new StringBuffer(\u0026#34;Hello World!\u0026#34;); sb.replace(6, 11, \u0026#34;Java\u0026#34;); System.out.println(sb); // 输出：Hello Java! 反转字符串 public StringBuffer reverse() 作用：\nreverse() 方法将 StringBuffer 中的字符序列反转。 例如，Hello 会变成 olleH。 示例：\n1 2 3 StringBuffer sb = new StringBuffer(\u0026#34;Hello\u0026#34;); sb.reverse(); System.out.println(sb); // 输出：olleH 获取属性 public int length()：获取字符串长度 public int capacity()：获取容量 操作指定位置的字符 public char charAt(int index)：获取指定位置的字符 public void setCharAt(int index, char ch)：设置指定位置的字符 截取子串 public String substring(int start) public String substring(int start, int end) 作用：\nsubstring() 方法返回 StringBuffer 中指定位置的子字符串。 如果只有 start 参数，则返回从 start 到最后的子字符串。 如果提供了 start 和 end，则返回该范围内的子字符串。 示例\n1 2 3 StringBuffer sb = new StringBuffer(\u0026#34;Hello World\u0026#34;); System.out.println(sb.substring(6)); // 输出：World System.out.println(sb.substring(0, 5)); // 输出：Hello 查找子串 public int indexOf(String str) public int indexOf(String str, int fromIndex) 作用：\nindexOf() 方法返回指定子字符串首次出现的位置。如果子字符串不存在，则返回 -1。 可以通过 fromIndex 参数指定从哪个位置开始查找。 示例\n1 2 3 StringBuffer sb = new StringBuffer(\u0026#34;Hello World\u0026#34;); System.out.println(sb.indexOf(\u0026#34;World\u0026#34;)); // 输出：6 System.out.println(sb.indexOf(\u0026#34;o\u0026#34;, 5)); // 输出：7 总体使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class StringBufferExample { public static void main(String[] args) { // 创建一个 StringBuffer 对象 StringBuffer sb = new StringBuffer(\u0026#34;Hello\u0026#34;); // 使用 append() 方法追加内容 sb.append(\u0026#34; World!\u0026#34;); System.out.println(sb); // 输出：Hello World! // 使用 insert() 方法插入内容 sb.insert(5, \u0026#34;,\u0026#34;); System.out.println(sb); // 输出：Hello, World! // 使用 delete() 方法删除内容 sb.delete(5, 6); // 删除从索引 5 到 6 的字符 System.out.println(sb); // 输出：Hello World! // 使用 reverse() 方法反转字符串 sb.reverse(); System.out.println(sb); // 输出：!dlroW olleH // 将 StringBuffer 转换为 String String str = sb.toString(); System.out.println(str); // 输出：!dlroW olleH // 获取 StringBuffer 的长度 System.out.println(sb.length()); // 输出：13 // 获取 StringBuffer 的容量 System.out.println(sb.capacity()); // 输出：27 (因为默认容量是16，加上追加的内容后，容量自动扩展) } } String，StringBuffer，StringBuilder的区别（面试题） String\n不可变：String 是不可变类，字符串一旦创建，其内容无法更改。每次对 String 进行修改操作（如拼接、截取等），都会创建新的 String 对象。 适合场景：String 适用于字符串内容不会频繁变化的场景，例如少量的字符串拼接操作或字符串常量。 StringBuffer\n可变：StringBuffer 是可变的，可以进行字符串的追加、删除、插入等操作。 线程安全：StringBuffer 是线程安全的，内部使用了 synchronized 关键字来保证多线程环境下的安全性。 适合场景：StringBuffer 适用于在多线程环境中需要频繁修改字符串的场景。 StringBuilder\n可变：StringBuilder 也是可变的，提供了与 StringBuffer 类似的操作接口。 非线程安全：StringBuilder 不保证线程安全，性能比 StringBuffer 更高。 适合场景：StringBuilder 适用于单线程环境中需要大量修改字符串的场景，如高频拼接操作。 ","date":"2024-11-15T23:03:07+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84stringbuffer/","title":"Java中的StringBuffer"},{"content":"StringBuilder的定义 StringBuilder 是 Java 中的一个 可变字符序列类，位于 java.lang 包中。它用于创建和操作可变的字符串（字符序列），与 String 不同，StringBuilder 的内容是 可变的，不会像 String 那样在每次修改时创建新的对象，从而提高了性能，尤其在需要频繁修改字符串时非常有用。\nStringBuilder的特点 可变性： StringBuilder 维护一个可变的char数组，操作时直接修改这个数组，不会生成新的对象。 效率高： 在进行字符串拼接、插入、删除等操作时，相比 String 创建大量临时对象，StringBuilder 只需在原对象上进行操作，因此效率更高。 线程不安全： 与 StringBuffer（线程安全版本）不同，StringBuilder 不是线程安全的，但在单线程环境下效率更高。 StringBuilder的构造方法 StringBuilder()\n无参构造函数，创建一个初始容量为 16 的空 StringBuilder 对象。\nStringBuilder(int capacity)\n指定初始容量的构造函数，创建一个具有指定初始容量的 StringBuilder 对象，如果在追加字符时超出指定容量，StringBuilder 会自动扩容，扩容规则为：\n新容量 = (旧容量 * 2) + 2\nStringBuilder(String str)\n以指定字符串内容为初始值的构造函数，创建一个包含给定字符串内容的 StringBuilder 对象，同时容量为 str.length() + 16。\nStringBuilder(CharSequence seq)\n以 CharSequence 接口实现类为初始内容的构造函数，创建一个包含指定字符序列的 StringBuilder 对象。\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Main { public static void main(String[] args) { // 无参构造 StringBuilder sb1 = new StringBuilder(); System.out.println(\u0026#34;sb1 的初始容量：\u0026#34; + sb1.capacity()); // 输出：16 // 指定容量构造 StringBuilder sb2 = new StringBuilder(30); System.out.println(\u0026#34;sb2 的初始容量：\u0026#34; + sb2.capacity()); // 输出：30 // 以字符串为初始值的构造 StringBuilder sb3 = new StringBuilder(\u0026#34;Hello\u0026#34;); System.out.println(\u0026#34;sb3 的初始内容：\u0026#34; + sb3.toString()); // 输出：Hello System.out.println(\u0026#34;sb3 的初始容量：\u0026#34; + sb3.capacity()); // 输出：21（5 + 16） // 以 CharSequence 为初始值的构造 CharSequence seq = \u0026#34;World\u0026#34;; StringBuilder sb4 = new StringBuilder(seq); System.out.println(\u0026#34;sb4 的初始内容：\u0026#34; + sb4.toString()); // 输出：World } } StringBuilder的常见操作 追加数据 public StringBuilder append(String str)：将字符串str追加到 StringBuilder 对象的末尾。 public StringBuilder append(int i)：将 i 转换为字符串并追加到 StringBuilder 对象的末尾。 public StringBuilder append(char c)：将 c 转换为字符串并追加到 StringBuilder 对象的末尾。 作用\nappend() 方法用于在 StringBuilder 对象的末尾追加指定的内容。 支持多种类型的参数，包括 String、int、char 等。调用时会将传入的内容转换为字符串后附加到原字符串的后面。 示例\n1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello\u0026#34;); sb.append(\u0026#34; World\u0026#34;).append(123).append(\u0026#39;!\u0026#39;); System.out.println(sb); // 输出：Hello World123! 插入内容 public StringBuilder insert(int offset, String str) public StringBuilder insert(int offset, int i) public StringBuilder insert(int offset, char c) 作用\ninsert() 方法将指定的内容插入到 StringBuilder 对象中指定位置。 offset 参数表示插入的位置，内容会从这个位置开始插入。 示例\n1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello!\u0026#34;); sb.insert(5, \u0026#34; Java\u0026#34;); System.out.println(sb); // 输出：Hello Java! 删除内容 public StringBuilder delete(int start, int end) 作用：\ndelete() 方法删除 StringBuilder 中从 start 到 end-1 位置的字符。 删除的是一个字符范围，start 是包含的起始位置，end 是不包含的结束位置。 示例：\n1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello Java!\u0026#34;); sb.delete(5, 10); System.out.println(sb); // 输出：Hello! 替换子串 public StringBuilder replace(int start, int end, String str) 作用：\nreplace() 方法将指定范围（start，end-1）内的字符替换为给定的字符串。 start 到 end 范围的字符被替换为 str。 示例：\n1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello World!\u0026#34;); sb.replace(6, 11, \u0026#34;Java\u0026#34;); System.out.println(sb); // 输出：Hello Java! 反转字符串 public StringBuilder reverse() 作用：\nreverse() 方法将 StringBuilder 中的字符序列反转。 例如，Hello 会变成 olleH。 示例：\n1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello\u0026#34;); sb.reverse(); System.out.println(sb); // 输出：olleH 获取属性 public int length()：获取字符串长度 public int capacity()：获取容量 操作指定位置的字符 public char charAt(int index)：获取指定位置的字符 public void setCharAt(int index, char ch)：设置指定位置的字符 截取子串 public String substring(int start) public String substring(int start, int end) 作用：\nsubstring() 方法返回 StringBuilder 中指定位置的子字符串。 如果只有 start 参数，则返回从 start 到最后的子字符串。 如果提供了 start 和 end，则返回该范围内的子字符串。 示例\n1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello World\u0026#34;); System.out.println(sb.substring(6)); // 输出：World System.out.println(sb.substring(0, 5)); // 输出：Hello 查找子串 public int indexOf(String str) public int indexOf(String str, int fromIndex) 作用：\nindexOf() 方法返回指定子字符串首次出现的位置。如果子字符串不存在，则返回 -1。 可以通过 fromIndex 参数指定从哪个位置开始查找。 示例\n1 2 3 StringBuilder sb = new StringBuilder(\u0026#34;Hello World\u0026#34;); System.out.println(sb.indexOf(\u0026#34;World\u0026#34;)); // 输出：6 System.out.println(sb.indexOf(\u0026#34;o\u0026#34;, 5)); // 输出：7 equals方法 StringBuilder 类中的 equals() 方法在默认情况下并不按内容比较两个 StringBuilder 对象，而是按 引用 比较，即两个 StringBuilder 对象是否指向相同的内存位置。\nStringBuilder的实现原理 大致核心实现 内部使用字符数组 (char[] value) 来存储字符序列 通过方法如 append()、insert() 等操作，直接修改内部的字符数组，而不会像 String 那样创建新的对象。 每次进行字符串操作时，如果当前容量不足，它会通过扩展数组容量来容纳新的字符，按 2 倍的容量扩展，以减少扩展次数，提高性能。 底层具体实现 StringBuilder 底层使用 char 数组 value 来存储字符，并且用 count 来记录存放的字符数 为了防止频繁地复制和申请内存，需要提供 capacity 参数来设置初始化数组的大小，这样可以减少数组的扩容次数，有效的提升效率！ append()的具体实现 int值转成 char 需要占数组的几位，然后计算一下现在的数组够不够放，如果不够就扩容，然后再把 int 转成 char 放进去，再更新现有的字符数。 扩容时调用 Arrays.copyOf，进行一波扩容加拷贝，扩容之后的数组容量为之前的两倍+2。 insert()的具体实现 这里是把 数据 转成 string 插入前先判断下数组长度足够，若不够就扩容。 移动字符，给待插入的位置腾出空间，然后往对应位置插入字符 最后更新 StringBuilder 已有的字符数 优化方法（JDK 11的优化） char 数组是可以优化的，底层可以用 byte 数组+一个 coder 标志位来实现，这样更节省内存，因为 char 占用两个字节，这样对于 latin 系的字符来说，太大了，就很浪费，所以用 byte 数组，然后配备一个 coder 来标识所用的编码。\n","date":"2024-11-15T21:13:12+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84stringbuilder/","title":"Java中的StringBuilder"},{"content":"一级缓存 一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问\n使一级缓存失效的四种情况: 不同的SqlSession对应不同的一级缓存 同一个SqlSession但是查询条件不同 同一个SqlSession两次查询期间执行了任何一次增删改操作 同一个SqlSession两次查询期间手动清空了缓存 二级缓存 二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存;此后若再次执行相同的查询语句，结果就会从缓存中获取。\n二级缓存开启的条件: 在核心配置文件中，设置全局配置属性cacheEnabled=\u0026ldquo;true\u0026rdquo;，默认为true，不需要设置 在mapper.xml映射文件中设置标签\u0026lt;cache \u0026gt; 二级缓存必须在SqlSession关闭或提交之后有效 查询的数据所转换的实体类类型必须实现序列化的接口 失效的情况 在两次查询之间进行任意的增删改，手动清空缓存只会清空一级缓存\n相关配置 在mapper.xml映射文件中设置标签\u0026lt;cache \u0026gt;\n相关属性参见 MyBatis官方文档\n缓存查询顺序 先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用 如果二级缓存没有命中，再查询一级缓存 如果一级缓存也没有命中，则查询数据库 Sqisession关闭之后，一级缓存中的数据会写入二级缓存 ","date":"2024-11-15T20:31:12+08:00","permalink":"https://Tyritic.github.io/p/mybatis%E7%BC%93%E5%AD%98/","title":"MyBatis缓存"},{"content":"Arrays类是用于对数组进行操作的工具类\n常见操作 排序 static void sort(int[] a) static \u0026lt;T\u0026gt; void sort(T[] a, Comparator\u0026lt;? super T\u0026gt; c) // 使用 Comparator 自定义排序 示例 1 2 3 4 5 6 7 int[] arr = {5, 2, 8, 1, 3}; Arrays.sort(arr); System.out.println(Arrays.toString(arr)); // 输出：[1, 2, 3, 5, 8] String[] strs = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;pear\u0026#34;}; Arrays.sort(strs, (s1, s2) -\u0026gt; s2.compareTo(s1)); // 按降序排序 System.out.println(Arrays.toString(strs)); // 输出：[pear, banana, apple] 二分查找 在已排序的数组中使用二分查找指定元素的索引。\nstatic int binarySearch(int[] a, int key) static \u0026lt;T\u0026gt; int binarySearch(T[] a, T key, Comparator\u0026lt;? super T\u0026gt; c) 示例 1 2 3 int[] arr = {1, 2, 3, 5, 8}; int index = Arrays.binarySearch(arr, 5); System.out.println(\u0026#34;元素 5 的索引：\u0026#34; + index); // 输出：元素 5 的索引：3 判断是否相等 判断两个数组是否相等（长度相同且对应元素相等）。\nstatic boolean equals(int[] a, int[] a2) static \u0026lt;T\u0026gt; boolean equals(T[] a, T[] a2) 示例 1 2 3 4 5 int[] arr1 = {1, 2, 3}; int[] arr2 = {1, 2, 3}; int[] arr3 = {1, 2, 4}; System.out.println(Arrays.equals(arr1, arr2)); // 输出：true System.out.println(Arrays.equals(arr1, arr3)); // 输出：false 判断两个多维数组是否相等\nstatic boolean deepEquals(Object[] a1, Object[] a2) 批量赋值 将数组的所有元素赋值为指定值\nstatic void fill(int[] a, int val) static \u0026lt;T\u0026gt; void fill(T[] a, T val) 示例 1 2 3 int[] arr = new int[5]; Arrays.fill(arr, 9); System.out.println(Arrays.toString(arr)); // 输出：[9, 9, 9, 9, 9] 复制数组 将指定数组复制到新的数组，返回一个新数组。\nstatic int[] copyOf(int[] original, int newLength) static \u0026lt;T\u0026gt; T[] copyOf(T[] original, int newLength) 示例 1 2 3 int[] arr = {1, 2, 3}; int[] newArr = Arrays.copyOf(arr, 5); System.out.println(Arrays.toString(newArr)); // 输出：[1, 2, 3, 0, 0] 将指定数组的某个范围复制到新的数组。\nstatic int[] copyOfRange(int[] original, int from, int to) static \u0026lt;T\u0026gt; T[] copyOfRange(T[] original, int from, int to) 示例\n1 2 3 int[] arr = {1, 2, 3, 4, 5}; int[] newArr = Arrays.copyOfRange(arr, 1, 4); // [from, to) System.out.println(Arrays.toString(newArr)); // 输出：[2, 3, 4] 数组转换为集合 static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; asList(T... a) 示例\n1 2 3 String[] strs = {\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;pear\u0026#34;}; List\u0026lt;String\u0026gt; list = Arrays.asList(strs); System.out.println(list); // 输出：[apple, banana, pear] ","date":"2024-11-15T17:32:46+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E5%B7%A5%E5%85%B7-arrays%E7%B1%BB/","title":"Java中的数组操作工具 Arrays类"},{"content":"内部类的定义 在 Java 中，**内部类（Inner Class）**是定义在另一个类内部的类。内部类可以更方便地访问外部类的成员变量和方法，同时也提升了封装性和代码的逻辑关联性。\n内部类的访问特定 内部类可以直接访问外部类的成员（包括private） 外部类要访问内部类的成员必须创建内部类对象 成员内部类 成员内部类是定义在外部类成员位置中的普通类。它与外部类的实例关联，只有在创建了外部类对象后，才能创建其内部类对象。\n特点 内部类可以直接访问外部类的私有成员。 创建内部类对象需要先创建外部类对象，再通过外部类对象创建内部类对象。 内部类中的变量可以被访问控制符和static修饰 使用格式 1 外部类.内部类 内存实现 在创建内部类对象时使用Outer.this记录外部类对象的地址值\n示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Outer { private String name = \u0026#34;OuterClass\u0026#34;; // 成员内部类 public class Inner { public void display() { System.out.println(\u0026#34;内部类访问外部类的成员: \u0026#34; + name); } } public static void main(String[] args) { Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); // 创建内部类对象 inner.display(); } } 静态内部类 静态内部类使用 static 修饰符定义，可以独立于外部类的实例进行创建\n特点 可以直接访问外部类的静态成员 不可以直接访问外部类的非静态成员,若要访问则要创建外部类对象 不存在Outer.this 语法格式 创建静态内部类对象\n1 外部类.内部类 变量名=new 外部类.内部类构造器 调用静态内部类方法的格式\n非静态方法：先创建静态内部类对象再调用 静态方法：外部类.内部类.方法名() 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Outer { private static String staticName = \u0026#34;StaticOuterClass\u0026#34;; // 静态内部类 public static class StaticInner { public void display() { System.out.println(\u0026#34;静态内部类访问外部类的静态成员: \u0026#34; + staticName); } } public static void main(String[] args) { Outer.StaticInner inner = new Outer.StaticInner(); // 直接创建静态内部类对象 inner.display(); } } 局部内部类 局部内部类是在方法或代码块中定义的类，作用域仅限于所在方法或代码块。\n特点 局部内部类的作用域仅限于定义它的方法或代码块中。 局部内部类可以访问外部类的成员以及方法中的局部变量（需要局部变量使用 final 或隐式 final 修饰）。 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Outer { public void method() { class LocalInner { public void display() { System.out.println(\u0026#34;这是局部内部类\u0026#34;); } } LocalInner inner = new LocalInner(); // 创建局部内部类对象 inner.display(); } public static void main(String[] args) { Outer outer = new Outer(); outer.method(); } } 匿名内部类 匿名内部类是没有名字的内部类，它是在定义类的同时创建该类的对象，通常用于简化代码，尤其在需要实现接口或继承抽象类时，可以避免单独定义实现类。\n本质：隐藏了名字的内部类\n使用前提：必须继承一个父类或实现一个接口\n特点 没有名字：匿名内部类在创建时定义，没有类名。\n一次性使用：匿名内部类只能使用一次，不能重复创建多个实例。\n可以继承类或实现接口：\n如果继承一个类，匿名内部类只能继承一个父类。\n如果实现一个接口，匿名内部类可以实现该接口并提供方法实现。\n与外部类关系：\n匿名内部类可以直接访问外部类的成员（包括私有成员）。\n如果匿名内部类是在局部方法中定义的，它只能访问**final**的局部变量。\n不能有构造方法：因为匿名内部类没有名字，无法定义构造方法。\n语法格式 1 2 3 new 接口名或父类名() { // 方法实现 }; Lambda表达式 Lambda 表达式是 Java 8 引入的一种新特性，旨在简化代码，特别是当使用匿名内部类实现接口时。Lambda 表达式可以理解为一种匿名函数，直接将行为（函数）作为参数传递，使代码更加简洁、可读。\n语法格式 1 (参数列表) -\u0026gt; { 方法体 } 可以用于简写匿名内部类 Lambda表达式只能简化实现函数式接口的匿名内部类\n函数式接口：有且仅有一个抽象方法的接口，被@FunctionalInterface注解\n省略规则 在参数列表中，参数类型可以省略，因为编译器会根据上下文推断参数的类型。 当 Lambda 表达式只有一个参数时，可以省略参数两边的小括号 () 当 Lambda 表达式的方法体中只有一条语句时，可以省略大括号 {}。同时，如果这条语句是 return 语句，可以省略 return 关键字。 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import java.util.Comparator; public class LambdaExample { public static void main(String[] args) { // 匿名内部类 Comparator\u0026lt;String\u0026gt; comparatorAnonymous = new Comparator\u0026lt;String\u0026gt;() { @Override public int compare(String s1, String s2) { return s1.length() - s2.length(); } }; // Lambda 表达式完整格式 Comparator\u0026lt;String\u0026gt; comparatorFull = (String s1, String s2) -\u0026gt; { return s1.length() - s2.length(); }; // Lambda 表达式省略格式 Comparator\u0026lt;String\u0026gt; comparatorSimplified = (s1, s2) -\u0026gt; s1.length() - s2.length(); // 使用匿名内部类 String resultAnonymous = max(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, comparatorAnonymous); System.out.println(\u0026#34;使用匿名内部类较长的字符串是：\u0026#34; + resultAnonymous); // 使用 Lambda 表达式完整格式 String resultFull = max(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, comparatorFull); System.out.println(\u0026#34;使用 Lambda 完整格式较长的字符串是：\u0026#34; + resultFull); // 使用 Lambda 表达式省略格式 String resultSimplified = max(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, comparatorSimplified); System.out.println(\u0026#34;使用 Lambda 省略格式较长的字符串是：\u0026#34; + resultSimplified); } // 辅助方法：根据 Comparator 返回较长的字符串 public static String max(String s1, String s2, Comparator\u0026lt;String\u0026gt; comparator) { return comparator.compare(s1, s2) \u0026gt; 0 ? s1 : s2; } } ","date":"2024-11-15T16:14:45+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB/","title":"Java中的内部类"},{"content":"JavaWeb的三大组件 Servlet Servlet是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容。\n狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。\n作用： 接收请求数据 处理请求 完成响应 使用方法 实现javax.servlet.Servlet接口； 继承javax.servlet.GenericServlet类； 继承javax.servlet.http.HttpServlet类； 工作原理 ​\tServlet接口定义了Servlet与servlet容器之间的契约。这个契约是：Servlet容器将Servlet类载入内存，并产生Servlet实例和调用它具体的方法。但是要注意的是，在一个应用程序中，每种Servlet类型只能有一个实例。\n​\t用户请求致使Servlet容器调用Servlet的Service（）方法，并传入一个ServletRequest对象和一个ServletResponse对象。ServletRequest对象和ServletResponse对象都是由Servlet容器（例如TomCat）封装好的，并不需要程序员去实现，程序员可以直接使用这两个对象。\nServletRequest中封装了当前的Http请求，因此，开发人员不必解析和操作原始的Http数据。ServletResponse表示当前用户的Http响应，程序员只需直接操作ServletResponse对象就能把响应轻松的发回给用户。 对于每一个应用程序，Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）的环境详情。每个应用程序只有一个ServletContext。每个Servlet对象也都有一个封装Servlet配置的ServletConfig对象。 生命周期 init( ),当Servlet第一次被请求时，Servlet容器就会开始调用这个方法来初始化一个Servlet对象出来，但是这个方法在后续请求中不会在被Servlet容器调用，就像人只能“出生”一次一样。我们可以利用init（ ）方法来执行相应的初始化工作。调用这个方法时，Servlet容器会传入一个ServletConfig对象进来从而对Servlet对象进行初始化。 service( )方法，每当请求Servlet时，Servlet容器就会调用这个方法。就像人一样，需要不停的接受老板的指令并且“工作”。第一次请求时，Servlet容器会先调用init( )方法初始化一个Servlet对象出来，然后会调用它的service( )方法进行工作，但在后续的请求中，Servlet容器只会调用service方法了。 destory,当要销毁Servlet时，Servlet容器就会调用这个方法，就如人一样，到时期了就得死亡。在卸载应用程序或者关闭Servlet容器时，就会发生这种情况，一般在这个方法中会写一些清除代码。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class MyFirstServlrt implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { System.out.println(\u0026#34;Servlet正在初始化\u0026#34;); } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { //专门向客服端提供响应的方法 System.out.println(\u0026#34;Servlet正在提供服务\u0026#34;); } @Override public String getServletInfo() { return null; } @Override public void destroy() { System.out.println(\u0026#34;Servlet正在销毁\u0026#34;); } } ServletRequest接口 Servlet容器对于接受到的每一个Http请求，都会创建一个ServletRequest对象，并把这个对象传递给Servlet的Sevice( )方法。其中，ServletRequest对象内封装了关于这个请求的许多详细信息。\n1 2 3 4 5 6 7 8 9 public interface ServletRequest { int getContentLength();//返回请求主体的字节数 String getContentType();//返回主体的MIME类型 String getParameter(String var1);//返回请求参数的值 } ServletResponse接口 javax.servlet.ServletResponse接口表示一个Servlet响应，在调用Servlet的Service( )方法前，Servlet容器会先创建一个ServletResponse对象，并把它作为第二个参数传给Service( )方法。ServletResponse隐藏了向浏览器发送响应的复杂过程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public interface ServletResponse { String getCharacterEncoding(); String getContentType(); ServletOutputStream getOutputStream() throws IOException; PrintWriter getWriter() throws IOException; void setCharacterEncoding(String var1); void setContentLength(int var1); void setContentType(String var1); //在发送任何HTML之前，应该先调用setContentType（）方法，设置响应的内容类型，并将“text/html”作为一个参数传入，这是在告诉浏览器响应的内容类型为HTML，需要以HTML的方法解释响应内容而不是普通的文本，或者也可以加上“charset=UTF-8”改变响应的编码方式以防止发生中文乱码现象。 void setBufferSize(int var1); int getBufferSize(); void flushBuffer() throws IOException; void resetBuffer(); boolean isCommitted(); void reset(); void setLocale(Locale var1); Locale getLocale(); } HttpServlet抽象类 HttpServlet抽象类是继承于GenericServlet抽象类而来的。使用HttpServlet抽象类时，还需要借助分别代表Servlet请求和Servlet响应的HttpServletRequest和HttpServletResponse对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doPut(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } protected void doDelete(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } HttpServletRequest接口 HttpServletRequest表示Http环境中的Servlet请求。它扩展于javax.servlet.ServletRequest接口，并添加了几个方法。\n获取请求的相关数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 String getContextPath();//返回请求上下文的请求URI部分 Cookie[] getCookies();//返回一个cookie对象数组 String getHeader(String var1);//返回指定HTTP标题的值 String getMethod();//返回生成这个请求HTTP的方法名称 String getQueryString();//返回请求URL中的查询字符串 HttpSession getSession();//返回与这个请求相关的会话对象 String getRequestURI(); StringBuffer getRequestURL(); String[] getParameterValues(String name); //获得如checkbox类（名字相同，但值有多个）的数据。 接收数组变量 String getParameter(String name)； //获得相应名的数据，如果有重复的参数名，则返回第一个的值 HttpServletResponse接口 在Service API中，定义了一个HttpServletResponse接口，它继承自ServletResponse接口，专门用来封装HTTP响应消息。 由于HTTP请求消息分为状态行，响应消息头，响应消息体三部分，因此，在HttpServletResponse接口中定义了向客户端发送响应状态码，响应消息头，响应消息体的方法。\n设置响应的相关数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void addCookie(Cookie var1);//给这个响应添加一个cookie void addHeader(String var1, String var2);//给这个请求添加一个响应头 void sendRedirect(String var1) throws IOException;//发送一条响应码，讲浏览器跳转到指定的位置 void setStatus(int var1);//设置响应行的状态码 void addHeader(String name, String value);//添加响应头 void addIntHeader(String name, int value) void addDateHeader(String name, long date) void setHeader(String name, String value) void setDateHeader(String name, long date) void setIntHeader(String name, int value) PrintWriter getWriter();//获得字符流，通过字符流的write(String s)方法可以将字符串设置到response 缓冲区中，随后Tomcat会将response缓冲区中的内容组装成Http响应返回给浏览器端。 ServletOutputStream getOutputStream();//获得字节流，通过该字节流的write(byte[] bytes)可以向response缓冲区中写入字节，再由Tomcat服务器将字节内容组成Http响应返回给浏览器。 Filter 参见先前博客 Filter\nListener 概述 ​\t监听器就是监听某个对象的状态变化的组件，监听web应用中某些对象、信息的创建、销毁、增加，修改，删除等动作的发生，然后作出相应的响应处理\n具体实现 实现ServletContextListener接口\n1 2 3 4 5 6 7 8 9 10 public class MyListener implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent sce){ System.out.println(\u0026#34;Servlet上下文---\u0026gt;当前web项目启动\u0026#34;); } @Override public void contextDestroyed(ServletContextEvent sce){ System.out.println(\u0026#34;当前类销毁\u0026#34;); } } 注册Listenner监听器\nSpringBoot对三大组件的集成 SpringBoot中内嵌的Servlet容器是Tomcat服务器\n嵌入式Servlet容器配置修改 方法一：通过全局配置文件Application.yml修改\n可以通过server.xxx 来进行web服务配置， 没有带服务器名称的则是通用配置,通过带了具体的服务器名称则是单独对该服务器进行设置，比如server.tomcat.xxx 就是专门针对tomcat的配置,具体配置参见SpringBoot官方文档\n1 2 3 server: port: 8080 tomcat: 方法二：通过注册一个实现 WebServerFactoryCustomizer 接口的Spring Bean\n1 2 3 4 5 6 7 8 9 10 11 12 13 import org.springframework.boot.web.server.WebServerFactoryCustomizer; import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory; import org.springframework.stereotype.Component; @Component public class MyWebServerFactoryCustomizer implements WebServerFactoryCustomizer\u0026lt;ConfigurableServletWebServerFactory\u0026gt; { @Override public void customize(ConfigurableServletWebServerFactory server) { server.setPort(9000); } } 修改server.xxx 配置的相关内容 会跟配置文件形成互补 三大组件的注册 方法一：servlet3.0规范提供的注解方式注册\n在组件的实现类使用提供的注解注册\n1 2 3 4 5 6 7 8 @WebServlet(name=\u0026#34;HelloServlet\u0026#34;,urlPatterns = \u0026#34;/HelloServlet\u0026#34;) public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { PrintWriter writer = resp.getWriter(); writer.println(\u0026#34;hello servlet!\u0026#34;); } } @WebServlet @WebListener @WebFilter 在SpringBoot启动类上添加注解@ServletComponentScan\n1 2 3 4 5 6 7 @SpringBootApplication @ServletComponentScan public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } }\t方法二：SpringBoot提供的注册方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package com.hzl.boot.config.filter; import org.springframework.boot.web.servlet.FilterRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.servlet.Filter; /** * @description * @create: 2024-09-23 22:25 **/ @Configuration public class FilterRegistrationDemo { @Bean public FilterRegistrationBean filterRegistrationBean(){ FilterRegistrationBean\u0026lt;Filter\u0026gt; registrationBean = new FilterRegistrationBean\u0026lt;\u0026gt;(); // 设置自己的过滤器 registrationBean.setFilter(new MyFilter()); // 设置自定义的拦截规则 registrationBean.addUrlPatterns(\u0026#34;/*\u0026#34;); // 设置拦截器的顺序 registrationBean.setOrder(1); return registrationBean; } } ServletRegistrationBean FilterRegistrationBean ServletListenerRegistrationBean 切换内嵌Servlet容器 SpringBoot包含了对Tomcat,Jetty（Socket)等服务器的支持\n通过修改pom.xml的依赖即可排除相关依赖并添加相关依赖即可\n排除原有的tomcat依赖\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring‐boot‐starter‐web\u0026lt;/artifactId\u0026gt; \u0026lt;!‐‐1.排除tomcat‐‐\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;spring‐boot‐starter‐tomcat\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 引入相关依赖\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!‐‐2.依赖jetty --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;artifactId\u0026gt;spring‐boot‐starter‐jetty\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!‐‐3.依赖undertow ‐‐\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;artifactId\u0026gt;spring‐boot‐starter‐undertow\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;/dependency\u0026gt; ","date":"2024-11-15T15:55:52+08:00","permalink":"https://Tyritic.github.io/p/springboot%E4%B8%AD%E7%9A%84%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6/","title":"SpringBoot中的三大组件"},{"content":"接口的定义 接口 (Interface) 是 Java 中一种特殊的引用类型，类似于类，但是接口只定义方法的签名，而不包含方法的实现。接口用于定义类应该遵循的行为规范，即一组方法的集合，而具体的实现由实现接口的类来完成。\n可以理解为特殊的类，接口的所有字段为public static final，不包含构造方法，成员方法中除了默认方法 (default methods) 和**静态方法 (static methods)**以外都是抽象方法\n接口的主要特点 接口无法实例化，不存在构造方法 接口的实现类要么是抽象类，要么实现接口中全部的抽象方法 接口允许多实现（一个实现类同时实现多个接口） 在 Java8 之前接口是无法定义具体方法实现的，所以即使有多个接口必须子类自己实现，所以并不会发生歧义。 Java8 之后出了默认方法（default method），该方法具有方法体，为了避免菱形继承的问题，强制规定，如果多个接口内有相同的默认方法，子类必须重写这个方法。 接口允许多继承 不要在定义接口的时候使用 final 关键字 接口的语法实现 定义接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 接口定义 public interface InterfaceName { // 常量（隐式 public static final） int CONSTANT_VALUE = 100; // 抽象方法（隐式 public abstract） void method1(); // 默认方法（Java 8 引入） default void defaultMethod() { System.out.println(\u0026#34;This is a default method.\u0026#34;); } // 静态方法（Java 8 引入） static void staticMethod() { System.out.println(\u0026#34;This is a static method.\u0026#34;); } } 实现接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 实现接口的类 public class MyClass implements InterfaceName { // 实现接口中的抽象方法 @Override public void method1() { System.out.println(\u0026#34;Method1 implemented in MyClass.\u0026#34;); } // 实现接口中的默认方法（可选） @Override public void defaultMethod(){ // 重写该方法 } } 接口中的变量 接口中的变量默认为public static final 接口中定义的变量会在编译的时候自动加上 public static final 修饰符 接口中的方法 抽象方法 抽象方法是接口的核心部分，所有实现接口的类都必须实现这些方法。接口中的方法默认为public abstract（没有使用 private、default 或者 static 关键字修饰的方法是隐式抽象的，在编译的时候会自动加上 public abstract 修饰符）\n注意事项 接口的抽象方法不能是 private、protected 或者 final 默认方法 接口中允许定义默认方法，默认方法被default修饰，必须具有方法体可供实现类使用或者重写，为实现该接口而不覆盖该方法的类提供默认实现\n定义格式 1 public default 返回值类型 方法名(形参列表){} 注意事项 默认方法可以被子接口继承 default方法不需要被强制重写 如果子类没有重写接口中的默认方法，那么会直接使用接口中提供的默认实现 若子类重写了默认方法，要去除该方法中的default关键字 public可以省略 不能通过接口名调用 如果子类实现了多个接口且多个接口内有相同的默认方法，子类必须重写这个方法。 静态方法 属于接口本身的方法，具有方法体，不依赖具体的实现类就能调用\n定义格式 1 public static 返回值类型 方法名(形参列表){} 调用格式 1 接口名.静态方法名() 私有方法 Java 9 引入了 接口私有方法，允许在接口中定义只能供默认方法和静态方法调用的私有辅助方法。这进一步增强了接口的灵活性和代码复用能力，同时隐藏了实现细节。\n方法类型 实例私有方法\n只能被默认方法调用。 不能被实现类调用，也不能被接口外部访问。 使用 private 关键字修饰。 静态私有方法\n只能被静态方法调用。 不能被默认方法或实现类调用。 接口的使用 作为变量类型 在 Java 中，接口不仅可以定义方法的签名，还可以作为 类型的约束，使得不同的类能够遵循相同的行为约定。\n在 Java 中，所有的类、接口、数组和枚举类型都被视为引用类型。接口定义了类应该具备的方法签名，但它本身不能直接创建实例。实际上，接口是用于为类定义一个“行为契约”的类型。接口可以作为变量类型，来指向那些实现了该接口的类的实例。\n多态性 Java 中的接口支持 多态性，这意味着一个接口类型的变量可以指向任何实现该接口的对象，哪怕是不同类的对象。因此，作为接口类型的变量，可以引用任何实现了接口的对象，而无需关心具体是哪一个类。\n接口和抽象类的区别 参考博客\n常见接口 Comparable接口 Comparable 接口是 Java 提供的一个用于定义对象自然排序的接口。它位于 java.lang 包中，常用于让类的对象能够通过 Collections.sort() 或 Arrays.sort() 方法进行排序。\n接口定义\n1 2 3 public interface Comparable\u0026lt;E\u0026gt; { public int compareTo(E o); } 接口使用\n让实现类实现该接口中的compareTo方法，返回值如下\n返回负值：当前对象小于参数对象 o。\n返回零值：当前对象等于参数对象 o。\n返回正值：当前对象大于参数对象 o。\n升序：当当前对象小于参数对象时，compareTo 返回负值。\n降序：当当前对象小于参数对象时，compareTo 返回正值。\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Person implements Comparable\u0026lt;Person\u0026gt; { private String name; private int age; // 构造方法 public Person(String name, int age) { this.name = name; this.age = age; } // 实现 compareTo 方法，按年龄升序排序 @Override public int compareTo(Person other) { return this.age - other.age; } // 重写 toString 方法，方便打印 @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } 缺点：需要在类定义时就要实现\nComparator接口 Comparator 是 Java 提供的一个用于定义对象自定义排序的接口，位于 java.util 包中。与 Comparable 接口不同，Comparator 可以让我们在不修改类本身代码的情况下，通过外部比较器灵活定义多种排序规则。\nComparator接口支持多排序规则：可以为同一类对象定义多种不同的排序规则，而不需要修改类本身。\n核心方法： compare\n1 int compare(T o1, T o2); 返回负值：当前对象o1小于参数对象 o2。\n返回零值：当前对象o1等于参数对象 o2。\n返回正值：当前对象o1大于参数对象 o2。\n升序：当当前对象小于参数对象时，compare 返回负值。\n降序：当当前对象小于参数对象时，compare 返回正值。\n使用方法\n声明一个比较器类实现Comparator接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 比较器类 import java.util.Comparator; public class AgeComparator implements Comparator\u0026lt;Person\u0026gt; { @Override public int compare(Person p1, Person p2) { return p1.getAge() - p2.getAge(); } } // 测试代码 import java.util.ArrayList; import java.util.Collections; import java.util.List; public class Test { public static void main(String[] args) { List\u0026lt;Person\u0026gt; people = new ArrayList\u0026lt;\u0026gt;(); people.add(new Person(\u0026#34;Alice\u0026#34;, 25)); people.add(new Person(\u0026#34;Bob\u0026#34;, 20)); people.add(new Person(\u0026#34;Charlie\u0026#34;, 30)); // 使用 AgeComparator 进行排序 Collections.sort(people, new AgeComparator()); // 输出排序结果 for (Person p : people) { System.out.println(p); } } } 在Collections.sort 或 Arrays.sort 方法，通过传入 Comparator 对象（匿名内部类）来进行排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import java.util.*; public class Test { public static void main(String[] args) { List\u0026lt;Person\u0026gt; people = new ArrayList\u0026lt;\u0026gt;(); people.add(new Person(\u0026#34;Alice\u0026#34;, 25)); people.add(new Person(\u0026#34;Bob\u0026#34;, 20)); people.add(new Person(\u0026#34;Charlie\u0026#34;, 30)); // 使用匿名内部类按年龄排序 Collections.sort(people, new Comparator\u0026lt;Person\u0026gt;() { @Override public int compare(Person p1, Person p2) { return p1.getAge() - p2.getAge(); } }); System.out.println(\u0026#34;按年龄排序：\u0026#34; + people); } } 其他方法\ncomparing(Function\u0026lt;T, U\u0026gt; keyExtractor)\t按指定字段升序排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import java.util.*; public class Test { public static void main(String[] args) { List\u0026lt;Person\u0026gt; people = Arrays.asList( new Person(\u0026#34;Alice\u0026#34;, 25), new Person(\u0026#34;Bob\u0026#34;, 20), new Person(\u0026#34;Charlie\u0026#34;, 30) ); // 按年龄升序排序 people.sort(Comparator.comparing(Person::getAge)); System.out.println(\u0026#34;按年龄升序排序：\u0026#34; + people); } } class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } reversed()\t将当前排序顺序反转\n1 2 people.sort(Comparator.comparing(Person::getAge).reversed()); System.out.println(\u0026#34;按年龄降序排序：\u0026#34; + people); thenComparing()\t在已有排序规则基础上追加新的排序规则\n1 2 people.sort(Comparator.comparing(Person::getAge).thenComparing(Person::getName)); System.out.println(\u0026#34;按年龄排序后再按姓名排序：\u0026#34; + people); naturalOrder()\t生成按自然顺序排序的 Comparator\n1 2 3 List\u0026lt;String\u0026gt; names = Arrays.asList(\u0026#34;Charlie\u0026#34;, \u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;); names.sort(Comparator.naturalOrder()); System.out.println(\u0026#34;按自然顺序排序：\u0026#34; + names); reverseOrder()\t生成按自然顺序的反序排序 Comparator\n1 2 names.sort(Comparator.reverseOrder()); System.out.println(\u0026#34;按降序排序：\u0026#34; + names); nullsFirst()\t处理 null 值，null 排在前面\nnullsLast()\t处理 null 值，null 排在后面\nCloneable接口 Cloneable 接口是 Java 中的一个标记接口（Marker Interface），它位于 java.lang 包中。实现了 Cloneable 接口的类表示该类的对象可以使用 Object 类的 clone() 方法进行浅拷贝。\n深拷贝和浅拷贝 深拷贝：在复制对象的同时，将对象内部的所有引用类型字段的内容也复制一份，而不是共享引用。换句话说，深拷贝会递归复制对象内部所有引用类型的字段，生成一个全新的对象以及其内部的所有对象。\n浅拷贝：只复制对象本身和其内部的值类型字段，但不会复制对象内部的引用类型字段。换句话说，浅拷贝只是创建一个新的对象，然后将原对象的字段值复制到新对象中，但如果原对象内部有引用类型的字段，只是将引用复制到新对象中，两个对象指向的是同一个引用对象。\n浅拷贝的实现方式 使用 Object.clone() 方法是浅拷贝的常见方式。默认情况下，clone() 方法只是对对象的字段进行字段拷贝，对于基本类型的字段会复制值，对于引用类型的字段则复制引用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import java.util.*; public class Person implements Cloneable { private String name; private List\u0026lt;String\u0026gt; hobbies; public Person(String name, List\u0026lt;String\u0026gt; hobbies) { this.name = name; this.hobbies = hobbies; } @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, hobbies=\u0026#34; + hobbies + \u0026#39;}\u0026#39;; } @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); // 浅拷贝 } public static void main(String[] args) { try { List\u0026lt;String\u0026gt; hobbies = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;Reading\u0026#34;, \u0026#34;Traveling\u0026#34;)); Person p1 = new Person(\u0026#34;Alice\u0026#34;, hobbies); Person p2 = (Person) p1.clone(); System.out.println(\u0026#34;原对象：\u0026#34; + p1); System.out.println(\u0026#34;克隆对象：\u0026#34; + p2); // 修改原对象的 hobbies p1.hobbies.add(\u0026#34;Swimming\u0026#34;); // 查看克隆对象的 hobbies 是否也发生了变化 System.out.println(\u0026#34;修改后的原对象：\u0026#34; + p1); System.out.println(\u0026#34;修改后的克隆对象：\u0026#34; + p2); } catch (CloneNotSupportedException e) { e.printStackTrace(); } } } // 输出结果 // 原对象：Person{name=\u0026#39;Alice\u0026#39;, hobbies=[Reading, Traveling]} // 克隆对象：Person{name=\u0026#39;Alice\u0026#39;, hobbies=[Reading, Traveling]} // 修改后的原对象：Person{name=\u0026#39;Alice\u0026#39;, hobbies=[Reading, Traveling, Swimming]} // 修改后的克隆对象：Person{name=\u0026#39;Alice\u0026#39;, hobbies=[Reading, Traveling, Swimming]} 深拷贝的实现方式 实现 Cloneable 接口并重写 clone() 方法\n要求对象及其所有引用类型字段都实现 Cloneable 接口，并且重写 clone() 方法。在 clone() 方法中，通过递归克隆引用类型字段来实现深拷贝。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Address implements Cloneable { String city; public Address(String city) { this.city = city; } @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); // 浅拷贝 } } class Person implements Cloneable { String name; int age; Address address; public Person(String name, int age, Address address) { this.name = name; this.age = age; this.address = address; } @Override protected Object clone() throws CloneNotSupportedException { Person cloned = (Person) super.clone(); // 创建了一个浅拷贝的 Person 对象 cloned，此时 cloned 中的 address 引用与原始 Person 对象的 address 引用指向同一个 Address 对象。 cloned.address = (Address) address.clone(); // address 是当前对象（this）中的 Address 字段，调用 address.clone() 会对这个 Address 对象进行克隆，生成一个新的 Address 对象 return cloned; } } 手动递归复制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Person { String name; int age; Address address; public Person(String name, int age, Address address) { this.name = name; this.age = age; this.address = address; } // 手动复制字段 public Person(Person person) { this.name = person.name; this.age = person.age; this.address = new Address(person.address.city); } } class Address { String city; public Address(String city) { this.city = city; } } public class Main { public static void main(String[] args) { Address address = new Address(\u0026#34;河南省洛阳市\u0026#34;); Person person1 = new Person(\u0026#34;王二\u0026#34;, 18, address); Person person2 = new Person(person1); System.out.println(person1.address == person2.address); // false } } 序列号和反序列化的方式\n通过将对象序列化为字节流，再从字节流反序列化为对象来实现深拷贝。要求对象及其所有引用类型字段都实现 Serializable 接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import java.io.*; // Address 类实现 Serializable 接口 class Address implements Serializable { private static final long serialVersionUID = 1L; String city; public Address(String city) { this.city = city; } @Override public String toString() { return \u0026#34;Address{city=\u0026#39;\u0026#34; + city + \u0026#34;\u0026#39;}\u0026#34;; } } // Person 类实现 Serializable 接口 class Person implements Serializable { private static final long serialVersionUID = 1L; String name; int age; Address address; public Person(String name, int age, Address address) { this.name = name; this.age = age; this.address = address; } // 使用序列化和反序列化来实现深拷贝 public Person deepClone() throws IOException, ClassNotFoundException { // 序列化 ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); // 将当前对象写入字节流 // 反序列化 ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return (Person) ois.readObject(); // 从字节流中读取对象 } @Override public String toString() { return \u0026#34;Person{name=\u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;, age=\u0026#34; + age + \u0026#34;, address=\u0026#34; + address + \u0026#34;}\u0026#34;; } } public class DeepCopyDemo { public static void main(String[] args) throws IOException, ClassNotFoundException { // 创建原始对象 Address address = new Address(\u0026#34;New York\u0026#34;); Person person1 = new Person(\u0026#34;Alice\u0026#34;, 25, address); // 深拷贝 Person person2 = person1.deepClone(); // 修改原始对象的地址字段 person1.address.city = \u0026#34;Los Angeles\u0026#34;; // 输出两个对象 System.out.println(\u0026#34;原始对象: \u0026#34; + person1); System.out.println(\u0026#34;深拷贝对象: \u0026#34; + person2); } } ","date":"2024-11-15T10:46:39+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3/","title":"Java中的接口"},{"content":"抽象方法 定义 抽象方法是没有方法体的方法。它只是声明了方法的签名（方法名、返回类型、参数），而没有提供具体的实现。抽象方法只能出现在抽象类中，且必须由子类实现。\n特点 没有方法体： 抽象方法只定义方法的签名，没有具体实现。 必须由子类实现： 如果一个类继承了抽象类，必须实现抽象类中的所有抽象方法，除非子类本身也是抽象类。 语法格式 1 2 3 abstract class ClassName { abstract void methodName(); } 抽象类 定义 抽象类是一个不能直接实例化的类，通常包含抽象方法（未实现的方法）和已实现的方法。抽象类作为其他类的父类，提供通用的接口和功能，而让子类去实现和完善。\n特点： 不能实例化： 你不能直接创建抽象类的对象，只能通过其子类来实例化。\n可以有抽象方法和非抽象方法：\n抽象类可以包含抽象方法（没有方法体的方法），也可以包含已实现的方法（有方法体的普通方法）。 抽象类的子类必须实现所有抽象方法，除非子类本身也是抽象类。 抽象类不一定包含抽象方法，但是有抽象方法的一定是抽象类 构造方法： 抽象类可以有构造方法，构造方法可以被子类调用，用于初始化父类的成员变量。\n可以有字段（成员变量）： 抽象类可以定义实例字段（成员变量）和静态字段。\n可以实现接口： 抽象类可以实现接口，因此也可以被用于约定子类需要实现的接口方法。\n抽象类不能被final修饰：\nJava中的抽象类是用来被继承的，而final修饰符用于禁止类被继承或方法被重写，因此，抽象类和final修饰符是互斥的，不能同时使用。\n语法格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 abstract class ClassName { // 抽象方法（没有方法体） abstract void abstractMethod(); // 非抽象方法（有方法体） void concreteMethod() { System.out.println(\u0026#34;This is a concrete method.\u0026#34;); } // 可以有构造方法 public ClassName() { System.out.println(\u0026#34;Abstract class constructor.\u0026#34;); } } ","date":"2024-11-15T10:21:43+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/","title":"Java中的抽象类和抽象方法"},{"content":"局部代码块 定义 局部代码块 是 Java 中一种由一对大括号 {} 包裹的代码块，通常用于限制变量的作用域，或者在某些情况下提供代码逻辑的分隔。\n特点 作用域限制：局部代码块中的变量只在代码块内有效，代码块外不可访问，因此可以避免变量命名冲突，增强代码的可读性和可维护性。 不影响程序的控制流：局部代码块只是对代码逻辑的封装，不会改变程序的控制流。它通常是为了作用域控制或某些资源的临时管理。 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Test { public static void main(String[] args) { int x = 10; // 局部代码块 { int y = 20; // y的作用域仅限于该局部代码块 System.out.println(\u0026#34;x = \u0026#34; + x); // 可以访问外部的x System.out.println(\u0026#34;y = \u0026#34; + y); // 可以访问该代码块内定义的y } // System.out.println(\u0026#34;y = \u0026#34; + y); // 编译错误，y超出了作用域 } } 构造代码块 定义 构造代码块 是 Java 类中的一块独立代码，由一对大括号 {} 包裹，直接定义在类中，不属于任何方法或构造方法。当创建类的对象时，构造代码块会在每次调用构造方法前自动执行。\n构造代码块的作用是将一些对象的公共初始化逻辑集中起来，避免在每个构造方法中重复编写相同的代码。\n特点 构造代码块的书写位置在类的定义中，用于收集构造函数中的公共逻辑 类实例化的时候执行构造代码块，而且构造代码块内的逻辑在构造方法内的逻辑执行之前执行 代码初始化块里的执行顺序是从前到后的 构造代码块的实现原理 对象在初始化的时候会先调用构造方法，构造方法在执行的时候会把代码初始化块放在构造方法中其他代码之前\n静态代码块 定义 静态代码块（Static Block）是 Java 中的一种特殊代码块，它用于在类加载时执行一次初始化操作。静态代码块由 static 关键字修饰，通常用于初始化类的静态变量，或者执行一些静态资源的初始化工作。\n特点 只在类加载时执行一次： 静态代码块在类第一次被加载到内存时执行，不依赖于类的对象实例化。 在构造函数之前执行： 类的构造函数在对象创建时执行，而静态代码块在类加载时就执行，因此它会先于任何构造函数或实例方法执行。 可以访问类的静态成员： 静态代码块可以访问类的静态变量和静态方法，但不能访问实例变量和实例方法，因为此时类的实例尚未创建。 执行顺序： 如果类中有多个静态代码块，它们会按照定义的顺序依次执行。 只有类第一次被加载时执行： 静态代码块不会在每次创建类的对象时执行，只会在类加载进 JVM 时执行一次。 语法格式 1 2 3 4 5 class ClassName { static { // 静态代码块中的初始化代码 } } 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 public class Example { // 静态变量 public static int staticVar = 1; // 实例变量 public int instanceVar = 2; // 静态初始化块 static { System.out.println(\u0026#34;执行静态初始化块\u0026#34;); staticVar = 3; } // 实例初始化块 { System.out.println(\u0026#34;执行实例初始化块\u0026#34;); instanceVar = 4; } // 构造方法 public Example() { System.out.println(\u0026#34;执行构造方法\u0026#34;); } public static void main(String[] args) { System.out.println(\u0026#34;执行main方法\u0026#34;); Example e1 = new Example(); Example e2 = new Example(); System.out.println(\u0026#34;e1的静态变量：\u0026#34; + e1.staticVar); System.out.println(\u0026#34;e1的实例变量：\u0026#34; + e1.instanceVar); System.out.println(\u0026#34;e2的静态变量：\u0026#34; + e2.staticVar); System.out.println(\u0026#34;e2的实例变量：\u0026#34; + e2.instanceVar); } } //执行结果 // 执行静态初始化块 // 执行main方法 // 执行实例初始化块 // 执行构造方法 // 执行实例初始化块 // 执行构造方法 // e1的静态变量：3 // e1的实例变量：4 // e2的静态变量：3 // e2的实例变量：4 ","date":"2024-11-15T09:35:34+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97/","title":"Java中的代码块"},{"content":"作用 final关键字用于修饰不可被改变的变量/方法\n修饰方式 方法：被final修饰的方法不能被继承，同时也意味着不能被重写 类：被final修饰的类无法被继承 变量：表明这个变量是常量，只能被赋值一次 修饰基本数据类型则变量存储的数值不变 修饰引用数据类型则变量存储的地址值不变，但是对象的属性可以改变 ","date":"2024-11-14T23:16:07+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84final%E5%85%B3%E9%94%AE%E5%AD%97/","title":"Java中的final关键字"},{"content":"什么是封装 封装是指利用抽象将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。\n数据被保护在类的内部，尽可能地隐藏内部的实现细节，只保留一些对外接口使之与外部发生联系。\n其他对象只能通过已经授权的操作来与这个封装的对象进行交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。\n基本概念 数据隐藏：通过将类的字段（成员变量）声明为 private 或 protected，避免直接被外部访问。只有通过类提供的公共方法（如 getter 和 setter）才能访问和修改这些字段。 公共接口：通过公共方法（如 getter 和 setter）提供访问对象数据的方式。这样可以对数据进行控制和验证，确保数据的一致性和合法性。 保护数据：封装通过限制对数据的直接访问，减少了对对象状态的不安全修改和潜在的错误。 优势 数据保护：通过隐藏数据和提供受控的访问方法，可以防止外部代码对数据进行不合法的修改。 维护性：封装使得对象的内部实现与外部接口分离，可以更容易地对内部实现进行更改，而不影响外部使用者。 简化接口：提供简洁的公共接口，减少外部代码对类的复杂性理解，从而降低系统的耦合度。 代码复用：通过封装，类可以重用已有的功能而不必重新实现，有助于构建模块化和可维护的代码。 ","date":"2024-11-14T23:02:48+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%B0%81%E8%A3%85/","title":"Java中的封装"},{"content":"什么是多态 多态是指同一个接口或父类引用变量可以指向不同的对象实例，并根据实际指向的对象类型执行相应的方法。\n它允许同一方法在不同对象上表现出不同的行为，是面向对象编程（OOP）的核心特性之一\n多态的前提条件 子类继承父类 子类重写父类的方法 父类引用指向子类的对象 语法格式\n1 father_className father=new son_className () 多态的运行特点 调用成员变量 遵守规则：编译看声明类型（左边），运行看声明类型（左边）\n编译代码时，会看左边的父类中有没有该变量，若不存在该变量则编译失败\n运行代码时，实际获取的是左边父类中成员变量的值\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Parent { public int num = 10; } class Child extends Parent { public int num = 20; } public class Test { public static void main(String[] args) { Parent obj = new Child(); // 左边是Parent类型，右边是Child类型 System.out.println(\u0026#34;num = \u0026#34; + obj.num); // 访问属性 } } // 输出：num = 10 调用成员方法 遵守规则：编译看声明类型（左边），运行看实际类型（右边）\n编译代码时，会看左边的父类中有没有该方法，若不存在该方法则编译失败\n运行代码时，实际执行的是右边父子中成员方法\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Parent { public void show() { System.out.println(\u0026#34;Parent的show方法\u0026#34;); } } class Child extends Parent { @Override public void show() { System.out.println(\u0026#34;Child的show方法\u0026#34;); } } public class Test { public static void main(String[] args) { Parent obj = new Child(); // 左边是Parent类型，右边是Child类型 obj.show(); // 调用show方法 } } // 输出：Child的show方法 多态的实现原理 动态绑定 多态通过动态绑定实现，Java 使用虚方法表存储方法指针，方法调用时根据对象实际类型从虚方法表查找具体实现。\n多态的实现方式 编译时多态和运行时多态是面向对象编程中多态性的两种实现方式，它们分别在不同的阶段决定方法的绑定。\n编译时多态：通过方法重载实现，在编译时确定方法的调用。 运行时多态：通过方法重写实现，在运行时确定方法的调用。 编译时多态（Compile-time Polymorphism） 编译时多态，也称为静态多态，是在编译阶段确定方法的调用。编译时多态主要通过 方法重载（Method Overloading） 实现。\n方法重载：指在同一个类中定义多个方法，这些方法的名称相同但参数列表（参数的类型或数量）不同。Java 编译器在编译时会根据方法调用时传入的参数类型和数量，决定调用哪一个重载方法。\n运行时多态（Runtime Polymorphism） 运行时多态，也称为动态多态，是在运行时确定方法的调用。运行时多态通过 方法重写（Method Overriding） 实现。\n方法重写：子类重写父类的一个或多个方法。通过父类引用调用方法时，实际执行的是子类重写后的方法。这种多态性是在运行时根据对象的实际类型决定的。\n向上转型和向下转型 向上转型（儿子变父亲） 向上转型是使用父类类型的引用指向子类对象，通过子类对象(小范围)实例化父类对象(大范围)\n父类引用变量指向子类对象后，只能使用父类已声明的方法，但方法如果被重写会执行子类的方法，如果方法未被重写那么将执行父类的方法。\n语法格式\n1 2 3 father_className father=new son_className () // 声明类型：father_className // 实际类型：son_className 向下转型（父亲变儿子） 向下转型是将父类引用转回其子类类型，通过父类对象(大范围)实例化子类对象(小范围)，但在执行前需要确认父类引用变量实际引用必须是子类对象才能成功转型以避免 ClassCastException\n向下转型允许我们通过父类引用访问子类特有的方法和属性\n语法格式 1 son_className son=(son_className) father 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Animal { public void makeSound() { System.out.println(\u0026#34;Animal makes a sound\u0026#34;); } } class Dog extends Animal { public void makeSound() { System.out.println(\u0026#34;Dog barks\u0026#34;); } public void wagTail() { System.out.println(\u0026#34;Dog wags its tail\u0026#34;); } } public class Test { public static void main(String[] args) { Animal animal = new Dog(); // 向上转型，父类引用指向子类对象 animal.makeSound(); // 调用子类重写的方法，输出：Dog barks // 向下转型，将Animal引用强制转换为Dog类型 if (animal instanceof Dog) { Dog dog = (Dog) animal; dog.wagTail(); // 输出：Dog wags its tail } else { System.out.println(\u0026#34;animal 不是 Dog 类型\u0026#34;); } Animal animal = new Cat(); // Animal引用指向Cat对象 // 强制将Cat对象转为Dog类型，会引发ClassCastException Dog dog = (Dog) animal; dog.makeSound(); } } instance of关键字 判断对象是否符合指定的类型，结果要么是 true，要么是 false\n语法格式\n1 2 3 4 5 6 (object) instanceof (className) // JDK16的新用法 if (obj instanceof String s) { // 如果类型匹配 直接使用 s } 判定为true的条件\nobject 是 ClassName 类型或其子类（或实现类）的对象 ClassName 是 object 实现的接口。 无论右边的类型是什么，null 对象总是返回 false。即：null instanceof SomeClass // 结果为 false\n","date":"2024-11-14T22:00:32+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81/","title":"Java中的多态"},{"content":"继承的定义 继承（inheritance）是面向对象中的一个概念。它使得复用以前的代码非常容易。\n在 Java 语言中继承就是子类继承父类的属性和方法，使得子类对象（实例）具有父类的属性和方法，或子类从父类继承方法，使得子类具有父类相同的方法。\n继承的优缺点 优点：\n代码复用：子类可以复用父类的代码，减少重复实现。 易于维护：可以通过修改父类代码来影响所有子类。 缺点：\n紧耦合：子类依赖于父类的实现，父类的修改可能会影响子类。 灵活性差：继承层次结构可能会变得复杂，不易于调整或扩展。 继承的特点 Java不允许多重继承（一个子类同时继承多个父类）但是支持多层继承，一个类只能继承一个父类 Object类是所有类中的公共父类 继承当中子类抛出的异常必须是父类抛出的异常或父类抛出异常的子异常 子类可以继承父类的部分属性和方法 继承的语法实现 1 class 子类名 extends 父类名{} 子类继承的内容 父类的所有属性 子类继承父类的所有的属性（但是被private修饰的变量被隐藏无法直接使用）\n如果要使用父类的private属性可以通过父类的getter方法和setter方法\n父类的构造方法不能被继承 父类的构造方法不能被子类继承：因为构造方法语法是与类同名，而继承则不更改方法名，如果子类继承父类的构造方法，那明显与构造方法的语法冲突了。\n成员方法（虚方法） 方法传递机制 Java虚拟机从最顶级的父类开始设置虚方法表，父类会将虚方法表传递给自己的子类，然后在父类的虚方法表的基础上添加自己的虚方法从而形成自己的虚方法表\n虚方法的条件\n非static 非final 非private 只有虚方法表中的方法会被子类继承\nsuper关键字 super关键字用于指代父类的存储空间\n指向父类对象； 调用父类的方法； super() 可以调用父类的无参构造方法。 继承中成员变量调用规则 成员变量的调用规则满足就近原则\n寻找顺序为：方法局部位置——\u0026gt;本类的成员位置——\u0026gt;父类成员位置\n逐级向上寻找\n使用this直接调用本类的变量\n使用super调用父类的变量\n继承中成员方法调用规则 直接调用 成员方法的调用规则满足就近原则\n寻找顺序为：方法局部位置——\u0026gt;本类的成员方法——\u0026gt;父类成员方法\n逐级向上寻找\n使用this直接调用本类的方法\n使用super调用父类的方法\n方法重写 子类中重写父类中的方法，保持返回值类型，方法名，参数列表不变，它建立在继承的基础上。\n重写条件 重写方法的名称、形参列表必须与父类中的一致。 子类重写父类方法时，访问权限子类必须大于等于父类(default\u0026lt;protected\u0026lt;public) 子类重写父类方法时，返回值类型子类必须小于等于父类 只有被添加到虚方法表中的方法才能被重写（静态方法，私有方法，被final修饰的方法不能重写） 继承当中子类抛出的异常必须是父类抛出的异常或父类抛出异常的子异常 底层实现 子类重写的新方法覆盖从父类继承来的虚方法表中父类的同名方法\n示例代码 1 2 3 4 5 6 7 8 9 10 11 class E1{ public void doA(int a){ System.out.println(\u0026#34;这是父类的方法\u0026#34;); } } class E2 extends E1{ @Override public void doA(int a) { System.out.println(\u0026#34;我重写父类方法，这是子类的方法\u0026#34;); } } 构造方法 子类的所有构造方法默认必须调用其父类的构造方法再执行自己的构造方法：Java 虚拟机构造子类对象前会先构造父类对象，父类对象构造完成之后再来构造子类特有的属性，这被称为内存叠加。 如果子类的构造方法中没有显式地调用父类构造方法，则系统默认调用父类无参数的构造方法：所有子类的构造方法第一行必须为super() 任何情况下实例化对象会调用继承链的所有父类构造方法 子类无法继承父类的构造方法但是可以通过super关键字来调用 当父类只有有参构造函数时，子类必须显式调用 super 并传入合适的参数。 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 正确继承演示 class A{ public String name; public A() {//无参构造 } public A (String name){//有参构造 } } class B extends A{ public B() {//无参构造 super(); } public B(String name) {//有参构造 //super(); super(name); } } 继承中类的加载顺序 在Java继承中，父子类初始化先后顺序为：\n父类中静态成员变量和静态代码块 子类中静态成员变量和静态代码块 父类中普通成员变量和代码块，父类的构造函数 子类中普通成员变量和代码块，子类的构造函数 总的来说，就是静态\u0026gt;非静态，父类\u0026gt;子类，非构造函数\u0026gt;构造函数。同一类别（例如普通变量和普通代码块）成员变量和代码块执行从前到后，需要注意逻辑。\n","date":"2024-11-14T19:21:51+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/","title":"Java中的继承"},{"content":"不可变类的定义 一个类的对象在通过构造方法创建后如果状态不会再被改变，那么它就是一个不可变（immutable）类。\n它的所有成员变量的赋值仅在构造方法中完成，不会提供任何 setter 方法供外部类去修改，这种类的实例在整个生命周期内保持不变。\n不可变类的实现 类被final修饰，保证该类不被继承 所有的字段都是private和final的，确保它们在初始化后不能被更改 不提供setter方法 通过构造函数初始化所有字段 如果类包含可变对象的引用，确保这些引用在对象外部无法被修改。例如 getter 方法中返回对象的副本（new 一个新的对象）来保护可变对象 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // 不可变类 Writer public final class Writer { private final String name; private final int age; private final Book book; public Writer(String name, int age, Book book) { this.name = name; this.age = age; this.book = book; } public int getAge() { return age; } public String getName() { return name; } // 确保返回的是可变对象的副本 public Book getBook() { Book clone = new Book(); clone.setPrice(this.book.getPrice()); clone.setName(this.book.getName()); return clone; } } // 可变类 Book public class Book { private String name; private int price; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getPrice() { return price; } public void setPrice(int price) { this.price = price; } @Override public String toString() { return \u0026#34;Book{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, price=\u0026#34; + price + \u0026#39;}\u0026#39;; } } 不可变类的特点 优点：\n线程安全：由于不可变对象的状态不能被修改，它们天生是线程安全的，在并发环境中无需同步。 缓存友好：不可变对象可以安全地被缓存和共享，如 String 的字符串常量池。 防止状态不一致：不可变类可以有效避免因意外修改对象状态而导致的不一致问题。 缺点：\n性能问题：不可变对象需要在每次状态变化时创建新的对象，这可能会导致性能开销，尤其是对于大规模对象或频繁修改的场景（例如 String 频繁拼接）。 ","date":"2024-11-14T19:07:43+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/","title":"Java中的不可变对象"},{"content":"static关键字 用于修饰成员变量，成员方法，代码块以及内部类，表示这是静态的，归属于整个类\n静态变量 被static修饰的成员变量\n特点 该变量被类的所有对象共享 静态变量不属于单个对象而属于整个类 随着类的加载而加载，在对象的产生之前存在 静态变量只会获取一次内存空间，所以任何对象对它的修改都会得到保留。如果一个实例修改了静态变量的值，其他实例也会看到这个更改。 内存原理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Student { String name; int age; static String school = \u0026#34;华南理工大学\u0026#34;; public Student(String name, int age) { this.name = name; this.age = age; } public static void main(String[] args) { Student s1 = new Student(\u0026#34;沉默王二\u0026#34;, 18); Student s2 = new Student(\u0026#34;沉默王三\u0026#34;, 16); } } s1 和 s2 这两个引用变量存放在栈区（stack） 沉默王二+18 这个对象和沉默王三+16 这个对象存放在堆区（heap） school 这个静态变量存放在公共的地址（静态区）。 调用方式 类名.静态变量（推荐） 对象名.静态变量 静态方法 被static修饰的成员方法\n特点 无须依赖类的实例就可以使用 只能访问静态变量和其他静态方法 不能使用this关键字 静态方法可以被重载（同类中方法名相同，但参数不同），但不能被子类重写（因为方法绑定在编译时已确定） 调用方式 类名.静态方法（推荐） 对象名.静态方法 ","date":"2024-11-14T17:11:24+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/","title":"Java中的静态变量和静态方法"},{"content":"MVC设计模式 MVC 是一种常见的软件设计模式，用于分离应用程序的不同部分以实现松散耦合和高内聚性。MVC 模式由三个核心组件组成：\n模型（Model）：表示应用程序的数据和业务逻辑。模型处理应用程序的数据，并根据控制器的指令执行相应的操作。 视图（View）：提供模型数据的用户界面。视图通常是模板、HTML 页面、XML 文件或其他格式，可以呈现模型数据给用户。 控制器（Controller）：处理用户交互并更新模型和视图。控制器负责接收来自视图的用户输入，对模型进行相应的操作，并更新视图以反映更改。 MVC 模式的优点是可以将代码分离成三个独立的组件，使得应用程序更易于维护和扩展。例如，如果要更改视图的外观，可以修改视图而不影响模型和控制器；如果要更改数据存储方式，可以修改模型而不影响视图和控制器。同时，MVC 模式还有助于降低应用程序中的耦合度，使得各组件更加独立和可重用。\nSpringMVC框架 概述： Spring MVC 是非常著名的 Web 应用框架，现在的大多数 Web 项目都采用 Spring MVC。它与 Spring 有着紧密的关系。是 Spring 框架中的模块，专注 Web 应用，能够使用 Spring 提供的强大功能，IOC、AOP等。 Spring MVC 框架底层是基于 Servlct 技术。遵循 Servlet 规范，Web 组件 Servlet 、Filter、Listener在 Spring MVC 中都能使用。同时 Spring MVC 也是基于 MVC 架构模式的，职责分离，每个组件只负责自己的功能，组件解耦。 Spring Boot 的自动配置、按约定编程极大简化，提高了 Web 应用的开发效率。 响应流程： 大体流程：请求到控制器（controller），经过业务模型（model）处理后返回响应给视图层。\n具体流程：\nDispatcherServlet 首先收到请求，将请求映射到对应的处理器（controller）上，映射到controller的时候会触发拦截器 处理器处理完后封装数据模型，交给视图解析器将数据模型解析为对应的视图返回给前端。 SpringMVC组件 控制器controller 控制器是一种由 Spring 管理的 Bean 对象，赋予角色是“控制器”。\n作用：处理请求，接收浏览器发送过来的参数，将数据或视图应答给浏览器或者客户端 App等。\n具体实现：一个Java类，使用@Controller或@RestController\n提示\n@Controller 和 @RestController 注解的区别：\n@RestController 包含了 @Controller 的功能，同时加入了 @ResponseBody 的注解。 表示当前控制器类中的方法，都会默认加入 @ResponseBody 的功能。方法的返回值是数据可以通过 HttpServletResponse 输出给浏览器。 接收请求\n@RequestMapping ：用于将 Web 请求映射到控制器类的方法。此方法处理请求。可用作在类上或方法上。在类上和方法上同时使用。\n1 2 3 @RequestMapping(value = \u0026#34;/updateProduct\u0026#34;,method = RequestMethod.POST) public Result\u0026lt;String\u0026gt; updateProduct(@RequestParam MultipartFile file, @RequestParam String dname, @RequestParam String tname, @RequestParam String content,@RequestParam String olddname) Value：别名 path 表示请求的 URI，在类和方法上同时使用 value，方法上的继承类上的 value。 method：请求方式，支持 GET、POST、HEAD、OPTIONS、PUT、PATCH、DELETE、TRACE。值为：RequestMethod[] method()，RquestMethod 是 enum 类型。 快捷注解：\n@GetMapping: 表示 get 请求方式的@RequestMapping @PostMapping:表示 post 请求方式的@RequestMapping @PutMapping：表示 put 请求方式的@RequestMapping @DeleteMapping: 表示 delete 请求方式的@RequestMapping 接收请求参数\n@RequestParam：把请求中的指定名称的参数传递给控制器中的形参赋值\nvalue属性值指定请求中的参数 required 属性指定请求中的参数是否必须，默认为 true ，如果加上 required=false，没对应上则不会报错，而是获取值为 null。 如果参数前不写@RequestParam(xxx)的话，那么就前端可以有可以没有对应的参数名字都行，如果有参数名的话，那么就会自动匹配；没有的话，请求也能正确发送。 HttpServletRequest对象 使用 HttpServletRequest 对象接收参数，request.getParameter(\u0026quot;XXX\u0026quot;)获取对应的值，这是原始的 JavaWeb 中的方式 @RequestBody：主要用来接收前端传递给后端的json字符串中的数据的(通常json字符串放在请求体中)\nGET方式无请求体，所以使用@RequestBody接收数据时，前端不能使用GET方式提交数据，而是用POST方式进行提交。 在后端的同一个接收方法里，@RequestBody与@RequestParam()可以同时使用，@RequestBody最多只能有一个，而@RequestParam()可以有多个。 如果后端参数是一个对象，且该参数前是以@RequestBody修饰的，那么前端传递json参数时，必须满足以下要求：后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类(即：@RequestBody后面的类)时，会根据json字符串中的key来匹配对应实体类的属性，如果匹配一致且json中的该key对应的值符合(或可转换为)实体类的对应属性的类型要求时，会调用实体类的setter方法将值赋给该属性 @RequestHeader：从请求头中获取某些值\n1 2 3 4 5 6 7 8 9 10 11 12 import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestHeader; import org.springframework.web.bind.annotation.RestController; @RestController public class MyController { @GetMapping(\u0026#34;/greet\u0026#34;) public String greet(@RequestHeader(\u0026#34;User-Agent\u0026#34;) String userAgent) { return \u0026#34;Hello! You are using \u0026#34; + userAgent; } } 返回值\n不使用 @ResponseBody的 String 返回值，返回的是一个页面视图 使用 @ResponseBody的 String 返回值，返回的是一个JSON数据 返回ModelAndView ，返回的是一个视图其中包含数据。（最后数据都是放到 Request 中的） 返回自定义的对像，默认的返回格式是json字符串（有jackson工具） 返回 Map，默认的返回格式是json字符串（有jackson工具） 返回ResponseEntity：包含数据和自定义的HttpStatus Code。（默认转为json格式的字符串） 模型 Model 在许多实际项目需求中，后台要从控制层直接返回前端所需要的数据，这时 Model 大家族就派上用场了。 Model Spring MVC 中的 ”M“，是用来传输数据的。从控制层直接返回数据给前端。内置的 JSP，模板技术能够展现 Model 中存储的数据。 Model 可以是承载数据的，也可以是处理具体业务的类，这些都是指 Spring MVC 中的Model。 视图 View Spring MVC 中的 View（视图）用于展示数据的，视图技术的使用是可插拔的。无论选择使用 thymleaf、jsp 还是其他技术，classpath 有 jar 就能使用视图了。开发者主要就是更改配置。SpringBoot3 不推荐使用 FreeMarker、JSP 这些了。建议使用 Thymeleaf。 SpringBoot框架中对SpringMVC框架的集成 自动配置：SpringBoot会自动配置一个嵌入式的Servlet容器（如Tomcat），并为我们提供默认的SpringMVC配置。这样我们无需手动配置Servlet容器和SpringMVC，只需添加相应的依赖即可快速搭建一个Web应用。 视图解析器：SpringBoot默认使用Thymeleaf作为视图解析器，如果需要更换其他视图解析器，可以在pom.xml中修改对应的依赖。 静态资源处理：SpringBoot默认会处理静态资源（如HTML、CSS、JavaScript等），并将其放在项目的/static或/public目录下。如果需要自定义静态资源的处理方式，可以通过编写一个类实现WebMvcConfigurer接口，并重写addResourceHandlers方法来实现。 拦截器：SpringBoot支持自定义拦截器，可以通过实现HandlerInterceptor接口来创建拦截器，同时编写一个类实现WebMvcConfigurer接口，并重写addInterceptors方法来实现。 异常处理：SpringBoot默认使用WhitelabelErrorView来处理异常，如果需要自定义异常处理方式，可以通过编写一个类实现ErrorController接口，并重写errorHtml方法来实现。 参数绑定：SpringBoot支持多种参数绑定方式，如@RequestParam、@PathVariable、@RequestBody等。如果需要自定义参数绑定方式，可以通过编写一个类实现MethodArgumentResolver接口，并重写resolveArgument方法来实现。 跨域支持：SpringBoot默认支持CORS跨域请求，如果需要自定义跨域配置，可以通过编写一个类实现WebMvcConfigurer接口，并重写addCorsMappings方法来实现。 Spring Boot中配置Spring MVC 配置方法 因为Spring Boot自动装配机制的存在，一般来说我们不需要对Spring MVC进行配置，如果要进行特别定制化的配置，Spring Boot也支持配置文件或者编写代码的两种方式来进行配置。\n方法一：修改application.xml 可以通过修改application.xml的spring.mvc属性来修改SpringBoot对SpringMVC的默认配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 spring: mvc: # 启用Spring MVC enabled: true # 配置静态资源路径 static-path-pattern: /static/** static-locations: classpath:/static/ # 配置视图解析器 view.prefix: /WEB-INF/views/ view.suffix: .jsp # 配置拦截器 interceptor: exclude-path-patterns: /login,/logout include-path-patterns: /admin/** # 配置HTTP缓存 resources: cache: period: 3600 servlet: # 配置文件上传 multipart: max-file-size: 10MB max-request-size: 10MB # 配置会话管理 session: timeout: 1800 cookie.max-age: 1800 # 配置JSON序列化 jackson: serialization: indent_output: true date-format: yyyy-MM-dd HH:mm:ss # 配置异常处理 error: whitelabel: enabled: false 方法二：编写一个被注解@WebMvcConfiguration修饰的Java配置类 WebMvcConfigurer接口是Spring提供的一个用于自定义Spring MVC配置的接口，主要提供了WebMvcConfigurer接口是Spring提供的一个用于自定义Spring MVC配置的接口，主要提供了多个回调方法，包括添加或修改Spring MVC的配置，如添加拦截器，自定义消息转换器等。具体来说，WebMvcConfigurer接口的主要方法包括：\nconfigurePathMatch（S）：此方法用于配置路由请求规则。 configureContentNegotiation（S）：该方法用于内容协商配置。 configureAsyncSupport（S）：该方法用于异步支持配置。 configureDefaultServletHandling（S）：该方法用于配置默认静态资源处理器。 addFormatters（S）：此方法用于注册自定义转化器。 addInterceptors（S）：此方法用于拦截器配置。 addResourceHandlers（S）：此方法用于资源处理。 addCorsMappings（S）：此方法用于CORS配置。 在使用时，只需要实现WebMvcConfigurer接口，重写上述的方法即可完成自定义配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @Configuration public class MyWebMvcConfig implements WebMvcConfigurer { // 配置视图解析器 @Override public void configureViewResolvers(ViewResolverRegistry registry) { InternalResourceViewResolver resolver = new InternalResourceViewResolver(); resolver.setPrefix(\u0026#34;/WEB-INF/views/\u0026#34;); resolver.setSuffix(\u0026#34;.jsp\u0026#34;); registry.viewResolver(resolver); } // 配置静态资源 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\u0026#34;/static/**\u0026#34;).addResourceLocations(\u0026#34;/static/\u0026#34;); } // 配置拦截器 @Autowired private MyInterceptor myInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(myInterceptor).addPathPatterns(\u0026#34;/**\u0026#34;); } // 配置消息转换器 @Override public void configureMessageConverters(List\u0026lt;HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converters) { MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter(); List\u0026lt;MediaType\u0026gt; supportedMediaTypes = new ArrayList\u0026lt;MediaType\u0026gt;(); supportedMediaTypes.add(MediaType.APPLICATION_JSON); converter.setSupportedMediaTypes(supportedMediaTypes); converters.add(converter); } // 配置异常处理器 @ControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(value = Exception.class) public ModelAndView handleException(HttpServletRequest req, Exception e) { ModelAndView mav = new ModelAndView(); mav.addObject(\u0026#34;exception\u0026#34;, e); mav.addObject(\u0026#34;url\u0026#34;, req.getRequestURL()); mav.setViewName(\u0026#34;error\u0026#34;); return mav; } } // 配置全局跨域资源共享（CORS） @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\u0026#34;/user/*\u0026#34;) // 映射服务器中那些http接口运行跨域访问 .allowedOrigins(\u0026#34;http://localhost:8081\u0026#34;) // 配置哪些来源有权限跨域 .allowedMethods(\u0026#34;GET\u0026#34;,\u0026#34;POST\u0026#34;,\u0026#34;DELETE\u0026#34;,\u0026#34;PUT\u0026#34;); // 配置运行跨域访问的请求方法 } // 配置文件上传 @Bean public MultipartResolver multipartResolver() { CommonsMultipartResolver resolver = new CommonsMultipartResolver(); resolver.setMaxUploadSize(10485760); resolver.setMaxInMemorySize(4096); return resolver; } // 配置请求缓存 @Bean public KeyGenerator keyGenerator() { return new DefaultKeyGenerator(); } @Bean public RequestCache requestCache() { return new HttpSessionRequestCache(); } // 配置视图控制器 @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\u0026#34;/\u0026#34;).setViewName(\u0026#34;index\u0026#34;); registry.addViewController(\u0026#34;/login\u0026#34;).setViewName(\u0026#34;login\u0026#34;); } } 提示\n使用Springboot框架对SpringMVC的默认设置：直接编写控制器逻辑\n手动设置SpringMVC的部分功能，定义MVC的底层组件：@Configuration+配置WebMvcConfiguration，不要使用@EnableWebMvc\n手动设置SpringMVC的所有功能：@Configuration+配置WebMvcConfiguration+@EnableMvc\n使用 @EnableWebMvc 会完全覆盖 SpringBoot 对 SpringMVC 的自动配置，因此如果使用了 @EnableWebMvc，就需要自己配置 Spring MVC 的全部内容，包括视图解析器、资源处理、异常处理等。通常情况下，只有在需要非常精细的控制 Spring MVC 配置时才会使用 @EnableWebMvc。\n","date":"2024-11-14T16:21:47+08:00","permalink":"https://Tyritic.github.io/p/springmvc/","title":"SpringMVC"},{"content":"构造方法的作用 用于给对象实例进行初始化，只有在构造方法被调用的时候，对象才会被分配内存空间。\n构造方法的调用时机 每次使用 new 关键字创建对象的时候，构造方法至少会被调用一次。”\n定义构造方法的规则 构造方法的名字必须和类名一样； 构造方法没有返回类型，包括 void； 构造方法不能是抽象的（abstract）、静态的（static）、最终的（final）、同步的（synchronized）。 由于构造方法不能被子类继承，所以用 final 和 abstract 关键字修饰没有意义； 构造方法用于初始化一个对象，所以用 static 关键字修饰没有意义； 多个线程不会同时创建内存地址相同的同一个对象，所以用 synchronized 关键字修饰没有必要。 无参构造方法（默认构造方法） 如果一个构造方法中没有任何参数，那么它就是一个默认构造方法，也称为无参构造方法。\n通常情况下，无参构造方法是可以缺省的，开发者并不需要显式的声明无参构造方法，编译器将提供一个无参数，方法体为空的构造方法。\n当用户显式定义了构造方法后，系统将不再提供默认构造函数。\n默认构造方法的目的主要是为对象的字段提供默认值\n有参构造方法 有参数的构造方法被称为有参构造方法，参数可以有一个或多个。有参构造方法可以为不同的对象提供不同的值。\n如果没有有参构造方法的话，就需要通过 setter 方法给字段赋值了。\n重载构造方法 构造方法它也可以像方法一样被重载。构造方法的重载只需要提供不同的参数列表即可。编译器会通过参数的数量来决定应该调用哪一个构造方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class OverloadingConstrutorPerson { private String name; private int age; private int sex; public OverloadingConstrutorPerson(String name, int age, int sex) { this.name = name; this.age = age; this.sex = sex; } public OverloadingConstrutorPerson(String name, int age) { this.name = name; this.age = age; } public void out() { System.out.println(\u0026#34;姓名 \u0026#34; + name + \u0026#34; 年龄 \u0026#34; + age + \u0026#34; 性别 \u0026#34; + sex); } public static void main(String[] args) { OverloadingConstrutorPerson p1 = new OverloadingConstrutorPerson(\u0026#34;王二\u0026#34;,18, 1); p1.out(); OverloadingConstrutorPerson p2 = new OverloadingConstrutorPerson(\u0026#34;王三\u0026#34;,16); p2.out(); } } 拷贝构造方法 利用一个已有对象将该对象的参数字段直接传递给新的对象\n语法格式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 语法格式 class_name(class_name obj) { //字段赋值操作 } //示例代码 public class CopyConstrutorPerson { private String name; private int age; public CopyConstrutorPerson(String name, int age) { this.name = name; this.age = age; } public CopyConstrutorPerson(CopyConstrutorPerson person) { this.name = person.name; this.age = person.age; } public void out() { System.out.println(\u0026#34;姓名 \u0026#34; + name + \u0026#34; 年龄 \u0026#34; + age); } public static void main(String[] args) { CopyConstrutorPerson p1 = new CopyConstrutorPerson(\u0026#34;沉默王二\u0026#34;,18); p1.out(); CopyConstrutorPerson p2 = new CopyConstrutorPerson(p1); p2.out(); } } ","date":"2024-11-14T12:15:40+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/","title":"Java中的构造方法"},{"content":"就近原则 通常是指在方法调用过程中，编译器或 JVM 根据 \u0026ldquo;就近\u0026rdquo; 的方式来解析某些元素，特别是 变量、方法、类型、类 等的访问。\n示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Example { private int x = 10; // 类成员变量 public void myMethod(int x) { // 参数 x 会遮蔽成员变量 x System.out.println(\u0026#34;Local x: \u0026#34; + x); // 使用的是方法参数 x System.out.println(\u0026#34;Member x: \u0026#34; + this.x); // 使用成员变量 x } public static void main(String[] args) { Example obj = new Example(); obj.myMethod(20); } } this关键字 this关键字用于指代类实例化后的当前实例\n使用场景 当局部变量和实例变量重名时进行区分 其中被this修饰的变量是实例变量\n不被 this修饰的变量是局部变量\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class WithThisStudent { String name; int age; WithThisStudent(String name, int age) { this.name = name; this.age = age; } void out() { System.out.println(name+\u0026#34; \u0026#34; + age); } public static void main(String[] args) { WithThisStudent s1 = new WithThisStudent(\u0026#34;王二\u0026#34;, 18); WithThisStudent s2 = new WithThisStudent(\u0026#34;王三\u0026#34;, 16); s1.out(); s2.out(); // 输出： // 王二 18 // 王三 16 } } 调用当前类的方法 可以在一个类中使用 this 关键字来调用另外一个方法，如果没有使用的话，编译器会自动帮我们加上\n调用当前类的其他构造方法 this关键字可以用于在当前类的构造方法中调用当前类的其他构造方法，但是this() 必须放在构造方法的第一行\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 调用当前类的无参构造方法 public class InvokeConstrutor { InvokeConstrutor() { System.out.println(\u0026#34;hello\u0026#34;); } InvokeConstrutor(int count) { this(); System.out.println(count); } public static void main(String[] args) { InvokeConstrutor invokeConstrutor = new InvokeConstrutor(10); } // 输出 // hello // 10 } // 调用当前类的有参构造方法 public class InvokeParamConstrutor { InvokeParamConstrutor() { this(10); System.out.println(\u0026#34;hello\u0026#34;); } InvokeParamConstrutor(int count) { System.out.println(count); } public static void main(String[] args) { InvokeParamConstrutor invokeConstrutor = new InvokeParamConstrutor(); } } 作为方法的参数 “this 关键字可以作为参数在方法中传递，此时，它指向的是当前类的对象。\n作为返回值实现链式调用 this 关键字作为方法的返回值的时候，方法的返回类型为类的类型\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class ThisAsMethodResult { ThisAsMethodResult getThisAsMethodResult() { return this; } void out() { System.out.println(\u0026#34;hello\u0026#34;); } public static void main(String[] args) { new ThisAsMethodResult().getThisAsMethodResult().out(); } } 内存实现 this代表当前调用方法的对象引用，哪个对象调用方法，this就代表哪个对象的地址值\n","date":"2024-11-14T11:44:37+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84this%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E5%B0%B1%E8%BF%91%E5%8E%9F%E5%88%99/","title":"Java中的this关键字和就近原则"},{"content":"面向对象编程和面向过程编程 面向对象编程 面向对象编程是一种编程范式，它将现实世界中的事物抽象为对象，把类或对象作为基本单元来组织代码，对象具有属性（称为字段或属性）和行为（称为方法）。面向对象编程的设计思想是以对象为中心，通过对象之间的交互来完成程序的功能，具有灵活性和可扩展性，通过封装和继承可以更好地应对需求变化。\n面向过程编程 面向过程编程是一种以过程或函数为中心的编程范式，以过程作为基本单元来组织代码。过程其实就是动作，对应到代码中来就是函数，面向过程中函数和数据是分离的，数据就是成员变量。\n主要区别 数据与行为的关系：\n面向对象：数据和行为封装在对象内部，数据操作由对象方法进行管理。 面向过程：数据和函数是分离的，函数对数据进行操作。 可扩展性和复用性：\n面向对象：通过继承、接口、多态等机制支持代码的高复用性和扩展性。 面向过程：复用性较低，扩展需要修改已有代码，影响整体稳定性。 面向对象的特性和设计原则 三大特性 封装：将数据和行为封装在对象内部，提供接口进行访问，隐藏实现细节，提高安全性。 继承：子类可以继承父类的属性和方法，实现代码复用和扩展。 多态：对象可以通过父类或接口进行多态性调用，不同对象在运行时执行不同的行为。 六大设计原则 单一职责原则（SRP）：一个类应该只有一个引起它变化的原因，即一个类应该只负责一项职责。例子：考虑一个员工类，它应该只负责管理员工信息，而不应负责其他无关工作。 开放封闭原则（OCP）：软件实体应该对扩展开放，对修改封闭。例子：通过制定接口来实现这一原则，比如定义一个图形类，然后让不同类型的图形继承这个类，而不需要修改图形类本身。 里氏替换原则（LSP）：子类对象应该能够替换掉所有父类对象。例子：一个正方形是一个矩形，但如果修改一个矩形的高度和宽度时，正方形的行为应该如何改变就是一个违反里氏替换原则的例子。 接口隔离原则（ISP）：客户端不应该依赖那些它不需要的接口，即接口应该小而专。例子：通过接口抽象层来实现底层和高层模块之间的解耦，比如使用依赖注入。 依赖倒置原则（DIP）：高层模块不应该依赖低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。例子：如果一个公司类包含部门类，应该考虑使用合成/聚合关系，而不是将公司类继承自部门类。 最少知识原则 (Law of Demeter)：一个对象应当对其他对象有最少的了解，只与其直接的朋友交互。 类的组成结构 变量（属性） 静态变量：归属于整个类 实例变量：归属于一个对象 方法（行为） 静态方法：归属于整个类 实例方法：归属于一个对象 实现细节 打印对象名可以输出该对象的内存地址 成员变量具有默认值 一个源文件中可以定义多个类但是只能出现一个主类（被 public修饰）且该类与源文件的文件名相同 内存原理 对象在内存中的创建过程 加载.class文件 在栈区声明局部变量（对象的引用） 在堆区中开辟内存空间并产生对象的地址值 默认初始化（对成员变量赋默认值） 显式初始化（对常量进行初始化） 构造方法初始化 单个对象的内存情况 栈区 主方法main\n对象的引用\n堆区 对象的变量 成员方法的地址 项目开发中类的种类 Bean类 使用场景 用于描述事物的类\n特点 至少两个构造方法，一个无参构造方法，一个有参构造方法 成员变量为private 为所有成员变量提供getter和setter 工具类（Utils) 使用场景 将常用的方法封装成工具类\n特点 构造方法是private的 方法都是静态方法（static） 测试类 使用场景 用于检查代码的正确性\n特点 带有main方法 ","date":"2024-11-14T10:26:52+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","title":"Java中的类与对象"},{"content":"简介 Springdoc-OpenApi是一个规范且完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。\nSpringdoc-OpenApi 的目标是对 REST API 定义一个标准且和语言无关的接口，可以让人和计算机拥有无须访问源码、文档或网络流量监测就可以发现和理解服务的能力。\n具体使用 引入具体依赖springfox\n1 2 3 4 5 6 \u0026lt;!-- 导入相关依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springdoc\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springdoc-openapi-starter-webmvc-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 添加配置类用于Api文档的基本配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package org.example.user.config; import io.swagger.v3.oas.models.OpenAPI; import io.swagger.v3.oas.models.info.Contact; import io.swagger.v3.oas.models.info.Info; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class SpringDocConfig { // OpenAPI类用于定制全局文档信息 @Bean public OpenAPI customOpenAPI() { return new OpenAPI() // 定制文档基本信息 .info(new Info() //关于文档信息 .title(\u0026#34;API 文档标题\u0026#34;) .description(\u0026#34;API 文档描述\u0026#34;) .version(\u0026#34;1.0.0\u0026#34;) .termsOfService(\u0026#34;https://example.com/terms\u0026#34;) //关于开发者 .contact(new Contact() .name(\u0026#34;开发者姓名\u0026#34;) .url(\u0026#34;开发者网址\u0026#34;) .email(\u0026#34;开发者邮箱\u0026#34;)) //关于许可证 .license(new License() .name(\u0026#34;许可证名称\u0026#34;) .url(\u0026#34;许可证文件\u0026#34;))) //配置服务器信息（可选） .servers(List.of( new Server().url(\u0026#34;服务器url\u0026#34;).description(\u0026#34;服务器描述\u0026#34;), new Server().url(\u0026#34;https://api.example.com\u0026#34;).description(\u0026#34;生产服务器\u0026#34;))) //配置外部文档信息（可选） .externalDocs(new ExternalDocumentation() .description(\u0026#34;外部文档描述\u0026#34;) .url(\u0026#34;外部文档url\u0026#34;)); } } 修改application.yml配置文件\n1 2 3 4 5 springdoc: api-docs: enable: true swagger-ui: enable: true 其余属性参见官方文档 SpringDoc-OpenApi官方文档\n提示\n1 2 3 4 5 6 7 8 springdoc: group-configs: #进行文档分组每个组配置对应的请求路径以及区分所在包 - group: \u0026#39;user\u0026#39; paths-to-match: \u0026#39;/api/users/**\u0026#39; packages-to-scan: com.toher.springdoc.user - group: \u0026#39;product\u0026#39; paths-to-match: \u0026#39;/api/product/**\u0026#39; packages-to-scan: com.toher.springdoc.product 可以在微服务架构中进行分组\n查看接口文档\nSwagger-UI接口文档：http://localhost:8080/swagger-ui/index.html Json形式接口文档：localhost:8080/v3/api-docs 使用注解编写接口文档\n常用注解 对实体类的描述 @Schema：用于描述类或字段的数据结构和属性，支持OpenAPI 3规范中的各种特性，如类型、格式、默认值等。\n1 2 3 4 5 6 7 8 9 10 11 12 @Data @NoArgsConstructor @AllArgsConstructor @Builder public class User { @Schema(description = \u0026#34;用户ID\u0026#34;, example = \u0026#34;1\u0026#34;) private int id; @Schema(description = \u0026#34;用户姓名\u0026#34;, example = \u0026#34;张三\u0026#34;) private String name; @Schema(description = \u0026#34;用户年龄\u0026#34;, example = \u0026#34;18\u0026#34;) private int age; } 对方法的描述 @Operation：用于方法级别，提供对API操作的详细描述，包括摘要、描述、响应、参数等信息。\nsummary：操作的简要描述。 description：操作的详细描述。 tags：与操作相关的标签。 operationId：操作的唯一标识符。 parameters：操作的参数列表。 responses：操作的响应列表。 1 2 3 4 5 6 7 8 9 10 @Operation( summary = \u0026#34;获取用户信息\u0026#34;, description = \u0026#34;根据用户ID获取用户详细信息\u0026#34;, tags = {\u0026#34;用户操作\u0026#34;}, operationId = \u0026#34;getUserById\u0026#34; ) @RequestMapping(\u0026#34;/users\u0026#34;) public User getUserById(@PathVariable Long id) { // 实现逻辑 } @ApiResponses是一个容器注解，用于收集多个@ApiResponse，描述方法可能返回的各种响应情况。\n@ApiResponse描述了API操作的一个特定响应，包括响应的状态码、描述、内容类型等。\nresponseCode：响应代码。 description：响应描述。 content：响应内容。 1 2 3 4 5 6 7 8 9 10 11 12 13 @RequestMapping(value=\u0026#34;/{id}\u0026#34;, method = RequestMethod.GET) @Operation(summary = \u0026#34;findById方法\u0026#34;, description = \u0026#34;根据id查询用户\u0026#34;) @Parameter(name = \u0026#34;id\u0026#34;, description = \u0026#34;用户id\u0026#34;, required = true, in = ParameterIn.PATH) @ApiResponses(value = { @ApiResponse(responseCode = \u0026#34;200\u0026#34;, description = \u0026#34;查询成功\u0026#34;,content={@Content(mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = Result.class))}), @ApiResponse(responseCode = \u0026#34;500\u0026#34;, description = \u0026#34;查询失败\u0026#34;,content={@Content(mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = Result.class))}) }) public Result\u0026lt;User\u0026gt; findById(@PathVariable Integer id) { return Result.success(\u0026#34;查询成功\u0026#34;, new User(id, \u0026#34;张三\u0026#34;, 20)); } @Parameters是一个容器注解，用于收集多个@Parameter注解，描述方法的多个请求参数。\n@Parameter：用于描述单个请求参数，可以是查询参数、路径参数、请求头等。\nname：参数名。 description：参数描述。 required：是否必需参数。 in：参数所在位置（query、header、path、cookie）。 1 2 3 4 5 6 7 8 @Parameters(value = { @Parameter(name = \u0026#34;name\u0026#34;, description = \u0026#34;姓名\u0026#34;, in = ParameterIn.PATH), @Parameter(name = \u0026#34;age\u0026#34;, description = \u0026#34;年龄\u0026#34;, in = ParameterIn.QUERY) }) @GetMapping(\u0026#34;/{name}\u0026#34;) public List\u0026lt;Programmer\u0026gt; getProgrammers(@PathVariable(\u0026#34;name\u0026#34;) String name, @RequestParam(\u0026#34;age\u0026#34;) Integer age) { ... } 对类的描述 @Tag：用于标记API控制器或方法属于哪一个功能分类或标签，有助于组织和分类API文档中的不同部分\n1 2 3 4 5 6 @Tag(name = \u0026#34;程序员\u0026#34;, description = \u0026#34;程序员乐园\u0026#34;) @RestController @RequestMapping(\u0026#34;/api/programmer\u0026#34;) public class ProgrammerController { ... } ","date":"2024-11-12T10:01:20+08:00","permalink":"https://Tyritic.github.io/p/springboot%E6%95%B4%E5%90%88springdoc-openapi/","title":"SpringBoot整合Springdoc-OpenApi"},{"content":"Restful服务 Restful是目前流行的互联网软件服务架构设计风格\n服务特点 每一个URL代表一种资源 客户端使用GET、POST、PUT、DELETE四种表示操作方式的动词对服务端资源进行操作：GET用于获取资源，POST用于新建资源（也可以用于更新资源），PUT用于更新资源，DELETE用于删除资源。 通过操作资源的表现形式来实现服务端请求操作。 资源的表现形式是JSON或者HTML。 客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都包含必需的信息。 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @RestController public class UserController{ @ApiOperation(\u0026#34;获取用户\u0026#34;) @GetMapping(\u0026#34;/user/{id}\u0026#34;) public String getUserById(@PathVariable int id){ System.out.println(id); return \u0026#34;根据ID获取用户信息\u0026#34;; } @PostMapping(\u0026#34;/user\u0026#34;) public String save(User user){ return \u0026#34;添加用户\u0026#34;; } @PutMapping(\u0026#34;/user\u0026#34;) public String update(User user){ return \u0026#34;更新用户\u0026#34;; } @DeleteMapping(\u0026#34;/user/{id}\u0026#34;) public String deleteById(@PathVariable int id){ System.out.println(id); return \u0026#34;根据ID删除用户\u0026#34;; } } 最佳实现 接口设计 URL的组成 网络协议 服务器地址 接口名称 ？参数列表（GET方法） 响应设计 Content-body用来存放数据 用于描述数据的msg和code放入Content-header中 RestTemplate 简介 RestTemplate是Spring提供的用于访问Rest服务的，RestTemplate提供了多种便捷访问远程Http服务的方法，传统情况下在java代码里访问restfuI服务，一般使用Apache的HttpClient，不过此种方法使用起来太过繁琐。spring提供了一种简单便捷的模板类来进行操作，这就是RestTemplate.（常用于客户端和微服务）\n具体使用 以微服务为例\n创建一个Controller类（用@RestController修饰）\n创建一个Config类对RestTemplate进行配置和创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Configuration public class RestTemplateConfig { /** * 没有实例化RestTemplate时，初始化RestTemplate * 性能上OkHttp优于Apache的HttpClient，Apache的HttpClient优于HttpURLConnection（默认）。 * @return */ @ConditionalOnMissingBean(RestTemplate.class) @Bean public RestTemplate restTemplate(){ RestTemplate restTemplate = new RestTemplate(getClientHttpRequestFactory()); return restTemplate; } /** * 使用OkHttpClient作为底层客户端 * @return */ private ClientHttpRequestFactory getClientHttpRequestFactory(){ OkHttpClient okHttpClient = new OkHttpClient.Builder() .connectTimeout(5, TimeUnit.SECONDS) .writeTimeout(5, TimeUnit.SECONDS) .readTimeout(5, TimeUnit.SECONDS) .build(); return new OkHttp3ClientHttpRequestFactory(okHttpClient); } } 进行依赖注入并使用该Bean对象\n常见方法 GET请求 getForObject：获取请求体\n不带参数：(uri, \u0026lt;T \u0026gt;.class) 代表 请求地址、HTTP响应转换被转换成的对象类型 带参数(uri, String.class, paramMap) 代表 请求地址、HTTP响应转换被转换成的对象类型，请求参数 getForEntity：获取整个请求，除了包含响应体，还包含HTTP状态码、contentType、contentLength、Header等信息\nPOST请求 postForObject：获取请求体 postForEntity：获取整个请求，除了包含响应体，还包含HTTP状态码、contentType、contentLength、Header等信息 PUT请求 put： Delete请求 delete： 通用请求 exchange(String url, HttpMethod method,@Nullable HttpEntity\u003c?\u003e requestEntity, Class responseType, Map uriVariables) url: 请求地址； method: 请求类型(如：POST,PUT,DELETE,GET)； requestEntity: 请求实体，封装请求头，请求内容 responseType: 响应类型，根据服务接口的返回类型决定 uriVariables: url中参数变量值 ","date":"2024-11-11T18:48:31+08:00","permalink":"https://Tyritic.github.io/p/resttemplate/","title":"RestTemplate"},{"content":"List集合的定义 在 Java 中，List 是一个接口，继承自 Collection 接口，表示一个有序的元素集合。List 集合中的元素是按插入顺序排列的，允许元素重复。\nList集合的特点 集合中允许重复元素 集合中的元素是按插入顺序排列 集合支持动态扩容 只能存储引用数据类型，基本数据类型要转化成包装类 List接口的实现类 ArrayList：基于动态数组实现，支持快速随机访问，插入和删除操作效率相对较低，适用于查询频繁的场景。 LinkedList：基于双向链表实现，支持快速插入和删除，查询效率较低，适用于频繁修改的场景。 Vector：与 ArrayList 类似，但它是同步的，线程安全的，适用于多线程并发的场景（但现在不常用）。 Stack：继承自 Vector，实现了栈的功能，支持后进先出（LIFO）操作。 List接口的常用方法 增加元素 boolean add(E e)：将指定的元素添加到列表的末尾 void add(int index, E element)：将指定的元素插入到列表的指定位置 boolean addAll(Collection\u0026lt;? extends E\u0026gt; c)：将指定集合中的所有元素添加到当前列表的末尾 boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c)：将指定集合中的所有元素插入到当前列表的指定位置。 删除元素 void clear()：删除全部元素 E remove(int index)：删除列表中指定位置的元素 boolean remove(Object o)：删除列表中第一次出现的指定元素。如果列表中没有该元素，则不做任何操作。 boolean removeAll(Collection\u0026lt;?\u0026gt; c)：删除当前列表中所有与指定集合中的元素相同的元素 void removeRange(int from,int to):删除索引[from，to）之间的元素 判断元素 boolean contains(Object o)：判断列表中是否包含指定的元素 boolean containsAll(Collection\u0026lt;?\u0026gt; c)：判断列表是否包含指定集合中的所有元素 修改元素 E set(int index, E element)：用指定的元素替换列表中指定位置的元素 访问元素 E get(int index)：返回指定位置的元素 int indexOf(Object o)：返回指定元素在列表中的第一次出现位置的索引。如果列表中没有该元素，则返回 -1 int lastIndexOf(Object o)：返回指定元素在列表中的最后一次出现位置的索引。如果列表中没有该元素，则返回 -1 获取大小 int size()：返回列表中元素的数量 boolean isEmpty()：判断列表是否为空 ","date":"2024-11-11T15:34:52+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84list%E6%8E%A5%E5%8F%A3/","title":"Java中的List接口"},{"content":"devtool热部署 为了进一步提高开发效率,springboot为我们提供了全局项目热部署,日后在开发过程中修改了部分代码以及相关配置文件后,不需要每次重启使修改生效,在项目中开启springboot全局热部署之后只需要在修改之后等待几秒即可使修改生效。\n开启热部署 引入相关依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; Java的日志体系 日志门面 每一种日志框架都有自己单独的API，要使用对应的框架就要使用其对应的API，这就大大的增加应用程序代码对于日志框架的耦合性。\n为了解决这个问题，就是在日志框架和应用程序之间架设一个沟通的桥梁，对于应用程序来说，无论底层的日志框架如何变，都不需要有任何感知。只要门面服务做的足够好，随意换另外一个日志框架，应用程序不需要修改任意一行代码，就可以直接上线。总而言之，日志门面用于整合不同日志框架的日志（类似接口），不实现具体日志\n常见的日志门面\nJCL（Java Common Logging）：Java自带的日志门面 SLF4J：目前最常用的日志门面 JCL 用户可以自由选择第三方的日志组件作为具体实现，像log4j，或者jdk自带的jul， common-logging会通过动态查找的机制，在程序运行时自动找出真正使用的日志库。\nJCL默认的情况下，会使用JUL日志框架做日志的记录操作。\nJCL使用原则：如果有log4j，优先使用log4j，如果没有任何第三方日志框架的时候，使用的就是JUL。再没有则使用JCL内部提供的 SimpleLog 实现\n具体实现\n导入相关依赖\n编写业务代码\n1 2 3 4 5 6 7 public class JulMain { public static void main(String[] args){ Log log= LogFactory.getLog(JulMain.class) log.info(\u0026#34;Hello world\u0026#34;); } } SLF4J 简单日志门面(Simple Logging Facade For Java) SLF4J主要是为了给Java日志访问提供一套标准、规范的API框架，\n主要意义：提供接口，具体的实现可以交由其他日志框架，例如log4j和logback等。\n对于一般的Java项目而言，日志框架会选择slf4j-api作为门面，配上具体的实现框架（log4j、logback等），中间使用桥接器完成桥接。所以我们可以得出SLF4J最重要的两个功能就是对于日志框架的绑定以及日志框架的桥接。\n具体使用\n引入相关依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!--slf4j 核心依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--slf4j 自带的简单日志实现 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-simple\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.25\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--具体日志框架的slf4j桥接器（可选）--\u0026gt; 编写业务代码(如果在没有任何其他日志实现框架集成的基础之上，slf4j使用的就是自带的框架slf4j-simple，slf4j-simple也必须以单独依赖的形式导入进来。)\n1 2 3 4 5 6 7 8 9 10 public class SLF4JTest01 { // 都是slf4j包下的 Logger logger = LoggerFactory.getLogger(SLF4JTest.class); logger.trace(\u0026#34;trace信息\u0026#34;); logger.debug(\u0026#34;debug信息\u0026#34;); logger.info(\u0026#34;info信息\u0026#34;); logger.warn(\u0026#34;warn信息\u0026#34;); logger.error(\u0026#34;error信息\u0026#34;); } 日志实现和对应的日志门面 日志实现 日志门面 log4j（已经淘汰） JCL/SLF4J JUL（java.utils.logging) JCL log4j2 SLF4J logback SLF4J 提示\n记录日志不能直接使用日志实现框架，必须通过日志门面来实现\n日志实现 JUL JUL全称 Java Util Logging，核心类在java.util.logging包下，它是java原生的日志框架，使用时不需要另外引用第三方的类库，相对其他的框架使用方便，学习简单，主要是使用在小型应用中。\n组件构成\nLogger：被称为记录器，应用程序通过获取Logger对象，调用其API来发布日志信息。Logger通常被认为是访问日志系统的入口程序。 Handler：处理器，每个Logger都会关联一个或者是一组Handler，Logger会将日志交给关联的Handler去做处理，由Handler负责将日志做记录。Handler具体实现了日志的输出位置，比如可以输出到控制台或者是文件中等等。 Filter：过滤器，根据需要定制哪些信息会被记录，哪些信息会被略过。 Formatter：格式化组件，它负责对日志中的数据和信息进行转换和格式化，所以它决定了我们输出日志最终的形式。 Level：日志的输出级别，每条日志消息都有一个关联的级别。我们根据输出级别的设置，用来展现最终所呈现的日志信息。根据不同的需求，去设置不同的级别。 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 日志示例 public static void test02() { /* 日志的级别，总共七级 Level.SEVERE：（最高级）错误 Level.WARNING：警告 Level.INFO：（默认级别）消息 Level.CONFIG：配置级别 Level.FINE：详细信息（少） Level.FINER：详细信息（中） Level.FINEST：（最低级）详细信息（多） 两个特殊的级别： Level.OFF；可用来关闭日志记录 Level.ALL：启用所有日志记录 */ // Logger创建方式，参数为当前类全路径字符串com.demo.logger.jul.JULTest Logger logger = Logger.getLogger(JULTest.class.getCanonicalName()); logger.severe(\u0026#34;severe信息\u0026#34;); logger.warning(\u0026#34;warning信息\u0026#34;); logger.info(\u0026#34;info信息\u0026#34;); logger.config(\u0026#34;config信息\u0026#34;); logger.fine(\u0026#34;fine信息\u0026#34;); logger.finer(\u0026#34;finer信息\u0026#34;); logger.finest(\u0026#34;finest信息\u0026#34;); /* 输出内容：我们看到，默认是输出info及比info信息级别高的信息 三月 20, 2023 9:47:27 下午 com.demo.logger.jul.JULTest test02 严重: severe信息 三月 20, 2023 9:47:27 下午 com.demo.logger.jul.JULTest test02 警告: warning信息 三月 20, 2023 9:47:27 下午 com.demo.logger.jul.JULTest test02 信息: info信息 */ } SpringBoot日志框架 SpringBoot框架底层使用slf4j+logback的方式进行日志记录同时对于其他日志实现都提供了slf4j日志门面的集成\nSpringBoot日志使用 日志级别 trace：日志追踪信息 debug：日志详细信息 info：日志的关键信息 默认打印级别 warn：日志警告信息 error：日志错误信息 只有级别大于日志核心配置文件的 rootlevel 的信息才会输出，SpringBoot默认的 rootlevel 是info\n可以在application.yml中进行 rootlevel 的修改\n1 2 3 4 5 6 7 8 9 10 #修改全局的rootlevel logging: level: root: #可以只修改某个包下日志的rootlevel #示例 logging: level: com: example: 日志记录器声明 方法一：Java语句声明\n1 2 //1.声明日志记录器 Logger logger=LoggerFactory.getLogger(全类名) 方法二：使用注解@Slf4j(这个注解基于lombok依赖)\n1 2 3 4 @Slf4j public class userController{ } ​\n日志格式 默认格式 日期和时间：毫秒精度，易于排序 日志级别：ERROR，WARN，INFO，DEBUG，或TRACE 进程ID \u0026mdash;：分离器来区分实际日志消息的开始。 线程名称:用方括号括起来(对于控制台输出可能会被截断) 记录器名称:这通常是源类名称(通常缩写)。 日志消息。 修改默认格式 可以在application.yml中修改logging.pattern.console属性来修改格式详情常见SpringBoot官方文档\n1 2 3 logging: pattern: console: SpringBoot官方文档\n日志输出 日志默认在控制台输出，可以通过修改applicaiton.yml中的logging.file.name和logging.file.path来输出日志文件\n1 2 3 4 5 6 7 8 logging: file: #只指定name属性不指定path属性则默认日志文件输出在项目的根目录中 #name属性可以同时指定输出路径和日志文件名例如D:/mylog.log name:日志文件名 #不可以指定文件名，只能指定一个物理文件夹路径，默认文件名为spring.log path:日志文件的输出路径 日志的归档和迭代 在application.yml中可以设置相关参数实现日志的归档和迭代\n名称 描述 logging.logback.rollingpolicy.file-name-pattern 归档的文件名 logging.logback.rollingpolicy.clean-history-on-start 是否在应用程序启动时进行日志归档清理。 logging.logback.rollingpolicy.max-file-size 归档前日志文件的最大大小。 logging.logback.rollingpolicy.total-size-cap 删除日志档案之前可以使用的最大大小 logging.logback.rollingpolicy.max-history 保留日志存档的天数(默认为7) 示例代码\n1 2 3 4 5 6 logging: file: name: 日志文件名 path: 日志文件的输出路径 max-file-size: 日志文件的最大大小(日志文件超出该大小则生成归档的压缩包) max-history: 日志文件保留的时间 切换日志框架 将SpringBoot底层默认日志框架logback修改为log4j2\n排除logback的场景启动器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;!‐‐starter‐web里面自动添加starter‐logging 也就是logback的依赖‐‐\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring‐boot‐starter‐web\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;!‐‐排除starter‐logging 也就是logback的依赖‐‐\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;spring‐boot‐starter‐logging\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 添加log4j2的场景启动器\n1 2 3 4 5 \u0026lt;!‐‐Log4j2的场景启动器‐‐\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring‐boot‐starter‐log4j2\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; ","date":"2024-11-09T19:20:26+08:00","permalink":"https://Tyritic.github.io/p/springboot%E7%83%AD%E9%83%A8%E7%BD%B2%E5%92%8C%E6%97%A5%E5%BF%97/","title":"SpringBoot热部署和日志"},{"content":"分模块设计与开发 将项目的不同业务功能划分为不同的Maven模块\n优点\n方便项目的维护拓展 方便模块的相互调用 继承 概念：继承描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。 作用：简化依赖配置、统一管理依赖（所有子工程共有的依赖配置在父工程中）\n所有的SpringBoot项目都继承一个统一的父工程spring-boot-starter-parent\n具体实现： 创建maven模块，该工程为父工程，设置打包方式pom(默认jar)\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.itheima\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.8-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; 在子工程的pom.xml文件中，配置继承关系。\n1 2 3 4 5 6 \u0026lt;parents \u0026lt;groupId\u0026gt;com.itheima\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;../ tlias-parent/pom,xml\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; 提示\n在子工程中，配置了继承关系之后，坐标中的groupId是可以省略的，因为会自动继承父工程的 relativePath指定父工程的pom文件的相对位置(如果不指定，将从本地仓库/远程仓库查找该工程)。 在父工程中配置各个工程共有的依赖(子工程会自动继承父工程的依赖)。 提示\n若子工程和父工程的依赖版本不同，以子工程的为准 打包方式 pom：父工程，该模块无代码只进行依赖管理 jar：内嵌Tomcat服务器 war：普通web程序，部署在在外部Tomcat服务器 版本锁定 在maven中，可以在父工程的pom文件中通过\u0026lt;dependencyManagement \u0026gt;来统一管理依赖版本。\n在父工程的pom文件中指定依赖版本后，子工程引入依赖时不需要指定依赖版本，变更依赖版本时在父工程的pom文件中统一更改\n示例\n1 2 3 4 5 6 7 8 9 10 11 #父工程 \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--JWT令牌--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 1 2 3 4 5 6 7 #子工程 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 提示\n\u0026lt; dependencies \u0026gt;和\u0026lt; dependencyManage \u0026gt;的区别\n\u0026lt; dependencies \u0026gt;是直接依赖，子工程的pom无须引入 \u0026lt; dependencyManage \u0026gt;是版本管理，子工程的pom依然需要引入 自定义属性/引用属性 可以在pom文件中使用标签\u0026lt;properties\u0026gt;标签来自定义属性\n1 2 3 4 \u0026lt;properties\u0026gt; \u0026lt;lombok.versiqn\u0026gt;1.18.24\u0026lt;/lombok.version\u0026gt; \u0026lt;jjwt.version\u0026gt;8.9.0\u0026lt;/jjwt.version\u0026gt; \u0026lt;/properties\u0026gt; 然后使用${}来引用自定义属性\n1 2 3 4 5 6 7 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${lombok.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 聚合 概述：将多个模块组织成一个整体，同时进行项目的构建。 聚合工程：一个不具有业务功能的“空”工程(有且仅有一个pom文件)通常是继承中的父工程 具体实现：在父工程中使用标签\u0026lt;module\u0026gt;指定子模块\n1 2 3 4 5 \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;../tlias-pojo\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;,./tlias-utils\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../tlias-web-management\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; 提示\n聚合工程中所包含的模块，在构建时，会自动根据模块间的依赖关系设置构建顺序，与聚合工程中模块的配置书写位置无关。\n继承和聚合的区别 作用\n聚合用于快速构建项目 继承用于简化依赖配置、统一管理依赖 相同点\n聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中 聚合与继承均属于设计型模块，并无实际的模块内容 不同点\n聚合是在聚合工程中配置关系，聚合可以感知到参与聚合的模块有哪些 继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己 ","date":"2024-11-09T12:27:38+08:00","permalink":"https://Tyritic.github.io/p/maven%E9%AB%98%E7%BA%A7/","title":"Maven高级"},{"content":"起步依赖 原理：SpringBoot框架提供的起步依赖通过Maven的依赖传递集成了开发中常见的依赖\n自动配置 概念 当spring容器启动后，一些配置类、bean对象就自动存入到了I0C容器中，不需要手动去声明，从而简化了开发，省去了繁琐的配置操作。\n实现方案 方案一：@ComponentScan 组件扫描依赖 1 2 3 4 @SpringBootApplication @ComponentScan({\u0026#34;com.alibaba\u0026#34;,\u0026#34;com.google\u0026#34;,\u0026#34;org.springframework\u0026#34;,\u0026#34;org.mybatis\u0026#34;,...} public class springbootWebconfig2Application{ } 方案二：@lmport 导入 使用@lmport导入的类会被Spring加载到I0C容器中，导入形式主要有以下几种:\n导入 普通类 导入 配置类 导入 ImportSelector 接口实现类 @EnableXXX注解，封装了@Import 1 2 3 4 5 @Import({TokenParser.class,Headerconfig.class}) @SpringBootApplication public class springbootWebconfig2Application{ } 源码分析 查看启动类的注解**@SpringBootApplication**的源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //自定义组件所需的元注解 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited //表示启动类也是一个配置类 @SpringBootConfiguration //自动配置功能 @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) 提示\n问：为什么在启动类中可以声明第三方Bean对象？\n答：@SpringBootApplication中封装了@SpringBootConfiguration，表明启动类也是一个配置类\n问：为什么启动类只会扫描启动类所在包及其子包的组件\n答：@SpringBootApplication中封装了@ComponentScan的注解\n由 @SpringBootApplication 的注解源码可知自动配置由注解 @EnableAutoConfiguration 提供，查看 @EnableAutoConfiguration的注解\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import({AutoConfigurationImportSelector.class}) public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = \u0026#34;spring.boot.enableautoconfiguration\u0026#34;; Class\u0026lt;?\u0026gt;[] exclude() default {}; String[] excludeName() default {}; } 可以看出 @EnableAutoConfiguration 注解通过 @Import注解导入 ImportSelector 接口实现类来实现自动配置\n查看AutoConfigurationImportSelector.class 的源码\n1 2 3 4 5 6 7 8 public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!this.isEnabled(annotationMetadata)) { return NO_IMPORTS; } else { AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); } } selectImports方法返回要导入的Bean对象的全类名\n从 AutoConfigurationImportSelector.class 的源码可以知道返回值从 autoConfigurationEntry.getConfigurations() 获得而autoConfigurationEntry 由 AutoConfigurationImportSelector.getAutoConfigurationEntry方法获得。查看 getAutoConfigurationEntry 的源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) { if (!this.isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } else { AnnotationAttributes attributes = this.getAttributes(annotationMetadata); List\u0026lt;String\u0026gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); configurations = this.removeDuplicates(configurations); Set\u0026lt;String\u0026gt; exclusions = this.getExclusions(annotationMetadata, attributes); this.checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = this.getConfigurationClassFilter().filter(configurations); this.fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); } } 从 AutoConfigurationImportSelector.getAutoConfigurationEntry看出 configuration是一个List\u0026lt;String\u0026gt;对象，从AutoConfigurationImportSelector.getCandidateConfigurations(annotationMetadata, attributes) 中获得。查看AutoConfigurationImportSelector.getCandidateConfigurations(annotationMetadata, attributes) 的源码\n1 2 3 4 5 protected List\u0026lt;String\u0026gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { List\u0026lt;String\u0026gt; configurations = ImportCandidates.load(AutoConfiguration.class, this.getBeanClassLoader()).getCandidates(); Assert.notEmpty(configurations, \u0026#34;No auto configuration classes found in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you are using a custom packaging, make sure that file is correct.\u0026#34;); return configurations; } SpringBoot框架会自动加载 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 的配置文件并封装到 configurations 这个List集合中\n实现过程 @SpringBootApplication注解封装了 @EnableAutoConfiguration 来实现自动配置\n@EnableAutoConfiguration 封装了 @Import 注解，该注解以引入 ImportSelector接口的实现类AutoConfigurationImportSelector 来完成自动装配\nAutoConfigurationImportSelector 获取 AutoConfigurationEntry 对象，该对象具有成员变量Configurations用于存储Bean对象的全类名\nAutoConfigurationEntry 使用 getCandidateConfigurations方法，SpringBoot框架会自动加载 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 配置文件并封装到 configurations 这个List集合中\nMETA-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 中封装了Bean对象的声明\n条件配置 @Conditional 作用：按照一定的条件进行判断，在满足给定条件后才会注册对应的bean对象到SpringIOC容器中。\n位置：方法、类\n@Conditional 本身是一个父注解，派生出大量的子注解:\n@Conditional0nClass：判断环境中是否有对应字节码文件，才注册bean到IOC容器。 @ConditionalOnMissingBean：判断环境中没有对应的bean(类型或名称)，才注册bean到IOC容器。 @ConditionalOnProperty：判断配置文件中有对应属性和值，才注册bean到IOC容器。 ","date":"2024-11-08T18:47:12+08:00","permalink":"https://Tyritic.github.io/p/springboot%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","title":"SpringBoot底层原理"},{"content":"Bean对象的获取 默认情况下，Spring项目启动时，会把bean都创建好放在IOC容器中\n提示\n上述所说的【Spring项目启动时，会把其中的bean都创建好】还会受到作用域及延迟初始化影响，这里主要针对于默认的单例非延迟加载的bean而言。\n但可以主动获取Bean对象\n具体实现\n注入IOC容器对象：ApplicationContext 1 2 3 根据name获取bean: Object getBean(String name) 根据类型获取bean：\u0026lt;T\u0026gt;T getBean(class\u0026lt;T\u0026gt; requiredType) 根据name获取bean(带类型转换)：\u0026lt;T\u0026gt;T getBean(String name,Class\u0026lt;T\u0026gt;requiredType) Bean对象的作用域 Spring支持五种作用域，后三种在web环境才生效\n作用域 说明 singleton 容器内同 名称 的 bean 只有一个实例(单例)(默认) prototype 每次使用该 bean 时会创建新的实例(非单例) request 每个请求范围内会创建新的实例(web环境中，了解) session 每个会话范围内会创建新的实例(web环境中，了解) application 每个应用范围内会创建新的实例(web环境中，了解) 使用@Scope注解来指定作用域\n1 2 3 4 5 @Scope(\u0026#34;prototype\u0026#34;) @RestController @RequestMapping(\u0026#34;/depts\u0026#34;) public class DeptController { } 警告\n注意事项\n默认singleton的bean，在容器启动时被创建，可以使用@Lazy注解来延迟初始化(延迟到第一次使用时)prototype的bean，每一次使用该bean的时候都会创建一个新的实例。 实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性。 第三方Bean对象 如果要管理的bean对象来自于第三方(不是自定义的)，是无法用 @Component及衍生注解声明bean的，就需要用到 @Bean注解。\n具体实现\n​\t方法一：在启动类中使用@Bean注解修饰一个返回值为Bean对象的方法（不推荐）\n1 2 3 4 5 6 @springBootApplication public class springbootWebconfig2Application { @Bean/将方法返回值交给I0C容器管理,成为IOC容器的bean对象 public SAXReader saxReader(){ return new SAXReader(); } 方法二：创建一个配置类（使用@Configuration)集中配置Bean对象\n1 2 3 4 5 6 @Configuration public class commonconfig{ @Bean/将方法返回值交给I0C容器管理,成为IOC容器的bean对象 public SAXReader saxReader(){ return new SAXReader(); } 提示\n通过@Bean注解的name或value属性可以声明bean的名称，如果不指定，默认bean的名称就是方法名 如果第三方bean需要依赖其它bean对象，直接在bean定义方法中设置形参即可，容器会根据类型自动装配。 ","date":"2024-11-08T17:05:51+08:00","permalink":"https://Tyritic.github.io/p/bean%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%AE%A1%E7%90%86/","title":"Bean对象的管理"},{"content":"配置方式 文件配置 properties文件 yml文件 yaml文件 Java系统属性 设置方法 执行maven打包指令package\n执行java指令，运行jar包，在执行java命令时添加参数\n参数格式\n1 -Dxxx=xxx 命令行参数 执行maven打包指令package\n执行java指令，运行jar包，在执行java命令时添加参数\n参数格式\n1 --xxx=xxx 配置优先级 优先级从低到高\napplication.yam](忽略) application.yml application.properties java系统属性(-Dxxx=xxx) 命令行参数(\u0026ndash;xxx=xxx) ","date":"2024-11-08T16:37:30+08:00","permalink":"https://Tyritic.github.io/p/springboot%E9%85%8D%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7/","title":"SpringBoot配置优先级"},{"content":"概述 AOP就是是Aspect Oriented Programming(面向切面编程、面向方面编程)，其实就是面向特定方法编程\n底层实现：动态代理是面向切面编程最主流的实现。而SpringAOP是Spring框架的高级技术，旨在管理bean对象的过程中，主要通过底层的动态代理机制，对特定的方法进行编程。\n应用场景\n记录操作日志 权限控制 事务管理 具体实现 导入相关依赖\n编写AOP程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Component @Aspect public class TimeAspect { @Around(\u0026#34;execution()”) public Object recordTime(ProceedingJoinPoint proceedingJoinPoint)throws Throwable { long begin=System.currentTimeMillis(); 0bject object=proceedingJoinPoint.proceed();//调用原始方法运行 long end=System.currentTimeMillis(); log.info(proceeding]oinPoint.getsignature()+\u0026#34;执行耗时:{}ms\u0026#34;,end - begin); return object; } } AOP核心概念 连接点（JoinPoint）：可以被AOP控制的方法(暗含方法执行时的相关信息)\n通知（Advice）：指哪些重复的逻辑，也就是共性功能\n体现为被@Around()修饰的方法 切入点（PointCut）：匹配连接点的条件，通知仅会在切入点方法执行时被应用\n相关注解：@Around(\u0026ldquo;execution()”) 切面（Aspect）：描述通知与切入点的对应关系(通知+切入点)\n相关注解：@Aspect用于修饰类 目标对象（Target）：通知所应用的对象\nAOP执行流程 底层为目标对象生成代理对象 在代理对象中使用通知对目标对象的连接点做功能增强 在依赖注入时注入代理对象 AOP通知 通知类型 @Around:环绕通知，此注解标注的通知方法在目标方法前、后都被执行 @Before:前置通知，此注解标注的通知方法在目标方法前披执行 @After :后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行 @AfterReturning: 返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行 @AfterThrowing: 异常后通知，此注解标注的通知方法发生异常后执行 提示\n@Around环绕通知需要自己调用 ProceedingJoinPoint.proceed()来让原始方法执行，其他通知不需要考虑目标方法 执行@Around环绕通知方法的返回值，必须指定为Object，来接收原始方法的返回值。 通知顺序 当有多个切面的切入点都匹配到了目标方法，目标方法运行时，多个通知方法都会被执行\n不同切面类的通知顺序 目标方法前的通知方法：字母排名靠前的先执行 目标方法后的通知方法：字母排名靠前的后执行 用注解@Order(数字) 加在切面类上来控制顺序 目标方法前的通知方法:数字小的先执行 目标方法后的通知方法:数字小的后执行 同一个切面类的通知顺序 Around-Before Before Around-after after 切入点表达式 切入点表达式：描述切入点方法的一种表达式 作用：主要用来决定项目中的哪些方法需要加入通知\nexecution(….)根据方法的签名来匹配 execution 主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配\n语法：execution(访问修饰符? 返回值 包名.类名.?方法名(方法参数)throws 异常?)\n带?的部分可以省略\n访问修饰符:可省略(比如:public、protected) 包名.类名: 可省略 throws 异常:可省略(注意是方法上声明抛出的异常，不是实际抛出的异常) 通配符\n*：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分\n1 execution(* com.*.service.*.update*(*)) :：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数\n1 execution(* com.itheima..Deptservice.*(..)) @annotation(.):根据注解匹配 @annotation切入点表达式，用于匹配标识有特定注解的方法\n语法：@annotation(全类名)\n1 2 3 4 @Before(\u0026#34;@annotation(com.itheima.anno.Log)\u0026#34;) public void before(){ log.info(\u0026#34;before ....\u0026#34;); } 提示\n@PointCut 该注解的作用是将公共的切点表达式抽取出来，需要用到时引用该切点表达式即可\n1 2 3 4 5 6 @Pointcut(\u0026#34;execution()\u0026#34;) public void pt(){) @Around(\u0026#34;pt()\u0026#34;) public Object recordrime(ProceedingjoinPoint joinPoint) throws Throwable { } 注意事项\nprivate:仅能在当前切面类中引用该表达式 public:在其他外部的切面类中也可以引用该表达式 连接点 在Spring中用JoinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等。\n对于 @Around 通知，获取连接点信息只能使用ProceedingJoinPoint\n对于其他四种通知，获取连接点信息只能使用JoinPoint，它是ProceedingJoinPoint 的父类型\n相关方法\n1 2 3 4 5 6 7 8 9 @Around(\u0026#34;execution()\u0026#34;) public object around(Proceeding)oinPoint joinPoint)throws Throwable { String className=joinPoint.getTarget().getc1ass().getName(); //获取目标类名 Signature signature=joinPoint.getsignature();//获取目标方法签名 String methodName= joinPoint.getsignature().getName();//获取目标方法名 0bject[]args = joinPoint.getArgs();//获取目标方法运行参数 0bject res= joinPoine.proceed();/执行原始方法,获取返回值(环绕通知) return res; } 1 2 3 4 5 6 7 8 @Before(\u0026#34;execution(\u0026#34;\u0026#34;)) public void befored(JoinPoint joinPoint) { String className=joinPoint.getTarget().getclass().getName();//获取目标类名 Signature signature=joinPoint.getsignature();//获取目标方法签名 String methodName =joinPoint.getsignature().getName();//获取目标方法名 0bject[]args= joinPoint.getArgs();//获取目标方法运行参数 } ","date":"2024-11-07T18:38:05+08:00","permalink":"https://Tyritic.github.io/p/aop/","title":"AOP"},{"content":"数据库中的事务 概念：事务是一组操作的集合，它是一个不可分割的工作单位，这些操作 要么同时成功，要么同时失败。\n操作\n开启事务(一组操作开始前，开启事务)\n1 start transaction; 提交事务(这组操作全部成功后，提交事务)\n1 commit; 回滚事务(中间任何一个操作出现异常，回滚事务)\n1 rollback; Spring中的事务管理 @Transactional 注解\n位置：service层的方法，类，接口上\n修饰方法\n1 2 3 4 5 6 @Transactional @Override public void delete(Integer id){ deptMapper.delete(id); empMapper.deleteByDeptId(id); } 修饰类\n1 2 3 4 @Transactional @Service public class DeptServiceImpl implements DeptService{ } 修饰接口\n1 2 3 4 @Transactional public interface DeptService { } 作用：将当前方法交给spring进行事务管理\n方法执行前，开启事务; 成功执行完毕，提交事务; 出现异常，回滚事务 事务属性 回滚 默认情况下，只有出现 RuntimeException 才回滚异常。rollbackFor 属性用于控制出现何种异常类型，回滚事务。\n示例代码\n1 2 3 4 5 6 @Transactional(rollbackFor=Exception.class) @Override public void delete(Integer id)throws Exception { deptMapper.deleteById(id); empMapper.deleteByDeptId(id); } 传播行为 传播行为：指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制。\n常见的传播行为属性\n属性值 含义 REQUIRED 【默认值】需要事务，有则加入，无则创建新事务 REQUIRES_NEW 需要新事务，无论有无，总是创建新事务 SUPPORTS 支持事务，有则加入，无则在无事务状态中运行 NOT_SUPPORTED 不支持事务，在无事务状态下运行,如果当前存在已有事务,则挂起当前事务 MANDATORY 必须有事务，否则抛异常 NEVER 必须没事务，否则抛异常 使用场景\nREQUIRED：大部分情况下都是用该传播行为即可。 REOUIRES NEW：当我们不希望事务之间相互影响时，可以使用该传播行为。比如:下订单前需要记录日志，不论订单保存成功与 否，都需要保证日志记录能够记录成功。 ","date":"2024-11-07T16:51:41+08:00","permalink":"https://Tyritic.github.io/p/springboot%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/","title":"SpringBoot事务管理"},{"content":"项目开发过程中会遇到异常问题\n全局异常处理器 @RestControllerAdvice：用于修饰类表示全局异常处理器\n@ExceptionHandler：用于修饰异常处理方法\n示例代码\n1 2 3 4 5 6 @RestControllerAdvice puhlic class GlobalExceptionHandler { @ExceptionHandler(Exception.class) public Result ex(Exception ex){ex.printstackTrace(); return Result.error(”对不起,操作失败,请联系管理员\u0026#34;); } 全局异常 在common包下定义基本异常BaseException，其余的异常为这个类的子类\n示例代码\n1 2 3 4 5 6 7 8 9 10 public class BaseException extends RuntimeException { public BaseException() { } public BaseException(String msg) { super(msg); } } ","date":"2024-11-07T16:33:35+08:00","permalink":"https://Tyritic.github.io/p/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","title":"异常处理"},{"content":"简介 Spring框架中提供的，用来动态拦截控制器方法的执行。 作用:拦截请求，在指定的方法调用前后，根据业务需要执行预先设定的代码。\n具体实现 定义Interceptor类，实现HandlerInterceptor接口并重写方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Component public class LoginCheckInterceptor implements HandlerInterceptor { @0verride //目标资源方法执行前执行，放回true:放行，返回false:不放行 public boolean prehandle(HttpServletRequest reg, HttpServletResponse resp, object handler) throws Exception { System.out.println(\u0026#34;preHandle ...\u0026#34;); return true; } @Override //目标资源方法执行后执行 public void postHandle(HttpservletRequest req, HttpServletResponse resp, object handler, ModelAndview modelAndview){ System.out.println(\u0026#34;postHandle..\u0026#34;); } @0verride //视图渲染完毕后执行，最后执行 public void afterCompletion (HttSservietReguest reg, HttpServletResponse resp, Object handler, Exception ex) { System.out.println(\u0026#34;aftercompletion ...\u0026#34;); } } 注册拦截器\n1 2 3 4 5 6 7 8 9 10 11 @Configuration public class webConfig implements WebMvcConfigurer { @Autowired private LoginCheckInterceptor logincheckInterceptor; @Override public void addInterceptors(InterceptorRegistry registry){ registry.addInterceptor (logincheckInterceptor) .addPathPatterns(\u0026#34;拦截路径\u0026#34;) .excludePathPatterns(\u0026#34;放行路径\u0026#34;) } } 拦截路径 拦截器可以根据需求，配置不同的拦截路径:\n拦截路径 含义 示例 /* 所有的一级路径 /depts /** 任意级路径 /depts，/depts/1 /depts/* /depts下的一级路径 /depts/1 /depts/** /depts下的任意级路径 /depts/emp/1 执行流程 请求先进入过滤器还未进入Spring容器中 经过过滤器的校验后进入DispatcherServlet 请求到达拦截器进行校验 提示\n接口规范不同: 过滤器需要实现Filter接口 拦截器需要实现Handlerinterceptor接口。 拦截范围不同: Filter会拦截所有的资源 Interceptor只会拦截Spring环境中的资源。 ","date":"2024-11-07T15:49:32+08:00","permalink":"https://Tyritic.github.io/p/interceptor/","title":"Interceptor"},{"content":"概述 Filter 过滤器是JavaWeb 三大组件(Servlet、Filter、Listener)之一。\n作用：过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。\n使用场景：过滤器一般完成一些通用的操作，比如:登录校验、统一编码处理、敏感字符处理等。\n具体实现 定义Filter类：实现 Filter接口，并重写其所有方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @WebFilter(urlPatterns =\u0026#34;/*\u0026#34;) public class DemoFilter implements Filter { //初始化方法,Web服务器启动,创建Filter时调用，只调用一次 public void init (Filterconfig filterconfig)throws ServletException { Filter.super.init(filterConfig); } ///拦截到请求时,调用该方法,可调用多次 public void doFilter (ServletRequest request, servletResponse response, Filterchain chain){ System.out.println(\u0026#34;拦截方法执行，拦截到了请求...\u0026#34;); System.out.println(\u0026#34;执行放行前的逻辑...\u0026#34;); chain.doFilter(request,response);// 放行请求 System.out.println(\u0026#34;执行放行后的逻辑...\u0026#34;); } //销毁方法，服务器关闭时调用，只调用一次 public void destroy(){ Filter.super.destroy(); } } 配置Filter：使用@WebFilter注解，配置拦截资源的路径。\n引导类上加 @ServletComponentScan 开启Servlet组件支持。\n1 2 3 4 5 @ServletComponentScan @SpringBootApplication public class TliasWebManagementApplication{public static void main(stringl] args){ SpringApplication.run(TliasWebManagementApplication.class, args); } 执行流程 过滤器拦截到请求 过滤器执行doFilter()之前的部分作为放行前的逻辑 过滤器执行doFilter()放行请求 过滤器执行doFilter()之后的部分作为放行后的逻辑 提示\n放行后访问对应资源，资源访问完成后，还会回到Filter中 回到Filter中执行放行后的逻辑 拦截路径 Filter 可以根据需求，配置不同的拦截资源路径\n拦截路径 urlPattern 含义 拦截具体路径 /login 只有访问/login才被拦截 目录拦截 /emp/* 访问emp目录下的资源都被拦截 拦截所有 /* 访问所有资源都被拦截 过滤器链 一个web应用中，可以配置多个过滤器，这多个过滤器就形成了一个过滤器链\n顺序：注解配置的Filter，优先级是按照过滤器类名(字符串)的自然排序\n","date":"2024-11-07T14:50:40+08:00","permalink":"https://Tyritic.github.io/p/filter/","title":"Filter"},{"content":"登录功能实现的基本思路 登录标记 用户登录成功之后，每一次请求中，都可以获取到该标记，\n常见技术\n会话技术 登录校验 对接收到的请求进行统一拦截\n常见技术\n过滤器（Filter） 拦截器（Interceptor） 登录标记 会话技术 用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。\n会话跟踪 一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。\n会话跟踪方案\n客户端会话跟踪技术:Cookie 服务端会话跟踪技术:Session 令牌技术 Cookies 基本流程\n浏览器第一次向服务端发出请求时服务端设置Cookies 服务端给浏览器响应并设置响应头的Set-Cookie 浏览器解析Cookie值并保存在浏览器本地 后续的每次请求中浏览器会将Cookis数据放入请求头中 优点：HTTP协议支持的技术\n缺点\n移动端APP不支持cookie 不安全，用户可以自己禁用Cookie Cookies不能跨域 提示\n跨域被分为三个维度：协议，IP，端口，三者有一个不同就是跨域\nSession 基本流程\n浏览器第一次向服务器端发出请求，此时服务器端没有Session对象 服务器端生成Session对象并将Session对象放入响应的响应头（Set-Cookies） 浏览器保存Session对象并在此后的每次请求中以请求头的Cookies数据附带Session对象 服务器会寻找到请求Cookies中的Session对象从而实现数据共享 优点：存储在服务器端安全\n缺点\n服务器集群中无法直接使用Session技术 Session技术基于Cookies技术，继承了Cookies的全部缺点 令牌技术 基本流程\n浏览器发出请求后，服务端生成令牌作为身份凭证放入响应 此后的每一次请求浏览器的请求携带会携带令牌 服务端则会校验令牌 优点:\n支持PC端、移动端 解决集群环境下的认证问题 减轻服务器端存储压力 JWT令牌技术 简介：全称:jSON Web Token(https://jwt.io/) 定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。\n令牌结构 第一部分:Header(头)，记录令牌类型、签名算法等。 第二部分:Payload(有效载荷)，携带一些自定义信息、默认信息等。 第三部分:Signature(签名)，防止Token被篡改、确保安全性。将header、payload，并加入指定秘钥，通过指定签名算法计算而来。 使用场景：登录认证 登录成功后服务端生成令牌，通过响应返回给客户端 此后每个请求都要携带JWT令牌，服务端每次处理请求前都要校验令牌，校验通过后再处理 具体实现 引入JWT相关依赖 将JWT数字签名的相关部分放入Properties文件中以备引用 书写JWT工具类的生成方法和解析方法 生成JWT令牌 具体思路\n指定签名算法 使用令牌持续时间来计算令牌的过期时间 生成JWT令牌函数Jwts.builder() 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * 创建jwt * 加密算法：HS256 * 私钥使用jwtProperties中的userSecretKey * @param claims 载荷 * @return jwt */ public String createJwt(Map\u0026lt;String, Object\u0026gt;claims) { String userSecretKey = jwtProperties.getUserSecretKey(); //自定义密钥 long userTtl = jwtProperties.getUserTtl(); //令牌持续时间 SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; //指定签名算法 long nowMillis = System.currentTimeMillis(); Date exp = new Date(nowMillis + userTtl); //令牌过期时间 JwtBuilder builder = Jwts.builder() //生成JWT令牌 .setClaims(claims) //设置载荷 .signWith(signatureAlgorithm, userSecretKey.getBytes()) //设置数字签名（签名算法，过期时间） .setExpiration(exp); //设置过期时间 return builder.compact(); } 解析JWT令牌 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * 解密jwt * @param token jwt * @return jwt中的数据 */ public Claims parseJwt(String token) { //获取jwtProperties中的userSecretKey String userSecretKey = jwtProperties.getUserSecretKey(); return Jwts.parser() .setSigningKey(userSecretKey.getBytes(StandardCharsets.UTF_8)) .parseClaimsJws(token) .getBody(); } 登录校验 过滤器（Filter） 参见博客Filter\n拦截器（interceptor） 参见博客Interceptor\n","date":"2024-11-07T13:11:16+08:00","permalink":"https://Tyritic.github.io/p/%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/","title":"登录功能"},{"content":"配置文件的种类 SpringBoot提供了多种属性配置方式\napplication.properties\n1 2 server.port=8080 server.address=127.0.0.1 application.yml\n1 2 3 server: port:8080 address:127.0.0.1 application.yaml\n1 2 3 server: port:8080 address:127.0.0.1 配置文件优先级 优先级从高到低：properties\u0026gt;yml\u0026gt;yaml\n外部配置文件的优先级（从低到高）\nclasspath（resource文件夹） classpath根config 项目根目录（对于存在继承/聚合关系的maven项目项目根目录是父工程的根目录） 项目根目录/config 直接子目录/config 多配置文件的加载 Profile意思是配置，不同环境可能需要不同的配置需要\nSpringBoot框架提供了多profile的管理功能，我们可以使用profile文件来区分不同环境的配置\n基本语法 如果需要创建自定义的yml文件时，可以用application-{profile}.yml的命名方式\n切换不同环境的yml文件时在application.yml中配置\n1 2 3 spring: profiles: active: profile yml文件语法 基本语法 大小写敏感 数值前边必须有空格，作为分隔符 使用缩进表示层级关系，缩进时，不允许使用Tab键，只能用空格(idea中会自动将Tab转换为空格) 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 #表示注释，从这个字符一直到行尾，都会被解析器忽略 数据格式 对象/Map集合\n1 2 3 4 user: name: zhangsan age: 18 password:123456 数组/List集合\n1 2 3 4 hobby: -java -game -sport 参数配置化 利用注解进行参数配置化 @Value 注解通常用于外部配置的属性注入，具体用法为: @Value(\u0026quot;${配置文件中的key}\u0026quot;)\n示例代码\n1 2 3 4 aliyun.oss.endpoint=https://oss-cn-hangzhou.aliyuncs.com aliyun.oss.accessKeyId=LTAI4GCHlvX6DKqJWxdбnEuW aliyun.oss.accessKeySecret=yBshYweHOpqDuhCArrVHwIiBKPYqSL aliyun.oss.bucketName=web-tlias 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Component pubiic class AliossUti1s{ @Value(\u0026#34;${aliyun.oss.endpoint}\u0026#34;) private string endpoint; @Value(\u0026#34;${aliyun.oss.accessKeyId}\u0026#34;) private string accesskeyId; @Value(\u0026#34;${aliyun.oss.accessKeySecret}\u0026#34;) private String accessKeySecret; @Value (\u0026#34;${aliyun.oss.bucketName } \u0026#34;) private String bucketName } 使用自定义配置类进行参数配置化 自定义properties文件使用@Component注册为Bean对象，使用 @ConfigurationProperties 注解批量的将yml配置文件的属性和Bean对象属性绑定，@ConfigurationProperties 的prefix属性指定application.yml的子节点，该节点中的子节点将自动和属性进行绑定\n示例代码\n1 2 3 4 5 6 7 8 9 10 @Data @Component @ConfigurationProperties(prefix = \u0026#34;operator.aliyun.oss\u0026#34;) public class AliyunOSSProperties { String endpoint; String accessKeyId; String accessKeySecret; String bucketName; String region; } @ConfigurationProperties 支持jsr-300数据校验使用 @Validate\n提示\n​\tjsr-300数据校验\n@Null：被注释的元素必须为 null @NotNull：被注释的元素必须不为nu11 @AssertTrue：被注释的元素必须为true @AssertFalse：被注释的元素必须为false @Min(value)：被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value)：被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value)：被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value)：被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max，min)：被注释的元素的大小必须在指定的范围内 @Digits (integer,fraction)：被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past：被注释的元素必须是一个过去的日期 @Future：被注释的元素必须是一个未来的日期 ","date":"2024-11-07T10:19:39+08:00","permalink":"https://Tyritic.github.io/p/springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","title":"SpringBoot配置文件"},{"content":"简介 文件上传，是指将本地图片、视频、音频等文件上传到服务器，供其他用户浏览或下载的过程。\n实现要点 前端页面 表单项 type=“file” 表单提交方式 post 表单的enctype属性 multipart/form-data 后端controller类 使用MultipartFile接收文件 实现方式 上传到本地 常见方法\n1 2 3 4 5 - String getOriginalFilename(); //获取原始文件名 - void transferTo(File dest); //将接牧的文件转存到磁盘文件中 - long getSize(); //获取文件的大小，单位:字节 - byte[] getBytes();//获取文件内容的字节数组 - InputStream getinputStream(); //获取接收到的文件内容的输入流 具体实现\n1 2 3 4 5 6 7 8 9 10 11 12 @RestController public class UploadController { @PostMapping(\u0026#34;/upload\u0026#34;) public Result upload(MultipartFile image) throws IOException //获取原始文件名 String originalFilename =image.getOriginalFilename(): //构建新的文件名 String newfileName = UUID.,randomUUID.toString()+originalFilename.substring(originalFilename.lastindexOf(\u0026#34;.\u0026#34;)); //将文件保存在服务器端 E:/images目景下 image.transferTo(new File(\u0026#34;E:/images/\u0026#34;+newFileName)): return Result,success(); } 提示\n在SpringBoot中，文件上传，默认单个文件允许最大大小为1M。如果需要上传大文件，可以进行在application.yml如下配置:\n1 2 3 4 spring: servlet: multipart.max-file-size=10MB #配置单个文件最大上传大小 max-request-size=100MB #配置单个请求最大上传大小(一次请求可以上传多个文件) 阿里云OSS存储 基本概念\nBucket：存储空间是用户用于存储对象(0bject，就是文件)的容器，所有的对象都必须隶属于某个存储空间。 SDK:Software Development Kit 的缩写，软件开发工具包，包括辅助软件开发的依赖(jar包)、代码示例等，都可以叫做SDK。 具体实现\n创建bucket并获取AccessKey\n在pom.xml中引入相关依赖\n将aliyunOSS服务所需的相关参数写入配置文件application.yml中，并专门建立一个properties配置文件\n将相关方法写入工具类中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 public String upload(MultipartFile file) throws ClientException { if(file==null||file.isEmpty()){ return null; } String endpoint = aliyunOSSProperties.getEndpoint(); String bucketName = aliyunOSSProperties.getBucketName(); String region = aliyunOSSProperties.getRegion(); String accessKeyId = aliyunOSSProperties.getAccessKeyId(); String accessKeySecret = aliyunOSSProperties.getAccessKeySecret(); // 创建OSSClient实例 ClientBuilderConfiguration clientBuilderConfiguration = new ClientBuilderConfiguration(); CredentialsProvider defaultCredentialProvider = new DefaultCredentialProvider(accessKeyId, accessKeySecret); OSS ossClient= OSSClientBuilder.create() .endpoint(endpoint) .credentialsProvider(defaultCredentialProvider) .clientConfiguration(clientBuilderConfiguration) .region(region) .build(); String originalFilename = file.getOriginalFilename(); String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(\u0026#34;.\u0026#34;)); try { InputStream fileInputStream = file.getInputStream(); ossClient.putObject(bucketName, fileName, fileInputStream); String url=endpoint.split(\u0026#34;//\u0026#34;)[0]+\u0026#34;/\u0026#34;+bucketName+\u0026#34;.\u0026#34;+endpoint.split(\u0026#34;//\u0026#34;)[1]+\u0026#34;/\u0026#34;+fileName; return url; } catch (Exception e) { log.error(\u0026#34;上传文件失败\u0026#34;, e); throw new ClientException(\u0026#34;上传文件失败\u0026#34;); } finally { ossClient.shutdown(); } } public void deleteExhibitImage(String d_url) { String endpoint = aliyunOSSProperties.getEndpoint(); String bucketName = aliyunOSSProperties.getBucketName(); String region = aliyunOSSProperties.getRegion(); String accessKeyId = aliyunOSSProperties.getAccessKeyId(); String accessKeySecret = aliyunOSSProperties.getAccessKeySecret(); String fileName=d_url.substring(d_url.lastIndexOf(\u0026#34;/\u0026#34;)+1);//从url中获取bucket中的文件名 // 创建OSSClient实例 ClientBuilderConfiguration clientBuilderConfiguration = new ClientBuilderConfiguration(); CredentialsProvider defaultCredentialProvider = new DefaultCredentialProvider(accessKeyId, accessKeySecret); OSS ossClient= OSSClientBuilder.create() .endpoint(endpoint) .credentialsProvider(defaultCredentialProvider) .clientConfiguration(clientBuilderConfiguration) .region(region) .build(); try { ossClient.deleteObject(bucketName, fileName); } catch (Exception e) { log.error(\u0026#34;删除文件失败\u0026#34;, e); } finally { ossClient.shutdown(); } } ","date":"2024-11-07T09:52:26+08:00","permalink":"https://Tyritic.github.io/p/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","title":"文件上传"},{"content":"BigInteger类和BigDecimal类 BigInteger类支持任意精度的整数，表示任何大小的整数\nBigDecimal类支持任意长度的小数\nBigInteger类和BigDecimal都是不可变类，一旦创建其值无法更改，只要产生计算操作就会产生新的对象\nBigInteger创建方法 通过有参构造器 BigInteger(String val) BigInteger(byte[] val) 通过valueOf()静态方法 BigInteger.valueOf(long val)\n1 2 3 4 5 6 7 8 9 10 import java.math.BigInteger; public class BigIntegerExample { public static void main(String[] args) { // 从 long 值创建 BigInteger 对象 BigInteger bigInt2 = BigInteger.valueOf(123456789L); System.out.println(bigInt2); // 输出：123456789 } } BigDecimal创建方法 通过有参构造器 类 创建方式 示例 注意事项 BigDecimal new BigDecimal(String val) new BigDecimal(\u0026quot;123.456789\u0026quot;) 推荐通过字符串创建，精度不会丢失。 new BigDecimal(double val) new BigDecimal(123.456) 精度可能丢失，尽量避免使用。 new BigDecimal(long val) new BigDecimal(123) 使用 long 值创建。 new BigDecimal(int val) new BigDecimal(123) 使用 int 值创建。 new BigDecimal(byte[] val) new BigDecimal(byteArray) 用字节数组创建。 通过静态方法valueOf() 1 2 3 4 5 6 7 8 9 import java.math.BigDecimal; public class BigDecimalExample { public static void main(String[] args) { // 从 long 值创建 BigDecimal 对象 BigDecimal decimal1 = BigDecimal.valueOf(123456789L); System.out.println(decimal1); // 输出：123456789 } } 创建 BigDecimal 时优先使用字符串类型的构造方法，以避免 double 转换时精度丢失。\n计算方法 操作 BigInteger 方法 BigDecimal 方法 加法 add() add() 减法 subtract() subtract() 乘法 multiply() multiply() 除法 divide() divide() 取余 mod() remainder() 幂运算 pow() pow() 比较 compareTo() compareTo() 相反数 negate() negate() BigDecimal保证精度不丢失的机制 BigDecimal 能够保证精度，是因为它使用了任意精度的整数表示法，而不是浮动的二进制表示。\nBigDecimal 内部使用两个字段存储数字，一个是整数部分 intVal，另一个是用来表示小数点的位置 scale，避免了浮点数转化过程中可能的精度丢失。\n计算时通过整数计算，再结合小数点位置和设置的精度与舍入行为，控制结果精度，避免了由默认浮点数舍入导致的误差。\n源码展示\n1 2 3 4 5 6 7 8 9 10 public class BigDecimal extends Number implements Comparable\u0026lt;BigDecimal\u0026gt; { private final BigInteger intVal; // 存储整数部分 private final int scale; // 存储小数点的位置 public BigDecimal(String val) { // 使用 BigInteger 来表示数值 intVal = new BigInteger(val.replace(\u0026#34;.\u0026#34;, \u0026#34;\u0026#34;)); scale = val.contains(\u0026#34;.\u0026#34;) ? val.length() - val.indexOf(\u0026#34;.\u0026#34;) - 1 : 0; } } ","date":"2024-11-06T23:18:11+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/","title":"Java中的高精度运算"},{"content":"包装类简介 包装类将基本数据类型包装成对象，用于集合操作等操作\n常见包装类 基本数据类型与包装类对照表： 基本数据类型 包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 创建方法 通过有参构造器创建 包装类不存在无参构造方法，\n通过valueOf()创建 一个常用静态方法，它用于将给定的基本数据类型或字符串转换为对应的包装类对象\n1 2 3 4 5 6 7 8 9 // 语法格式：包装类名.valueOf() public class ValueOfExample { public static void main(String[] args) { String str = \u0026#34;100\u0026#34;; Integer integerValue = Integer.valueOf(str); // 将字符串 \u0026#34;100\u0026#34; 转换为 Integer int i = 200; Integer integerValue = Integer.valueOf(i); // 将 int 200 转换为 Integer } } 自动装箱和自动拆箱 自动装箱（Autoboxing）：指的是 Java 编译器自动将基本数据类型转换为它们对应的包装类型。比如，将 int 转换为 Integer。\n自动拆箱（Unboxing）：指的是 Java 编译器自动将包装类型转换为基本数据类型。比如，将 Integer 转换为 int。\n主要作用：\n它在 Java 5 中引入，主要是为了提高代码的可读性，减少手动转换操作，简化了代码编写，开发者可以更方便地在基本类型和包装类型之间进行转换。 常见于：\n集合类如 List\u0026lt;Integer\u0026gt; 中无法存储基本类型，通过自动装箱，可以将 int 转换为 Integer 存入集合。\n1 2 3 4 int i = 99; //声明基础数据类型int变量 ArrayList list = new ArrayList(); list.add(i); //触发自动装箱，int类型自动转换成 Integer System.out.println(list); 自动装箱和拆箱经常在算术运算中出现，尤其是包装类型参与运算时。\n计算方法 Java 允许包装类和基本数据类型之间的自动转换，因此你可以直接对包装类对象进行算术运算，Java 会自动进行拆箱和装箱。\n缓存机制 包装类型中的 Byte、Short、Integer 和 Long 对某些范围内的值（例如 Integer，Long,Byte 缓存 -128 到 127）会使用对象缓存来提升性能。因此，同一数值的包装类型对象可能是同一个实例。\n在 -128 到 127 范围内的 Integer 对象会被缓存和复用。\n包装类的存在意义 存在意义就是将基本数据类型封装成对象\n对象封装的好处\n可以把属性也就是数据跟处理这些数据的方法结合在一起，比如Integer就有parseInt()等方法来专门处理int型相关的数据。 Java中绝大部分方法或类都是用来处理类类型对象的，如ArrayList集合类就只能以类作为他的存储对象， 在Java中，泛型只能使用引用类型，而不能使用基本类型。 包装类和基本数据类型的对比 基本类型和引用类型：基本数据类型是Java中最基本的数据类型，它们是预定义的，不需要实例化就可以使用。而引用类型则需要通过实例化对象来使用。这意味着，使用基本数据类型来存储一个整数时，不需要任何额外的内存分配，而使用包装类时，必须为对象分配内存。在性能方面，基本数据类型的操作通常比相应的引用类型快。 自动装箱和拆箱：包装可以实现自动装箱和拆箱。自动装箱是指将基本类型转化为相应的包装类类型，而自动拆箱则是将包装类类型转化为相应的基本类型。这使得Java程序员更加方便地进行数据类型转换。 空指针异常：另外，int变量可以直接赋值为0，而Integer变量必须通过实例化对象来赋值。如果对一个未经初始化的Integer变量进行操作，就会出现空指针异常。这是因为它被赋予了null值，而null值是无法进行自动拆箱的。 ","date":"2024-11-06T22:46:11+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB/","title":"Java中的包装类"},{"content":"在Mapper接口中基于注解书写sql语句 设置动态参数 1 #{参数名} 如果mapper接口中的方法参数名和mapper.xml中sql语句中的字段名一致，spring会自动进行封装\n设置mappper接口方法参数名和mapper.xml中的sql语句中的字段一致 如果mapper接口中的方法参数名和mapper.xml中sql语句中的字段名不一致，需要通过注解@Param来指定对应关系\n1 @Param(Sql语句中的字段名) 方法参数名 示例\n1 User selectUser(@param(“name”)String personName); 1 2 3 \u0026lt;select id=\u0026#34; selectUser\u0026#34; resultMap=\u0026#34;BaseResultMap\u0026#34;\u0026gt; select * from user where user_name = #{name} \u0026lt;/select\u0026gt; 删除操作 sql语句 1 delete from emp where id=#{id} 接口方法 1 2 3 4 5 @Mapper public interface EmpMapper //根据ID删除数据 @Delete(\u0026#34;delete from emp where id=#{id}\u0026#34;) public void delete(Integer id): 添加操作 sql语句 1 2 insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) values(#{username), #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptld}, #{createTime}, #{updateTime} 接口方法 1 2 3 4 5 @Mapper public interface EmpMapper //根据ID添加数据 @Insert(\u0026#34;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time)\u0026#34; +\u0026#34;values(#{username), #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptld}, #{createTime}, #{updateTime}\u0026#34;) public void insert(Emp emp); 主键返回 描述：在数据添加成功后，需要获取插入数据库数据的主键。\n实现：在@Insert上添加注解 @Options(keyProperty = \u0026ldquo;id\u0026rdquo;, useGeneratedKeys = true) 会自动将生成的主键值赋给id属性\n更新操作 sql语句 1 update emp set username=#{username),name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_Id=#{deptld}, create_time=#{createTime}, update_time=#{updateTime} where id=#{id} 接口方法 1 2 3 4 @Mapper public interface EmpMapper @Update(\u0026#34;update emp set username=#{username), name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_Id=#{deptld}, create_time=#{createTime}, update_time=#{updateTime} where id=#{id}\u0026#34;) public void update(Emp emp); 提示\n数据封装\n实体类属性名和数据库表查询返回的字段名一致，mybatis会自动封装。 如果实体类属性名 和 数据库表查询返回的字段名不一致，不能自动封装。 解决方案\n方案一：给字段起别名与实体类属性名相同\n方案二：使用@Results注解手动指定映射，@Result封装映射\ncolumn属性指定数据库字段 property属性指定实体类属性 1 2 3 @Results({ @Result(column=\u0026#34;数据库字段\u0026#34;,property=\u0026#34;实体类属性\u0026#34;) }) 查询操作 sql语句 1 2 3 select * from emp where name like \u0026#39;%李%\u0026#39; 接口方法 1 2 3 4 @Mapper public interface EmpMapper @Select(\u0026#34;select * from emp where name like \u0026#39;%#{name}%\u0026#39;\u0026#34;) public List\u0026lt;User\u0026gt; list(String name) 警告\n在模糊匹配中%#{name}%不建议使用（不是预编译sql语句）\n可以使用concat(‘%\u0026rsquo;,\u0026rsquo;#{name}\u0026rsquo;,\u0026rsquo;%')\n在Mapper.xml中基于映射文件属性sql语句 使用规范 XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下(同包同名)。\nXML映射文件的namespace属性为Mapper接口全限定名一致。\nXML映射文件中sql语句的id与Mapper 接口中的方法名一致，并保持返回类型一致。\n编写sql语句的格式\n1 2 3 \u0026lt;操作名 id=\u0026#34;函数名\u0026#34; resultType=\u0026#34;单条记录的实体类全类名\u0026#34;\u0026gt; sql语句 \u0026lt;/操作名\u0026gt; 提示\n只有select操作需要resultType\n动态SQL语句 \u0026lt; if \u0026gt;标签 ​\t描述：用于判断条件是否成立。使用test属性进行条件判断，如果条件为true，则拼接SQL\n​\t示例代码\n1 2 3 4 5 6 7 8 \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.itheima.pojo.Emp\u0026#34;\u0026gt; select * from omp where \u0026lt;if test=\u0026#34;name !=null\u0026#34;\u0026gt; name like concat(\u0026#34;%\u0026#34;,#{name},\u0026#34;%\u0026#34;) \u0026lt;/if\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;where\u0026gt;标签 ​\t描述：动态生成where子句，若子标签的条件都不满足则不会生成where子句，同时会删除子句开头的条件运算符\n​\t示例代码\n1 2 3 4 5 6 7 8 9 \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.itheima.pojo.Emp\u0026#34;\u0026gt; select * from emp \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name !=null\u0026#34;\u0026gt; name like concat(\u0026#34;%\u0026#34;,#{name},\u0026#34;%\u0026#34;) \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;set\u0026gt;标签 描述：动态生成set子句\n示例代码\n1 2 3 4 5 6 7 8 9 \u0026lt;update id=\u0026#34;update\u0026#34;\u0026gt; update emp \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;name !=null\u0026#34;\u0026gt; name=#{name} \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id=#{id} \u0026lt;/update\u0026gt; \u0026lt;foreach\u0026gt;标签 描述：用于遍历元素\n属性\ncollection：遍历的集合 item：集合中的元素 separator：分隔符 open：遍历开始前的SQL语句 close：遍历结束后的SQL语句 示例代码\n1 2 3 4 5 6 \u0026lt;delete id=\u0026#34;delete\u0026#34;\u0026gt; delete from emp where id in \u0026lt;foreach collection=\u0026#34;遍历的集合\u0026#34;,item=\u0026#34;集合中的元素\u0026#34;,separator=\u0026#34;分隔符\u0026#34;,open=\u0026#34;(\u0026#34;,close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; \u0026lt;sql\u0026gt;标签和\u0026lt;include\u0026gt;标签 \u0026lt;sql\u0026gt;:定义可重用的 SQL片段。 \u0026lt;include\u0026gt;:通过属性refid，指定包含的sql片段。 示例代码\n1 2 3 4 5 6 7 8 9 10 \u0026lt;sql id=\u0026#34;commonSelect\u0026#34;\u0026gt; select id, username from emp \u0026lt;/sql\u0026gt; \u0026lt;select id=\u0026#34;getById\u0026#34; resultTypea\u0026#34;com.itheima.pojo.Emp\u0026#34;\u0026gt; \u0026lt;include refid=\u0026#34;commonselect\u0026#34;/\u0026gt; where id = #{id} \u0026lt;/select\u0026gt; \u0026lt; trim \u0026gt;标签 prefix：将trim标签中内容前面添加指定内容 suffix：将trim标签中内容前面添加指定内容 prefixOverride：将trim标签中内容前面去除指定内容 suffixOverride：将trim标签中内容后面去除指定内容 \u0026lt;choose\u0026gt;,\u0026lt;when\u0026gt;,\u0026lt;otherwise\u0026gt; 相当于switch，if，else\n1 2 3 4 5 6 \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;满足的条件\u0026#34;\u0026gt; \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; 字段名和属性名的映射关系 通常情况下当数据表中的字段名和实体类的属性名对应相等时，MyBatis会将查询出的字段数据自动赋值给实体类\n当字段名和属性名不一致时 在sql语句中给字段名起别名使得字段名与属性名相同\n通过resultMap解决，其他的sql语句设置resultMap属性来确定映射关系\n1 2 3 4 \u0026lt;resultMap id=\u0026#34;resultMap_name\u0026#34;,type=\u0026#34;实体类\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;属性名\u0026#34;,column=\u0026#34;主键字段名\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;属性名\u0026#34;,column=\u0026#34;其他字段名\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultMap\u0026gt; 多对一的映射关系 示例：查询员工及其对应部门信息时，将员工的did和dname合并为一个dept对象，作为emp对象的成员变量\n通过resultMap中的级联属性解决，其他的sql语句设置resultMap属性来确定映射关系\nresultMap使用级联属性对应成员对象名\n1 2 3 4 5 6 7 8 9 \u0026lt;resultMap id=\u0026#34;empAndDeptResultMapone\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34;column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;dept.did\u0026#34; column=\u0026#34;did\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;dept.deptName\u0026#34; column=\u0026#34;dept_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultMap\u0026gt; 通过resultMap中的association标签解决，其他的sql语句设置resultMap属性来确定映射关系\nassociation具有两个属性，property对应实体类中的成员对象名，javaType对应该成员对象的java类型\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;resultMap id=\u0026#34;empAndDeptResultMapone\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34;column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;association property=\u0026#34;dept\u0026#34; javaType=\u0026#34;Dept\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;did\u0026#34; column=\u0026#34;did\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;dept.deptName\u0026#34; column=\u0026#34;dept_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; 一对多的映射方式 示例：查询部门及其下属员工时，一个部门作为实体类具有一个员工对象的集合作为成员变量\n通过resultMap的collection标签解决，其他的sql语句设置resultMap属性来确定映射关系\ncollection具有两个属性，property对应实体类中的成员对象名，ofType对应该成员对象的java类型\n1 2 3 4 5 6 7 8 9 \u0026lt;resultMap id=\u0026#34;empAndDeptResultMapone\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;collection property=\u0026#34;成员变量名\u0026#34; ofType=\u0026#34;集合内的泛型\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34;column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; ","date":"2024-11-06T17:26:14+08:00","permalink":"https://Tyritic.github.io/p/mybatis%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","title":"MyBatis基本使用"},{"content":"Lombok简介 Lombok是一个实用的java类库，能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法 并可以自动化生成日志变量，简化iava开发\n常见注解 注解 作用 @Getter/@Setter 为所有的属性提供get/set方法 @ToString 会给类自动生成易阅读的toString 方法 @EqualsAndHashCode 根据类所拥有的非静态字段自动重写 equals方法和 hashcode 方法 @Data 提供了更综合的生成代码功能(@Getter+@Setter+@ToString+@EqualsAndHashCode) @NoArgsConstructor 为实体类生成无参的构造器方法 @AllArgsConstructor 为实体类生成除了static修饰的字段之外带有各参数的构造器方法 ","date":"2024-11-06T17:19:27+08:00","permalink":"https://Tyritic.github.io/p/lombok/","title":"Lombok"},{"content":"什么是MyBatis MyBatis是一款优秀的 持久层框架，用于简化JDBC的开发。 MyBatis本是 Apache的一个开源项目iBatis,2010年这个项目由apache迁移到了google code，并且改名为MyBatis。2013年11月迁移到Github。 官网:https://mybatis.org/mybatis-3/zh/index.html MyBatis的配置 在pom.xml中配置相关依赖\n在application.yml中的spring.database属性下配置相关数据库连接信息\n指定驱动类名称：driver-class-name 数据库连接的url：url 连接数据库的用户名 连接数据库的密码 编写sql语句\n在mapper文件夹下编写接口，用@Mapper修饰\n在每一个函数上根据操作名使用对应的注解修饰sql语句\n1 2 3 4 5 @Mapper public interface UserMapper{ @Select(\u0026#34;select * from user\u0026#34;) public List\u0026lt;User\u0026gt;list(); } 或者在resource文件夹下创建和接口全名（包名.接口名）一致的xml，在xml文件中根据具体的接口函数编写对应的sql语句\n1 2 3 4 5 6 7 8 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34; \u0026gt; \u0026lt;mapper namespace=\u0026#34;org.example.operator.mapper.userMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;list\u0026#34;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 数据库连接池 什么是数据连接池 数据库连接池是个容器，负责分配、管理数据库连接(Connection) 它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个 释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏 优势 资源重用 提升系统响应速度 避免数据库连接遗漏 常见产品 C3PO DBCP Druid Hikari(springboat默认) ","date":"2024-11-06T16:50:26+08:00","permalink":"https://Tyritic.github.io/p/mybatis%E7%AE%80%E4%BB%8B/","title":"MyBatis简介"},{"content":"基本概念 索引(index)：帮助数据库 高效获取数据的数据结构\n优点\n提高数据查询的效率，降低数据库的I0成本， 通过索引列对数据进行排序，降低数据排序的成本，降低CPU消耗。 缺点\n索引会占用存储空间。 索引大大提高了查询效率，同时却也降低了insert、 update、delete的效率。 索引结构 MySQL数据库支持的索引结构有很多，如:Hash索引、B+Tree索引、Full-Text索引等。我们平常所说的索引，如果没有特别指明，都是指默认的 B+Tree 结构组织的索引。\n索引操作 创建索引\n1 create [unique] index index_name on table_name(字段名,...) 查看索引\n1 show index from table_name 删除索引\n1 drop index index_name on table_name 提示\n主键字段，在建表时，会自动创建主键索引。 添加唯一约束时，数据库实际上会添加唯一索引。 ","date":"2024-11-04T19:18:04+08:00","permalink":"https://Tyritic.github.io/p/mysql%E7%B4%A2%E5%BC%95/","title":"MySQL索引"},{"content":"概念 事务是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作 要么同时成功，要么同时失败。\n提示\nMySQL会立即隐式的提交事务。默认MySQL的事务是自动提交的，\n事务控制语句 开启事务\n1 start transaction； 提交事务\n1 commit; 回滚事务\n1 rollback; 四大特性 原子性（Atomicity）：事务是不可分割的最小单元，要么全部成功，要么全部失败 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态 隔离性（lsolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的 并发事务问题 脏读：一个事务读到另外一个事务还没有提交的数据。 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了幻影”。 事务隔离级别 隔离级别 脏读 不可重复度 幻读 Read uncommitted √ √ √ Read committed × √ √ Repeatable Read(默认) × × √ Serializable × × × 其中 Serializable 数据安全性更好但是性能最差，Read uncommitted反之\n相关SQL语句 查看事务隔离级别 1 select @@transaction isolation; 设置事务隔离级别 1 set [ session | global] transaction isolation level { read uncommitted | read committed | repeatable read | serializable } ","date":"2024-11-04T19:06:51+08:00","permalink":"https://Tyritic.github.io/p/mysql%E4%BA%8B%E5%8A%A1/","title":"MySQL事务"},{"content":"基本查询 基本语法\n1 2 3 4 5 6 7 8 9 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from table_name where condition #条件列表 #以下均为可选选项 group by 聚合函数（字段列表） having 对分组条件的过滤操作 order by 对字段列表的排序 #（ASC升序，DESC降序） limit 分页参数 (起始索引，查询记录数) #索引从0开始，起始索引=（查询页码-1)*每页记录数 条件查询 常见条件运算符 比较运算符 功能 \u0026gt; 大于 \u0026gt;= 大于等于 \u0026lt; 小于 \u0026lt;= 小于等于 \u0026lt;\u0026gt;或!= 不等于 常见逻辑运算符 逻辑运算符 功能 and 或 \u0026amp;\u0026amp; 与 or 或 || 或 not 或 | 非 单表查询 1 2 3 4 5 6 7 8 9 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from table_name where condition #条件列表 #以下均为可选选项 group by 聚合函数（字段列表） having 对分组条件的过滤操作 order by 对字段列表的排序 #（ASC升序，DESC降序） limit 分页参数 (起始索引，查询记录数) #索引从0开始，起始索引=（查询页码-1)*每页记录数 select子句：指定所需的属性，对应关系代数中的投影操作\n默认允许重复的元组\n显式指示使用all关键字\n强制去除重复使用distinct关键字\n查询所有属性可以简写为*\nfrom子句：确定查询中需要访问的表\nwhere子句：指定结果满足的特定条件\n附加的基本操作 更名运算 作用 长命名改为短命名 比较同一个关系的元组 放置位置：位置灵活，无限制 1 2 3 4 5 6 7 8 9 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from old_name as new_name where condition #条件列表 #以下均为可选选项 group by 聚合函数（字段列表） having 对分组条件的过滤操作 order by 对字段列表的排序 #（ASC升序，DESC降序） limit 分页参数 (起始索引，查询记录数) #索引从0开始，起始索引=（查询页码-1)*每页记录数 显示顺序 在查询语句的结尾使用order by子句来决定显示按顺序还是倒序，默认为顺序\ndes：降序 asc：升序（默认） 1 2 3 select columns from table order by column_name [asc | desc]; 字符串相关操作 放置位置\nwhere子句中充当条件 select子句中充当元素 常见操作\n标识一个字符串\n1 \u0026#39;字符串\u0026#39; 模式匹配\nlike关键字\n1 2 3 4 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from table_name as s where s.name like %|_% escape \u0026#39;|\u0026#39; #匹配任何包含_的字符串 百分号%：匹配任意子串\n例如以substring开头：substring%\n匹配任何包含substring的字符串：%substring%\n下划线_：匹配任意字符\n定义转义字符：escape\u0026rsquo;转义字符'\nregexp：正则表达式匹配\n1 2 3 select * from users where name regexp \u0026#39;^张.$\u0026#39;; 字符串串联\nconcat(str1, str2, \u0026hellip;)\n1 2 select concat(first_name, \u0026#39; \u0026#39;, last_name) as full_name from users; str1|| str2\n1 2 select first_name || \u0026#39; \u0026#39; || last_name as full_name from users; concat_ws(separator, str1, str2, \u0026hellip;)：允许指定分隔符\n1 2 select concat_ws(\u0026#39;, \u0026#39;, first_name, last_name) as full_name from users; 大小写以及首尾去除空格\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #转小写 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from table_name as s where s.name =lower(\u0026#39;hEllO world\u0026#39;) #与hello world匹配的字符串 #转大写 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from table_name as s where s.name =upper(\u0026#39;hEllO world\u0026#39;) #与HELLO WORLD匹配的字符串 #去除首尾空格 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from table_name as s where s.name =upper(\u0026#39; hEllO world \u0026#39;) #与hEllO world匹配的字符串 大写：upper(str) 小写：lower(str) 去除空格：trim(str) where子句谓词 between min_value and max_value：说明一个值位于某个范围,大于等于min_value，小于等于max_value\n1 2 3 select columns from table as t where t.age between 10 and 100 #年龄在10岁到100岁 元组比较：元组之间使用字典序进行比较\n1 2 3 select name, course_id from instructor, teaches where (instructor.ID, dept_name) = (teaches.ID, ’Biology’); 集合运算 所有的集合运算默认去除重复，若保留重复则在集合运算符后面加上关键字all\n查找在 2009 年秋季或 2010 年春季开设的课程（使用并运算）\n1 2 3 (select course_id from section where sem = ‘Fall’ and year = 2009) union (select course_id from section where sem = ‘Spring’ and year = 2010) 查找在 2009 年秋季和2010 年春季开设的课程（使用交运算）\n1 2 3 (select course_id from section where sem = ‘Fall’ and year = 2009) intersect (select course_id from section where sem = ‘Spring’ and year = 2010) 查找在 2009 年秋季开课但未在 2010 年春季开课的课程（使用差运算）\n1 2 3 (select course_id from section where sem = ‘Fall’ and year = 2009) except (select course_id from section where sem = ‘Spring’ and year = 2010) 分组查询 基本聚合函数 函数 功能 sum 求和 avg 平均值 count 计数 max 最大值 min 最小值 提示\nnull不参与聚合函数的运算\n使用关键字*指代所有\n可以在聚集表达式中使用关键字distinct修饰被聚合的属性来删除重复的元组如count (distinct id)\ngroup by子句 将聚集函数用于一组元组集上而利用属性进行的分组操作\n1 2 3 4 #正确示范 select dept_name, avg(salary)as avg_salary) from instructor group by dept_name; 提示\nselect子句中的字段为用于分组的字段（group by中的属性，当只有一个聚合函数时可以不存在）和聚合函数（保证select子句中非聚集的属性只能是出现在group by子句）\n1 2 3 4 5 #错误查询，select子句中的非聚合属性ID #没出现在group by子句中 select dept_name, ID, avg(salary) from instructor group by dept_name ; 在默认情况下，系统按照group by子句中指定的列升序排列，但是可以使用order by子句指定新的排列顺序。\nhaving子句 对group by后的分组进行过滤操作\n可以使用聚集函数\n1 2 3 4 5 select course_id,semester,year,sec_id,avg(tot_cred) from takes natural join student where year = 2009 group by course_id,semester,year,sec_id having count(ID)\u0026gt;=2; 提示\nhaving和where的区别\n执行时机不同:where是分组之前进行过滤，不满足where条件，不参与分组;而having是分组之后对结果进行过滤。\n判断条件不同:where不能对聚合函数进行判断，而having可以。\n保证出现在having子句中的非聚集的属性只能出现在group by子句中\n1 2 3 4 5 6 # 错误示范 having子句中非聚集的属性salary # 没有出现在group by中 select department,AVG(salary)AS avg_salary from employees group by department having salary \u0026gt;5000; 查询的执行顺序 根据from子句计算出关系 若出现了where子句则将where子句中的谓词应用到from子句的结果关系上 若出现了group by子句，满足where子句的元组通过group by子句形成分组，若没有group by子句则满足where子句谓词的整个元组集被当成一个分组 若出现了having子句，将被应用到每一个分组，不满足子句谓词的分组将被抛弃 select子句利用剩下的分组产生出查询结果中的元组，在每个分组上应用聚集函数来得到单个结果元组 多表查询 连接查询 笛卡尔积\n描述：输出两个关系中输出所有的元组对（无论在共同属性上的取值是否相同）\n若关系r中属性和关系s中的属性相同则区分命名\n属性名不相同 属性名相同 示例代码：\n1 2 3 4 #隐式笛卡尔积 table a,table b #显式笛卡尔积 table a join table b 内连接\n描述：查询A表和B表相交的部分（有条件的笛卡尔积）\n性质：不保留未匹配元组的连接运算（合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行）\n语法：\n1 2 3 4 5 6 7 8 9 #隐式内连接 select 字段列表 from table a,table b where condition #显式内连接 select 字段列表 from table a join table b on 连接条件 外连接：\n描述：通过在表中创建包含空值元组的方式保留未匹配元组的连接运算\n左外连接：只保留出现在左外连接运算之前（左边）的关系中的元组。 右外连接：只保留出现在右外连接运算之后（右边）的关系中的元组。 全外连接：保留出现在两个关系中的元组。 语法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #左外连接 select 字段列表 from table a left join table b on 连接条件 #右外连接 select 字段列表 from table a right join table b on 连接条件 #mysql不直接支持全外连接,可以通过左外连接和右外连接union操作后实现 select 字段列表 from table a left join table b on 连接条件 union select 字段列表 from table a right join table b on 连接条件 自然连接\n描述：从A表和B表中输出在具有相同名字的所有属性上取值相同的元组对，基于两个表中共同属性的值相等的元组进行合并。\n1 2 3 4 #自然连接 select 字段列表 from table a natural join table b on 连接条件 提示\n自然连接和内连接的区别\n若两张表具有同名的属性，自然连接会删除重复的属性而内连接不会删除而是保留重复的属性\n嵌套子查询 子查询：SQL语句中嵌套select语句\n类别\n标量子查询：子查询返回的结果为单个值 列子查询：子查询返回的结果为一列 行子查询：子查询返回的结果为一行 表子查询：子查询返回的结果为多行多列 子查询的位置\nselect后面：标量子查询（作为所需要的一个字段） from后面：表子查询 where/having（作为条件的一部分）：标量子查询/列子查询/行子查询 with子句 with定义了临时关系，只对with子句所在的查询有效 其中as子句内定义临时关系，后面紧跟查询语句 可以使用多个as对应多个临时关系 1 2 3 4 5 6 7 8 9 10 with it department as( select department,AVG(salary) as avg_salary from employees where department =IT group by department ) select e.name,e.salary,it.avg_salary from employees e join it department it on e.department = it.department where e.salary \u0026gt;it.avg_salary; where子句中的子查询 子查询类型\n行子查询：子查询返回的结果为一行 列子查询：子查询返回的结果为一列 检测集合的成员资格（列子查询）\nin连接字检测元组是否是集合中的成员\n1 2 3 4 5 6 7 #查找 2009 年秋季和 2010 年春季提供的课程 select distinct course_id from section where semester = ’Fall’ and year= 2009 and course_id in (select course_id from section where semester = ’Spring’ and year= 2010); not in连接检测元组是否不是集合中的成员\n1 2 3 4 5 6 7 #查找 2009 年秋季提供的课程，但不在2010 年春季提供的课程 select distinct course_id from section where semester = ’Fall’ and year= 2009 and course_id not in (select course_id from section where semester = ’Spring’ and year= 2010); 空关系测试（行子查询）\nexist结构在作为参数的子查询非空时返回true，not exist在作为参数的子查询为空时返回true\n关系A包含关系B可以写为not exists (B except A)\n1 2 3 4 5 6 7 8 9 10 # 查找所有参加过生物系提供的所有课程的学生。 select distinct S.ID, S.name from student as S where not exists ( (select course_id from course where dept_name = ’Biology’) except (select T.course_id from takes as T where S.ID = T.ID)); 测试重复元组（行子查询）\nunique结构：如果作为参数的子查询结果中没有重复的元组，则返回true\n1 2 3 4 5 6 select T.course_id from course as T where not unique (select R.course_id from section as R where T.course_id= R.course_id and R.year = 2009); 集合的比较（列子查询）\nall:指代集合中的每一个元素\n1 2 3 4 5 6 # 查找薪水大于 Biology 系中所有教员薪水的所有教员的姓名。 select name from instructor where salary \u0026gt; all (select salary from instructor where dept_name = ’Biology’); some：指代集合中的其中一个元素\n1 2 3 4 5 6 # 查找薪水高于 Biology 系中某些（至少一名）讲师的讲师的姓名。 select name from instructor where salary \u0026gt; some (select salary from instructor where dept_name = ’Biology’); 视图 描述 ​\t一种虚拟表，它基于 SQL 查询结果创建。视图并不存储数据，而是动态地从基础表中提取数据。这使得视图像一个窗口，可以用来查看和操作表的数据。\n特点 虚拟表： 视图本身不存储数据，它的内容来自于定义视图时的查询语句。 每次访问视图时，都会动态执行查询以生成视图的数据。 逻辑隔离： 视图是基础表的一种逻辑表示，对视图的操作不会直接修改基础表。 安全性： 通过视图，可以限制用户访问表的部分数据，而不是直接授予表的访问权限。 可简化复杂查询： 视图可以封装复杂的 SQL 查询逻辑，从而简化对数据的访问。 创建过程 ​\t视图关系在概念上包含查询结果中的元组， 但并不进行预计算和存储（数据库系统存储视图的定义本身， 而不存储定义该视图的查询表达式的执行结果）。相反， 数据库系统存储与视图关系相关联的查询表达式。 当视图关系被访问时， 其中的元组是通过计算查询结果而被创建出来的。 从而，视图关系是在需要的时候才被创建的。\n在查询中使用视图 ​\t在任何给定时刻， 视图关系中的元组集是该时刻视图定义中的查询表达式的计算结果。当我们定义一个视图时， 数据库系统存储视图的定义本身， 而不存储定义该视图的查询表达式的执行结果。一旦视图关系出现在查询中，它就被已存储的查询表达式代替。因此， 无论我们何时执行这个查询， 视图关系都被重新计算。\n物化视图 定义：创建一个物理表，其中包含定义视图的查询结果中的所有元组\n如果查询中使用的关系已更新，则物化视图结果将过时，因此需要维护视图，通过在底层关系更新时更新视图\n语法 1 2 3 # 创建视图（可以通过其他视图进行创建） create view view_name as \u0026lt;查询表达式\u0026gt; ","date":"2024-11-04T15:07:25+08:00","permalink":"https://Tyritic.github.io/p/mysql%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C/","title":"MySQL表数据查询操作"},{"content":"插入元组 指定字段添加元组\n1 insert into table_name (字段1,子段2,...子段n) values(值1,..值n); 全部字段添加元组\n1 insert into table_name values(值1,值2,...值n); 批量添加指定子段的元组\n1 insert into table_name (子段1,子段2,...子段n) values(值1,...值n),..(值1,...值n); 全部数据批量添加\n1 insert into table_name values(值1,...值n),..(值1,...值n); 更新元组 更新符合指定条件的元组\n1 update table_name set 字段1=值1,..字段n=值n [where condition] 删除元组 删除表中的元组但是不删除表（当不存在条件时为删除所有元组\n1 delete from table_name [where condition] 删除表中的所有元组但是保留表结构（同时按照原来的建表语句重新建立表）\n1 truncate table table_name ","date":"2024-11-04T14:57:14+08:00","permalink":"https://Tyritic.github.io/p/mysql%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/","title":"MySQL表数据操作"},{"content":"创建表结构 代码结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 创建一个新的表 create table table_name( 字段1 字段类型[约束] [comment \u0026#39;关于字段的描述\u0026#39;], ... 字段n 字段类型[约束] [comment \u0026#39;关于字段的描述\u0026#39;] \u0026lt;完整性约束\u0026gt;, ... \u0026lt;完整性约束\u0026gt; )[comment 关于表的描述] #创建与现有的某个表的模式相同的表 create table new_table like old_name #将查询结果保存为一张表,默认插入数据 create table new_table as \u0026lt;查询表达式\u0026gt;; 约束 概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据\n目的：保证数据库中数据的正确性、有效性和完整性。\n常见约束参考\n约束 描述 关键字 非空约束 限制该字段不能为null not null 唯一约束 保证该字段的所有数据都是唯一，不存在重复 unique 主键约束 主键是一个元组的唯一标识，要求非空且唯一 primary key 默认约束 保存数据时要是未指定该字段值则存入默认值 default 谓词约束 保证所有数据都满足条件谓词 check 外键约束 通过外键建立两张表的联系，保证数据的一致性和完整性 foreign key 示例代码\n1 2 3 4 5 6 7 8 9 10 create table student (ID varchar (5) comment[\u0026#39;唯一标识符\u0026#39;], name varchar (20) not null,unique dept_name varchar (20), tot_cred numeric (3,0) check (tot_cred \u0026gt;= 0), age int default 18 #默认约束 primary key (ID), #主键约束 foreign key (dept_name) references department(dept_name) #外键约束 on delete set null) #违反约束的方法：置为null unique(name,age); #多列唯一约束 数据类型 数值类型 类型 大小（byte) 有符号范围 无符号范围 描述 备注 tinyint 1 (-128,127) (0,255) 小整数 smallint 2 (-32768,32767) (0,65535) 大整数 mediumint 3 (-8388608,8388607) (0,1677215) 大整数 int 4 (-2^31 ,2^31-1) (0,2^32-1) 大整数 bigint 8 (-2^63 ,2^63-1) (0,2^64-1) 极大整数 float 4 单精度浮点值 float(5,2)，其中5为数字长度，2为小数位数 double 8 双精度浮点值 double(5,2)，其中5为数字长度，2为小数位数 decimal 小数值（精度最高） 字符类型 类型 大小（byte） 描述 备注 char 0~255 定长字符串 char(10),最多只能存10个字符，不足10个字符也占有10个字符空间 varchar 0~63315 变长字符串 varchar(10),最多只能存10个字符，不足10个字符按实际长度存储 tinyblob 0~255 不超过255个字符的二进制数据 tinytext 0~255 短文本字符串 blob 0~65535 二进制形式长文本数据 text 0~65535 长文本数据 mediumblob 0~16777215 二进制形式中等长文本数据 mediumtext 0~16777215 中等长度文本数据 longblob 0~4294967295 二进制形式的极大文本数据 longtext 0~4294967295 极大文本数据 日期类型 类型 大小（byte） 格式 范围 描述 date 3 YYYY-MM-DD 1000-01-01到 9999-12-31 日期值 time 3 HH:MM:SS -838:59:59 到 838:59:59 时间值或持续时间 year 1 YYYY 1901到2155 年份值 datetime 8 YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00到 9999-12-31 23:59:59 混合日期和时间值 timestamp 4 YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00到 9999-12-31 23:59:59 混合日期和时间值，时间戳 时间域的提取\n1 2 3 extract(unit from date) ## unit为所提取的时间域 ## date为字符串 字符串转时间类型\n1 cast(\u0026#39;2024-12-21\u0026#39; as date) 大对象类型 大对象类型\n字符数据：clob\n二进制数据：blob\n查询表结构 查询当前数据库的所有表\n1 show tables 查询指定表的表结构\n1 desc table_name 查询建表语句\n1 show create table table_name 修改表结构 添加字段\n1 2 alter table table_name add 字段名 字段类型（长度） [comment \u0026#39;关于字段的描述\u0026#39;] [约束]; 修改字段类型\n1 2 alter table table_name modify 字段名 新字段类型（长度）; 修改字段名和字段类型\n1 2 alter table table_name change 旧字段名 新字段名 新类型（长度）[comment \u0026#39;关于字段的描述\u0026#39;] [约束]; 删除字段\n1 2 3 4 5 alter table table_name drop column 字段名; #column可以不填写 alter table table_name drop 字段名; 修改表名\n1 rename table 旧表名 to 新表名; 删除表结构 删除表中所有元组以及表的结构\n1 drop table 表名; ","date":"2024-11-03T18:46:17+08:00","permalink":"https://Tyritic.github.io/p/mysql%E8%A1%A8%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C/","title":"MySQL表结构操作"},{"content":"切换数据库 1 use database_name; 创建数据库 1 create database[if not exists] database_name; 查询数据库 查询所有的数据库\n1 show databases; 查询当前正在使用的数据库\n1 select database(); 删除数据库 1 drop database [if exist] database_name 授权机制 权限类型 数据库各部分的授权形式 Read：允许读取数据，但不允许修改数据。 Insert - 允许插入新数据，但不允许修改现有数据。 Update：允许修改数据，但不允许删除数据。 Delete：允许删除数据。 修改数据库架构的授权形式 Index - 允许创建和删除索引。 Resource - 允许创建新关系。 Alteration - 允许在关系中添加或删除属性。 Drop - 允许删除关系。 用户与角色 用户是指可以连接到数据库并执行操作的实体。每个用户有一个唯一的用户名和密码，通过这些凭证来认证和识别该用户。用户具有访问数据库和执行某些操作的权限。通常情况下，用户是直接与权限绑定的。\n每个用户可以拥有一个或多个权限，这些权限控制用户能在数据库中执行哪些操作（如查询、插入、更新、删除等）。 用户可以是数据库的实际操作实体，如开发人员、管理员、应用程序等。 创建用户\n1 2 3 4 create user \u0026#39;username\u0026#39;@\u0026#39;host\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; # username：用户名 # host：主机名，\u0026#39;%\u0026#39; 代表任何主机 # password：密码 角色是一种逻辑上的权限集合，它允许将多个权限组合在一起并赋予用户。角色是权限的集合，用户可以通过赋予某个角色来间接获得角色所包含的权限。这样，通过角色管理权限比直接授予权限给用户更简洁和灵活，尤其是当多个用户需要相同权限时。\n角色是一个权限集合，可以包含多个权限，用户通过赋予角色来获得这些权限。 角色并不直接与具体的数据库操作实体（如用户）绑定，而是充当权限的管理和分配工具。 创建角色\n1 create role \u0026#39;developer\u0026#39;; 授权规范 授予权限 代码语法\n1 2 3 4 grant \u0026lt;权限列表\u0026gt; #all privileges表示全部权限 on \u0026lt;视图名/关系名\u0026gt; to \u0026lt;角色/用户列表\u0026gt; with grant option #可选表示被授予权限的用户／角色可以把得到的权限再授予给另外的用户／角色 注意事项\n权限的授予者必须已经拥有指定项目的权限（或者是数据库管理员）。 授予对视图的特权并不意味着授予对基础关系的任何特权。 默认情况下， 被授予权限的用户／角色无权把此权限授予其他用户／角色，除非使用with grant option子句 视图的授权\n创建视图的用户不需要获得该视图上的所有权限。他得到的那些权限不会为他提供超越他已有权限的额外授权。例如，如果一个创建视图的用户在用来定义视图的关系上没有update 权限的话，那么他不能得到视图上的update权限。 如果用户创建一个视图， 而此用户在该视图上不能获得任何权限，系统会拒绝这样的视图创建请求 模式的授权\n默认情况：只有模式的拥有者才能够执行对模式的任何修改， 诸如创建或删除关系， 增加或删除关系的属性， 以及增加或删除索引 referrence权限允许用户在创建关系时声明外码，例如你有两个表：orders 和 customers，其中 orders表中的 customer_id列引用了 customers 表中的 id 列作为外键。这时，在创建外键约束时，用户需要拥有对 customers 表的 REFERENCES 权限。 一个用户/角色的权限\n所有直接授予用户／角色的权限。\n所有授予给用户／角色所拥有角色的权限。\n收回权限 代码语法\n1 2 3 revoke \u0026lt;权限列表\u0026gt; on \u0026lt;视图名/关系名\u0026gt; from \u0026lt;角色/用户列表\u0026gt; 注意事项\n若权限列表中包含public,所有用户都将失去该权限，但明确授予该权限的用户除外。 如果不同的授权者两次向同一用户授予相同的权限，则用户在权限撤销后可以保留该权限 所有依赖于被撤销的权限的权限也将被撤销。 收回权限的方式 cascade：级联收回，从一个用户／角色那里收回权限可能导致其他用户／角色也失去该权限 restrict：不需要级联收回 可以收回grant option ","date":"2024-11-03T18:26:36+08:00","permalink":"https://Tyritic.github.io/p/mysql%E5%BA%93%E6%93%8D%E4%BD%9C/","title":"MySQL库操作"},{"content":"MySQL配置使用 启动服务：\n1 net start mysql 停止服务：\n1 net stop mysql 登录MySQL\n1 mysql -u[用户名] -p[密码] [-h 数据库服务器IP -p 端口号] 退出MySQL\n1 exit MySQL数据模型 关系型数据库(RDBMS)：建立在关系模型基础上，由多张相互连接的二维表组成的数据库\n特点\n使用表存储数据，格式统一，便于维护 使用SQL语言操作，标准统一，使用方便，可用于复杂查询 SQL简介 SQL：一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准。\n通用语法 SOL语句可以单行或多行书写，以分号结尾。 SOL语句可以使用空格/缩进来增强语句的可读性。 MySQL数据库的SQL语句不区分大小写。 注释 单行注释：\u0026ndash;注释内容或者#注释内容**（MySQL特有）** 多行注释：/* 注释内容 */ 分类 分类 全称 说明 DDL Data Definition Language 数据定义语言，用来定义数据库对象(数据库，表，字段) DML Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改 DQL Data Query Lanquage 数据查询语言，用来查询数据库中表的记录 DCL Data Control Language 数据控制语言，用来创建数据库用户、控制数据库的访问权限 ","date":"2024-11-03T17:02:26+08:00","permalink":"https://Tyritic.github.io/p/mysql%E7%AE%80%E4%BB%8B/","title":"MySQL简介"},{"content":"什么是控制反转（IOC) IOC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。以右图为例\nIOC容器作为中间位置“第三方”，也就是，使得A、B、C、D这四个对象没有了耦合关系，齿轮之间的传动全部依靠IOC容器，全部对象的控制权上交给IOC容器，所以IOC容器成了整个系统的关键核心，它起到一个“粘合剂”的作用，把系统中所有对象粘合在一起发挥作用。\nIOC的关键点 谁控制谁： 传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象； 而IOC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建； 控制了什么 那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 什么是反转： 传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转； 而反转则是由容器来帮忙创建及注入依赖对象 为什么是反转：因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象。 哪些方面反转了：依赖对象的获取被反转了。 IOC的过程 所有的类都会在Spring容器中登记，告诉spring你是个什么东西，你需要什么东西， 然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。 所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。 对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。 Bean对象的声明 注解 说明 位置 @Component 声明Bean对象的基本注解 不属于以下三类时使用该注解 @Service @Component的衍生注解 标注在ServiceImpl类上 @Controller @Component的衍生注解 标注在Controller类上 @Repository @Component的衍生注解 标注在数据访问类上（现在有mybatis，使用评论少） 注意事项\n声明bean的时候，可以通过value属性指定bean的名字，如果没有指定，默认为类名首字母小写 使用以上四个注解都可以声明bean，但是在springboot集成web开发中，声明控制器bean只能用@Controller. Bean组件扫描 声明bean的四大注解，要想生效，还需要被组件扫描注解 @ComponentScan 扫描。 @ComponentScan 注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解 @SpringBootApplication 中，默认扫描的范围是启动类所在包及其子包。\n","date":"2024-11-03T15:06:44+08:00","permalink":"https://Tyritic.github.io/p/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/","title":"控制反转"},{"content":"String类型是不可变的 不可变的实现方式 String类本身被final修饰表示该类不允许被继承 从JDK1.9开始String类底层已经不再使用char[]存储而是使用byte[]加上并一个字段 coder 来指示编码方式，同时这个byte[]数组被private final修饰，保证初始化后不再被更改 不可变性的体现 当对字符串重新赋值的时候，需要重新指定内存区域赋值，不能使用原来的内存区域 String类是线程安全的 当对现有字符串进行修改的时候，需要重新指定内存区域赋值，不能使用原来的内存区域 String对象的创建方式 通过构造函数创建（new+构造器） 构造函数 public String()：创建空白字符串 public String(String input)：根据输入字符串input创建字符串 public String(char[] input)：根据输入char数组input创建字符串 public String(byte[] input)：根据输入byte数组input创建字符串 底层实现 使用构造函数创建String对象的时候，先在堆区中创建一个新的String对象（引用常量池中的字面量），同时在字符串常量池中保存其字面量，在栈中保存字符串对象的引用。若常量池中存在相同的字面值则只会在堆区中创建新的String对象\n参考补充材料\n在堆区中创建一个新的String对象 若常量池中不存在所需的字面量则在常量池中创建新的字面量并将堆区中的对象指向常量池中的字面量 若存在则将堆区中的对象指向常量池中的字面量 通过字面量创建 语法格式 1 String s=\u0026#34;abc\u0026#34; 底层实现 使用字面量创建String对象的时候，会将在常量池中创建字面量。而不会在堆区创建String对象。若使用了相同的字面值则直接复用常量池中的字面量\nJVM检查该字符串的字面是否存在于常量池中 若不存在则在常量池中创建新的字面量 若存在则复用常量池中的字面量 两者创建方式的比较 使用字面量创建String对象不会在堆区创建对象 使用构造函数创建String对象会在堆区创建对象 示例比较 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class StringExercise01 { public static void main(String[] args) { //字面量创建对象 String s1 = \u0026#34;abc\u0026#34;; String s2 = \u0026#34;abc\u0026#34;; //通过new+构造器的方式: 此时s3,s4保存的地址值，是数据在堆空间中开辟以后对应的地址值 String s3 = new String(\u0026#34;abc\u0026#34;); String s4 = new String(\u0026#34;abc\u0026#34;); //s1 首先看常量池有没有abc //s2 首先看常量池有没有abc 有，就将b直接指向abc //所以地址值是一样的 System.out.println(s1==s2);//true //s1在常量池中，s3和s4在堆区中，指向地址不同 System.out.println(s1==s3);//false System.out.println(s1==s4);//false //s3和s4在堆区中，但是两个对象指向地址不同 System.out.println(s3==s4);//false } } String对象的拼接操作 常量与常量的拼接结果在常量池，且常量池中不会存在相同内容的常量 只要其中有一个结果是变量，结果就在堆中 如果拼接的结果调用intern()方法，返回值就在常量池中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 String s1 = \u0026#34;Java\u0026#34;; String s2 = \u0026#34;Android\u0026#34;; String ss =\u0026#34;JavaAndroid\u0026#34;; String s3 = \u0026#34;Java\u0026#34;+\u0026#34;Android\u0026#34;; String s4 = s1 + \u0026#34;Android\u0026#34;; String s5 = \u0026#34;Java\u0026#34; + s2; String s6 = s1 + s2; System.out.println(ss==s3);//true System.out.println(ss==s4); //false System.out.println(ss==s5);//false System.out.println(ss==s6);//false System.out.println(s4==s5);//false String s7=s4.intern(); System.out.println(ss==s7);//true String的常见操作 字符串查找 查找字符串中的字符 charAt(int index) 方法：用于返回字符串指定位置的字符，返回值为 char 类型，参数为 int 类型\n1 2 3 4 String str = new String(\u0026#34;Hello World\u0026#34;); for (int i = 0; i \u0026lt; str.length(); i++) { System.out.println(\u0026#34;下标为\u0026#34; + i + \u0026#34;的元素为：\u0026#34; + str.charAt(i));//打印的是每个字母 } 查找字符串中下标 int indexOf(int ch)\t用于返回当前字符串中参数 ch 指定的字符第一次出现的下标 int indexOf(int ch, int fromIndex)\t用于从 fromIndex(包含) 位置开始查找ch指定的字符 int indexOf(String str)\t在字符串中检索 str 返回其第一次出现的位置，若找不到返回-1 int indexOf(String str, int fromIndex)\t表示从字符串的 fromIndex(包含) 位置开始检索str第一次出现的位置 int lastIndexOf(int ch)\t用于返回参数 ch 指定的字符最后一次出现的下标 int lastIndexOf(int ch, int fromIndex)\t用于从 fromIndex(包含) 位置开始反向查找 ch 指定字符出现的下标，若找不到返回-1 int lastIndexOf(String str)\t返回 str 指定字符串最后一次出现的下标 int lastIndexOf(String str, int fromIndex)\t用于从 fromIndex(包含) 位置开始反向搜索的第一次出现的下标 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 String str = \u0026#34;Good Good Study, Day Day Up!\u0026#34;; System.out.println(str.indexOf(\u0026#39;g\u0026#39;)); // -1 代表查找失败 System.out.println(str.indexOf(\u0026#39;G\u0026#39;)); // 0 该字符第一次出现的索引位置 System.out.println(str.indexOf(\u0026#39;G\u0026#39;, 0)); // 0 System.out.println(str.indexOf(\u0026#39;G\u0026#39;, 1)); // 5 // 查找字符串 System.out.println(str.indexOf(\u0026#34;day\u0026#34;)); // -1 System.out.println(str.indexOf(\u0026#34;Day\u0026#34;)); // 17 字符串中第一个字符的下标 System.out.println(str.indexOf(\u0026#34;Day\u0026#34;, 17)); // 17 字符串中第一个字符的下标 System.out.println(str.indexOf(\u0026#34;Day\u0026#34;, 18)); // 21 字符串中第一个字符的下标 // 字符串内容的反向查找 System.out.println(str.lastIndexOf(\u0026#34;Day\u0026#34;)); // 21 System.out.println(str.lastIndexOf(\u0026#34;Day\u0026#34;, 21)); // 21 System.out.println(str.lastIndexOf(\u0026#34;Day\u0026#34;, 20)); // 17 System.out.println(str.lastIndexOf(\u0026#34;Day\u0026#34;, 15)); // -1 字符串截取 substring(int beginIndex, int endIndex) 方法：返回字符串中从下标 beginIndex(包括) 开始到 endIndex(不包括) 结束的子字符串，返回值为 String 类型，参数为 int 类型 substring(int beginIndex) 方法：返回字符串中从下标 beginIndex(包括) 开始到字符串结尾的子字符串，返回值为 String 类型，参数为 int 类型 字符串比较 判定是否相等 equals(Object anObject) 方法：比较字符串内容是否相等并返回，返回值为 boolean 类型 equalsIgnoreCase(String anotherString)方法：比较字符串内容是否相等并返回，返回值为 boolean 类型，不考虑大小写， 如：\u0026lsquo;A’和’a’是相等 比较大小 compareTo(String anotherString) 方法：比较调用对象和参数对象的大小关系，返回值为 int 类型 compareToIgnoreCase(String str) 方法：比较调用对象和参数对象的大小关系，返回值为 int 类型，不考虑大小写，也就是’a’和’A’是相等的关系 比较方法\n方法调用者的字符依次与方法参数的字符作比较，即用 A 的 ASCII码减去 B 的ASCII码；结果有三种：负整数、正整数、零。负整数即按字典顺序 A 在 B 之前，正整数即 A 在 B 之后，零则为字符串相等。注意：比较出大小就不往后进行，即从第一个字符串开始比较，相同则比较下一个，直到比较出大小或比较到最后一个字符。\n判定前缀/后缀 startsWith(String prefix) 方法：判断字符串是否以参数字符串开头，返回值为 boolean 类型，参数为 String 类型 startsWith(String prefix, int toffset) 方法：从指定位置开始是否以参数字符串开头，返回值为 boolean 类型，参数 prefix 为 String 类型，toffset 为 int 类型 endsWith(String suffix) 方法：判断字符串是否以参数字符串结尾，返回值为 boolean 类型，参 数为 String 类型 示例代码\n1 2 3 4 5 6 String str = \u0026#34;Give you some color to see see\u0026#34;; System.out.println(str.startsWith(\u0026#34;G\u0026#34;));//true System.out.println(str.startsWith(\u0026#34; \u0026#34;));//false System.out.println(str.startsWith(\u0026#34;you\u0026#34;, 5));//true System.out.println(str.endsWith(\u0026#34; \u0026#34;));//false System.out.println(str.endsWith(\u0026#34;see\u0026#34;));//true 判定子串 contains(CharSequence s) 方法：判断当前字符串是否包含参数指定的内容，返回值为 boolean 类型\n1 2 3 String str = \u0026#34;Give you some color to see see\u0026#34;; System.out.println(str.contains(\u0026#34;some\u0026#34;));//true System.out.println(str.contains(\u0026#34;Some\u0026#34;));//false 字符串替换 replace(char oldChar, char newChar) 方法：使用参数newChar替换此字符串中出现的所有参数oldChar，返回值为 String 类型，参数为 char 类型 replace(CharSequence target, CharSequence replacement) 方法：用新字符串replacement替换所有的旧字符串target，返回值为 String 类型，参数为 CharSequence 接口 字符串拆分 split(String regex)：根据给定的正则表达式分割此字符串，并返回一个String数组。 split(String regex,int limit)：根据给定的正则表达式分割此字符串分割成limit组，并返回一个String数组。 字符串与其他类型的相互转换 数字和字符串之间相互转换 数字转字符串：String.valueOf(var var_name) 字符串转数字 Integer.valueOf(String var) Integer.parseInt(String var) 字符串和char数组的相互转换 字符串转字符数组：char[] toCharArray() 方法： 字符串转byte数组 byte[] getBytes() ","date":"2024-11-03T14:22:08+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84string%E7%B1%BB/","title":"Java中的String类"},{"content":"什么是依赖注入（DI） 组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。\n关键点分析 谁依赖于谁：当然是应用程序依赖于IoC容器； 为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源； 谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象； 注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据） Bean注入方式 @Autowired注入 使用@Autowired注解修饰要注入的对象\n1 2 @Autowired userMapper mapper; 注意事项 @Autowired注解默认按Bean对象的类型进行自动装配，若存在多个相同类型的Bean对象会报错 可以使用注解@Primary指定Bean对象的优先级，对优先级高的Bean对象使用 @Primary 注解 可以使用注解@Qualifier和@Autowired配合使用，@Qualifier的value属性用于按名字指定Bean对象 提示\nBean对象的默认名称是类名首字母小写\n@Resource ​\t使用 @Resource 注解修饰要注入的对象,@Resource 注解按照Bean对象名注入对象\n1 2 @Resource(name=\u0026#34;Bean_name\u0026#34;) userMapper mapper; 提示\n@Resource 和 @Autowired 的区别\n@Autowired 是Spring框架提供的注解，而 @Resource 是IDK提供的注解 @Autowired 默认是按照类型注入，而 @Resource 默认是按照名称注入。 ","date":"2024-11-03T13:37:35+08:00","permalink":"https://Tyritic.github.io/p/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/","title":"依赖注入"},{"content":"Scanner类 java.utils包中用于获取输入的类，用于解析基本类型和字符串类型的输入。它可以从控制台、文件、字符串等不同的数据源读取数据，并将其解析为适当的类型。\n基本构造函数 Scanner可以接收控制台的键盘输入（标准输入流），文件和字符串\n从控制台输入读取\n1 Scanner scanner = new Scanner(System.in); 从文件输入读取\n1 2 File file = new File(\u0026#34;input.txt\u0026#34;); Scanner scanner = new Scanner(file); 从字符串中读取\n1 2 String input = \u0026#34;Hello World!\u0026#34;; Scanner scanner = new Scanner(input); 基本用法 读取基本类型 nextInt()：读取int类型 nextShort()：读取short类型 nextLong()：读取long类型 nextFloat()：读取float类型 nextDouble()：读取double类型 读取字符串 next()：读取下一个字符串，遇到空白符（如空格、制表符、换行符等）停止 nextLine()：读取下一行文本，遇到回车停止 提示\nnext()和 nextLine()的区别\nnext()\n一定要读取到有效字符后才可以结束输入。 对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。 只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 next() 不能得到带有空格的字符串。 nextLine( )\n以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 可以获得空白。 先使用nextLine()再使用next()、nextInt()等没问题，但是先使用next()和nextInt()等之后就不可以再紧跟nextLine()使用。\n原因：因为next()等这些方法读取结束后会紧跟一个回车符，而nextLine()会直接读取到这个回车符，这就导致出现我们还没有来得及输入我们想要输入的数据，nextLine()就以为我们已经输入完了\n解决方法：我们直接在next()使用后加两个nextLine()即可了，这样第一个nextLine()就会当一个‘替死鬼’读取前一个next()遗留的空白符，第二个nextLine()就可以输入自己想要输入的数据啦！\n检验输入 hasNext()方法会检查输入中是否还有下一个单词，即是否存在非空白字符。这意味着，只要输入中还有非空白字符，无论是在当前行还是在下一行，hasNext()都会返回true。通常配合next()使用 hasNextLine()方法则会检查输入中是否还有下一行。如果输入中存在换行符，或者如果输入中至少还有一个字符（即使这个字符是空白字符），hasNextLine()都会返回true。但是如果输入已经到达结尾，或者输入中的下一个字符是输入流的结尾，hasNextLine()就会返回阻塞。 设置分隔符 Scanner类默认使用空白字符（空格、制表符、换行符等）作为分隔符，但可以自定义分隔符。\ndelimiter()用于查看当前分隔符\nuseDelimiter()方法用于修改分隔符\n示例代码 1 2 3 4 5 6 7 Scanner scanner = new Scanner(System.in); scanner.useDelimiter(\u0026#34;,\u0026#34;); // 使用逗号作为分隔符 System.out.print(\u0026#34;Enter comma-separated values: \u0026#34;); while (scanner.hasNext()) { String value = scanner.next(); System.out.println(\u0026#34;Value: \u0026#34; + value); } 关闭扫描器 使用完Scanner后，一定要记得将它关闭！因为使用Scanner本质上是打开了一个IO流，如果不关闭的话，它将会一直占用系统资源。\nclose()方法\n","date":"2024-11-03T12:09:48+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E6%93%8D%E4%BD%9C/","title":"Java中的键盘输入操作"},{"content":"Math类的简介 Java在Math类中封装了相关的数学函数，位于Java.lang包中\n构造方法是private的，且所有方法都是静态方法，可以不依赖实例进行调用\n静态常量 自然对数$e$：Math.E（double数据类型）\n圆周率$π$：Math.PI（double数据类型）\n三角函数 Math.toRadians()：角度 \u0026ndash;\u0026gt; 弧度 Math.toDegrees()：弧度 \u0026ndash;\u0026gt; 弧度 正切值：Math.sin() 余弦值：Math.cos() 反正弦值：Math.asin() 反余弦值：Math.acos() 正切值：Math.tan() 反正切值：Math.atan() 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* 三角函数 */ // 角度 --\u0026gt; 弧度 toRadians() double x = 45; // 45° 45° --\u0026gt; PI / 4 System.out.println(\u0026#34;45°转换为弧度：\u0026#34; + Math.toRadians(x)); System.out.println(Math.PI / 4); double y = 180; System.out.println(\u0026#34;180°转换为弧度：\u0026#34; + Math.toRadians(y)); System.out.println(Math.PI); // 弧度 --\u0026gt; 弧度 toDegrees() double z = 0.7853981633974483; // PI / 4 --\u0026gt; 45° System.out.println(\u0026#34;0.7853981633974483转换为角度\u0026#34; + Math.toDegrees(z)); // 正弦函数sin() double degrees = 45.0; double radians = Math.toRadians(degrees); System.out.println(\u0026#34;45° 的正弦值: \u0026#34; + Math.sin(radians)); // 余弦函数cos() System.out.println(\u0026#34;45° 的余弦值: \u0026#34; + Math.cos(radians)); // 反正弦值asin() System.out.println(\u0026#34;45° 的反正弦值: \u0026#34; + Math.asin(radians)); // 反余弦值acos() System.out.println(\u0026#34;45° 的反余弦值: \u0026#34; + Math.acos(radians)); // 正切值tan() System.out.println(\u0026#34;45° 的正切值: \u0026#34; + Math.tan(radians)); // 反正切值atan() atan2() double m = 45; double n = 30; System.out.println(\u0026#34;45° 的反正切值1: \u0026#34; + Math.atan(radians)); // atan() System.out.println(\u0026#34;反正弦值2: \u0026#34; + Math.atan2(m, n)); // atan2() 坐标系表示角的反正切值 指数函数 Math.exp()：自然对数e的幂函数 Math.pow()：幂函数 Math.sqrt()：平方根 Math.cbrt()：立方根 Math.log()：ln函数 Math.log 10()：log_10函数 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* 指数函数 */ double p = 8; double q = 3; // exp() System.out.println(\u0026#34;e的6次幂: \u0026#34; + Math.exp(p)); // e^8 // pow() System.out.println(\u0026#34;8的3次幂: \u0026#34; + Math.pow(p, q)); // 8^3 // sqrt() System.out.println(\u0026#34;8的平方根: \u0026#34; + Math.sqrt(p)); // cbrt() System.out.println(\u0026#34;8的立方根: \u0026#34; + Math.cbrt(p)); // 2 // log() System.out.println(\u0026#34;ln(8): \u0026#34; + Math.log(p)); // ln(8) // log10() System.out.println(\u0026#34;log10(8): \u0026#34; + Math.log10(p)); // log10(8) 取整函数 Math.ceil()：上取整 Math.floor()：下取整 Math.rint()：最近的整数，0.5返回0 Math.round()：四舍五入的整数，0.5返回1 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 取整 */ double d = 100.675; double e = 100.500; // \u0026gt;=的整数 ceil() System.out.println(\u0026#34;ceil(100.675): \u0026#34; + Math.ceil(d)); // \u0026lt;=的整数 floor() System.out.println(\u0026#34;floor(100.675): \u0026#34; + Math.floor(d)); // 最近的整数 rint() System.out.println(\u0026#34;rint(100.675): \u0026#34; + Math.rint(d)); System.out.println(\u0026#34;rint(100.500): \u0026#34; + Math.rint(e)); // 四舍五入的整数 round() System.out.println(\u0026#34;round(100.675): \u0026#34; + Math.round(d)); System.out.println(\u0026#34;round(100.500): \u0026#34; + Math.round(e)); 比较函数 Math.min()：最小值 Math.max()：最大值 Math.abs()：绝对值 示例代码\n1 2 3 4 5 6 7 8 9 /* 其他 */ // min() 最小 System.out.println(\u0026#34;min(): \u0026#34; + Math.min(2, 10)); // max() 最大 System.out.println(\u0026#34;max(): \u0026#34; + Math.max(2, 10)); // abs() 绝对值 System.out.println(\u0026#34;abs(): \u0026#34; + Math.abs(-5)); 随机数生成 Math.random()：随机产生一个数 random()，随机数范围为 0.0 =\u0026lt; Math.random \u0026lt; 1.0 a+Math.random()+b生成[a,a+b)\n","date":"2024-11-03T11:35:06+08:00","permalink":"https://Tyritic.github.io/p/java%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E5%AD%A6%E6%93%8D%E4%BD%9C/","title":"Java中的基本数学操作"},{"content":"一维数组的声明与创建 声明数组 1 2 ElementType[] array_name; // 一维数组 ElementType[][] array_name; // 二维数组 创建数组 除非数组被创建否则不能分配任何元素\n1 array_name=new ElementType[size]; 初始化数组 静态初始化 指定数组内的元素而不指定数组的长度\n1 ElementType array_name={x1,x2,..xn}; 动态初始化 指定数组的长度而不指定数组的元素，系统自动赋默认值\n1 ElementType[]array_name=new ElementType[size]; 获取一维数组长度 1 int length=array_name.length; 访问一维数组元素 通过数组下标访问，数组下标从0开始\n数组元素的默认值 整型：0 浮点型：0.0 布尔：false 字符：’\\u000' 字符串：null 引用数据类型：null 一维数组的处理 遍历数组 不通过数组下标可以完成数组的遍历\n1 2 3 4 for(数据类型 引用名:数组名) { // 循环体 } 复制数组 使用for循环/for-each循环逐一复制元素\n使用system类中的静态方法arraycopy复制数组\n1 2 3 4 System.arraycopy(sourceArray,srcPos,targetArray,tarPos,length); // srcPos：源数组中的起始位置 // tarPos：目标数组的起始位置 // length：决定复制数组的元素个数 提示\n数组的复制不能简单使用赋值号，赋值号只是将引用的地址值赋值，此时两个变量指向同一个数组\n可变长参数列表 可以将类型相同但是数目可变的参数作为方法的形参\n语法形式 1 TypeName... parameterName 示例代码 1 2 3 4 5 6 // 定义一个带有可变参数的方法 public static void printAll(String... strings) { for (String s : strings) { System.out.println(s); } } 注意事项 可变参数必须是方法参数列表中的最后一个参数。 一个方法只能有一个可变参数。 当你调用一个带有可变参数的方法时，你可以直接传入逗号分隔的参数列表，也可以传入一个数组（数组会自动被拆分成单独的参数）。 在调用方法时同时传入了一个数组和一个或多个单独的参数，那么数组必须被明确地作为最后一个参数传入（即它不能被单独的可变参数分隔开） 二维数组的声明和创建 初始化二维数组 静态初始化 1 ElementType[][]array_name=new ElementType[][]{{var1,var2,..varN},{var1,var2,..varN}}; 动态初始化 1 ElementType[][]array_name=new ElementType[m][n]; m表示这个二维数组存放了多少个一维数组 n表示这个一维数组存放多少个元素 二维数组的存储方式 二维数组本质上是一个一维数组，这个一维数组的存储元素是其他一维数组的地址值\n例如\n1 int[][]arr={{11,22},{33,44}}; 其中arr的地址为0x0011\narr的元素为\narr[0]为0x0022（对应arr[0][])\narr[1]为0x0033(对应arr[1][])\n访问二维数组元素 1 array_name[m][n]; m索引指定访问哪个一维数组 n索引指定访问这个一维数组的哪个元素 获取二维数组的长度 对应二维数组array_name[m][n]\n通过array_name.length获取二维数组中包含多少个一维数组 通过array_name[0].length获取一维数组的长度 ","date":"2024-11-03T00:27:14+08:00","permalink":"https://Tyritic.github.io/p/java%E6%95%B0%E7%BB%84/","title":"Java数组"},{"content":"请求响应过程 基本流程 浏览器向SpringBoot项目中内置的Tomcat服务器发送请求 SpringBoot项目中的controller类接收浏览器发出的请求并发送响应 请求参数的接收 简单参数 方法一：设置controller类中的函数形参名和请求的参数名相同 1 2 3 4 5 @RequsetMapping(\u0026#34;/simpleParam\u0026#34;) public String getParam(String param) { return param; } 方法二：参数名和形参名不匹配使用@RequestParam注解的name属性将参数名映射到形参 1 2 3 4 5 @RequestMapping(\u0026#34;/simpleParam\u0026#34;) public String getParam(@RequestParam(name=“username\u0026#34;)String param) { return param; } 提示\n@RequestParam\n作用：建立请求参数和controller形参的映射关系\n属性\nvalue/name：请求的参数名 required：参数是否必需。默认为true 实体对象参数 简单实体对象 请求参数与形参对象属性名相同\n1 2 3 4 5 @RequestMapping(\u0026#34;/objectParam\u0026#34;) public User getParam(User user) { return user; } 复杂实体对象（对象的成员变量是对象） 请求参数与形参对象属性名相同，按对象层次关系接收\n数组集合参数 数组参数 请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数\n1 2 3 4 5 @RequestMapping(\u0026#34;/arrayParam\u0026#34;) public User getParam(String[]array) { return array; } 集合参数 请求参数名与形参数组名称相同且请求参数为多个，@RequestParam绑定参数关系\n1 2 3 4 5 @RequestMapping(\u0026#34;/listParam\u0026#34;) public User getParam(@RequestParam List\u0026lt;String\u0026gt;param) { return param; } 日期参数 使用**@DateTimeFormat**注解完成日期格式转换\n1 2 3 4 5 @RequestMapping(\u0026#34;/dateParam\u0026#34;) public String getParam(@DateTimeFormat(pattern=\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;) LocalDateTime param) { return param.toString(); } 提示\n@DateTimeFormat\npattern属性用于指定时间格式\nJson参数 JSON数据键名与形参对象属性名相同，定义pojo类型形参即可接收参数，需要使用 @RequestBody标识\n1 2 3 4 5 @RequestMapping(\u0026#34;/jsonParam\u0026#34;) public String getParam(@RequestBody User user) { return user.toString(); } 路径参数 通过请求URL直接传递参数，使用{..}来标识该路径参数，需要使用 @PathVariable 获取路径参数\n1 2 3 4 5 @RequestMapping(\u0026#34;/path/{id}\u0026#34;) public String getParam(@PathVariable Integer id) { return id; } 响应报文的回写 @RequestBody 类型：方法注解，类注解 位置：controller类/方法上 作用：将方法返回值直接响应，如果返回值类型是 实体对象/集合，将会转换为JSON格式响应 说明：@RequestController=@RequestBody+@Controller ","date":"2024-11-03T00:05:27+08:00","permalink":"https://Tyritic.github.io/p/%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/","title":"请求与响应"},{"content":"方法的定义 1 2 3 修饰符 返回值类型 方法名(形参列表){ // 方法体 } 修饰符 访问修饰符 Java 中的访问修饰符用于控制类、字段、方法和构造函数的访问权限。通过使用访问修饰符，可以实现封装，保护数据，并控制不同部分之间的访问范围。\npublic 定义：被public修饰的成员可以被外界访问\n作用域：在一个Java源文件（.java文件）中只有一个类被声明为public，且这个源文件的文件名要与这个公共类的类名相同\npublic修饰类成员时可以在所有类中被访问\n在继承中public修饰的所有成员都被继承\nprotect 定义：受保护的，受该类所在包保护，只能被同一个包内的类或者不同包的子类访问\n作用域：被protect修饰的成员可以被同一个包内的所有类访问，同时也会被该类的所有子类继承\ndefault 定义：只对同一个包中的类友好，只能被同一个包中的类访问\n作用域：同一个包中的所有类可以访问，被default修饰的成员只能被同一个包中的子类继承\nprivate 定义：私有的，只能被同一个类中的成员访问\n作用域：同一个类\n表格整理如下\n修饰符 当前类 同一包内 子类（不同包） 其他包 public 是 是 是 是 protected 是 是 是 否 default 是 是 否 否 private 是 否 否 否 静态修饰符 static 被static修饰的成员是静态方法，静态方法属于整个类，非静态方法属于单个对象\n静态方法的生命周期与类一样长，随着类的消亡而消亡\n非静态方法的生命周期与对象一样长，随着对象的消亡而消亡\n静态方法和非静态方法的对比参考补充资料\n方法调用 main方法作为程序入口先压入栈区 执行main方法中的代码，遇到方法后，将该方法压入栈区，执行完毕后出栈 方法重载 方法重载（Overloading） ：在同一个类中，允许有多个同名方法，只要它们的参数列表不同（参数个数、类型或顺序）。主要关注方法的签名变化，适用于在同一类中定义不同场景下的行为。\n判定依据 方法在同一个类中，且具有相同的方法名 具有不同的形参列表（满足以下其中之一即可） 形参个数不同 形参类型不同 形参顺序不同 提示\n方法重载与返回值无关\n方法重载与方法重写的区别见补充材料\n方法的参数传递 在 Java 中，参数传递只有按值传递，不论是基本类型还是引用类型。\n方法传递基本数据类型 具体类型见往期博客\n基本数据类型的特点 基本数据类型在栈空间中存储的是真实的数据字面值，在堆区中不开辟空间\n具体表现 方法中对参数的改变不会影响原始变量的值\n示例代码 1 2 3 4 5 6 7 8 9 10 public static void main(String [] args) { int nums=100; change(nums); //change(100) System.out.println(nums); //nums=100; } public static void change(int nums) { nums=110; } 内存解释 每个方法压入栈区中，都会有独立的栈空间，在该方法的栈空间中传入的实际上是参数值的副本（参数的字面值）来对形参进行初始化，在这个栈区中形参值发生了改变。方法执行完成后出栈，原来栈区中的变量不受影响\n方法传递引用数据类型 除基本数据类型以外的所有数据类型包括数组，字符串，类都是引用数据类型\n特点 引用数据类型在栈空间中存储的是其地址值，在堆区中开辟空间，真实的数据保存在堆区中\n具体表现 方法中对参数的改变会影响原始变量的值\n示例代码 1 2 3 4 5 6 7 8 9 10 public static void main(String [] args) { int[] nums={0,1,2}; change(nums); //change(nums) System.out.println(nums); //nums={0,3,2}; } public static void change(int[] nums) { nums[1]=3; } 内存解释 每个方法压入栈区中，都会有独立的栈空间，在该方法的栈空间中传入的实际上是参数值的副本（参数的地址值）对形参进行初始化。\n在这个栈区中形参和原始变量指向同一块内存区域，对形参的修改会通过引用影响原始变量。\n方法执行完成后出栈，原来栈区中的变量指向的内存区域已经受到影响\n总结 方法参数传递的本质是值传递（引用数据类型被视为地址值） 函数调用时在函数作用域创建栈区空间，再使用实参对形参进行初始化（形参作为实参的副本） 基本数据类型：形参改变不影响实参，形参在方法结束后弹出栈区 引用数据类型：形参是地址值，形参地址值的改变不影响实参地址值，此时形参和实参指向同一个地址 特殊的例子String类 具体表现 作为一个单独的数据类型，传递效果与传递基本数据类型相同\n作为对象的成员，传递效果与传递引用数据类型相同\n特点 String对象一旦创建就不可更改（String是不可变类） String类的所有方法都不会改变String的内容 示例代码（作为单独的数据类型） 1 2 3 4 5 6 7 8 public static void main(String[] args) { String s1=new String(\u0026#34;张三\u0026#34;); change(s1); System.out.println(s1); // s1=\u0026#34;张三\u0026#34; } public static void change(String s2){ s2=\u0026#34;李四\u0026#34;; } 解析过程 方法调用前\n首先 String s=new String(\u0026quot;张三\u0026quot;)，在堆中开辟内存放对象，变量s1在栈中，存放的是堆的地址 将地址0x11传入change方法复制一份用于初始化s2，此时s2放的是地址0x11 方法调用时\ns2=\u0026quot;李四\u0026quot;；通过=赋值是直接先去常量池寻找是否存在与“李四”相同的值，有的话直接将其地址返回。否则创建一个值，再返回其地址。这里改变的是s2在栈区 方法调用后\ns1和s2最终存储的地址不同\n示例代码（作为类的成员变量） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Person { String name; public Person(String name){ this.name=name; } } public static void main(String[] args) { Person p1 = new Person(\u0026#34;张三\u0026#34;); change(p1); System.out.println(p1.name); // 李四 } public static void change(Person p2){ p2.name=\u0026#34;李四\u0026#34;; } 解析过程 方法调用前\n首先 Person s=new Person(\u0026quot;张三\u0026quot;)，在堆中开辟内存放对象，变量p1在栈中，存放的是堆的地址 将地址0x11复制一份给s2用于初始化，此时s2放的是地址0x11 方法调用时\np2.name=\u0026quot;李四\u0026quot;；要知道通过=赋值是直接先去常量池寻找是否存在与“李四”相同的值，有的话直接将其地址返回。否则创建一个值，再返回其地址。与上一问题不同的是，这里我们改变的是name，而name在堆中，所以常量池中地址是复制给了name 方法调用后\np1.name和p2.name最终存储的地址相同\n","date":"2024-11-02T20:30:52+08:00","permalink":"https://Tyritic.github.io/p/java%E6%96%B9%E6%B3%95/","title":"Java方法"},{"content":"如何读懂SpringBoot项目结构 SpringBoot项目本质上是一个Maven项目，大体骨架与普通的Maven项目相同\n普通Maven项目结构\n1 2 3 4 5 6 7 8 9 10 Maven-name/ |--src（源代码） |\t|--main（项目实际资源） |\t|--java（java代码） |\t|--resource（资源文件） |\t|--test（测试代码资源） |\t|--java |\t|--resource |--pom.xml（依赖配置文件） |--target（打包后的jar包存放地） 开发者的代码都存放到src/main/java文件夹中\n代码层 根目录：src/main/java\n作用：该目录下存放入口启动类及程序的开发目录。在这个目录下进行业务开发、创建实体层、控制器层、数据连接层等。\n注解\n入口启动类：运行整个项目main方法的类\n1 2 3 4 5 6 @SpringBootApplication public class UserApplication { public static void main(String[] args) { SpringApplication.run(UserApplication.class, args); } } 其中@SpringBootApplication用于标识SpringBoot项目的入口类\n控制器层（controller) 根目录：src/main/java/controller\n作用：主要负责具体业务模块的流程控制，负责前后端交互，接受前端请求，调用service层，接收service层返回的数据，最后返回具体的页面和数据到客户端\n功能实现：通过实现controller类来实现\n1 2 3 4 5 6 7 @RequestMapping(\u0026#34;/user\u0026#34;) @RestController // @RestController=@RequestMapping + @ResponseBody public class UserController { @RequestMapping(\u0026#34;/映射资源\u0026#34;) public List\u0026lt;User\u0026gt; findAll(){ return userService.findAll(); } 业务逻辑层(service) 根目录：src/main/java/service\n作用：主要负责业务逻辑应用设计\n功能实现：首先设计service接口，然后再设计其实现该接口的类(serviceImpl)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Service public class UserRegisterServiceImpl implements UserRegisterService { @Autowired UserMapper userMapper; @Override public void register(UserRegisterDTO userRegisterDTO) { //判断用户是否已存在 User tempUser=userMapper.getByUsername(userRegisterDTO.getUsername()); if(tempUser!=null){ log.error(\u0026#34;用户{}已存在\u0026#34;,userRegisterDTO.getUsername()); throw new UsernameHasBeenRegisteredException(\u0026#34;用户名已存在\u0026#34;); } //注册 User user=new User(); BeanUtils.copyProperties(userRegisterDTO,user); userMapper.register(user); log.info(\u0026#34;用户{}注册成功\u0026#34;,userRegisterDTO.getUsername()); } } 常量层(common) 根目录：src/main/java/common\n作用：主要存放工具类（utils)，常量类（constant），统一响应模板（result），统一异常处理（exception)\n数据库实体层(pojo) 根目录：src/main/java/pojo\n作用：存放数据库的实体类，通常一个实体类对应一张数据库表\n数据持久层（mapper) 根目录：src/main/java/mapper\n作用：访问数据库，向数据库发送sql语句，完成数据的增删改查任务\n功能实现：通过@Mapper注解接口来建立java方法和sql语句的映射关系\n1 2 3 4 5 6 7 8 9 10 @Mapper public interface DistrictMapper { List\u0026lt;District\u0026gt;searchAll(String tname); boolean deleteDistrict(String dname); District getDistrictByName(String dname); void insertDistrict(DistrictDTO districtDTO); void updateDistrictTdid(DistrictDTO districtDTO); boolean deleteAll(Long tid); void updateDistrictDetail(DistrictDTO districtDTO); } 数据传输对象（dto） 根目录：src/main/java/dto（或者放入pojo层中）\n作用：对entity进行封装，不破坏实体类结构，进行层与层之间的数据传输\n提示\n​\tDTO通常用于\n控制器（Controller）与服务层（Service）之间的数据传输：控制器通过 DTO 将请求参数传递给服务层，服务层返回 DTO 对象给控制器。 服务层与持久层（Mapper）之间的数据传输：服务层通过 DTO 将实体对象转换为需要的数据结构传递给持久层，持久层返回 DTO 对象给服务层。 视图包装对象（vo） 根目录：src/main/java/vo（或者放入pojo层中）\n作用：用于封装客户端请求的数据同时不破坏原有的实体类结构\n提示\nVO在实际开发中通常作为controller类方法的形参从而起到封装客户端请求数据的作用\n配置类（config) 根目录：src/main/java/config\n作用：以java类代替yaml文件进行Bean对象配置\n功能实现：通过**@Configuration**注解一个java类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration public class WebMvcConfiguration implements WebMvcConfigurer { @Autowired JwtTokenUserInterceptor jwtTokenUserInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { log.info(\u0026#34;开始注册拦截器\u0026#34;); log.info(\u0026#34;注册Jwt令牌拦截器：{}\u0026#34;,jwtTokenUserInterceptor); registry.addInterceptor(jwtTokenUserInterceptor) .addPathPatterns(\u0026#34;/Operator/**\u0026#34;) .excludePathPatterns(\u0026#34;/Operator/user/login\u0026#34;) .excludePathPatterns(\u0026#34;/Operator/user/register\u0026#34;); } } 参数配置类（properties） 根目录：src/main/java/properties\n作用：以java实体类代替yaml文件进行参数配置\n功能实现：通过**@ConfigurationProperties**注解一个java类\n1 2 3 4 5 6 7 8 9 10 @Data @Component @ConfigurationProperties(prefix = \u0026#34;operator.aliyun.oss\u0026#34;) public class AliyunOSSProperties { String endpoint; String accessKeyId; String accessKeySecret; String bucketName; String region; } 过滤器（filter） 根目录：src/main/java/filter\n作用：在Servlet 处理请求之前或响应之后对数据进行某些处理，实现诸如日志记录、请求数据修改、响应数据修改、权限控制等功能\n提示\n过滤器工作在 Servlet 容器容中，它拦截客户端的请求和服务器的响应。过滤器链（Filter Chain）是多个过滤器按照一定的顺序执行的集合，一个请求可以依次通过多个过滤器，然后到达目标 Servlet，响应也会按相反的顺序经过这些过滤器返回给客户端。\n生命周期管理\nServlet 容器负责过滤器的生命周期管理。过滤器的生命周期方法包括 init（初始化）、doFilter（执行过滤操作）和 destroy（销毁）。 请求处理流程\n当一个请求到达 Servlet 容器时，容器会根据部署描述符（web.xml）或注解配置，决定是否以及如何调用过滤器链。 过滤器链是多个过滤器按照一定的顺序执行的集合。容器按照这个顺序依次调用每个过滤器的 doFilter 方法。 doFilter 方法\n在 doFilter 方法中，开发者可以实现自定义的处理逻辑，比如修改请求头、记录日志等。 doFilter 方法中必须调用 FilterChain 的 doFilter 方法，这样请求才能继续传递给下一个过滤器或目标资源（如 Servlet）。如果不调用，请求处理流程将会停止。 工作机制\n过滤器可以修改请求和响应，但它们通常不会生成响应或结束请求，因为这通常是 Servlet 或其他资源的职责 参考文章：\nFilter（过滤器）和 Interceptor（拦截器）详解_过滤器和拦截器-CSDN博客 功能实现\n创建过滤器类\n实现 javax.servlet.Filter 接口。 重写 init、doFilter 和 destroy 方法。 配置过滤器\n使用注解 @WebFilter 进行声明和配置。 或者在 web.xml 文件中配置。 编写过滤逻辑：\n在 doFilter方法中实现具体的过滤逻辑。 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import javax.servlet.*; import javax.servlet.annotation.WebFilter; import java.io.IOException; @WebFilter(\u0026#34;/example/*\u0026#34;) // 过滤器应用于 URL 模式 \u0026#34;/example/*\u0026#34; public class ExampleFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { // 初始化代码，例如资源加载 } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { // 在请求处理之前执行的代码 System.out.println(\u0026#34;Before Servlet processing\u0026#34;); chain.doFilter(request, response); // 将请求传递给下一个过滤器或目标资源 // 在请求处理之后执行的代码 System.out.println(\u0026#34;After Servlet processing\u0026#34;); } @Override public void destroy() { // 清理代码，例如释放资源 } } 拦截器（interceptor） 根目录：src/main/java/interceptor\n作用：是 Spring MVC 框架中的一个核心组件，用于在处理 HTTP 请求的过程中进行拦截和处理。拦截器主要用于实现跨切面（cross-cutting）的逻辑，如日志记录、性能统计、安全控制、事务处理等。\n功能实现\n创建拦截器类：\n实现 HandlerInterceptor接口或继承 HandlerInterceptorAdapter类。 重写 preHandle、postHandle 和 afterCompletion 方法。 注册拦截器：\n创建一个配置类，实现 WebMvcConfigurer接口。 重写 addInterceptors 方法来添加拦截器。 编写拦截逻辑：\n在 preHandle、postHandle 和 afterCompletion方法中实现具体的拦截逻辑。 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { // 请求处理前的逻辑 return true; // 返回 true 继续流程，返回 false 中断流程 } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) { // 请求处理后的逻辑，但在视图渲染前 } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { // 请求处理完毕后的逻辑 } } @Configuration public class WebMvcConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new MyInterceptor()).addPathPatterns(\u0026#34;/**\u0026#34;); // 应用于所有路径 } } 项目配置层 根目录：src/main/resource\napplication.yml：项目的整体配置文件\nmapper：数据库映射文件\n","date":"2024-11-02T19:26:08+08:00","permalink":"https://Tyritic.github.io/p/springboot%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/","title":"SpringBoot项目结构"},{"content":"什么是HTTP协议 ​\tHTTP协议（Hyper Text Transfer Protocol，超文本传输协议）：规定了浏览器和服务器之间数据传输的规则。\n特点 在传输层上基于TCP协议\n提示\nTCP协议是面向连接的，安全性好。\n基于请求-响应机制\n无状态协议，对于事务的处理没有记忆，每次请求-响应都是独立的\n优点：速度快 缺点：多次请求之间不能共享数据 HTTP请求协议 请求报文结构 请求行（红色部分）：请求数据的第一行（请求方式/资源路径/协议版本）\n注解\n常见的请求方式有\nGET：请求指定页面的信息 POST：向指定资源提交数据进行处理请求，数据被包含在请求体 DELETE：请求服务器删除指定的页面 PUT：从客户端向服务端传输的数据取代指定的页面，向指定的位置上传最新的内容 请求头（深黄色部分）：以键值对的形式表现\n请求体（浅黄色部分）：在POST请求中存放请求参数\n提示\nGET请求没有请求体\n请求参数\nGET：请求参数在请求行中，且GET请求没有请求体，GET请求大小有限制 POST:请求参数在请求体中，POST请求大小没有限制 HTTP响应协议 响应报文结构 ​\t响应行（红色部分）：响应报文的第一行（协议版本，状态码，描述）\n注解\nhttp状态码用于描述响应结果\n分为以下几类\n1XX（临时响应信息提示）：这些状态代码表示临时的响应。客户端在收到常规响应之前，应准备接收一个或多个1xx 100（继续） ：请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101（切换协议） ： 服务器将遵从客户的请求转换到另外一种协议 2XX（成功） 200（成功）：服务器已成功处理了请求。 201（已创建）：请求成功并且服务器创建了新的资源。 202（已接受）：服务器已接受请求，但尚未处理。 3XX（重定向）：表示要完成请求，需要进一步操作。客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同的页面，或通过代理服务器重复该请求。 建议在每次请求中使用重定向不要超过 5次。 300（多种选择）：针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301（永久移动）：请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置 4XX（请求错误）：这些状态码表示请求可能出错，客户端似乎有问题。 400（错误请求）：服务器不理解请求的语法。 401（未授权）：请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。 403（禁止）：服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码(您可以在 Google网站管理员工具诊断下的网络抓取页面上看到此信息)，可能是您的服务器或主机拒绝了 Googlebot 访问。 404（未找到）：服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。 5XX（服务器错误）：服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错 500 （服务器内部错误） ：服务器遇到错误，无法完成请求。 响应头（黄色部分）：以键值对形式表现\n响应体（绿色部分）：存放响应数据\nHTTP协议解析 ​\tWeb服务器：一个软件程序，对HTTP协议进行封装，使得开发者不必直接面对HTTP协议进行开发\nTomcat服务器 基本使用 启动Tomcat服务器：双击Tomcat服务器目录下的bin\\startup.bat\n关闭Tomcat服务器\nCTRL+C：正常关闭 直接关闭运行窗口：强制关闭 双击Tomcat服务器目录下的bin\\shutdown.bat：正常关闭 部署项目：将应用放入webapps目录下\nTomcat服务器的目录结构 1 2 3 4 5 6 7 8 Tomcat/ |--bin（可执行文件） |--conf（配置文件） |--lib（Tomcat依赖的jar包） |--logs（日志文件） |--temp（测试代码资源） |--webapps（应用发布目录） |--resource（工作目录） ","date":"2024-11-02T16:04:47+08:00","permalink":"https://Tyritic.github.io/p/http%E5%8D%8F%E8%AE%AE/","title":"HTTP协议"},{"content":"顺序结构 代码逐行执行，执行逻辑为线性逻辑\n选择结构 代码遇到选择结构根据关系表达式的不同计算结果执行不同的操作\nif语句 语法结构 1 2 3 if(关系表达式){ //语句体 } 执行流程 计算关系表达式 若为 true 执行语句体内的语句，若为 false 则跳过语句体内的语句 继续执行语句体外的语句 if-else语句 语法结构 1 2 3 4 5 if(关系表达式){ //语句体1 }else{ //语句体2 } 执行流程 计算关系表达式 若为 true 执行语句体1内的语句，若为 false 则执行语句体2内的语句 继续执行语句体外的语句 if-else if语句 语法结构 1 2 3 4 5 6 7 8 9 if(关系表达式 1){ //语句体1 }else if(关系表达式 2){ //语句体2 } ... else{ //语句体n+1 } 执行流程 计算关系表达式1 若为 true 执行语句体1内的语句，若为 false 则计算关系表达式2 若为 true 执行语句体2内的语句，若为 false 则计算关系表达式3 以此类推 若所有的关系表达式为 false 则执行语句体n+1 switch语句 语法结构 1 2 3 4 5 6 7 8 9 10 11 12 switch(表达式){ case 值1: 语句体1; break; case 值2: 语句体2; break; ...... default: 语句体 n+1 break; } 执行流程 计算表达式的值 依次与case后面的值比较。若有对应的值就会执行对应的语句体，在执行过程中遇到break结束整个switch语句 若与所有的case后面的值不匹配，便会执行default内的语句体 格式说明 表达式取值只能为byte，short，int，char，enum，string case后面是与关系式匹配的值，只能是字面量不能说变量且不允许重复 注意事项 default 可以放在任意位置，也可以省略不写 不写 break会发生case穿透问题，在case匹配过程中若没有break会执行下一个case的语句体，直到遇到 break/大括号 JDK12的新特性 语法格式 1 2 3 4 5 6 7 8 9 10 11 12 13 switch(表达式) case 值1 -\u0026gt; { //语句体1 } case 值2 -\u0026gt; { //语句体2 } .... default -\u0026gt;{ //语句体n+1 } 循环结构 for循环 语法格式 1 2 3 4 for(初始化语句;终止条件判断语句;条件控制语句) { //循环体结构 } 执行流程 执行初始化语句 执行条件判断语句，检验其结果 若为 false，循环结束 若为 true，执行循环体语句 执行条件控制语句 单次循环结束后继续执行条件判断语句 while循环 语法格式 1 2 3 4 5 6 // 初始化语句 while(条件判断语句) { // 循环体语句 // 条件控制语句 } 执行流程 执行初始化语句 执行条件判断语句，检验其结果 若为 false，循环结束 若为 true，执行循环体语句 执行条件控制语句 单次循环结束后继续执行条件判断语句 提示\nfor和while的对比\n相同点：运行规则相同\n不同点\nfor循环中控制循环的变量在循环结束后无法被访问，while循环中可以继续使用 for循环限定循环次数和范围，while循环不知道循环次数 do-while循环 语法结构 1 2 3 4 5 // 初始化语句 do{ // 循环体语句 // 条件控制语句 }while(条件判断语句) 执行流程 执行初始化语句 先执行条件判断语句 执行条件控制语句 单次循环结束后继续执行条件判断语句 若为 false，循环结束 若为 true，执行循环体语句 循环控制语句 break：立即终止当前所在的循环\ncontinue：跳过当前循环的剩余部分，直接进入下一次循环\n在嵌套循环中，break 和 continue 仅影响它所在的最近一层循环\n","date":"2024-11-02T15:41:14+08:00","permalink":"https://Tyritic.github.io/p/java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%84/","title":"Java程序运行结构"},{"content":"算术运算符 一般运算符 $+$：加法 $-$：减法 $*$：乘法 $/$：除法 $%$：取余数 注意事项 整数之间相除只会得到结果的整数部分 小数直接参与运算结果可能不准确 至少有一个操作数需要是浮点类型才能得到浮点数结果 字符串的拼接操作 使用$+$让字符串前后拼接，拼接操作从左向右连续执行\n字符的加法 字符和字符的加法以及字符和整型的加法是通过将字符转换成ASCII码来进行的加法\n自增自减运算符 符号 作用 等效语句 ++ 变量加一 $a++ \\iff a=a+1$ \u0026ndash; 变量减一 $a\u0026ndash; \\iff a=a-1$ 前置与后置的区别 $$ var++ \\iff ++var \\iff var=var+1 \\\\ var-- \\iff --var \\iff var=var-1 $$ 参与计算是有区别\n后置时先使用变量的原始值计算，然后对变量加一\n1 2 3 4 5 6 int a=10; int b=a++; //结果 //a：10 //b：11 前置时先对变量加一，再使用变量的新值进行计算\n1 2 3 4 5 6 int a=10; int b=++a; //结果 //a：11 //b：11 赋值运算符 分类 符号 作用 说明 = 直接赋值 int a=10; 将10赋值给变量a += 加后赋值 a+=b; 将a+b赋值给变量a -= 减后赋值 a-=b; 将a-b赋值给变量a *= 乘后赋值 a*=b; 将a*b赋值给变量a /= 除后赋值 a/=b; 将a/b赋值给变量a %= 余后赋值 a%=b; 将a%b赋值给变量a 注意事项 底层实现中包含了强制类型转换 在表达式中所有其他运算符完成后再进行计算 关系运算符 分类 $\u0026gt;$ 大于 $\u0026lt;$ 小于 $\\leq$ 小于等于 $\\geq$ 大于等于 $==$ 等于 $!=$ 不等于 运算结果为 boolean\n逻辑运算符 一般逻辑运算符 \u0026amp; 逻辑与 全真为真 | 逻辑或 一真为真 ! 逻辑非 取反 ^ 逻辑异或 相同为假，不同为真 短路逻辑运算符 \u0026amp;\u0026amp; 逻辑与 结果与\u0026amp;相同但是具有短路效果 || 逻辑或 结果与|相同但是具有短路效果 短路效果指的是当左边的表达式可以确定最终结果那么就不会执行右边的表达式\n三元运算符 语法格式 1 (关系表达式)?(表达式1):(表达式2) 计算规则 计算关系表达式的值 判断关系表达式的运算结果 若为 true 执行表达式1 若为 false 执行表达式2 ","date":"2024-11-02T12:23:34+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6/","title":"Java的运算符"},{"content":"字面量 数据在程序中的运行格式\n字面量类型 整数类型：不带小数点的数字 浮点数类型：带小数点的数字 字符串类型：用双引号括起来的多个字符 字符类型：用单引号括起来的单个字符 布尔类型：true/false 空类型：null 基本数据类型 整型\n整型 取值范围 内存占用 byte $-2^7 到 2^7-1 $ 1 short $-2^{15} 到 2^{15}-1 $ 2 int $-2^{31} 到 2^{31}-1 $ 4 long（字面量之后加上大写L） $-2^{63} 到 2^{63}-1 $ 8 浮点数\n浮点数 取值范围 内存占用 float（字面量之后加上大写F） 4 double 8 字符\n字符 取值范围 内存占用 char 2 布尔\n布尔 取值范围 内存占用 boolean 数据类型转换 数据类型不同不能直接参与运算，需要进行类型转换后再进行运算\n隐式类型转换 将取值范围小的数据赋值给取值范围大的数据类型时，程序自动进行类型转换\n提升规则 取值范围小的数据类型和取值范围大的数据类型大的进行运算，取值范围小的数据类型先提升为取值范围大的数据类型大的再进行运算 byte，short，char在运算时直接提升为int再运算 显式类型转换 不允许直接将取值范围大的数据赋值给取值范围小的数据类型，需要开发者进行强制类型转换\n语法格式 1 目标格式 变量名 = (目标格式) 被强制类型转换的变量名 注意事项 将 double/float 强制转为 int 时会截断小数部分 Java具有常量优化机制，编译器在编译过程中，将能够在编译期确定的常量表达式直接计算并替换成结果 ","date":"2024-11-02T11:20:03+08:00","permalink":"https://Tyritic.github.io/p/java%E7%9A%84%E5%AD%97%E9%9D%A2%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","title":"Java的字面量和基本数据类型"},{"content":"执行过程 开发者编写Java源代码（ .java 文件） 编译源代码（.java文件）使用javac命令编译器将源代码转化成字节码（.class文件） 在虚拟机（JVM）上运行字节码（.class 文件），将字节码解释成机器码 在程序运行时，JVM 会监控哪些字节码被频繁调用（热点代码）。一旦识别出热点代码，JVM 会将这些代码交给 JIT 编译器进行编译，并缓存编译后的机器码。 字节码中不经常调用的部分（非热点代码）用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的 提示\n解释执行比编译执行效率差\n解释执行：在程序执行时，逐行解释执行源代码，不生成独立的可执行文件。通常由解释器动态解释并执行代码，跨平台性好，但执行速度相对较慢。（类比每次给你英语让你翻译阅读）\n编译执行：在程序执行之前，整个源代码会被编译成机器码或者字节码，生成可执行文件。执行时直接运行编译后的代码，速度快，但跨平台性较差。（类比直接给你看中文）\nJava同时具有解释性和编译性\n编译性 Java源代码首先被编译成字节码，JIT 会把编译过的机器码保存起来,以备下次使用。 JVM 加载并执行 Java 字节码文件，在执行过程中，JVM 会发现一些高频次执行的代码（热点代码），然后将这些字节码交给 JIT 编译器进行编译，生成平台相关的机器码。这样，Java 程序的性能就能得到优化，因为热点代码被 JIT 编译成了机器码，可以直接运行，而不需要每次都解释执行。 解释性：字节码中非热点部分（不经常调用的部分）用解释器进行解释执行，然后字节码也是经过解释器进行解释运行的 跨平台性 Java程序具有在任意操作系统平台上运行\n实现原理 在运行Java程序程序的操作系统上安装一个与操作系统对应的Java虚拟机。源代码会被编译成相同的字节码，然后虚拟机根据操作系统将字节码解释成不同的机器码\nJava的运行环境 JVM（Java虚拟机） Java虚拟机用于解释Java源代码，加载Java程序。针对不同的操作系统设计有不同的Java虚拟机\nJRE（Java运行时环境） JRE全称**（Java Runtime Environment）是Java运行时环境，包含了 JVM, Java核心类库和其他支持Java程序的文件，但是不包含任何开发工具**\n组成部分 JVM（Java Virtual Machine）：执行由源代码编译后得到的Java字节码，提供了Java程序的运行环境 核心类库：标准的类库（java.lang,java.utils）供Java程序使用 其他文件：配置文件，库文件，支持JVM的运行 JDK（Java开发包） JDK全称 **（Java Development Kit）**是一组独立程序构成的集合，是用于开发Java 程序的完整开发环境，它包含了JRE，以及用于开发、调试和监控 Java 应用程序的工具。\n组成部分 JRE：JDK包含了完整的JRE，可以运行java程序 开发工具：包含编译器（javac），打包工具（jar） 附加库和文件：支持开发，文档生成 常见开发工具 javac ：Java 编译器，用于将 Java 源代码（.java 文件）编译成字节码（.class 文件）。 java ：Java 应用程序启动器，用于运行 Java 应用程序。 javadoc：文档生成器，用于从 Java 源代码中提取注释并生成 HTML 格式的 API 文档。 jar ：归档工具，用于创建和管理 JAR（Java Archive）文件。 jdb：Java 调试器，用于调试 Java 程序。 jps：Java 进程状态工具，用于列出当前所有的 Java 进程。 jstat：JVM 统计监视工具，用于监视 JVM 统计信息。 jstatd：JVM 统计监视守护进程，用于在远程监视 JVM 统计信息。 jmap：内存映射工具，用于生成堆转储（heap dump）、查看内存使用情况。 jhat：堆分析工具，用于分析堆转储文件。 jstack：线程栈追踪工具，用于打印 Java 线程的栈追踪信息。 javap：类文件反汇编器，用于反汇编和查看 Java 类文件。 jdeps：Java 类依赖分析工具，用于分析类文件或 JAR 文件的依赖关系 相互关系 JDK JRE JVM 核心类库 开发工具 ","date":"2024-11-02T10:46:06+08:00","permalink":"https://Tyritic.github.io/p/java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/","title":"Java程序的编译执行过程"},{"content":"文章存储位置 本博客的所有文章都存放在E/MyBlog/content/post文件夹中\n如何添加文章 在 content/tags/文章名 下新建文件 index.md\n命令行操作 在MyBlog主文件夹的cmd中运行以下命令\n1 hugo new content post/\u0026lt;FileName\u0026gt;/index.md 参数解释 post：所有文章保存的文件路径\nFileName为当前文章所在的文件夹名\nindex.md为当前文章的markdown文件\nindex.en.md：英文文章 index.zh-cn.md：中文文章 文章内修改 插入照片 将需要的图片放入文章的文件夹中即可\n头文字参数 data：创建时间\ndraft：是否草稿\ntitle：文章标题\nimage：博客网站的开头图片\ncategories：文章的分类\ntags：文章的标签\ndescription：文章的描述\n短代码 文章引用 在markdown文件中插入以下短代码，使用时将{}改为{{}}\n1 2 3 {\u0026lt; quote author=\u0026#34;作者\u0026#34; url=\u0026#34;作品的来源（可不填）\u0026#34; source=\u0026#34;作品名\u0026#34; \u0026gt;} 引用内容 {\u0026lt; /quote \u0026gt;} 插入B站视频 在markdown文件中插入以下短代码，使用时将{}改为{{}}\n1 {\u0026lt; bilibili VIDEO_ID PART_NUMBER \u0026gt;} 可以在B站视频的url中找到Video_ID``https://www.bilibili.com/video/BV1BPSdYHEbj/?spm_id_from=333.1007.tianma.1-2-2.click\u0026amp;vd_source=7db50a55b19a59c42ee778836913c04f\n其中VIDEO_ID：BV1BPSdYHEbj\n插入hugo notice hugo notice有以下几个类别\ntip：提示 info：引言 warning：警告 note：注解 创建方法为在markdown文件中插入短代码，使用时将{}改为{{}}\n创建Tip 1 2 3 {\u0026lt; notice tip \u0026gt;} This is a very good tip. {\u0026lt; /notice \u0026gt;} 提示\nThis is a very good tip.\n创建Info 1 2 3 {\u0026lt; notice info \u0026gt;} This is a very good info. {\u0026lt; /notice \u0026gt;} 引言\nThis is a very good info.\n创建Warning 1 2 3 {\u0026lt; notice warning \u0026gt;} This is a very bad warning. {\u0026lt; /notice \u0026gt;} 警告\nThis is a very bad warning.\n创建Note 1 2 3 {\u0026lt; notice note \u0026gt;} This is a very good note. {\u0026lt; /notice \u0026gt;} 注解\nThis is a very bad note.\n插入参考博客 直接将参考博客的网址复制到markdown文件中\nTyritic的个人博客\n创建分组（categories） 在 content/categories/分类名 下新建文件 _index.md\n可以使用命令行工具\n1 hugo new content categories/\u0026lt;分组名\u0026gt;/_index.md 参数解释 categories：所有分组的所在目录 _index.md：分组的配置文件 _ndex.en.md：英文分组 _index.zh-cn.md：中文分组 创建标签（Tags) 在 content/tags/分类名 下新建文件 _index.md\n可以使用命令行工具\n1 hugo new content tags/\u0026lt;标签名\u0026gt;/_index.md 参数解释 tags：所有标签所在的目录 _index.md：分组的配置文件 index.en.md：英文标签 index.zh-cn.md：中文标签 创建友情链接（Links) 在 content/page/links 下修改文件 _index.md，创建与GitHub同级的元素\n参数列表 title：博客显示该网站的名字 description：博客对该网站的描述 website：网站链接 image：网站的icon ","date":"2024-11-01T15:28:47+08:00","permalink":"https://Tyritic.github.io/p/%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"博客使用指南"},{"content":"Maven的作用 依赖管理：方便快捷地管理依赖\n统一项目结构：提供标准的项目结构\n项目构建：提供了标准的跨平台项目构建方式\nMaven项目的结构 1 2 3 4 5 6 7 8 9 10 Maven-name/ |--src（源代码） |\t|--main（项目实际资源） |\t|--java（java代码） |\t|--resource（资源文件） |\t|--test（测试代码资源） |\t|--java |\t|--resource |--pom.xml（依赖配置文件） |--target（打包后的jar包存放地） Maven项目模型 仓库：用于存储资源以及各种JAR包\n本地仓库：计算机上的目录 中央仓库：由Maven团队维护的仓库 私服：公司团队搭建的私有仓库 依赖管理 什么是依赖 依赖就是项目所需要的jar包\nMaven坐标 ​\tMaven坐标是依赖资源的唯一标识，可以唯一定位资源的位置，使用Maven坐标可以引入项目依赖\n组成结构 groupId：项目所属的组织名 artifactId：项目名称/模块名称 version：版本号 依赖配置 配置方法 在pom.xml文件中使用标签\u0026lt; dependencies \u0026gt; 单个依赖在\u0026lt; dependencies \u0026gt;中被\u0026lt; dependency \u0026gt; 包围 定义依赖的坐标 刷新Maven文件 提示\n若本地仓库不存在依赖则会连接私服或者中央仓库进行下载\n依赖传递 ​\t依赖具有传递性\n​\t直接依赖：在当前项目中通过依赖配置建立的依赖关系\n​\t间接依赖:被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源\n​\t依赖的传递关系可能出现冲突\n路径优先：当依赖中出现相同的资源时：层级越深优先级越低 声明优先：当资源在相同的层级被依赖，配置靠前的覆盖配置靠后的 特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的 依赖排除 ​\t依赖可以被开发者手动排除\n​\t实现形式\n在pom.xml文件中使用标签\u0026lt; exclusions \u0026gt;包围\n对于要排除的单个依赖使用标签\u0026lt; exclusion \u0026gt;包围\n提示\n排除依赖的时候无须指定版本号\n依赖范围 ​\t依赖的jar包，默认情况下，可以在任何地方使用。但是可以通过\u0026lt; scope \u0026gt; 手动指定其使用范围\n作用范围 主程序范围有效。(main文件夹范围内) 测试程序范围有效。(test文件夹范围内) 是否参与打包运行。(package指令范围内) \u0026lt;scope\u0026gt;标签的取值 scope的取值 主程序 测试程序 打包运行 举例 compile(默认) Y Y Y log4j（日志框架） test X Y X junit（单元测试） provided Y Y X servlet（三大组件） runtime X Y Y jdbc（数据库连接依赖） 生命周期 ​\tMaven中有三套独立的生命周期\nclean：清理工作 default：核心工作包括（编译，测试，打包，变更，部署） site：生成报告，发布站点 生命周期的阶段 ​\n​\t提示\n​\t同一套生命周期，后面的阶段要依托前面的阶段来执行\n​\n重要阶段 clean:移除上一次构建生成的文件 compile:编译项目源代码 test:使用合适的单元测试框架运行测试(junit) package:将编译后的文件打包，如:jar、war等 install:安装项目到本地仓库 ","date":"2024-11-01T15:28:45+08:00","permalink":"https://Tyritic.github.io/p/maven%E5%9F%BA%E7%A1%80/","title":"Maven基础"}]