[{"content":"基本查询 基本语法\n1 2 3 4 5 6 7 8 9 select #可以添加distinct来去除重复项 字段列表 #(查询所有字段可以简写为*) from table_name where condition #条件列表 #以下均为可选选项 group by 聚合函数（字段列表） having 对分组条件的过滤操作 order by 对字段列表的排序 #（ASC升序，DESC降序） limit 分页参数 (起始索引，查询记录数) #索引从0开始，起始索引=（查询页码-1)*每页记录数 条件查询 常见条件运算符 比较运算符 功能 \u0026gt; 大于 \u0026gt;= 大于等于 \u0026lt; 小于 \u0026lt;= 小于等于 \u0026lt;\u0026gt;或!= 不等于 between \u0026hellip; and \u0026hellip; 在某个区间范围内（含最大值和最小值） in(\u0026hellip;) 在in中的列表的值，多选一 like 占位符 模糊匹配（_匹配单个字符，\u0026amp;匹配任意字符 is null 是null 常见逻辑运算符 逻辑运算符 功能 and 或 \u0026amp;\u0026amp; 与 or 或 || 或 not 或 | 非 分组查询 聚合函数 函数 功能 sum 求和 avg 平均值 count 计数 max 最大值 min 最小值 提示\nnull不参与聚合函数的运算\nhaving和where的区别 执行时机不同:where是分组之前进行过滤，不满足where条件，不参与分组;而having是分组之后对结果进行过滤。 判断条件不同:where不能对聚合函数进行判断，而having可以。 查询的执行顺序 where \u0026gt;聚合函数 \u0026gt;having\n注意事项 提示\nselect 子句中的字段一般为用于分组的字段和聚合函数（保证出现在select子句中但是没有被聚集的属性只能出现在group by子句中 在默认情况下，系统按照group by子句中指定的列升序排列，但是可以使用order by子句指定新的排列顺序。 任何出现在having子句中但没有被聚集的属性只能出现在group by子句中 多表查询 连接查询 笛卡尔积：A表和B表元组的所有组合情况\n示例代码：\n1 table a,table b 内连接：查询A表和B表相交的部分\n语法：\n1 2 3 4 5 6 7 8 9 #隐式内连接 select 字段列表 from table a,table b where condition #显式内连接 select 字段列表 from table a join table b on 连接条件 外连接：查询只存在A表或B表的部分\n1 2 3 4 5 6 7 8 9 #左外连接 select 字段列表 from table a left join table b on 连接条件 #右外连接 select 字段列表 from table a right join table b on 连接条件 子查询 子查询：SQL语句中嵌套select语句\n类别\n标量子查询:子查询返回的结果为单个值 列子查询:子查询返回的结果为一列 行子查询:子查询返回的结果为一行 表子查询:子查询返回的结果为多行多列 子查询的位置\nselect后面：标量子查询 from后面：表子查询 where/having：标量/列/行子查询 ","date":"2024-11-04T15:07:25+08:00","permalink":"https://Tyritic.github.io/p/mysql%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C/","title":"MySQL表数据查询操作"},{"content":"插入元组 指定字段添加元组\n1 insert into table_name (字段1,子段2,...子段n) values(值1,..值n); 全部字段添加元组\n1 insert into table_name values(值1,值2,...值n); 批量添加指定子段的元组\n1 insert into table_name (子段1,子段2,...子段n) values(值1,...值n),..(值1,...值n); 全部数据批量添加\n1 insert into table_name values(值1,...值n),..(值1,...值n); 更新元组 更新符合指定条件的元组\n1 update table_name set 字段1=v值1,..字段n=值n [where condition] 删除元组 1 delete from table_name [where condition] ","date":"2024-11-04T14:57:14+08:00","permalink":"https://Tyritic.github.io/p/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/","title":"MySQL数据库表数据操作"},{"content":"创建表结构 代码结构 1 2 3 4 5 create table table_name( 字段1 字段类型[约束] [comment \u0026#39;关于字段的描述\u0026#39;], ... 字段n 字段类型[约束] [comment \u0026#39;关于字段的描述\u0026#39;] )[comment 关于表的描述] 约束 概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据\n目的：保证数据库中数据的正确性、有效性和完整性。\n常见约束参考\n约束 描述 关键字 非空约束 限制该字段不能为null not null 唯一约束 保证该字段的所有数据都是唯一，不存在重复 unique 主键约束 主键是一个元组的唯一标识，要求非空且唯一 primary key 默认约束 保存数据时要是未指定该字段值则存入默认值 default 外键约束 通过外键建立两张表的联系，保证数据的一致性和完整性 foreign key 示例代码\n1 2 3 4 5 6 7 8 create table student (ID varchar (5) comment[\u0026#39;唯一标识符\u0026#39;], name varchar (20) not null, dept_name varchar (20), tot_cred numeric (3,0) check (tot_cred \u0026gt;= 0), primary key (ID), #主键约束 foreign key (dept_name) references department(dept_name) on delete set null); #外键约束 数据类型 数值类型 类型 大小（byte) 有符号范围 无符号范围 描述 备注 tinyint 1 (-128,127) (0,255) 小整数 smallint 2 (-32768,32767) (0,65535) 大整数 mediumint 3 (-8388608,8388607) (0,1677215) 大整数 int 4 (-2^31 ,2^31-1) (0,2^32-1) 大整数 bigint 8 (-2^63 ,2^63-1) (0,2^64-1) 极大整数 float 4 单精度浮点值 float(5,2)，其中5为数字长度，2为小数位数 double 8 双精度浮点值 double(5,2)，其中5为数字长度，2为小数位数 decimal 小数值（精度最高） 字符类型 类型 大小（byte） 描述 备注 char 0~255 定长字符串 char(10),最多只能存10个字符，不足10个字符也占有10个字符空间 varchar 0~63315 变长字符串 varchar(10),最多只能存10个字符，不足10个字符按实际长度存储 tinyblob 0~255 不超过255个字符的二进制数据 tinytext 0~255 短文本字符串 blob 0~65535 二进制形式长文本数据 text 0~65535 长文本数据 mediumblob 0~16777215 二进制形式中等长文本数据 mediumtext 0~16777215 中等长度文本数据 longblob 0~4294967295 二进制形式的极大文本数据 longtext 0~4294967295 极大文本数据 日期类型 类型 大小（byte） 格式 范围 描述 date 3 YYYY-MM-DD 1000-01-01到 9999-12-31 日期值 time 3 HH:MM:SS -838:59:59 到 838:59:59 时间值或持续时间 year 1 YYYY 1901到2155 年份值 datetime 8 YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00到 9999-12-31 23:59:59 混合日期和时间值 timestamp 4 YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00到 9999-12-31 23:59:59 混合日期和时间值，时间戳 查询表结构 查询当前数据库的所有表\n1 show tables 查询指定表的表结构\n1 desc table_name 查询建表语句\n1 show create table table_name 修改表结构 添加字段\n1 2 alter table table_name add 字段名 字段类型（长度） [comment \u0026#39;关于字段的描述\u0026#39;] [约束]; 修改字段类型\n1 2 alter table table_name modify 字段名 新字段类型（长度）; 修改字段名和字段类型\n1 2 alter table table_name change 旧字段名 新字段名 新类型（长度）[comment \u0026#39;关于字段的描述\u0026#39;] [约束]; 删除字段\n1 2 alter table table_name drop column 字段名; 修改表名\n1 rename table 旧表名 to 新表名; 删除表结构 1 drop table 表名; ","date":"2024-11-03T18:46:17+08:00","permalink":"https://Tyritic.github.io/p/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C/","title":"MySQL数据库表结构操作"},{"content":"切换数据库 1 use database_name; 创建数据库 1 create database[if not exists] database_name; 查询数据库 查询所有的数据库\n1 show databases; 查询当前正在使用的数据库\n1 select database(); 删除数据库 1 drop database [if exist] database_name ","date":"2024-11-03T18:26:36+08:00","permalink":"https://Tyritic.github.io/p/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/","title":"MySQL数据库操作"},{"content":"MySQL配置使用 启动服务：\n1 net start mysql 停止服务：\n1 net stop mysql 登录MySQL\n1 mysql -u[用户名] -p[密码] [-h 数据库服务器IP -p 端口号] 退出MySQL\n1 exit MySQL数据模型 关系型数据库(RDBMS)：建立在关系模型基础上，由多张相互连接的二维表组成的数据库\n特点\n使用表存储数据，格式统一，便于维护 使用SQL语言操作，标准统一，使用方便，可用于复杂查询 SQL简介 SQL：一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准。\n通用语法 SOL语句可以单行或多行书写，以分号结尾。 SOL语句可以使用空格/缩进来增强语句的可读性。 MySQL数据库的SQL语句不区分大小写。 注释 单行注释：\u0026ndash;注释内容或者#注释内容**（MySQL特有）** 多行注释：/* 注释内容 */ 分类 分类 全称 说明 DDL Data Definition Language 数据定义语言，用来定义数据库对象(数据库，表，字段) DML Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改 DQL Data Query Lanquage 数据查询语言，用来查询数据库中表的记录 DCL Data Control Language 数据控制语言，用来创建数据库用户、控制数据库的访问权限 ","date":"2024-11-03T17:02:26+08:00","permalink":"https://Tyritic.github.io/p/mysql%E7%AE%80%E4%BB%8B/","title":"MySQL简介"},{"content":"什么是控制反转（IOC) IOC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。以右图为例\nIOC容器作为中间位置“第三方”，也就是，使得A、B、C、D这四个对象没有了耦合关系，齿轮之间的传动全部依靠IOC容器，全部对象的控制权上交给IOC容器，所以IOC容器成了整个系统的关键核心，它起到一个“粘合剂”的作用，把系统中所有对象粘合在一起发挥作用。\nIOC的关键点 谁控制谁： 传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象； 而IOC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建； 控制了什么 那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 什么是反转： 传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转； 而反转则是由容器来帮忙创建及注入依赖对象 为什么是反转：因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象。 哪些方面反转了：依赖对象的获取被反转了。 IOC的过程 所有的类都会在Spring容器中登记，告诉spring你是个什么东西，你需要什么东西， 然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。 所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。 对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。 Bean对象的声明 注解 说明 位置 @Component 声明Bean对象的基本注解 不属于以下三类时使用该注解 @Service @Component的衍生注解 标注在ServiceImpl类上 @Controller @Component的衍生注解 标注在Controller类上 @Repository @Component的衍生注解 标注在数据访问类上（现在有mybatis，使用评论少） 注意事项\n声明bean的时候，可以通过value属性指定bean的名字，如果没有指定，默认为类名首字母小写 使用以上四个注解都可以声明bean，但是在springboot集成web开发中，声明控制器bean只能用@Controller. Bean组件扫描 声明bean的四大注解，要想生效，还需要被组件扫描注解 @ComponentScan 扫描。 @ComponentScan 注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解 @SpringBootApplication 中，默认扫描的范围是启动类所在包及其子包。\n","date":"2024-11-03T15:06:44+08:00","permalink":"https://Tyritic.github.io/p/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/","title":"控制反转"},{"content":"什么是依赖注入（DI） 组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。\n关键点分析 谁依赖于谁：当然是应用程序依赖于IoC容器； 为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源； 谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象； 注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据） Bean注入方式 @Autowired注入 使用@Autowired注解修饰要注入的对象\n1 2 @Autowired userMapper mapper; 注意事项 @Autowired注解默认按Bean对象的类型进行自动装配，若存在多个相同类型的Bean对象会报错 可以使用注解@Primary指定Bean对象的优先级，对优先级高的Bean对象使用 @Primary 注解 可以使用注解@Qualifier和@Autowired配合使用，@Qualifier的value属性用于按名字指定Bean对象 提示\nBean对象的默认名称是类名首字母小写\n@Resource ​\t使用 @Resource 注解修饰要注入的对象,@Resource 注解按照Bean对象名注入对象\n1 2 @Resource(name=\u0026#34;Bean_name\u0026#34;) userMapper mapper; 提示\n@Resource 和 @Autowired 的区别\n@Autowired 是Spring框架提供的注解，而 @Resource 是IDK提供的注解 @Autowired 默认是按照类型注入，而 @Resource 默认是按照名称注入。 ","date":"2024-11-03T13:37:35+08:00","permalink":"https://Tyritic.github.io/p/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/","title":"依赖注入"},{"content":"请求响应过程 基本流程 浏览器向SpringBoot项目中内置的Tomcat服务器发送请求 SpringBoot项目中的controller类接收浏览器发出的请求并发送响应 请求参数的接收 简单参数 方法一：设置controller类中的函数形参名和请求的参数名相同 1 2 3 4 5 @RequsetMapping(\u0026#34;/simpleParam\u0026#34;) public String getParam(String param) { return param; } 方法二：参数名和形参名不匹配使用@RequestParam注解的name属性将参数名映射到形参 1 2 3 4 5 @RequestMapping(\u0026#34;/simpleParam\u0026#34;) public String getParam(@RequestParam(name=“username\u0026#34;)String param) { return param; } 提示\n@RequestParam\n作用：建立请求参数和controller形参的映射关系\n属性\nvalue/name：请求的参数名 required：参数是否必需。默认为true 实体对象参数 简单实体对象 请求参数与形参对象属性名相同\n1 2 3 4 5 @RequestMapping(\u0026#34;/objectParam\u0026#34;) public User getParam(User user) { return user; } 复杂实体对象（对象的成员变量是对象） 请求参数与形参对象属性名相同，按对象层次关系接收\n数组集合参数 数组参数 请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数\n1 2 3 4 5 @RequestMapping(\u0026#34;/arrayParam\u0026#34;) public User getParam(String[]array) { return array; } 集合参数 请求参数名与形参数组名称相同且请求参数为多个，@RequestParam绑定参数关系\n1 2 3 4 5 @RequestMapping(\u0026#34;/listParam\u0026#34;) public User getParam(@RequestParam List\u0026lt;String\u0026gt;param) { return param; } 日期参数 使用**@DateTimeFormat**注解完成日期格式转换\n1 2 3 4 5 @RequestMapping(\u0026#34;/dateParam\u0026#34;) public String getParam(@DateTimeFormat(pattern=\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;) LocalDateTime param) { return param.toString(); } 提示\n@DateTimeFormat\npattern属性用于指定时间格式\nJson参数 JSON数据键名与形参对象属性名相同，定义pojo类型形参即可接收参数，需要使用 @RequestBody标识\n1 2 3 4 5 @RequestMapping(\u0026#34;/jsonParam\u0026#34;) public String getParam(@RequestBody User user) { return user.toString(); } 路径参数 通过请求URL直接传递参数，使用{..}来标识该路径参数，需要使用 @PathVariable 获取路径参数\n1 2 3 4 5 @RequestMapping(\u0026#34;/path/{id}\u0026#34;) public String getParam(@PathVariable Integer id) { return id; } 响应报文的回写 @RequestBody 类型：方法注解，类注解 位置：controller类/方法上 作用：将方法返回值直接响应，如果返回值类型是 实体对象/集合，将会转换为JSON格式响应 说明：@RequestController=@RequestBody+@Controller ","date":"2024-11-03T00:05:27+08:00","permalink":"https://Tyritic.github.io/p/%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/","title":"请求与响应"},{"content":"如何读懂SpringBoot项目结构 SpringBoot项目本质上是一个Maven项目，大体骨架与普通的Maven项目相同\n普通Maven项目结构\n1 2 3 4 5 6 7 8 9 10 Maven-name/ |--src（源代码） |\t|--main（项目实际资源） |\t|--java（java代码） |\t|--resource（资源文件） |\t|--test（测试代码资源） |\t|--java |\t|--resource |--pom.xml（依赖配置文件） |--target（打包后的jar包存放地） 开发者的代码都存放到src/main/java文件夹中\n代码层 根目录：src/main/java\n作用：该目录下存放入口启动类及程序的开发目录。在这个目录下进行业务开发、创建实体层、控制器层、数据连接层等。\n注解\n入口启动类：运行整个项目main方法的类\n1 2 3 4 5 6 @SpringBootApplication public class UserApplication { public static void main(String[] args) { SpringApplication.run(UserApplication.class, args); } } 其中@SpringBootApplication用于标识SpringBoot项目的入口类\n控制器层（controller) 根目录：src/main/java/controller\n作用：主要负责具体业务模块的流程控制，负责前后端交互，接受前端请求，调用service层，接收service层返回的数据，最后返回具体的页面和数据到客户端\n功能实现：通过实现controller类来实现\n1 2 3 4 5 6 7 @RequestMapping(\u0026#34;/user\u0026#34;) @RestController // @RestController=@RequestMapping + @ResponseBody public class UserController { @RequestMapping(\u0026#34;/映射资源\u0026#34;) public List\u0026lt;User\u0026gt; findAll(){ return userService.findAll(); } 业务逻辑层(service) 根目录：src/main/java/service\n作用：主要负责业务逻辑应用设计\n功能实现：首先设计service接口，然后再设计其实现该接口的类(serviceImpl)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Service public class UserRegisterServiceImpl implements UserRegisterService { @Autowired UserMapper userMapper; @Override public void register(UserRegisterDTO userRegisterDTO) { //判断用户是否已存在 User tempUser=userMapper.getByUsername(userRegisterDTO.getUsername()); if(tempUser!=null){ log.error(\u0026#34;用户{}已存在\u0026#34;,userRegisterDTO.getUsername()); throw new UsernameHasBeenRegisteredException(\u0026#34;用户名已存在\u0026#34;); } //注册 User user=new User(); BeanUtils.copyProperties(userRegisterDTO,user); userMapper.register(user); log.info(\u0026#34;用户{}注册成功\u0026#34;,userRegisterDTO.getUsername()); } } 常量层(common) 根目录：src/main/java/common\n作用：主要存放工具类（utils)，常量类（constant），统一响应模板（result），统一异常处理（exception)\n数据库实体层(pojo) 根目录：src/main/java/pojo\n作用：存放数据库的实体类，通常一个实体类对应一张数据库表\n数据持久层（mapper) 根目录：src/main/java/mapper\n作用：访问数据库，向数据库发送sql语句，完成数据的增删改查任务\n功能实现：通过@Mapper注解接口来建立java方法和sql语句的映射关系\n1 2 3 4 5 6 7 8 9 10 @Mapper public interface DistrictMapper { List\u0026lt;District\u0026gt;searchAll(String tname); boolean deleteDistrict(String dname); District getDistrictByName(String dname); void insertDistrict(DistrictDTO districtDTO); void updateDistrictTdid(DistrictDTO districtDTO); boolean deleteAll(Long tid); void updateDistrictDetail(DistrictDTO districtDTO); } 数据传输对象（dto） 根目录：src/main/java/dto（或者放入pojo层中）\n作用：对entity进行封装，不破坏实体类结构，进行层与层之间的数据传输\n提示\n​\tDTO通常用于\n控制器（Controller）与服务层（Service）之间的数据传输：控制器通过 DTO 将请求参数传递给服务层，服务层返回 DTO 对象给控制器。 服务层与持久层（Mapper）之间的数据传输：服务层通过 DTO 将实体对象转换为需要的数据结构传递给持久层，持久层返回 DTO 对象给服务层。 视图包装对象（vo） 根目录：src/main/java/vo（或者放入pojo层中）\n作用：用于封装客户端请求的数据同时不破坏原有的实体类结构\n提示\nVO在实际开发中通常作为controller类方法的形参从而起到封装客户端请求数据的作用\n配置类（config) 根目录：src/main/java/config\n作用：以java类代替yaml文件进行Bean对象配置\n功能实现：通过**@Configuration**注解一个java类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration public class WebMvcConfiguration implements WebMvcConfigurer { @Autowired JwtTokenUserInterceptor jwtTokenUserInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { log.info(\u0026#34;开始注册拦截器\u0026#34;); log.info(\u0026#34;注册Jwt令牌拦截器：{}\u0026#34;,jwtTokenUserInterceptor); registry.addInterceptor(jwtTokenUserInterceptor) .addPathPatterns(\u0026#34;/Operator/**\u0026#34;) .excludePathPatterns(\u0026#34;/Operator/user/login\u0026#34;) .excludePathPatterns(\u0026#34;/Operator/user/register\u0026#34;); } } 参数配置类（properties） 根目录：src/main/java/properties\n作用：以java实体类代替yaml文件进行参数配置\n功能实现：通过**@ConfigurationProperties**注解一个java类\n1 2 3 4 5 6 7 8 9 10 @Data @Component @ConfigurationProperties(prefix = \u0026#34;operator.aliyun.oss\u0026#34;) public class AliyunOSSProperties { String endpoint; String accessKeyId; String accessKeySecret; String bucketName; String region; } 过滤器（filter） 根目录：src/main/java/filter\n作用：在Servlet 处理请求之前或响应之后对数据进行某些处理，实现诸如日志记录、请求数据修改、响应数据修改、权限控制等功能\n提示\n过滤器工作在 Servlet 容器容中，它拦截客户端的请求和服务器的响应。过滤器链（Filter Chain）是多个过滤器按照一定的顺序执行的集合，一个请求可以依次通过多个过滤器，然后到达目标 Servlet，响应也会按相反的顺序经过这些过滤器返回给客户端。\n生命周期管理\nServlet 容器负责过滤器的生命周期管理。过滤器的生命周期方法包括 init（初始化）、doFilter（执行过滤操作）和 destroy（销毁）。 请求处理流程\n当一个请求到达 Servlet 容器时，容器会根据部署描述符（web.xml）或注解配置，决定是否以及如何调用过滤器链。 过滤器链是多个过滤器按照一定的顺序执行的集合。容器按照这个顺序依次调用每个过滤器的 doFilter 方法。 doFilter 方法\n在 doFilter 方法中，开发者可以实现自定义的处理逻辑，比如修改请求头、记录日志等。 doFilter 方法中必须调用 FilterChain 的 doFilter 方法，这样请求才能继续传递给下一个过滤器或目标资源（如 Servlet）。如果不调用，请求处理流程将会停止。 工作机制\n过滤器可以修改请求和响应，但它们通常不会生成响应或结束请求，因为这通常是 Servlet 或其他资源的职责 参考文章：\nFilter（过滤器）和 Interceptor（拦截器）详解_过滤器和拦截器-CSDN博客 功能实现\n创建过滤器类\n实现 javax.servlet.Filter 接口。 重写 init、doFilter 和 destroy 方法。 配置过滤器\n使用注解 @WebFilter 进行声明和配置。 或者在 web.xml 文件中配置。 编写过滤逻辑：\n在 doFilter方法中实现具体的过滤逻辑。 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import javax.servlet.*; import javax.servlet.annotation.WebFilter; import java.io.IOException; @WebFilter(\u0026#34;/example/*\u0026#34;) // 过滤器应用于 URL 模式 \u0026#34;/example/*\u0026#34; public class ExampleFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { // 初始化代码，例如资源加载 } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { // 在请求处理之前执行的代码 System.out.println(\u0026#34;Before Servlet processing\u0026#34;); chain.doFilter(request, response); // 将请求传递给下一个过滤器或目标资源 // 在请求处理之后执行的代码 System.out.println(\u0026#34;After Servlet processing\u0026#34;); } @Override public void destroy() { // 清理代码，例如释放资源 } } 拦截器（interceptor） 根目录：src/main/java/interceptor\n作用：是 Spring MVC 框架中的一个核心组件，用于在处理 HTTP 请求的过程中进行拦截和处理。拦截器主要用于实现跨切面（cross-cutting）的逻辑，如日志记录、性能统计、安全控制、事务处理等。\n功能实现\n创建拦截器类：\n实现 HandlerInterceptor接口或继承 HandlerInterceptorAdapter类。 重写 preHandle、postHandle 和 afterCompletion 方法。 注册拦截器：\n创建一个配置类，实现 WebMvcConfigurer接口。 重写 addInterceptors 方法来添加拦截器。 编写拦截逻辑：\n在 preHandle、postHandle 和 afterCompletion方法中实现具体的拦截逻辑。 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) { // 请求处理前的逻辑 return true; // 返回 true 继续流程，返回 false 中断流程 } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) { // 请求处理后的逻辑，但在视图渲染前 } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { // 请求处理完毕后的逻辑 } } @Configuration public class WebMvcConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new MyInterceptor()).addPathPatterns(\u0026#34;/**\u0026#34;); // 应用于所有路径 } } 项目配置层 根目录：src/main/resource\napplication.yml：项目的整体配置文件\nmapper：数据库映射文件\n","date":"2024-11-02T19:26:08+08:00","permalink":"https://Tyritic.github.io/p/springboot%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/","title":"SpringBoot项目结构"},{"content":"什么是HTTP协议 ​\tHTTP协议（Hyper Text Transfer Protocol，超文本传输协议）：规定了浏览器和服务器之间数据传输的规则。\n特点 在传输层上基于TCP协议\n提示\nTCP协议是面向连接的，安全性好。\n基于请求-响应机制\n无状态协议，对于事务的处理没有记忆，每次请求-响应都是独立的\n优点：速度快 缺点：多次请求之间不能共享数据 HTTP请求协议 请求报文结构 请求行（红色部分）：请求数据的第一行（请求方式/资源路径/协议版本）\n注解\n常见的请求方式有\nGET：请求指定页面的信息 POST：向指定资源提交数据进行处理请求，数据被包含在请求体 DELETE：请求服务器删除指定的页面 PUT：从客户端向服务端传输的数据取代指定的页面，向指定的位置上传最新的内容 请求头（深黄色部分）：以键值对的形式表现\n请求体（浅黄色部分）：在POST请求中存放请求参数\n提示\nGET请求没有请求体\n请求参数\nGET：请求参数在请求行中，且GET请求没有请求体，GET请求大小有限制 POST:请求参数在请求体中，POST请求大小没有限制 HTTP响应协议 响应报文结构 ​\t响应行（红色部分）：响应报文的第一行（协议版本，状态码，描述）\n注解\nhttp状态码用于描述响应结果\n分为以下几类\n1XX（临时响应信息提示）：这些状态代码表示临时的响应。客户端在收到常规响应之前，应准备接收一个或多个1xx 100（继续） ：请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101（切换协议） ： 服务器将遵从客户的请求转换到另外一种协议 2XX（成功） 200（成功）：服务器已成功处理了请求。 201（已创建）：请求成功并且服务器创建了新的资源。 202（已接受）：服务器已接受请求，但尚未处理。 3XX（重定向）：表示要完成请求，需要进一步操作。客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同的页面，或通过代理服务器重复该请求。 建议在每次请求中使用重定向不要超过 5次。 300（多种选择）：针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301（永久移动）：请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置 4XX（请求错误）：这些状态码表示请求可能出错，客户端似乎有问题。 400（错误请求）：服务器不理解请求的语法。 401（未授权）：请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。 403（禁止）：服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码(您可以在 Google网站管理员工具诊断下的网络抓取页面上看到此信息)，可能是您的服务器或主机拒绝了 Googlebot 访问。 404（未找到）：服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。 5XX（服务器错误）：服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错 500 （服务器内部错误） ：服务器遇到错误，无法完成请求。 响应头（黄色部分）：以键值对形式表现\n响应体（绿色部分）：存放响应数据\nHTTP协议解析 ​\tWeb服务器：一个软件程序，对HTTP协议进行封装，使得开发者不必直接面对HTTP协议进行开发\nTomcat服务器 基本使用 启动Tomcat服务器：双击Tomcat服务器目录下的bin\\startup.bat\n关闭Tomcat服务器\nCTRL+C：正常关闭 直接关闭运行窗口：强制关闭 双击Tomcat服务器目录下的bin\\shutdown.bat：正常关闭 部署项目：将应用放入webapps目录下\nTomcat服务器的目录结构 1 2 3 4 5 6 7 8 Tomcat/ |--bin（可执行文件） |--conf（配置文件） |--lib（Tomcat依赖的jar包） |--logs（日志文件） |--temp（测试代码资源） |--webapps（应用发布目录） |--resource（工作目录） ","date":"2024-11-02T16:04:47+08:00","permalink":"https://Tyritic.github.io/p/http%E5%8D%8F%E8%AE%AE/","title":"HTTP协议"},{"content":"文章存储位置 本博客的所有文章都存放在E/MyBlog/content/post文件夹中\n如何添加文章 在 content/tags/文章名 下新建文件 index.md\n命令行操作 在MyBlog主文件夹的cmd中运行以下命令\n1 hugo new content post\\\u0026lt;FileName\u0026gt;/index.md 参数解释 post：所有文章保存的文件路径\nFileName为当前文章所在的文件夹名\nindex.md为当前文章的markdown文件\nindex.en.md：英文文章 index.zh-cn.md：中文文章 文章内修改 插入照片 将需要的图片放入文章的文件夹中即可\n头文字参数 data：创建时间\ndraft：是否草稿\ntitle：文章标题\nimage：博客网站的开头图片\ncategories：文章的分类\ntags：文章的标签\ndescription：文章的描述\n短代码 文章引用 在markdown文件中插入以下短代码，使用时将{}改为{{}}\n1 2 3 {\u0026lt; quote author=\u0026#34;作者\u0026#34; url=\u0026#34;作品的来源（可不填）\u0026#34; source=\u0026#34;作品名\u0026#34; \u0026gt;} 引用内容 {\u0026lt; /quote \u0026gt;} 插入B站视频 在markdown文件中插入以下短代码，使用时将{}改为{{}}\n1 {\u0026lt; bilibili VIDEO_ID PART_NUMBER \u0026gt;} 可以在B站视频的url中找到Video_ID``https://www.bilibili.com/video/BV1BPSdYHEbj/?spm_id_from=333.1007.tianma.1-2-2.click\u0026amp;vd_source=7db50a55b19a59c42ee778836913c04f\n其中VIDEO_ID：BV1BPSdYHEbj\n插入hugo notice hugo notice有以下几个类别\ntip：提示 info：引言 warning：警告 note：注解 创建方法为在markdown文件中插入短代码，使用时将{}改为{{}}\n创建Tip 1 2 3 {\u0026lt; notice tip \u0026gt;} This is a very good tip. {\u0026lt; /notice \u0026gt;} 提示\nThis is a very good tip.\n创建Info 1 2 3 {\u0026lt; notice info \u0026gt;} This is a very good info. {\u0026lt; /notice \u0026gt;} 引言\nThis is a very good info.\n创建Warning 1 2 3 {\u0026lt; notice warning \u0026gt;} This is a very bad warning. {\u0026lt; /notice \u0026gt;} 警告\nThis is a very bad warning.\n创建Note 1 2 3 {\u0026lt; notice note \u0026gt;} This is a very good note. {\u0026lt; /notice \u0026gt;} 注解\nThis is a very bad note.\n插入参考博客 直接将参考博客的网址复制到markdown文件中\nTyritic的个人博客\n创建分组（categories） 在 content/categories/分类名 下新建文件 _index.md\n可以使用命令行工具\n1 hugo new content categories/\u0026lt;分组名\u0026gt;/_index.md 参数解释 categories：所有分组的所在目录 _index.md：分组的配置文件 _ndex.en.md：英文分组 _index.zh-cn.md：中文分组 创建标签（Tags) 在 content/tags/分类名 下新建文件 _index.md\n可以使用命令行工具\n1 hugo new content tags/\u0026lt;标签名\u0026gt;/_index.md 参数解释 tags：所有标签所在的目录 _index.md：分组的配置文件 index.en.md：英文标签 index.zh-cn.md：中文标签 创建友情链接（Links) 在 content/page/links 下修改文件 _index.md，创建与GitHub同级的元素\n参数列表 title：博客显示该网站的名字 description：博客对该网站的描述 website：网站链接 image：网站的icon ","date":"2024-11-01T15:28:47+08:00","permalink":"https://Tyritic.github.io/p/%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"博客使用指南"},{"content":"Maven的作用 依赖管理：方便快捷地管理依赖\n统一项目结构：提供标准的项目结构\n项目构建：提供了标准的跨平台项目构建方式\nMaven项目的结构 1 2 3 4 5 6 7 8 9 10 Maven-name/ |--src（源代码） |\t|--main（项目实际资源） |\t|--java（java代码） |\t|--resource（资源文件） |\t|--test（测试代码资源） |\t|--java |\t|--resource |--pom.xml（依赖配置文件） |--target（打包后的jar包存放地） Maven项目模型 仓库：用于存储资源以及各种JAR包\n本地仓库：计算机上的目录 中央仓库：由Maven团队维护的仓库 私服：公司团队搭建的私有仓库 依赖管理 什么是依赖 依赖就是项目所需要的jar包\nMaven坐标 ​\tMaven坐标是依赖资源的唯一标识，可以唯一定位资源的位置，使用Maven坐标可以引入项目依赖\n组成结构 groupId：项目所属的组织名 artifactId：项目名称/模块名称 version：版本号 依赖配置 配置方法 在pom.xml文件中使用标签\u0026lt; dependencies \u0026gt; 单个依赖在\u0026lt; dependencies \u0026gt;中被\u0026lt; dependency \u0026gt; 包围 定义依赖的坐标 刷新Maven文件 提示\n若本地仓库不存在依赖则会连接私服或者中央仓库进行下载\n依赖传递 ​\t依赖具有传递性\n​\t直接依赖：在当前项目中通过依赖配置建立的依赖关系\n​\t间接依赖:被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源\n​\t依赖的传递关系可能出现冲突\n路径优先：当依赖中出现相同的资源时：层级越深优先级越低 声明优先：当资源在相同的层级被依赖，配置靠前的覆盖配置靠后的 特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的 依赖排除 ​\t依赖可以被开发者手动排除\n​\t实现形式\n在pom.xml文件中使用标签\u0026lt; exclusions \u0026gt;包围\n对于要排除的单个依赖使用标签\u0026lt; exclusion \u0026gt;包围\n提示\n排除依赖的时候无须指定版本号\n依赖范围 ​\t依赖的jar包，默认情况下，可以在任何地方使用。但是可以通过\u0026lt; scope \u0026gt; 手动指定其使用范围\n作用范围 主程序范围有效。(main文件夹范围内) 测试程序范围有效。(test文件夹范围内) 是否参与打包运行。(package指令范围内) \u0026lt;scope\u0026gt;标签的取值 scope的取值 主程序 测试程序 打包运行 举例 compile(默认) Y Y Y log4j（日志框架） test X Y X junit（单元测试） provided Y Y X servlet（三大组件） runtime X Y Y jdbc（数据库连接依赖） 生命周期 ​\tMaven中有三套独立的生命周期\nclean：清理工作 default：核心工作包括（编译，测试，打包，变更，部署） site：生成报告，发布站点 生命周期的阶段 ​\n​\t提示\n​\t同一套生命周期，后面的阶段要依托前面的阶段来执行\n​\n重要阶段 clean:移除上一次构建生成的文件 compile:编译项目源代码 test:使用合适的单元测试框架运行测试(junit) package:将编译后的文件打包，如:jar、war等 install:安装项目到本地仓库 ","date":"2024-11-01T15:28:45+08:00","permalink":"https://Tyritic.github.io/p/maven%E5%9F%BA%E7%A1%80/","title":"Maven基础"}]