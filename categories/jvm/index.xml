<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>JVM on Tyritic</title>
        <link>https://Tyritic.github.io/categories/jvm/</link>
        <description>Recent content in JVM on Tyritic</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Tyritic</copyright><atom:link href="https://Tyritic.github.io/categories/jvm/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>JVM的类加载机制</title>
        <link>https://Tyritic.github.io/p/jvm%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</link>
        <pubDate>Mon, 10 Mar 2025 16:27:55 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/jvm%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</guid>
        <description>&lt;h2 id=&#34;类加载器的作用&#34;&gt;类加载器的作用
&lt;/h2&gt;&lt;p&gt;Java 的类加载器（ClassLoader）是 JVM 中用于动态加载类文件的组件。它将 &lt;code&gt;.class&lt;/code&gt; 文件中的字节码加载到内存中，并将其转换为 &lt;code&gt;Class&lt;/code&gt; 对象，以供 JVM 执行。JVM 的操作对象是 Class 文件，JVM 把 Class 文件中描述类的数据结构加载到内存中，并对数据进行校验、解析和初始化，最终转化成可以被 JVM 直接使用的类型，这个过程被称为类加载机制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;动态加载类&lt;/strong&gt; ：在运行时根据需要加载类，而不是在编译时加载所有类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隔离不同的类命名空间&lt;/strong&gt; ：通过不同的类加载器，可以隔离同名类，使得它们不会相互冲突&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;类加载器加载原则&#34;&gt;类加载器加载原则
&lt;/h2&gt;&lt;p&gt;JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。&lt;/p&gt;
&lt;p&gt;对于已经加载的类会被放在 &lt;code&gt;ClassLoader&lt;/code&gt; 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。&lt;/p&gt;
&lt;h2 id=&#34;类加载器的种类&#34;&gt;类加载器的种类
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;启动类加载器：它是属于虚拟机自身的一部分，用 C++ 实现的（JDK9 后用 java 实现），主要负责加载&amp;lt;JAVA_HOME&amp;gt;\lib目录中或被 -Xbootclasspath 指定的路径中的并且文件名是被虚拟机识别的文件，它是所有类加载器的父亲。&lt;/li&gt;
&lt;li&gt;扩展类加载器：它是 Java 实现的，独立于虚拟机，主要负责加载&amp;lt;JAVA_HOME&amp;gt;\lib\ext目录中或被 java.ext.dirs 系统变量所指定的路径的类库。&lt;/li&gt;
&lt;li&gt;应用程序类加载器：它是 Java 实现的，独立于虚拟机。主要负责加载用户类路径(classPath)上的类库，如果我们没有实现自定义的类加载器那这个加载器就是我们程序中的默认加载器。&lt;/li&gt;
&lt;/ul&gt;
&lt;style type=&#34;text/css&#34;&gt;
   
  .notice {
    --title-color: #fff;
    --title-background-color: #6be;
    --content-color: #444;
    --content-background-color: #e7f2fa;
  }

  .notice.info {
    --title-background-color: #fb7;
    --content-background-color: #fec;
  }

  .notice.tip {
    --title-background-color: #5a5;
    --content-background-color: #efe;
  }

  .notice.warning {
    --title-background-color: #c33;
    --content-background-color: #fee;
  }

   
  @media (prefers-color-scheme: dark) {
    .notice {
      --title-color: #fff;
      --title-background-color: #069;
      --content-color: #ddd;
      --content-background-color: #023;
    }

    .notice.info {
      --title-background-color: #a50;
      --content-background-color: #420;
    }

    .notice.tip {
      --title-background-color: #363;
      --content-background-color: #121;
    }

    .notice.warning {
      --title-background-color: #800;
      --content-background-color: #400;
    }
  }

  body.dark .notice {
    --title-color: #fff;
    --title-background-color: #069;
    --content-color: #ddd;
    --content-background-color: #023;
  }

  body.dark .notice.info {
    --title-background-color: #a50;
    --content-background-color: #420;
  }

  body.dark .notice.tip {
    --title-background-color: #363;
    --content-background-color: #121;
  }

  body.dark .notice.warning {
    --title-background-color: #800;
    --content-background-color: #400;
  }

   
  .notice {
    width: 100%;  
    max-width: 600px;  
    padding: 18px;
    line-height: 24px;
    margin-bottom: 24px;
    border-radius: 4px;
    color: var(--content-color);
    background: var(--content-background-color);
  }

  .notice p:last-child {
    margin-bottom: 0;
  }

   
  .notice-title {
    margin: -18px -18px 12px;
    padding: 4px 18px;
    border-radius: 4px 4px 0 0;
    font-weight: 700;
    color: var(--title-color);
    background: var(--title-background-color);
  }

   
  .icon-notice {
    display: inline-flex;
    align-self: center;
    margin-right: 8px;
  }

  .icon-notice img,
  .icon-notice svg {
    height: 1em;
    width: 1em;
    fill: currentColor;
  }

  .icon-notice img,
  .icon-notice.baseline svg {
    top: 0.125em;
    position: relative;
  }
&lt;/style&gt;&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;
  &lt;p&gt;除了 &lt;code&gt;BootstrapClassLoader&lt;/code&gt; 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 &lt;code&gt;ClassLoader&lt;/code&gt;抽象类。&lt;/p&gt;
  &lt;/div&gt;

&lt;h2 id=&#34;类加载过程&#34;&gt;类加载过程
&lt;/h2&gt;&lt;p&gt;类从被加载到 JVM 开始，到卸载出内存，整个生命周期分为七个阶段，分别是加载、验证、准备、解析、初始化、使用和卸载。其中验证、准备和解析这三个阶段统称为连接。&lt;/p&gt;
&lt;h3 id=&#34;加载&#34;&gt;加载
&lt;/h3&gt;&lt;p&gt;JVM 在该阶段的目的是将字节码从不同的数据源（可能是 class 文件、也可能是 jar 包，甚至网络）转化为二进制字节流加载到内存中，将静态数据结构转化成方法区中运行时的数据结构，并生成一个代表该类的 &lt;code&gt;java.lang.Class&lt;/code&gt; 对象&lt;/p&gt;
&lt;h3 id=&#34;链接&#34;&gt;链接
&lt;/h3&gt;&lt;h4 id=&#34;验证&#34;&gt;验证
&lt;/h4&gt;&lt;p&gt;JVM 会在该阶段对二进制字节流进行校验，只有符合 JVM 字节码规范的才能被 JVM 正确执行。该阶段是保证 JVM 安全的重要屏障，保证被校验类的方法在运行时不会做出危害虚拟机的事件。&lt;/p&gt;
&lt;h4 id=&#34;准备&#34;&gt;准备
&lt;/h4&gt;&lt;p&gt;JVM 会在该阶段对&lt;code&gt;static&lt;/code&gt; 关键字修饰的静态变量，分配内存并初始化，对应数据类型的默认初始值。&lt;/p&gt;
&lt;h4 id=&#34;解析&#34;&gt;解析
&lt;/h4&gt;&lt;p&gt;该阶段将常量池中的符号引用转化为直接引用。&lt;/p&gt;
&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;符号引用和直接引用的区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;符号引用&lt;/strong&gt; ：以一组符号（任何形式的字面量，只要在使用时能够无歧义的定位到目标即可）来描述所引用的目标。在编译时，Java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：包含了类、字段、方法、接口等多种符号的全限定名。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：在编译时生成，存储在编译后的字节码文件的常量池中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;独立性&lt;/strong&gt;：不依赖于具体的内存地址，提供了更好的灵活性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;直接引用&lt;/strong&gt; ：通过对符号引用进行解析，找到引用的实际内存地址。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：直接指向目标的指针、相对偏移量或者能间接定位到目标的句柄。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：在运行时生成，依赖于具体的内存布局。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;效率&lt;/strong&gt;：由于直接指向了内存地址或者偏移量，所以通过直接引用访问对象的效率较高。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h3 id=&#34;初始化&#34;&gt;初始化
&lt;/h3&gt;&lt;p&gt;初始化阶段是执行初始化方法  &lt;code&gt;&amp;lt;clinit&amp;gt; ()&lt;/code&gt; 方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。&lt;/p&gt;
&lt;p&gt;初始化的时机&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建类的实例时。&lt;/li&gt;
&lt;li&gt;访问类的静态方法或静态字段时（除了 final 常量，它们在编译期就已经放入常量池）。&lt;/li&gt;
&lt;li&gt;使用 java.lang.reflect 包的方法对类进行反射调用时。&lt;/li&gt;
&lt;li&gt;初始化一个类的子类（首先会初始化父类）。&lt;/li&gt;
&lt;li&gt;JVM 启动时，用户指定的主类（包含 main 方法的类）将被初始化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;卸载&#34;&gt;卸载
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;卸载类即该类的 Class 对象被 GC。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。&lt;/li&gt;
&lt;li&gt;该类没有在其他任何地方被引用&lt;/li&gt;
&lt;li&gt;该类的类加载器的实例已被 GC&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;双亲委派模型&#34;&gt;双亲委派模型
&lt;/h2&gt;&lt;p&gt;双亲委派模型是 Java 类加载机制的设计模式之一。它的核心思想是：类加载器在加载某个类时，会先委派给父类加载器去加载，父类加载器无法加载时，才由当前类加载器自行加载。&lt;/p&gt;
&lt;h3 id=&#34;工作流程&#34;&gt;工作流程
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。&lt;/li&gt;
&lt;li&gt;类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 &lt;code&gt;loadClass()&lt;/code&gt;方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 &lt;code&gt;BootstrapClassLoader&lt;/code&gt; 中。&lt;/li&gt;
&lt;li&gt;只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 &lt;code&gt;findClass()&lt;/code&gt; 方法来加载类）。&lt;/li&gt;
&lt;li&gt;如果子类加载器也无法加载这个类，那么它会抛出一个 &lt;code&gt;ClassNotFoundException&lt;/code&gt; 异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;&lt;strong&gt;双亲委派机制先自下而上委托，再自上而下加载，那为什么不直接自上而下加载？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为本来类加载器是组合关系，也就是子加载器只记录了父加载器，父加载器没记录子加载器（找不到子加载器）。&lt;/p&gt;
&lt;p&gt;其次如果先父加载器接活再传给子加载器，假设有 5 个子加载器 （比如 5 个平级的自定义加载器）传给哪个加载呢？每个试过去嘛？效率就不高了。&lt;/p&gt;&lt;/div&gt;

&lt;h3 id=&#34;好处&#34;&gt;好处
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;保证类的唯一性&lt;/strong&gt; ：通过委托机制，确保了所有加载请求都会传递到启动类加载器，避免了不同类加载器重复加载相同类的情况，保证了Java核心类库的统一性，也防止了用户自定义类覆盖核心类库的可能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保证安全性&lt;/strong&gt; ：由于Java核心库被启动类加载器加载，而启动类加载器只加载信任的类路径中的类，这样可以防止不可信的类假冒核心类，增强了系统的安全性。例如，恶意代码无法自定义一个Java.lang.System类并加载到JVM中，因为这个请求会被委托给启动类加载器，而启动类加载器只会加载标准的Java库中的类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持隔离和层次划分&lt;/strong&gt; ：双亲委派模型支持不同层次的类加载器服务于不同的类加载需求，如应用程序类加载器加载用户代码，扩展类加载器加载扩展框架，启动类加载器加载核心库。这种层次化的划分有助于实现沙箱安全机制，保证了各个层级类加载器的职责清晰，也便于维护和扩展。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简化了加载流程&lt;/strong&gt; ：通过委派，大部分类能够被正确的类加载器加载，减少了每个加载器需要处理的类的数量，简化了类的加载过程，提高了加载效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;
  &lt;p&gt;&lt;strong&gt;JVM 判定两个 Java 类是否相同的具体规则&lt;/strong&gt; ：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 &lt;code&gt;Class&lt;/code&gt; 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。&lt;/p&gt;
  &lt;/div&gt;

&lt;h3 id=&#34;破环双亲委派模型的方法&#34;&gt;破环双亲委派模型的方法
&lt;/h3&gt;&lt;p&gt;重写 ClassLoader 的 &lt;code&gt;loadClass()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;举例：JDBC 的接口（如 &lt;code&gt;java.sql.Driver&lt;/code&gt;）是由 Java 核心库提供的，由&lt;code&gt;BootstrapClassLoader&lt;/code&gt; 加载。而 SPI 的实现（如&lt;code&gt;com.mysql.cj.jdbc.Driver&lt;/code&gt;）是由第三方供应商提供的，它们是由应用程序类加载器或者自定义类加载器来加载的。&lt;/p&gt;
&lt;p&gt;默认情况下，一个类及其依赖类由同一个类加载器加载。所以，加载 SPI 的接口的类加载器（&lt;code&gt;BootstrapClassLoader&lt;/code&gt;）也会用来加载 SPI 的实现。按照双亲委派模型，&lt;code&gt;BootstrapClassLoader&lt;/code&gt; 是无法找到 SPI 的实现类的，因为它无法委托给子类加载器去尝试加载。&lt;/p&gt;
&lt;p&gt;解决方案：使用线程上下文类加载器，通过 &lt;code&gt;setContextClassLoader()&lt;/code&gt; 默认设置了应用程序类加载器，然后通过 &lt;code&gt;Thread.current.currentThread().getContextClassLoader()&lt;/code&gt; 获得类加载器来加载。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>JVM的组织架构</title>
        <link>https://Tyritic.github.io/p/jvm%E7%9A%84%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84/</link>
        <pubDate>Mon, 10 Mar 2025 15:56:14 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/jvm%E7%9A%84%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84/</guid>
        <description>&lt;h2 id=&#34;java程序的执行流程&#34;&gt;Java程序的执行流程
&lt;/h2&gt;&lt;p&gt;Java 程序的执行流程经历了从编译到字节码的生成，再到类加载和 JIT 编译的过程，最终在 JVM 中执行。并且在程序运行过程中，JVM 负责内存管理、垃圾回收和线程调度等工作。&lt;/p&gt;
&lt;p&gt;主要流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源代码：编写 .java 文件。&lt;/li&gt;
&lt;li&gt;编译：使用 javac 编译器生成 .class 字节码文件。&lt;/li&gt;
&lt;li&gt;类加载：JVM 的类加载器加载 .class 文件到内存中。&lt;/li&gt;
&lt;li&gt;解释执行：JVM 将字节码转为机器码执行。&lt;/li&gt;
&lt;li&gt;JIT 编译：JVM 根据需要将热点代码编译为机器码。&lt;/li&gt;
&lt;li&gt;运行：执行 main 方法中的逻辑。&lt;/li&gt;
&lt;li&gt;垃圾回收：JVM 管理内存，并回收不再使用的对象。&lt;/li&gt;
&lt;li&gt;程序结束：main 方法结束，JVM 清理资源，退出程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;style type=&#34;text/css&#34;&gt;
   
  .notice {
    --title-color: #fff;
    --title-background-color: #6be;
    --content-color: #444;
    --content-background-color: #e7f2fa;
  }

  .notice.info {
    --title-background-color: #fb7;
    --content-background-color: #fec;
  }

  .notice.tip {
    --title-background-color: #5a5;
    --content-background-color: #efe;
  }

  .notice.warning {
    --title-background-color: #c33;
    --content-background-color: #fee;
  }

   
  @media (prefers-color-scheme: dark) {
    .notice {
      --title-color: #fff;
      --title-background-color: #069;
      --content-color: #ddd;
      --content-background-color: #023;
    }

    .notice.info {
      --title-background-color: #a50;
      --content-background-color: #420;
    }

    .notice.tip {
      --title-background-color: #363;
      --content-background-color: #121;
    }

    .notice.warning {
      --title-background-color: #800;
      --content-background-color: #400;
    }
  }

  body.dark .notice {
    --title-color: #fff;
    --title-background-color: #069;
    --content-color: #ddd;
    --content-background-color: #023;
  }

  body.dark .notice.info {
    --title-background-color: #a50;
    --content-background-color: #420;
  }

  body.dark .notice.tip {
    --title-background-color: #363;
    --content-background-color: #121;
  }

  body.dark .notice.warning {
    --title-background-color: #800;
    --content-background-color: #400;
  }

   
  .notice {
    width: 100%;  
    max-width: 600px;  
    padding: 18px;
    line-height: 24px;
    margin-bottom: 24px;
    border-radius: 4px;
    color: var(--content-color);
    background: var(--content-background-color);
  }

  .notice p:last-child {
    margin-bottom: 0;
  }

   
  .notice-title {
    margin: -18px -18px 12px;
    padding: 4px 18px;
    border-radius: 4px 4px 0 0;
    font-weight: 700;
    color: var(--title-color);
    background: var(--title-background-color);
  }

   
  .icon-notice {
    display: inline-flex;
    align-self: center;
    margin-right: 8px;
  }

  .icon-notice img,
  .icon-notice svg {
    height: 1em;
    width: 1em;
    fill: currentColor;
  }

  .icon-notice img,
  .icon-notice.baseline svg {
    top: 0.125em;
    position: relative;
  }
&lt;/style&gt;&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;编译执行和解释执行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译执行&lt;/strong&gt;：是指程序在执行之前，首先通过编译器将源代码编译为机器代码，然后直接在 CPU 上运行。常见的编译语言如 C、C++。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：编译后的程序运行速度快，因为机器代码是针对目标平台直接生成的，且不需要在运行时再进行翻译。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：程序必须针对每个平台重新编译，跨平台性差；另外，编译后生成的机器代码难以调试和逆向工程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解释执行&lt;/strong&gt;：解释执行是指源代码不经过编译器的预先编译，而是在运行时通过解释器逐行翻译并执行。常见的解释语言如 Python、Ruby。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：跨平台性好，因为代码在每个平台上都是通过相应平台的解释器来运行的，且开发周期更短。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：运行速度较慢，因为每次执行时都需要进行动态翻译和解释。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;JVM&lt;/strong&gt; 采用 &lt;strong&gt;编译执行&lt;/strong&gt; 和 &lt;strong&gt;解释执行&lt;/strong&gt; 相结合的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;解释执行&lt;/strong&gt; ：JVM 会逐行解释执行字节码，尤其是程序初次运行时，这种方式有助于程序的跨平台性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;即时编译（JIT）&lt;/strong&gt; ：JVM 引入了即时编译器（Just-In-Time Compiler），在程序运行时将热代码（经常执行的代码）编译为本地机器码，避免反复解释，提升性能。因此，JVM 实际上是混合使用解释执行和编译执行。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h2 id=&#34;jvm的特性&#34;&gt;JVM的特性
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;JVM 可以自动管理内存，通过垃圾回收器回收不再使用的对象并释放内存空间。&lt;/li&gt;
&lt;li&gt;JVM 包含一个即时编译器 JIT，它可以在运行时将热点代码缓存到 codeCache 中，下次执行的时候不用再一行一行的解释，而是直接执行缓存后的机器码，执行效率会大幅提高。&lt;/li&gt;
&lt;li&gt;JVM 会Java 程序在编译后生成字节码（&lt;code&gt;.class&lt;/code&gt; 文件），而不是直接生成特定于某一操作系统的机器代码。在不同操作系统上都有各自实现的 JVM，负责将字节码翻译为特定平台的机器代码并执行。这使得同一份 Java 字节码可以在任何支持 JVM 的平台上运行。实现了 Java 一次编译，处处运行的特性&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jvm的组织架构&#34;&gt;JVM的组织架构
&lt;/h2&gt;&lt;p&gt;JVM 大致可以划分为三个部门，分别是类加载器（Class Loader）、运行时数据区（Runtime Data Areas）和执行引擎（Excution Engine）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/jvm%E7%9A%84%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84/seven-06.png&#34;
	width=&#34;1066&#34;
	height=&#34;1142&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;JVM的组织架构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;93&#34;
		data-flex-basis=&#34;224px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;类加载器&#34;&gt;类加载器
&lt;/h3&gt;&lt;p&gt;类加载器子系统负责将 &lt;code&gt;.class&lt;/code&gt; 文件加载到 JVM 中。它负责将 Java 类从文件系统或网络中加载，并将它们转化为 JVM 能理解的数据结构。类加载器的主要过程包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;加载（Loading）&lt;/strong&gt;：找到并加载类文件到 JVM。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链接（Linking）&lt;/strong&gt;：将类文件的数据合并到 JVM 中，分为验证（Verification）、准备（Preparation）和解析（Resolution）三个阶段。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化（Initialization）&lt;/strong&gt;：执行类的静态初始化块和静态变量赋值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;运行时数据区&#34;&gt;运行时数据区
&lt;/h3&gt;&lt;p&gt;JVM 定义了 Java 程序运行期间需要使用到的内存区域，简单来说，这块内存区域存放了字节码信息以及程序执行过程的数据，垃圾收集器]也会针对运行时数据区进行对象回收的工作。&lt;img src=&#34;https://Tyritic.github.io/p/jvm%E7%9A%84%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84/seven-07.png&#34;
	width=&#34;954&#34;
	height=&#34;860&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;运行时数据区&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;110&#34;
		data-flex-basis=&#34;266px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;执行引擎&#34;&gt;执行引擎
&lt;/h3&gt;&lt;p&gt;执行引擎负责将字节码转换为机器指令并执行。执行引擎的主要组成部分包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;解释器&lt;/strong&gt;：逐行解释字节码并执行，适用于程序首次运行时。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;即时编译器&lt;/strong&gt;：将热点代码（频繁执行的代码）编译为机器码，提升执行效率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;垃圾回收器&lt;/strong&gt; ：用来回收堆内存中的垃圾对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;本地方法接口jni&#34;&gt;本地方法接口（JNI）
&lt;/h3&gt;&lt;p&gt;本地方法接口允许 Java 程序调用非 Java 代码（如 C/C++），便于与操作系统或其他本地库交互。JNI 提供了跨语言调用能力，使 Java 程序可以访问操作系统级别的功能或高性能库。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Java内存区域</title>
        <link>https://Tyritic.github.io/p/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</link>
        <pubDate>Mon, 10 Mar 2025 15:46:26 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</guid>
        <description>&lt;h2 id=&#34;jvm内存区域的划分&#34;&gt;JVM内存区域的划分
&lt;/h2&gt;&lt;p&gt;JVM内存区域被划分为以下部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方法区&lt;/strong&gt; ：JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。以元空间的形式实现方法区&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;堆&lt;/strong&gt;：堆内存是 JVM 所有线程共享的部分，在虚拟机启动的时候就已经创建。所有的对象实例和数组都在堆上分配，这部分空间可通过 GC 进行回收。&lt;/li&gt;
&lt;li&gt;**虚拟机栈：每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫 “栈帧” 的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息。栈的大小可以固定也可以动态扩展。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;本地方法栈&lt;/strong&gt; ：与虚拟机栈类似，区别是虚拟机栈执行 Java 方法，本地方法栈执行 native 方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;程序计数器&lt;/strong&gt;：程序计数器可以看成是当前线程所执行的字节码的行号指示器。在任何一个确定的时刻，一个处理器（对于多内核来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;直接内存&lt;/strong&gt; ：直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。&lt;/li&gt;
&lt;/ul&gt;
&lt;style type=&#34;text/css&#34;&gt;
   
  .notice {
    --title-color: #fff;
    --title-background-color: #6be;
    --content-color: #444;
    --content-background-color: #e7f2fa;
  }

  .notice.info {
    --title-background-color: #fb7;
    --content-background-color: #fec;
  }

  .notice.tip {
    --title-background-color: #5a5;
    --content-background-color: #efe;
  }

  .notice.warning {
    --title-background-color: #c33;
    --content-background-color: #fee;
  }

   
  @media (prefers-color-scheme: dark) {
    .notice {
      --title-color: #fff;
      --title-background-color: #069;
      --content-color: #ddd;
      --content-background-color: #023;
    }

    .notice.info {
      --title-background-color: #a50;
      --content-background-color: #420;
    }

    .notice.tip {
      --title-background-color: #363;
      --content-background-color: #121;
    }

    .notice.warning {
      --title-background-color: #800;
      --content-background-color: #400;
    }
  }

  body.dark .notice {
    --title-color: #fff;
    --title-background-color: #069;
    --content-color: #ddd;
    --content-background-color: #023;
  }

  body.dark .notice.info {
    --title-background-color: #a50;
    --content-background-color: #420;
  }

  body.dark .notice.tip {
    --title-background-color: #363;
    --content-background-color: #121;
  }

  body.dark .notice.warning {
    --title-background-color: #800;
    --content-background-color: #400;
  }

   
  .notice {
    width: 100%;  
    max-width: 600px;  
    padding: 18px;
    line-height: 24px;
    margin-bottom: 24px;
    border-radius: 4px;
    color: var(--content-color);
    background: var(--content-background-color);
  }

  .notice p:last-child {
    margin-bottom: 0;
  }

   
  .notice-title {
    margin: -18px -18px 12px;
    padding: 4px 18px;
    border-radius: 4px 4px 0 0;
    font-weight: 700;
    color: var(--title-color);
    background: var(--title-background-color);
  }

   
  .icon-notice {
    display: inline-flex;
    align-self: center;
    margin-right: 8px;
  }

  .icon-notice img,
  .icon-notice svg {
    height: 1em;
    width: 1em;
    fill: currentColor;
  }

  .icon-notice img,
  .icon-notice.baseline svg {
    top: 0.125em;
    position: relative;
  }
&lt;/style&gt;&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;&lt;strong&gt;线程私有的：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序计数器&lt;/li&gt;
&lt;li&gt;虚拟机栈&lt;/li&gt;
&lt;li&gt;本地方法栈&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;线程共享的：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆&lt;/li&gt;
&lt;li&gt;方法区&lt;/li&gt;
&lt;li&gt;直接内存 (非运行时数据区的一部分)&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/java-runtime-data-areas-jdk1.8.png&#34;
	width=&#34;560&#34;
	height=&#34;680&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Java 运行时数据区域（JDK1.8 ）&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;82&#34;
		data-flex-basis=&#34;197px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;程序计数器&#34;&gt;程序计数器
&lt;/h2&gt;&lt;p&gt;程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。&lt;/p&gt;
&lt;p&gt;另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。&lt;/li&gt;
&lt;li&gt;在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;java虚拟机栈&#34;&gt;Java虚拟机栈
&lt;/h2&gt;&lt;p&gt;每个线程有一个私有的栈，随着线程的创建而创建。除了一些 Native 方法调用是通过本地方法栈实现的，其他所有的 Java 方法调用都是通过栈来实现的（也需要和其他运行时数据区域比如程序计数器配合）。方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。&lt;/p&gt;
&lt;p&gt;栈由一个个栈帧组成，而每个栈帧中都对应一个被调用的方法。当线程执行一个方法时，会创建一个对应的栈帧，并将栈帧压入栈中。当方法执行完毕后，将栈帧从栈中移除。&lt;/p&gt;
&lt;p&gt;栈帧的结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;局部变量表&lt;/strong&gt; ：主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作数栈&lt;/strong&gt; ：主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态链接&lt;/strong&gt; ：主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 &lt;strong&gt;动态连接&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法返回地址&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指向运行时常量池的引用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/stack-area.png&#34;
	width=&#34;451&#34;
	height=&#34;551&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Java 虚拟机栈&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;81&#34;
		data-flex-basis=&#34;196px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;栈中存储的 &lt;strong&gt;不是&lt;/strong&gt; 对象，而是 &lt;strong&gt;对象的引用&lt;/strong&gt; 。对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。&lt;/p&gt;
&lt;h2 id=&#34;本地方法栈&#34;&gt;本地方法栈
&lt;/h2&gt;&lt;p&gt;和虚拟机栈所发挥的作用非常相似，区别是：&lt;strong&gt;虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。&lt;/p&gt;
&lt;h2 id=&#34;堆区&#34;&gt;堆区
&lt;/h2&gt;&lt;p&gt;Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。 &lt;strong&gt;此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;堆区空间的进一步划分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;新生代&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Eden 区&lt;/strong&gt;：新对象最初会被分配到 Eden 区，频繁进行垃圾回收。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Survivor 区&lt;/strong&gt;：通常分为两个相等大小的区域，称为S0（Survivor 0）和S1（Survivor 1）， S0 和 S1 交替使用，新对象在 Eden 区经过一次垃圾回收后存放到其中一个 Survivor 区，进一步存活的对象会移动到另一个 Survivor 区，最终晋升到老年代。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;老年代&lt;/strong&gt; ：长生命周期对象经过多次垃圾回收后会被移到老年代，Major GC 在老年代进行，频率较低但耗时较长。&lt;/li&gt;
&lt;li&gt;字符串常量池&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;方法区和元空间&#34;&gt;方法区和元空间
&lt;/h2&gt;&lt;p&gt;方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 &lt;strong&gt;类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;JDK 7 及之前，HotSpot 使用 &lt;strong&gt;永久代&lt;/strong&gt; 实现方法区，主要存储类信息、静态变量等。&lt;/p&gt;
&lt;p&gt;JDK 8 之后，永久代被移除，改为使用元空间，元空间使用本地内存来提高性能和避免 OOM 错误。元空间可以动态调整大小，而永久代大小是固定的。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
