<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Redis on Tyritic</title>
        <link>https://Tyritic.github.io/categories/redis/</link>
        <description>Recent content in Redis on Tyritic</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Tyritic</copyright><atom:link href="https://Tyritic.github.io/categories/redis/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Redis的缓存设计</title>
        <link>https://Tyritic.github.io/p/redis%E7%9A%84%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/</link>
        <pubDate>Sat, 01 Mar 2025 19:56:40 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/redis%E7%9A%84%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/</guid>
        <description>&lt;h2 id=&#34;redis的缓存&#34;&gt;Redis的缓存
&lt;/h2&gt;&lt;p&gt;Redis最常见的用途就是作为缓存系统。通过将热门数据存储在内存中，可以极大地提高访问速度，减轻数据库负载，这对于需要快速响应时间的应用程序非常重要。&lt;/p&gt;
&lt;p&gt;用户的数据一般都是存储于数据库，数据库的数据是落在磁盘上的，磁盘的读写速度很慢了。当用户的请求，都访问数据库的话，请求数量一上来，数据库很容易就崩溃的了，所以为了避免用户直接访问数据库，会用 Redis 作为缓存层。&lt;/p&gt;
&lt;p&gt;因为 Redis 是内存数据库，我们可以将数据库的数据缓存在 Redis 里，相当于数据缓存在内存，内存的读写速度比硬盘快好几个数量级，这样大大提高了系统性能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/redis%E7%9A%84%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/37e4378d2edcb5e217b00e5f12973efd-20230309232858764.png&#34;
	width=&#34;377&#34;
	height=&#34;686&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;缓存系统设计&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;54&#34;
		data-flex-basis=&#34;131px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;缓存雪崩&#34;&gt;缓存雪崩
&lt;/h2&gt;&lt;h3 id=&#34;定义&#34;&gt;定义
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;缓存雪崩&lt;/strong&gt;：指多个缓存数据在同一时间过期或者Redis宕机，导致大量请求同时访问数据库，从而造成数据库瞬间负载激增。&lt;/p&gt;
&lt;p&gt;通常为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间，当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/redis%E7%9A%84%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/e2b8d2eb5536aa71664772457792ec40-20230309232851699.png&#34;
	width=&#34;692&#34;
	height=&#34;438&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;工作流程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;157&#34;
		data-flex-basis=&#34;379px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;那么，当 &lt;strong&gt;大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机&lt;/strong&gt; 时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃。&lt;/p&gt;
&lt;h3 id=&#34;数据大量过期的应对方法&#34;&gt;数据大量过期的应对方法
&lt;/h3&gt;&lt;h4 id=&#34;均匀设置过期时间&#34;&gt;均匀设置过期时间
&lt;/h4&gt;&lt;p&gt;如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时， &lt;strong&gt;给这些数据的过期时间加上一个随机数&lt;/strong&gt; ，这样就保证数据不会在同一时间过期。&lt;/p&gt;
&lt;h4 id=&#34;互斥锁&#34;&gt;互斥锁
&lt;/h4&gt;&lt;p&gt;当业务线程在处理用户请求时， &lt;strong&gt;如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存&lt;/strong&gt; （从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。&lt;/p&gt;
&lt;p&gt;实现互斥锁的时候，最好设置&lt;strong&gt;超时时间&lt;/strong&gt;，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。&lt;/p&gt;
&lt;h3 id=&#34;redis故障宕机的应对方法&#34;&gt;Redis故障宕机的应对方法
&lt;/h3&gt;&lt;h4 id=&#34;服务熔断和请求限流机制&#34;&gt;服务熔断和请求限流机制
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;服务熔断机制&lt;/strong&gt; ：因为 Redis 故障宕机而导致缓存雪崩问题时， &lt;strong&gt;暂停业务应用对缓存服务的访问，直接返回错误&lt;/strong&gt; ，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求限流&lt;/strong&gt; ：&lt;strong&gt;只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务&lt;/strong&gt; ，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。
&lt;ul&gt;
&lt;li&gt;令牌桶算法&lt;/li&gt;
&lt;li&gt;漏斗算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;style type=&#34;text/css&#34;&gt;
   
  .notice {
    --title-color: #fff;
    --title-background-color: #6be;
    --content-color: #444;
    --content-background-color: #e7f2fa;
  }

  .notice.info {
    --title-background-color: #fb7;
    --content-background-color: #fec;
  }

  .notice.tip {
    --title-background-color: #5a5;
    --content-background-color: #efe;
  }

  .notice.warning {
    --title-background-color: #c33;
    --content-background-color: #fee;
  }

   
  @media (prefers-color-scheme: dark) {
    .notice {
      --title-color: #fff;
      --title-background-color: #069;
      --content-color: #ddd;
      --content-background-color: #023;
    }

    .notice.info {
      --title-background-color: #a50;
      --content-background-color: #420;
    }

    .notice.tip {
      --title-background-color: #363;
      --content-background-color: #121;
    }

    .notice.warning {
      --title-background-color: #800;
      --content-background-color: #400;
    }
  }

  body.dark .notice {
    --title-color: #fff;
    --title-background-color: #069;
    --content-color: #ddd;
    --content-background-color: #023;
  }

  body.dark .notice.info {
    --title-background-color: #a50;
    --content-background-color: #420;
  }

  body.dark .notice.tip {
    --title-background-color: #363;
    --content-background-color: #121;
  }

  body.dark .notice.warning {
    --title-background-color: #800;
    --content-background-color: #400;
  }

   
  .notice {
    width: 100%;  
    max-width: 600px;  
    padding: 18px;
    line-height: 24px;
    margin-bottom: 24px;
    border-radius: 4px;
    color: var(--content-color);
    background: var(--content-background-color);
  }

  .notice p:last-child {
    margin-bottom: 0;
  }

   
  .notice-title {
    margin: -18px -18px 12px;
    padding: 4px 18px;
    border-radius: 4px 4px 0 0;
    font-weight: 700;
    color: var(--title-color);
    background: var(--title-background-color);
  }

   
  .icon-notice {
    display: inline-flex;
    align-self: center;
    margin-right: 8px;
  }

  .icon-notice img,
  .icon-notice svg {
    height: 1em;
    width: 1em;
    fill: currentColor;
  }

  .icon-notice img,
  .icon-notice.baseline svg {
    top: 0.125em;
    position: relative;
  }
&lt;/style&gt;&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;令牌桶算法的基本概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;令牌桶（Token Bucket）&lt;/strong&gt;：一个固定容量的桶，用于存放令牌。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;令牌生成速率（Rate）&lt;/strong&gt;：令牌按固定速率 &lt;strong&gt;r&lt;/strong&gt;（个/秒）加入桶中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;桶的最大容量（Capacity）&lt;/strong&gt;：最多可存放的令牌数量，超过部分被丢弃。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;令牌桶算法的算法流程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;系统初始化&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;令牌桶被创建，初始令牌数 &lt;strong&gt;&lt;code&gt;C&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;每秒会 &lt;strong&gt;自动生成 &lt;code&gt;r &lt;/code&gt; 个新令牌&lt;/strong&gt;，但总令牌数不会超过 &lt;strong&gt;&lt;code&gt;C&lt;/code&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;请求到来&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如果桶内 &lt;code&gt;T &amp;gt; 0&lt;/code&gt;&lt;/strong&gt;，则允许请求通过，并消耗 1 个令牌。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果桶内 &lt;code&gt;T == 0&lt;/code&gt;&lt;/strong&gt;，请求被 &lt;strong&gt;拒绝（限流）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;令牌自动填充&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每 &lt;code&gt;1/r&lt;/code&gt; 秒，系统会向桶内添加 &lt;strong&gt;新令牌&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;新增的令牌 &lt;strong&gt;不会超过桶的最大容量&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;突发流量处理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当桶内 &lt;strong&gt;有足够令牌时&lt;/strong&gt;，可支持短时间 &lt;strong&gt;高并发请求&lt;/strong&gt;（比如 10 个请求瞬间到来）。&lt;/li&gt;
&lt;li&gt;但当桶内令牌 &lt;strong&gt;耗尽&lt;/strong&gt; 时，系统会 &lt;strong&gt;严格按照 &lt;code&gt;r&lt;/code&gt; 速率处理请求&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h4 id=&#34;多级缓存&#34;&gt;多级缓存
&lt;/h4&gt;&lt;p&gt;对于关键数据，除了在主缓存中存储，还可以在备用缓存中保存一份。当主缓存不可用时，可以快速切换到备用缓存，确保系统的稳定性和可用性。&lt;/p&gt;
&lt;h4 id=&#34;构建redis集群&#34;&gt;构建Redis集群
&lt;/h4&gt;&lt;p&gt;服务熔断或请求限流机制是缓存雪崩发生后的应对方案，可以通过 &lt;strong&gt;主从节点的方式构建 Redis 缓存高可靠集群&lt;/strong&gt;。如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。&lt;/p&gt;
&lt;p&gt;Redis 集群（Redis cluster）是通过多个 Redis 实例组成的，&lt;strong&gt;每个实例存储部分的数据（即每个实例之间的数据是不重复的）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;具体是采用哈希槽（Hash Slot）机制来分配数据，将整个键空间划分为 16384 个槽（slots）。每个 Redis 实例负责一定范围的哈希槽，数据的 key 经过哈希函数计算后对 16384 取余即可定位到对应的节点。&lt;/p&gt;
&lt;p&gt;客户端在发送请求时，会通过集群的任意节点进行连接，如果该节点存储了对应的数据则直接返回，反之该节点会根据请求的键值计算哈希槽并路由到正确的节点。&lt;/p&gt;
&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;信息同步机制&lt;/p&gt;
&lt;p&gt;Redis 集群内每个节点都会保存集群的完整拓扑信息，包括每个节点的 ID、IP 地址、端口、负责的哈希槽范围等。节点之间使用 &lt;strong&gt;&lt;code&gt;Gossip&lt;/code&gt;&lt;/strong&gt; 协议进行状态交换，以保持集群的一致性和故障检测。每个节点会周期性地发送 PING 和 PONG 消息，交换集群信息，使得集群信息得以同步。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;状态报告&lt;/strong&gt; ：每个节点在特定的时间间隔内，向随机选择的其他节点发送其自身的状态信息，包括节点的主从关系、槽位分布等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;信息更新&lt;/strong&gt; ：接收到状态信息的节点会根据所接收到的数据更新自己的状态，并将更新后的状态继续传播给其他节点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;节点检测&lt;/strong&gt;：通过周期性交换状态信息，节点可以检测到其他节点的存活状态。如果某个节点未能在预定时间内响应，则该节点会被标记为故障节点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容错处理&lt;/strong&gt; ：在检测到节点故障后，集群中的其他节点可以采取措施（如重新分配槽位）以保持系统的高可用性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;节点路由机制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个节点会拥有一部分的槽位，然后对应的键值会根据其本身的 key，映射到一个哈希槽中，其主要流程如下：
&lt;ul&gt;
&lt;li&gt;根据键值的 key，按照 CRC 16 算法计算一个 16 bit 的值，然后将 16 bit 的值对 16384 进行取余运算，最后得到一个对应的哈希槽编号。&lt;/li&gt;
&lt;li&gt;根据每个节点分配的哈希槽区间，对应编号的数据落在对应的区间上，就能找到对应的分片实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h2 id=&#34;缓存击穿&#34;&gt;缓存击穿
&lt;/h2&gt;&lt;h3 id=&#34;定义-1&#34;&gt;定义
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;缓存击穿&lt;/strong&gt;：指某个热点数据在缓存中失效，导致大量请求直接访问数据库。此时，由于瞬间的高并发，可能导致数据库崩溃。&lt;/p&gt;
&lt;h3 id=&#34;应对方案&#34;&gt;应对方案
&lt;/h3&gt;&lt;h4 id=&#34;互斥锁方案&#34;&gt;互斥锁方案
&lt;/h4&gt;&lt;p&gt;使用互斥锁保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。&lt;/p&gt;
&lt;p&gt;假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/redis%E7%9A%84%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/1653328288627.png&#34;
	width=&#34;569&#34;
	height=&#34;723&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;互斥锁方案&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;78&#34;
		data-flex-basis=&#34;188px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;核心思路利用redis的 &lt;strong&gt;&lt;code&gt;setnx&lt;/code&gt;&lt;/strong&gt; 方法来表示获取锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若redis中如果没有这个key，则插入成功，返回1，在stringRedisTemplate中返回true&lt;/li&gt;
&lt;li&gt;如果有这个key则插入失败，则返回0，在stringRedisTemplate返回false&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;缓存穿透&#34;&gt;缓存穿透
&lt;/h2&gt;&lt;h3 id=&#34;定义-2&#34;&gt;定义
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;缓存穿透&lt;/strong&gt;：指查询一个不存在（ &lt;strong&gt;既不在缓存中，也不在数据库中&lt;/strong&gt; ）的数据，缓存中没有相应的记录，每次请求都会去数据库查询，造成数据库负担加重。&lt;/p&gt;
&lt;h3 id=&#34;应对方案-1&#34;&gt;应对方案
&lt;/h3&gt;&lt;h4 id=&#34;限制非法请求&#34;&gt;限制非法请求
&lt;/h4&gt;&lt;p&gt;当有大量请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。&lt;/p&gt;
&lt;h4 id=&#34;缓存空值&#34;&gt;缓存空值
&lt;/h4&gt;&lt;p&gt;当发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。客户端请求某个 ID 的数据，首先检查缓存是否命中。如果缓存未命中，查询数据库。如果数据库查询结果为空，将该空结果（如 null 或 {}）缓存起来，并设置一个合理的过期时间。当后续请求再访问相同 ID 时，缓存直接返回空结果，避免每次都打到数据库。&lt;/p&gt;
&lt;h4 id=&#34;布隆过滤器&#34;&gt;布隆过滤器
&lt;/h4&gt;&lt;p&gt;在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行&lt;/p&gt;
&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;布隆过滤器是一种空间效率极高的概率型数据结构，用于快速检查一个元素是否存在于一个集合中。&lt;/p&gt;
&lt;p&gt;构造操作如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开始时，布隆过滤器的每个位都被设置为 0。&lt;/li&gt;
&lt;li&gt;当一个元素被添加到过滤器中时，它会被 k 个哈希函数分别计算得到 k 个位置，然后将位数组中对应的位设置为 1。&lt;/li&gt;
&lt;li&gt;当检查一个元素是否存在于过滤器中时，同样使用 k 个哈希函数计算位置，如果任一位置的位为 0，则该元素肯定不在过滤器中；如果所有位置的位都为 1，则该元素可能在过滤器中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;误判问题&lt;/p&gt;
&lt;p&gt;由于哈希冲突的原因，布隆过滤器存在误判问题，&lt;strong&gt;查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;误判率的决定因素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位数组的大小（m）：位数组的大小决定了可以存储的标志位数量。如果位数组过小，那么哈希碰撞的几率就会增加，从而导致更高的误判率。&lt;/li&gt;
&lt;li&gt;哈希函数的数量（k）：哈希函数的数量决定了每个元素在位数组中标记的位数。哈希函数越多，碰撞的概率也会相应变化。如果哈希函数太少，则过滤器很快会变得不精确；如果太多，误判率也会升高，效率下降。&lt;/li&gt;
&lt;li&gt;存入的元素数量（n）：存入的元素越多，哈希碰撞的几率越大，从而导致更高的误判率。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优缺点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高效性：插入和查询操作都非常高效，时间复杂度为 O(k)，k 为哈希函数的数量。&lt;/li&gt;
&lt;li&gt;节省空间：相比于直接存储所有元素，布隆过滤器大幅度减少了内存使用。&lt;/li&gt;
&lt;li&gt;可扩展性：可以根据需要调整位数组的大小和哈希函数的数量来平衡时间和空间效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;误判率：可能会误认为不存在的元素在集合中，但不会漏报（不存在的元素不会被认为存在）。&lt;/li&gt;
&lt;li&gt;不可删除：一旦插入元素，不能删除，因为无法确定哪些哈希值是由哪个元素设置的。&lt;/li&gt;
&lt;li&gt;需要多个哈希函数：选择合适的哈希函数并保证它们独立性并不容易。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与哈希表的比较&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;布隆过滤器是一种基于位数组和多个哈希函数的概率型数据结构，适合在内存资源有限、数据量大且能容忍一定误判的场景下使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相比哈希表，布隆过滤器的内存开销非常小，能快速判断一个元素是否存在。虽然它存在误判，但不会漏报，因此在防止缓存穿透、黑名单过滤和推荐系统去重等场景中广泛使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/redis%E7%9A%84%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/1653326156516.png&#34;
	width=&#34;1012&#34;
	height=&#34;569&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;上面策略的示意图&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;177&#34;
		data-flex-basis=&#34;426px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;缓存和数据库的一致性问题&#34;&gt;缓存和数据库的一致性问题
&lt;/h2&gt;&lt;h3 id=&#34;旁路缓存策略&#34;&gt;旁路缓存策略
&lt;/h3&gt;&lt;p&gt;对于读操作：如果缓存不命中，则会从数据库读取数据，然后将数据库的数据回种到缓存中&lt;/p&gt;
&lt;p&gt;对于写操作：先更新数据库，再删除缓存，后续等查询把数据库的数据回种到缓存中&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/redis%E7%9A%84%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/1720197145123-7e06f9a4-fcc7-42cc-a3d2-c44af4a73214.webp&#34;
	width=&#34;731&#34;
	height=&#34;618&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;旁路缓存策略&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;118&#34;
		data-flex-basis=&#34;283px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;缓存是通过牺牲强一致性来提高性能的。这是由 &lt;strong&gt;CAP理论&lt;/strong&gt; 决定的。缓存系统适用的场景就是非强一致性的场景，它属于CAP中的AP。所以，如果需要数据库和缓存数据保持强一致，就不适合使用缓存。&lt;/p&gt;
&lt;p&gt;所以使用缓存提升性能，就是会有数据更新的延迟。这需要我们在设计时结合业务仔细思考是否适合用缓存。然后缓存一定要设置过期时间，这个时间太短、或者太长都不好：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;太短的话请求可能会比较多的落到数据库上，这也意味着失去了缓存的优势。&lt;/li&gt;
&lt;li&gt;太长的话缓存中的脏数据会使系统长时间处于一个延迟的状态，而且系统中长时间没有人访问的数据一直存在内存中不过期，浪费内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;CAP理论&lt;/p&gt;
&lt;p&gt;理论描述：描述了在分区（Partition）发生的情况下，系统无法同时保证一致性（Consistency）和可用性（Availability），只能在两者之间做权衡。&lt;/p&gt;
&lt;p&gt;核心属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一致性（Consistency）&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;所有节点对同一份数据的访问必须是最新的（或者说是同步的）。&lt;/li&gt;
&lt;li&gt;任何一个读请求都应该返回最新的写入数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可用性（Availability）&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;每个请求都能在合理的时间内获得响应（无论返回的数据是否是最新的）。&lt;/li&gt;
&lt;li&gt;不能因为某些节点故障而影响整个系统的正常运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分区容忍性（Partition Tolerance）&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;系统能在网络分区的情况下继续运行，即使部分节点之间的通信被中断。&lt;/li&gt;
&lt;li&gt;分布式系统中，网络分区是不可避免的，因此任何实际系统都必须具备分区容忍性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;为什么选择删除缓存而不是更新缓存&lt;/p&gt;
&lt;p&gt;相对而言，删除缓存的速度比更新缓存的速度要快得多。假如是更新缓存，那么可能请求 A 更新完 MySQL 后在更新 Redis 中，请求 B 已经读取到 Redis 中的旧值返回了，又一次导致了缓存和数据库不一致。&lt;/p&gt;&lt;/div&gt;

&lt;h3 id=&#34;延时双删策略&#34;&gt;延时双删策略
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;更新数据库之前，删除一次缓存&lt;/li&gt;
&lt;li&gt;更新完数据库后，再进行一次延迟删除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 &lt;strong&gt;第一步删除缓存&lt;/strong&gt; 后，仍然存在并发请求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;另一个线程可能 &lt;strong&gt;读取旧数据并写回缓存&lt;/strong&gt; ，导致缓存回滚。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;延迟一段时间&lt;/strong&gt; 后，第二次删除可以清理这类脏数据，保证缓存不包含旧数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/redis%E7%9A%84%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/Snipaste_2024-05-18_16-59-05_mianshiya.jpg&#34;
	width=&#34;1461&#34;
	height=&#34;968&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;延时双删策略&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;150&#34;
		data-flex-basis=&#34;362px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;由图可知需要保证第二次删除缓存要在回写缓存之后，常见策略是 &lt;strong&gt;让请求 A 的最后一次删除，等待 500ms&lt;/strong&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Redis的缓存淘汰策略和过期删除策略</title>
        <link>https://Tyritic.github.io/p/redis%E7%9A%84%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E5%92%8C%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/</link>
        <pubDate>Sat, 01 Mar 2025 17:51:38 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/redis%E7%9A%84%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E5%92%8C%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/</guid>
        <description>&lt;h2 id=&#34;过期删除策略&#34;&gt;过期删除策略
&lt;/h2&gt;&lt;p&gt;Redis 数据过期主要有两种删除策略，分别为 &lt;strong&gt;定期删除、惰性删除&lt;/strong&gt; 两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定期删除&lt;/strong&gt;：Redis 每隔一定时间（默认是 100 毫秒）会随机检查一定数量的键，如果发现过期键，则将其删除。这种方式能够在后台持续清理过期数据，防止内存膨胀。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;惰性删除&lt;/strong&gt;：在每次访问键时，Redis 检查该键是否已过期，如果已过期，则将其删除。这种策略保证了在使用过程中只删除不再需要的数据，但在不访问过期键时不会立即清除。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;key过期的判定&#34;&gt;Key过期的判定
&lt;/h3&gt;&lt;p&gt;每当对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间存储到一个 &lt;strong&gt;过期字典&lt;/strong&gt; 中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。&lt;/p&gt;
&lt;p&gt;字典实际上是哈希表。当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果不在，则正常读取键值；&lt;/li&gt;
&lt;li&gt;如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;定期删除策略&#34;&gt;定期删除策略
&lt;/h3&gt;&lt;p&gt;定期删除策略的做法：&lt;strong&gt;每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。&lt;/li&gt;
&lt;li&gt;难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略对CPU不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;惰性删除策略&#34;&gt;惰性删除策略
&lt;/h3&gt;&lt;p&gt;惰性删除策略的做法是：&lt;strong&gt;不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 CPU 时间最友好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内存淘汰策略&#34;&gt;内存淘汰策略
&lt;/h2&gt;&lt;p&gt;内存淘汰策略是在内存满了的时候，redis 会触发内存淘汰策略，来淘汰一些不必要的内存资源，以腾出空间，来保存新的内容&lt;/p&gt;
&lt;p&gt;Redis 的内存淘汰策略一共有 8 种。 分为以下几类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;开启数据淘汰&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基于过期时间的淘汰策略&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;volatile-random&lt;/strong&gt;：随机淘汰设置了过期时间的任意键值；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;volatile-ttl&lt;/strong&gt;：优先淘汰更早过期的键值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;volatile-lru&lt;/strong&gt; ：淘汰所有设置了过期时间的键值中，最久未使用的键值；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;volatile-lfu&lt;/strong&gt; ：淘汰所有设置了过期时间的键值中，最少使用的键值；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全部数据的淘汰策略&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;allkeys-random&lt;/strong&gt;：随机淘汰任意键值;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;allkeys-lru&lt;/strong&gt;：淘汰整个键值中最久未使用的键值；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;allkeys-lfu&lt;/strong&gt; ：淘汰整个键值中最少使用的键值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不开启数据淘汰&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;noeviction&lt;/strong&gt; ：当运行内存超过最大设置内存的时候，不会淘汰数据，而是直接返回报错禁止写入&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Redis的持久化策略</title>
        <link>https://Tyritic.github.io/p/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/</link>
        <pubDate>Sat, 01 Mar 2025 16:36:44 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/</guid>
        <description>&lt;h2 id=&#34;主要的持久化机制&#34;&gt;主要的持久化机制
&lt;/h2&gt;&lt;p&gt;Redis 提供两种主要的持久化机制：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RDB（Redis Database）快照&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RDB 是通过生成某一时刻的数据快照来实现持久化的，可以在特定时间间隔内保存数据的快照。&lt;/li&gt;
&lt;li&gt;适合灾难恢复和备份，能生成紧凑的二进制文件，但可能会在崩溃时丢失最后一次快照之后的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;AOF（Append Only File）日志&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AOF 通过将每个写操作追加到日志文件中实现持久化，支持将所有写操作记录下来以便恢复。&lt;/li&gt;
&lt;li&gt;数据恢复更为精确，但文件体积较大，重写时可能会消耗更多资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;aof持久化机制&#34;&gt;AOF持久化机制
&lt;/h2&gt;&lt;p&gt;AOF 持久化机制是指 &lt;strong&gt;将 Redis 写命令以追加的形式写入到磁盘中的 AOF 文件&lt;/strong&gt; ，AOF 文件记录了 Redis 在内存中的操作过程，只要在 Redis 重启后重新执行 AOF 文件中的写命令即可将数据恢复到内存中。&lt;/p&gt;
&lt;h3 id=&#34;执行过程&#34;&gt;执行过程
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/6f0ab40396b7fc2c15e6f4487d3a0ad7.png&#34;
	width=&#34;902&#34;
	height=&#34;332&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;AOF持久化&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;271&#34;
		data-flex-basis=&#34;652px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;实际上Redis先执行写操作命令后，才将该命令记录到 AOF 日志里&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当 AOF 持久化机制被启用时，Redis 服务器会将接收到的所有写命令追加到 AOF 缓冲区的末尾。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据写回策略将缓冲区中的命令刷新到磁盘的 AOF 文件中，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随着 AOF 文件的不断增长，Redis 会启用重写机制来生成一个更小的 AOF 文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当 Redis 服务器重启时，会读取 AOF 文件中的所有命令并重新执行它们，以恢复重启前的内存状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;避免额外的检查开销。&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。&lt;/li&gt;
&lt;li&gt;而如果先执行写操作命令再记录日志的话，只有在该命令执行成功后，才将命令记录到 AOF 日志里，这样就不用额外的检查开销，保证记录在 AOF 日志里的命令都是可执行并且正确的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不会阻塞当前写操作命令的执行&lt;/strong&gt; ：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;丢失的风险&lt;/strong&gt; ：执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失风险&lt;/li&gt;
&lt;li&gt;由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前写操作命令的执行，但是 &lt;strong&gt;可能会给「下一个」命令带来阻塞风险&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;恢复速度慢&lt;/strong&gt; ：因为记录了每一个写操作，所以AOF文件通常比RDB文件更大，消耗更多的磁盘空间。并且，频繁的磁盘IO操作可能会对Redis的写入性能造成一定影响。而且，当问个文件体积过大时，AOF会进行重写操作，AOF如果没有开启AOF重写或者重写频率较低，恢复过程可能较慢，因为它需要重放所有的操作命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;写回策略&#34;&gt;写回策略
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Always&lt;/strong&gt; ：每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Everysec&lt;/strong&gt; ：每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No&lt;/strong&gt; ：不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三种写回策略的缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Always 策略：可以最大程度保证数据不丢失，但是由于它每执行一条写操作命令就同步将 AOF 内容写回硬盘，所以是不可避免会影响主进程的性能；&lt;/li&gt;
&lt;li&gt;No 策略：是交由操作系统来决定何时将 AOF 日志内容写回硬盘，相比于 Always 策略性能较好，但是操作系统写回硬盘的时机是不可预知的，如果 AOF 日志内容没有写回硬盘，一旦服务器宕机，就会丢失不定数量的数据。&lt;/li&gt;
&lt;li&gt;Everysec 策略：是折中的一种方式，避免了 Always 策略的性能开销，也比 No 策略更能避免数据丢失，当然如果上一秒的写操作命令日志没有写回到硬盘，发生了宕机，这一秒内的数据自然也会丢失。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;重写机制&#34;&gt;重写机制
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;主进程在通过 &lt;code&gt;fork&lt;/code&gt; 系统调用生成 bgrewriteaof 子进程时，操作系统会把主进程的「&lt;strong&gt;页表&lt;/strong&gt;」复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。&lt;/li&gt;
&lt;li&gt;当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发 &lt;strong&gt;写保护中断&lt;/strong&gt; ，这个写保护中断是由于违反权限导致的，然后操作系统会在「写保护中断处理函数」里进行 &lt;strong&gt;物理内存的复制&lt;/strong&gt; ，并重新设置其内存映射关系，将父子进程的内存读写权限设置为 &lt;strong&gt;可读写&lt;/strong&gt; ，最后才会对内存进行写操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了。为了解决这个问题，Redis 设置了一个 &lt;strong&gt;AOF 重写缓冲区&lt;/strong&gt;，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。&lt;/p&gt;
&lt;p&gt;在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会 &lt;strong&gt;同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;当子进程完成 AOF 重写工作后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。&lt;/p&gt;
&lt;p&gt;主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；&lt;/li&gt;
&lt;li&gt;新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rdb持久化机制&#34;&gt;RDB持久化机制
&lt;/h2&gt;&lt;p&gt;RDB 持久化通过创建快照来获取内存某个时间点上的副本，利用快照可以进行方便地进行主从复制。&lt;/p&gt;
&lt;p&gt;redis.conf 文件可以配置在 x 秒内如果至少有 y 个 key 发生变化就会触发命令进行持久化操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;恢复速度快&lt;/strong&gt; ： RDB通过快照的形式保存某一时刻的数据状态，文件体积小，备份和恢复的速度非常快。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务性能影响小&lt;/strong&gt; ：RDB是在主线程之外通过fork子进程来进行的，不会阻塞服务器处理命令请求，对Redis服务的性能影响较小。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件小&lt;/strong&gt; ：由于是定期快照，RDB文件通常比AOF文件小得多。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据丢失&lt;/strong&gt; ：RDB方式在两次快照之间，如果Redis服务器发生故障，这段时间的数据将会丢失。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据不一致&lt;/strong&gt; ：如果在RDB创建快照到恢复期间有写操作，恢复后的数据可能与故障前的数据不完全一致&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;生成rdb快照的过程&#34;&gt;生成RDB快照的过程
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，&lt;strong&gt;会阻塞主线程&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以&lt;strong&gt;避免主线程的阻塞&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用bgsave命令的流程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查子进程（检查是否存在 AOF/RDB 的子进程正在进行），如果有返回错误&lt;/li&gt;
&lt;li&gt;触发持久化，调用 rdbSaveBackground&lt;/li&gt;
&lt;li&gt;开始 fork，子进程执行 rdb 操作，同时主进程响应其他操作。&lt;/li&gt;
&lt;li&gt;RDB 完成后，替换原来的旧 RDB 文件，子进程退出。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;生成rdb快照的请求处理&#34;&gt;生成RDB快照的请求处理
&lt;/h3&gt;&lt;p&gt;在 Redis 生成 RDB 文件时是异步的（使用 bgsave 命令），&lt;strong&gt;采用了 fork 子进程的方式来进行快照操作&lt;/strong&gt;。生成 RDB 文件的过程由子进程执行，主进程继续处理客户端请求，所以可以保证 Redis 在生成快照的过程中依然对外提供服务，不会影响正常请求。&lt;/p&gt;
&lt;p&gt;在生成过程中依然能正常进行数据修改&lt;/p&gt;
&lt;p&gt;主要原理就是 &lt;strong&gt;写时复制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当主进程 &lt;code&gt;fork&lt;/code&gt; 出一个子进程后，并不会把主进程的所有内存数据重新复制一份给子进程，而是让主进程和子进程共享相同的内存页面。底层的实现仅仅复制了&lt;strong&gt;页表&lt;/strong&gt;，但映射的物理内存还是同一个。&lt;/li&gt;
&lt;li&gt;当主进程接收到写的请求时，主进程会将对应数据所在的页复制一份，对复制的副本进行修改。此时子进程指向的还是老的页，因此数据没有变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rdb和aof的选择&#34;&gt;RDB和AOF的选择
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如果需要尽可能减少数据丢失，AOF 是更好的选择。尤其是在频繁写入的环境下，设置 AOF 每秒同步可以最大限度减少数据丢失。&lt;/li&gt;
&lt;li&gt;如果性能是首要考虑，RDB 可能更适合。RDB 的快照生成通常对性能影响较小，并且数据恢复速度快。&lt;/li&gt;
&lt;li&gt;如果系统需要经常重启，并且希望系统重启后快速恢复，RDB 可能是更好的选择。虽然 AOF 也提供了良好的恢复能力，但重写 AOF 文件可能会比较慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;bigkey问题&#34;&gt;BigKey问题
&lt;/h2&gt;&lt;p&gt;Redis 中的 &amp;ldquo;big Key&amp;rdquo; 是指一个内存空间占用比较大的键（Key）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工作线程阻塞&lt;/strong&gt; ：由于 Redis 单线程执行命令，操作大 Key 时耗时较长，从而导致 Redis 出现其它命令阻塞的问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络阻塞&lt;/strong&gt; ：大 Key 对资源的占用巨大，在你进行网络 I/O 传输的时候，导致你获取过程中产生的网络流量较大，从而产生网络传输时间延长甚至网络传输发现阻塞的现象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端超时&lt;/strong&gt; ：因为操作大 Key 时耗时较长，可能导致客户端等待超时。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;对持久化的影响&#34;&gt;对持久化的影响
&lt;/h3&gt;&lt;h4 id=&#34;对aof的影响&#34;&gt;对AOF的影响
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对写回策略的影响&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当使用 Always 策略的时候：如果写入是一个大 Key，主线程在执行 fsync() 函数的时候，阻塞的时间会比较久，因为当写入的数据量很大的时候，数据同步到硬盘这个过程是很耗时的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当使用 Everysec 策略的时候，由于是异步执行 fsync() 函数，所以大 Key 持久化的过程（数据同步磁盘）不会影响主线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当使用 No 策略的时候，由于永不执行 fsync() 函数，所以大 Key 持久化的过程不会影响主线程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对AOF重写的影响&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 AOF 日志写入了很多的大 Key，AOF 日志文件的大小会很大，那么很快就会触发 &lt;strong&gt;AOF 重写机制&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；&lt;/li&gt;
&lt;li&gt;创建完子进程后，如果父进程修改了共享数据中的大 Key，就会发生写时复制，这期间会拷贝物理内存，由于大 Key 占用的物理内存会很大，那么在复制物理内存这一过程，就会比较耗时，所以有可能会阻塞父进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;对rdb的影响&#34;&gt;对RDB的影响
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；&lt;/li&gt;
&lt;li&gt;创建完子进程后，如果父进程修改了共享数据中的大 Key，就会发生写时复制，这期间会拷贝物理内存，由于大 Key 占用的物理内存会很大，那么在复制物理内存这一过程，就会比较耗时，所以有可能会阻塞父进程。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Redis的Java客户端和与SpringBoot的集成</title>
        <link>https://Tyritic.github.io/p/redis%E7%9A%84java%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E4%B8%8Espringboot%E7%9A%84%E9%9B%86%E6%88%90/</link>
        <pubDate>Thu, 27 Feb 2025 16:57:13 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/redis%E7%9A%84java%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E4%B8%8Espringboot%E7%9A%84%E9%9B%86%E6%88%90/</guid>
        <description>&lt;h2 id=&#34;redis的java客户端&#34;&gt;Redis的Java客户端
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Jedis&lt;/code&gt;&lt;/strong&gt; 适用于简单的同步操作和单线程环境。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Lettuce&lt;/code&gt;&lt;/strong&gt; 适用于高并发、高性能和多线程环境，尤其是需要异步和响应式编程的场景。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Redisson&lt;/code&gt;&lt;/strong&gt; 适用于复杂的分布式系统，提供丰富的分布式对象和服务，简化开发。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;jedis&#34;&gt;Jedis
&lt;/h3&gt;&lt;p&gt;Jedis 是一款比较经典的 Java 客户端了，提供了比较全面的 Redis 命令。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单易用：提供了直观的 API，使得开发者能够方便地与 Redis 进行交互。&lt;/li&gt;
&lt;li&gt;使用广泛：在 Java 社区中被广泛采用，有丰富的文档和示例可供参考。&lt;/li&gt;
&lt;li&gt;性能良好：在大多数情况下能够提供高效的 Redis 操作。&lt;/li&gt;
&lt;li&gt;功能丰富：支持常见的 Redis 操作，如字符串、列表、哈希、集合等数据结构的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程安全问题：线程不安全，每个线程需独立使用 Jedis 实例。&lt;/li&gt;
&lt;li&gt;不支持自动重连：在网络异常或 Redis 服务器重启时，需要手动处理重连。&lt;/li&gt;
&lt;li&gt;阻塞操作：同步的 API，因此高并发下可能会发生阻塞&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lettuce&#34;&gt;Lettuce
&lt;/h3&gt;&lt;p&gt;Lettuce 其相对于 Jedis，其最突出的点就是线程安全，且其扩展性较高，它支持异步和响应式 API，底层基于 Netty 实现。&lt;/p&gt;
&lt;p&gt;Lettuce 具有以下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多线程安全&lt;/strong&gt; ：在多线程环境中可以安全使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动重连&lt;/strong&gt; ：当网络连接出现问题时，能够自动重新连接。&lt;/li&gt;
&lt;li&gt;支持多种编程模型：同步、异步、响应式，适应不同的应用场景&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;redisson&#34;&gt;Redisson
&lt;/h3&gt;&lt;p&gt;Redisson 是一个高级的 Redis 客户端，提供分布式和并行编程的支持，提供了丰富的分布式对象和服务，底层也是基于 Netty 实现通信。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;高级特性&lt;/strong&gt; ：支持分布式锁、缓存、队列等常见场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;支持集群&lt;/strong&gt; ：支持 Redis 集群模式，适应大规模分布式应用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;线程安全&lt;/strong&gt; ：无需手动处理多线程问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;springboot集成redis&#34;&gt;SpringBoot集成Redis
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;SpringData&lt;/code&gt;&lt;/strong&gt; 是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块 &lt;strong&gt;&lt;code&gt;SpringDataRedis&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供了对不同Redis客户端的整合（Lettuce和Jedis）&lt;/li&gt;
&lt;li&gt;提供了RedisTemplate统一API来操作Redis&lt;/li&gt;
&lt;li&gt;支持Redis的发布订阅模型&lt;/li&gt;
&lt;li&gt;支持Redis哨兵和Redis集群&lt;/li&gt;
&lt;li&gt;支持基于Lettuce的响应式编程&lt;/li&gt;
&lt;li&gt;支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化&lt;/li&gt;
&lt;li&gt;支持基于Redis的JDKCollection实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用过程&#34;&gt;使用过程
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;引入对应依赖&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&amp;lt;!--Redis依赖--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&#34;nt&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-data-redis&lt;span class=&#34;nt&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&amp;lt;!--连接池依赖--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nt&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.commons&lt;span class=&#34;nt&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nt&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;commons-pool2&lt;span class=&#34;nt&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 &lt;strong&gt;&lt;code&gt;application.yml&lt;/code&gt;&lt;/strong&gt; 的spring.data.redis的字段配置连接信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将 &lt;strong&gt;&lt;code&gt;RedisTemplate&lt;/code&gt;&lt;/strong&gt; 进行依赖注入和泛型&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;常用方法&#34;&gt;常用方法
&lt;/h3&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;&lt;strong&gt;API&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;返回值类型&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;redisTemplate&lt;/strong&gt;.opsForValue()&lt;/td&gt;
          &lt;td&gt;ValueOperations&lt;/td&gt;
          &lt;td&gt;操作String类型数据&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;redisTemplate&lt;/strong&gt;.opsForHash()&lt;/td&gt;
          &lt;td&gt;HashOperations&lt;/td&gt;
          &lt;td&gt;操作Hash类型数据&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;redisTemplate&lt;/strong&gt;.opsForList()&lt;/td&gt;
          &lt;td&gt;ListOperations&lt;/td&gt;
          &lt;td&gt;操作List类型数据&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;redisTemplate&lt;/strong&gt;.opsForSet()&lt;/td&gt;
          &lt;td&gt;SetOperations&lt;/td&gt;
          &lt;td&gt;操作Set类型数据&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;redisTemplate&lt;/strong&gt;.opsForZSet()&lt;/td&gt;
          &lt;td&gt;ZSetOperations&lt;/td&gt;
          &lt;td&gt;操作SortedSet类型数据&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;redisTemplate&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;通用的命令&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;对象序列化&#34;&gt;对象序列化
&lt;/h3&gt;&lt;p&gt;RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可读性差&lt;/li&gt;
&lt;li&gt;内存占用较大&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;自定义序列化&#34;&gt;自定义序列化
&lt;/h4&gt;&lt;p&gt;RedisTemplate可以自定义序列化方式。设置一个配置类来自定义RedisTemplate的序列方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通常对key采用string序列化&lt;/li&gt;
&lt;li&gt;对value采用json序列化&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nd&#34;&gt;@Bean&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RedisTemplate&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;redisTemplate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RedisConnectionFactory&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisConnectionFactory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;UnknownHostException&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 创建Template&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RedisTemplate&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisTemplate&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RedisTemplate&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 设置连接工厂   &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisTemplate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setConnectionFactory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisConnectionFactory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 设置序列化工具 &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GenericJackson2JsonRedisSerializer&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jsonRedisSerializer&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GenericJackson2JsonRedisSerializer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// key和 hashKey采用 string序列化   &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisTemplate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setKeySerializer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RedisSerializer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisTemplate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setHashKeySerializer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RedisSerializer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// value和 hashValue采用 JSON序列化    &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisTemplate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setValueSerializer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jsonRedisSerializer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisTemplate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setHashValueSerializer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jsonRedisSerializer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redisTemplate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;保存结果&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{&amp;#34;@class&amp;#34;:&amp;#34;org.example.redisdemo.pojo.User&amp;#34;,&amp;#34;name&amp;#34;:&amp;#34;zhangsan&amp;#34;,&amp;#34;age&amp;#34;:18,&amp;#34;id&amp;#34;:1}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;使用stringredistemplate&#34;&gt;使用StringRedisTemplate
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;使用StringRedisTemplate&lt;/li&gt;
&lt;li&gt;写入Redis时，使用 &lt;strong&gt;&lt;code&gt;ObjectMapping&lt;/code&gt;&lt;/strong&gt; 手动把对象序列化为JSON&lt;/li&gt;
&lt;li&gt;读取Redis时，&lt;strong&gt;&lt;code&gt;ObjectMapping&lt;/code&gt;&lt;/strong&gt;  手动把读取到的JSON反序列化为对象&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Redis中的Zset</title>
        <link>https://Tyritic.github.io/p/redis%E4%B8%AD%E7%9A%84zset/</link>
        <pubDate>Wed, 26 Feb 2025 19:53:16 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/redis%E4%B8%AD%E7%9A%84zset/</guid>
        <description>&lt;h2 id=&#34;zset的定义&#34;&gt;ZSet的定义
&lt;/h2&gt;&lt;p&gt;Redis的ZSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。ZSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。ZSet具备下列特性：可排序元素不重复查询速度快&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/redis%E4%B8%AD%E7%9A%84zset/zset.png&#34;
	width=&#34;1226&#34;
	height=&#34;616&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;ZSet&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;199&#34;
		data-flex-basis=&#34;477px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;常用命令&#34;&gt;常用命令
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;查看
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ZSCORE key member&lt;/code&gt;&lt;/strong&gt; ：返回有序集合key中元素member的分值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ZCARD key&lt;/code&gt;&lt;/strong&gt;  ：返回有序集合key中元素个数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ZRANGE key start stop [WITHSCORES]&lt;/code&gt;&lt;/strong&gt; ：正序获取有序集合key从start下标到stop下标的元素&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]&lt;/code&gt;&lt;/strong&gt; ：返回有序集合中指定分数区间内的成员，分数由低到高排序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ZCOUNT key min max&lt;/code&gt;&lt;/strong&gt; ：计算有序集合中指定分数区间的成员数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;加入元素
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ZADD KEY_NAME SCORE1 VALUE1.. SCOREN VALUEN&lt;/code&gt;&lt;/strong&gt; ：将一个或多个成员元素及其分数值加入到有序集当中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除元素
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ZREM key member [member ...]&lt;/code&gt;&lt;/strong&gt; ：移除有序集中的一个或多个成员，不存在的成员将被忽略。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;底层实现&#34;&gt;底层实现
&lt;/h2&gt;&lt;p&gt;Redis 中的 &lt;strong&gt;ZSet（有序集合，Sorted Set）&lt;/strong&gt; 是一种由 &lt;strong&gt;跳表（Skip List）&lt;/strong&gt; 和 &lt;strong&gt;哈希表（Hash Table）&lt;/strong&gt; 组成的数据结构。ZSet 结合了集合（Set）的特性和排序功能，能够存储具有唯一性的成员，并根据成员的分数（score）进行排序。&lt;/p&gt;
&lt;p&gt;ZSet 的实现由两个核心数据结构组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;跳表（Skip List）&lt;/strong&gt;：用于存储数据的排序和快速查找。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;哈希表（Hash Table）&lt;/strong&gt;：用于存储成员与其分数的映射，提供快速查找。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;跳表的实现原理&#34;&gt;跳表的实现原理
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/redis%E4%B8%AD%E7%9A%84zset/1719804939236-89f12a47-b851-4d06-a5f3-399e1119db57.png&#34;
	width=&#34;1164&#34;
	height=&#34;287&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;跳表原理&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;405&#34;
		data-flex-basis=&#34;973px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;跳表的查找复杂度就是 $O(logN)$。&lt;/p&gt;
&lt;p&gt;跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的 &lt;strong&gt;zskiplistLevel 结构体类型的 level 数组&lt;/strong&gt; 。&lt;/p&gt;
&lt;h4 id=&#34;数据结构&#34;&gt;数据结构
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;层：跳跃表节点的 level 数组可以包含多个元素，每个元素都包含一个指向其它节点的指针，程序可以通过这些层来加快访问其它节点的速度，一般来说，层的数量月多，访问其它节点的速度就越快。每次创建一个新的跳跃表节点的时候，程序都根据幂次定律，随机生成一个介于 1 和 32 之间的值作为 level 数组的大小，这个大小就是层的“高度”&lt;/li&gt;
&lt;li&gt;前进指针：每个层都有一个指向表尾的前进指针（&lt;code&gt;level[i].forward&lt;/code&gt; 属性），用于从表头向表尾方向访问节点。&lt;/li&gt;
&lt;li&gt;跨度：用于记录两个节点之间的距离。跨度是用来计算排位（rank）的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;查找操作&#34;&gt;查找操作
&lt;/h4&gt;&lt;p&gt;从最高层开始，逐层向下，直到找到目标元素或确定元素不存在。查找效率高，时间复杂度为 O(logn)&lt;/p&gt;
&lt;h4 id=&#34;插入操作&#34;&gt;插入操作
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;首先从最高层开始查找插入位置&lt;/li&gt;
&lt;li&gt;随机决定新节点的层数
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在相应的层中插入节点并更新指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;跳表和b树的区别&#34;&gt;跳表和B+树的区别
&lt;/h3&gt;&lt;p&gt;Redis 是内存数据库，&lt;strong&gt;跳表在实现简单性、写入性能、内存访问模式等方面的综合优势&lt;/strong&gt;，使其成为更合适的选择。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;维度&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;跳表优势&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;B+ 树劣势&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;内存访问&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;符合CPU缓存局部性，指针跳转更高效&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;节点结构复杂，缓存不友好&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;实现复杂度&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;代码简洁，无复杂平衡操作&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;节点分裂/合并逻辑复杂，代码量大&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;写入性能&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;插入/删除仅需调整局部指针&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;插入可能触发递归节点分裂，成本高&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;内存占用&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;结构紧凑，无内部碎片&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;节点预分配可能浪费内存&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Redis 选择使用跳表（Skip List）而不是 B+ 树来实现有序集合（Sorted Set）等数据结构，是经过多方面权衡后的结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;内存结构和访问模式差异&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;B+ 树的特性&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;磁盘友好&lt;/strong&gt; ：B+ 树的设计目标是优化磁盘I/O，通过减少树的高度来降低磁盘寻道次数（例如，一个3层的B+树可以管理数百万数据）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;节点填充率高&lt;/strong&gt; ：每个节点存储多个键值（Page/Block），适合批量读写。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;范围查询高效&lt;/strong&gt; ：叶子节点形成有序链表，范围查询（如 &lt;code&gt;ZRANGE&lt;/code&gt;）性能极佳。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跳表的特性&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内存友好&lt;/strong&gt; ：跳表基于链表，通过多级索引加速查询，&lt;strong&gt;内存访问模式更符合CPU缓存局部性&lt;/strong&gt;（指针跳跃更少）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简单灵活&lt;/strong&gt; ：插入/删除时仅需调整局部指针，无需复杂的节点分裂与合并。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;概率平衡&lt;/strong&gt; ：通过随机层高实现近似平衡，避免了严格的平衡约束（如红黑树的旋转）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现复杂度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;B+ 树的实现复杂度&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;节点分裂与合并&lt;/strong&gt; ：插入/删除时可能触发节点分裂或合并，需要复杂的再平衡逻辑。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;锁竞争&lt;/strong&gt; ：在并发环境下，B+ 树的锁粒度较粗（如页锁），容易成为性能瓶颈。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;跳表的实现复杂度&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;无再平衡操作&lt;/strong&gt; ：插入时只需随机生成层高，删除时直接移除节点并调整指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;细粒度锁或无锁&lt;/strong&gt; ：跳表可以通过分段锁或无锁结构（如 CAS）实现高效并发。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常见应用&#34;&gt;常见应用
&lt;/h2&gt;&lt;h3 id=&#34;实现延时队列&#34;&gt;实现延时队列
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/redis%E4%B8%AD%E7%9A%84zset/redis-54bbcc36-0b00-4142-a6eb-bf2ef48c2213.png&#34;
	width=&#34;902&#34;
	height=&#34;171&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;三分恶面渣逆袭：zset实现延时队列&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;527&#34;
		data-flex-basis=&#34;1265px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务添加到 zset 中，score 为任务的执行时间戳，value 为任务的内容。&lt;/li&gt;
&lt;li&gt;定期（例如每秒）从 zset 中获取 score 小于当前时间戳的任务，然后执行任务。&lt;/li&gt;
&lt;li&gt;任务执行后，从 zset 中删除任务。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Redis中的Set</title>
        <link>https://Tyritic.github.io/p/redis%E4%B8%AD%E7%9A%84set/</link>
        <pubDate>Wed, 26 Feb 2025 19:19:37 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/redis%E4%B8%AD%E7%9A%84set/</guid>
        <description>&lt;h2 id=&#34;set的定义&#34;&gt;set的定义
&lt;/h2&gt;&lt;p&gt;Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。&lt;img src=&#34;https://Tyritic.github.io/p/redis%E4%B8%AD%E7%9A%84set/set.png&#34;
	width=&#34;1268&#34;
	height=&#34;654&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;示意图&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;193&#34;
		data-flex-basis=&#34;465px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;set的常见命令&#34;&gt;set的常见命令
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;添加元素
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;SADD KEY_NAME VALUE1..VALUEN&lt;/code&gt;&lt;/strong&gt; ：将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略。
&lt;ul&gt;
&lt;li&gt;被添加到集合中的新元素的数量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;SMOVE SOURCE DESTINATION MEMBER&lt;/code&gt;&lt;/strong&gt;  ：将指定成员 member 元素从 source 集合移动到 destination 集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;移除元素
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;SPOP key [count]&lt;/code&gt;&lt;/strong&gt; ：移除集合中的指定 key 的一个或多个随机元素
&lt;ul&gt;
&lt;li&gt;被移除的随机元素。 当集合不存在或是空集时，返回 nil 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;SREM KEY MEMBER1..MEMBERN&lt;/code&gt;&lt;/strong&gt; ：移除集合中的一个或多个成员元素，不存在的成员元素会被忽略。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;获取元素
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;SMEMBERS key&lt;/code&gt;&lt;/strong&gt; ：返回集合中的所有成员&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;SISMEMBER KEY VALUE&lt;/code&gt;&lt;/strong&gt;  ：判断成员元素是否是集合的成员&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;集合运算
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;SDIFF FIRST_KEY OTHER_KEY1..OTHER_KEYN&lt;/code&gt;&lt;/strong&gt;  ：计算差集
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;SDIFFSTORE destination key [key ...]&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;SINTER KEY KEY1..KEYN&lt;/code&gt;&lt;/strong&gt; ：计算交集
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;SINTERSTORE destination key [key ...]&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;SUNION KEY KEY1..KEYN&lt;/code&gt;&lt;/strong&gt; ：计算并集&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;SUNIONSTORE destination key [key ...]&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;底层实现&#34;&gt;底层实现
&lt;/h2&gt;&lt;p&gt;Set 类型的底层数据结构是由&lt;strong&gt;哈希表或整数集合&lt;/strong&gt;实现的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果集合中的元素都是整数且元素个数小于 &lt;code&gt;512&lt;/code&gt; （默认值，&lt;code&gt;set-maxintset-entries&lt;/code&gt;配置）个，Redis 会使用&lt;strong&gt;整数集合&lt;/strong&gt;作为 Set 类型的底层数据结构；&lt;/li&gt;
&lt;li&gt;如果集合中的元素不满足上面条件，则 Redis 使用&lt;strong&gt;哈希表&lt;/strong&gt;作为 Set 类型的底层数据结构。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Redis中的Hash</title>
        <link>https://Tyritic.github.io/p/redis%E4%B8%AD%E7%9A%84hash/</link>
        <pubDate>Wed, 26 Feb 2025 17:00:26 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/redis%E4%B8%AD%E7%9A%84hash/</guid>
        <description>&lt;h2 id=&#34;hash的定义&#34;&gt;Hash的定义
&lt;/h2&gt;&lt;p&gt;Hash 是一个键值对（key - value）集合，其中 value 的形式如： &lt;code&gt;value=[{field1，value1}，...{fieldN，valueN}]&lt;/code&gt;。Hash 适合用于存储对象。&lt;img src=&#34;https://Tyritic.github.io/p/redis%E4%B8%AD%E7%9A%84hash/hash.png&#34;
	width=&#34;1240&#34;
	height=&#34;888&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;139&#34;
		data-flex-basis=&#34;335px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;常用命令&#34;&gt;常用命令
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;设置键值对&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;HSET KEY_NAME FIELD VALUE&lt;/code&gt;&lt;/strong&gt; ：为哈希表中的字段赋值
&lt;ul&gt;
&lt;li&gt;如果字段是哈希表中的一个新建字段，并且值设置成功，返回 1 。 如果哈希表中域字段已经存在且旧值已被新值覆盖，返回 0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;HMSET KEY_NAME FIELD1 VALUE1 ...FIELDN VALUEN&lt;/code&gt;&lt;/strong&gt; ：同时将多个 field-value (字段-值)对设置到哈希表中。
&lt;ul&gt;
&lt;li&gt;如果命令执行成功，返回 OK 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;HGET KEY_NAME FIELD_NAME&lt;/code&gt;&lt;/strong&gt;  ：返回哈希表中指定字段的值
&lt;ul&gt;
&lt;li&gt;返回给定字段的值。如果给定的字段或 key 不存在时，返回 nil 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;HKEYS key&lt;/code&gt;&lt;/strong&gt; ：获取哈希表中的所有域（field）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;HMGET KEY_NAME FIELD1...FIELDN&lt;/code&gt;&lt;/strong&gt; ：返回哈希表中，一个或多个给定字段的值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;HGETALL KEY_NAME&lt;/code&gt;&lt;/strong&gt; ：返回哈希表中，所有的字段和值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;HEXISTS KEY_NAME FIELD_NAME&lt;/code&gt;&lt;/strong&gt;  ：查看哈希表的指定字段是否存在。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;HDEL KEY_NAME FIELD1.. FIELDN&lt;/code&gt;&lt;/strong&gt;  ：删除哈希表 key 中的一个或多个指定字段，不存在的字段将被忽略。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;底层实现&#34;&gt;底层实现
&lt;/h2&gt;&lt;p&gt;Hash 类型的底层数据结构是由 &lt;strong&gt;压缩列表或哈希表&lt;/strong&gt; 实现的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果哈希类型元素个数小于 &lt;code&gt;512&lt;/code&gt; 个（默认值，可由 &lt;code&gt;hash-max-ziplist-entries&lt;/code&gt; 配置），所有值小于 &lt;code&gt;64&lt;/code&gt; 字节（默认值，可由 &lt;code&gt;hash-max-ziplist-value&lt;/code&gt; 配置）的话，Redis 会使用 &lt;strong&gt;压缩列表&lt;/strong&gt; 作为 Hash 类型的底层数据结构；&lt;/li&gt;
&lt;li&gt;如果哈希类型元素不满足上面条件，Redis 会使用 &lt;strong&gt;哈希表&lt;/strong&gt; 作为 Hash 类型的 底层数据结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后面版本使用 &lt;strong&gt;ListPack&lt;/strong&gt; 实现&lt;/p&gt;
&lt;style type=&#34;text/css&#34;&gt;
   
  .notice {
    --title-color: #fff;
    --title-background-color: #6be;
    --content-color: #444;
    --content-background-color: #e7f2fa;
  }

  .notice.info {
    --title-background-color: #fb7;
    --content-background-color: #fec;
  }

  .notice.tip {
    --title-background-color: #5a5;
    --content-background-color: #efe;
  }

  .notice.warning {
    --title-background-color: #c33;
    --content-background-color: #fee;
  }

   
  @media (prefers-color-scheme: dark) {
    .notice {
      --title-color: #fff;
      --title-background-color: #069;
      --content-color: #ddd;
      --content-background-color: #023;
    }

    .notice.info {
      --title-background-color: #a50;
      --content-background-color: #420;
    }

    .notice.tip {
      --title-background-color: #363;
      --content-background-color: #121;
    }

    .notice.warning {
      --title-background-color: #800;
      --content-background-color: #400;
    }
  }

  body.dark .notice {
    --title-color: #fff;
    --title-background-color: #069;
    --content-color: #ddd;
    --content-background-color: #023;
  }

  body.dark .notice.info {
    --title-background-color: #a50;
    --content-background-color: #420;
  }

  body.dark .notice.tip {
    --title-background-color: #363;
    --content-background-color: #121;
  }

  body.dark .notice.warning {
    --title-background-color: #800;
    --content-background-color: #400;
  }

   
  .notice {
    width: 100%;  
    max-width: 600px;  
    padding: 18px;
    line-height: 24px;
    margin-bottom: 24px;
    border-radius: 4px;
    color: var(--content-color);
    background: var(--content-background-color);
  }

  .notice p:last-child {
    margin-bottom: 0;
  }

   
  .notice-title {
    margin: -18px -18px 12px;
    padding: 4px 18px;
    border-radius: 4px 4px 0 0;
    font-weight: 700;
    color: var(--title-color);
    background: var(--title-background-color);
  }

   
  .icon-notice {
    display: inline-flex;
    align-self: center;
    margin-right: 8px;
  }

  .icon-notice img,
  .icon-notice svg {
    height: 1em;
    width: 1em;
    fill: currentColor;
  }

  .icon-notice img,
  .icon-notice.baseline svg {
    top: 0.125em;
    position: relative;
  }
&lt;/style&gt;&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;
  &lt;p&gt;ListPack 是 Redis 内部的一种数据结构，用于高效存储短小的字符串或整数集合。它是一种 &lt;strong&gt;紧凑型的序列化数据结构&lt;/strong&gt; ，旨在减少内存占用和提升性能。直接以字节序列的形式存储数据。&lt;/p&gt;
  &lt;/div&gt;

&lt;h2 id=&#34;扩容机制&#34;&gt;扩容机制
&lt;/h2&gt;&lt;p&gt;Redis的哈希扩容是渐进式的&lt;/p&gt;
&lt;p&gt;在正常服务请求阶段，插入的数据，都会写入到「哈希表 1」，此时的「哈希表 2 」 并没有被分配空间。&lt;/p&gt;
&lt;p&gt;随着数据逐步增多，触发了 rehash 操作，这个过程分为三步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将「哈希表 1 」的数据迁移到「哈希表 2」 中；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com//picgo/image-20240725232528097.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;rehash的过程&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在进行渐进式 rehash 的过程中，会有两个哈希表，所以在渐进式 rehash 进行期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。查找操作时先会在「哈希表 1」 里面进行查找，如果没找到，就会继续到哈希表 2 里面进行找到。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Redis中的List</title>
        <link>https://Tyritic.github.io/p/redis%E4%B8%AD%E7%9A%84list/</link>
        <pubDate>Wed, 26 Feb 2025 16:28:56 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/redis%E4%B8%AD%E7%9A%84list/</guid>
        <description>&lt;h2 id=&#34;list类型定义&#34;&gt;List类型定义
&lt;/h2&gt;&lt;p&gt;List 列表是简单的字符串列表，&lt;strong&gt;按照插入顺序排序&lt;/strong&gt;，可以从头部或尾部向 List 列表添加元素。&lt;/p&gt;
&lt;p&gt;列表的最大长度为 &lt;code&gt;2^32 - 1&lt;/code&gt;，也即每个列表支持超过 &lt;code&gt;40 亿&lt;/code&gt;个元素。&lt;/p&gt;
&lt;p&gt;特点与LinkedList一致&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有序&lt;/li&gt;
&lt;li&gt;元素可以重复&lt;/li&gt;
&lt;li&gt;插入和删除快&lt;/li&gt;
&lt;li&gt;查询速度一般&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常见命令&#34;&gt;常见命令
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;获取元素
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;LINDEX KEY_NAME INDEX_POSITION&lt;/code&gt;&lt;/strong&gt; ：通过索引获取列表中的元素。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;插入元素
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;LPUSH KEY_NAME VALUE1.. VALUEN&lt;/code&gt;&lt;/strong&gt; ：将一个或多个值插入到列表头部。 如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。 当 key 存在但不是列表类型时，返回一个错误。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;LPUSHX KEY_NAME VALUE1.. VALUEN&lt;/code&gt;&lt;/strong&gt; ：将一个值插入到已存在的列表头部，列表不存在时操作无效。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;LINSERT key BEFORE|AFTER pivot value&lt;/code&gt;&lt;/strong&gt; ：将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;RPUSH KEY_NAME VALUE1..VALUEN&lt;/code&gt;&lt;/strong&gt; ：将一个或多个值插入到列表的尾部(最右边)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;RPUSHX KEY_NAME VALUE1..VALUEN&lt;/code&gt;&lt;/strong&gt; ：将一个值插入到已存在的列表尾部(最右边)。如果列表不存在，操作无效&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;BRPOPLPUSH LIST1 ANOTHER_LIST TIMEOUT&lt;/code&gt;&lt;/strong&gt;  ：Redis Brpoplpush 命令从列表中取出最后一个元素，并插入到另外一个列表的头部； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除元素
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;BLPOP LIST1 LIST2 .. LISTN TIMEOUT&lt;/code&gt;&lt;/strong&gt; ：移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止
&lt;ul&gt;
&lt;li&gt;如果列表为空，返回一个 nil 。 否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;BRPOP LIST1 LIST2 .. LISTN TIMEOUT&lt;/code&gt;&lt;/strong&gt; ：移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。
&lt;ul&gt;
&lt;li&gt;假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Lpop KEY_NAME&lt;/code&gt;&lt;/strong&gt; ：移除并返回列表的第一个元素&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;RPOP KEY_NAME&lt;/code&gt;&lt;/strong&gt; ：用于移除列表的最后一个元素，返回值为移除的元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;底层实现原理&#34;&gt;底层实现原理
&lt;/h2&gt;&lt;p&gt;List 类型的底层数据结构是由 &lt;strong&gt;双向链表或压缩列表&lt;/strong&gt; 实现的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果列表的元素个数小于 &lt;code&gt;512&lt;/code&gt; 个（默认值，可由 &lt;code&gt;list-max-ziplist-entries&lt;/code&gt; 配置），列表每个元素的值都小于 &lt;code&gt;64&lt;/code&gt; 字节（默认值，可由 &lt;code&gt;list-max-ziplist-value&lt;/code&gt; 配置），Redis 会使用 &lt;strong&gt;压缩列表（ziplist）&lt;/strong&gt; 作为 List 类型的底层数据结构；&lt;/li&gt;
&lt;li&gt;如果列表的元素不满足上面的条件，Redis 会使用&lt;strong&gt;双向链表&lt;/strong&gt;作为 List 类型的底层数据结构&lt;/li&gt;
&lt;/ul&gt;
&lt;style type=&#34;text/css&#34;&gt;
   
  .notice {
    --title-color: #fff;
    --title-background-color: #6be;
    --content-color: #444;
    --content-background-color: #e7f2fa;
  }

  .notice.info {
    --title-background-color: #fb7;
    --content-background-color: #fec;
  }

  .notice.tip {
    --title-background-color: #5a5;
    --content-background-color: #efe;
  }

  .notice.warning {
    --title-background-color: #c33;
    --content-background-color: #fee;
  }

   
  @media (prefers-color-scheme: dark) {
    .notice {
      --title-color: #fff;
      --title-background-color: #069;
      --content-color: #ddd;
      --content-background-color: #023;
    }

    .notice.info {
      --title-background-color: #a50;
      --content-background-color: #420;
    }

    .notice.tip {
      --title-background-color: #363;
      --content-background-color: #121;
    }

    .notice.warning {
      --title-background-color: #800;
      --content-background-color: #400;
    }
  }

  body.dark .notice {
    --title-color: #fff;
    --title-background-color: #069;
    --content-color: #ddd;
    --content-background-color: #023;
  }

  body.dark .notice.info {
    --title-background-color: #a50;
    --content-background-color: #420;
  }

  body.dark .notice.tip {
    --title-background-color: #363;
    --content-background-color: #121;
  }

  body.dark .notice.warning {
    --title-background-color: #800;
    --content-background-color: #400;
  }

   
  .notice {
    width: 100%;  
    max-width: 600px;  
    padding: 18px;
    line-height: 24px;
    margin-bottom: 24px;
    border-radius: 4px;
    color: var(--content-color);
    background: var(--content-background-color);
  }

  .notice p:last-child {
    margin-bottom: 0;
  }

   
  .notice-title {
    margin: -18px -18px 12px;
    padding: 4px 18px;
    border-radius: 4px 4px 0 0;
    font-weight: 700;
    color: var(--title-color);
    background: var(--title-background-color);
  }

   
  .icon-notice {
    display: inline-flex;
    align-self: center;
    margin-right: 8px;
  }

  .icon-notice img,
  .icon-notice svg {
    height: 1em;
    width: 1em;
    fill: currentColor;
  }

  .icon-notice img,
  .icon-notice.baseline svg {
    top: 0.125em;
    position: relative;
  }
&lt;/style&gt;&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Ziplist&lt;/strong&gt;：压缩列表是 &lt;strong&gt;由连续内存块组成的顺序型数据结构&lt;/strong&gt; ，有点类似于数组&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：简单、紧凑、连续存储，适用于小数据量场景&lt;/li&gt;
&lt;li&gt;缺点：连锁更新的，因此 &lt;strong&gt;连锁更新一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Quicklist&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过将链表和 Ziplist 结合，既实现了链表的灵活操作，又能节省内存&lt;/li&gt;
&lt;li&gt;Quicklist 是为了替代纯链表而设计的，适用于需要频繁对列表进行插入、删除、查找等操作的场景，并且数据量可能较大。它在存储多个元素时，既保留了链表的灵活性，又具备压缩列表的内存优势。&lt;/li&gt;
&lt;li&gt;Quicklist 由 list 和 ziplist 结合而成，它是一个由 ziplist 充当节点的双向链表。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h2 id=&#34;应用场景&#34;&gt;应用场景
&lt;/h2&gt;&lt;h3 id=&#34;简单消息队列&#34;&gt;简单消息队列
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;消息保序性：使用 LPUSH + RPOP&lt;img src=&#34;https://Tyritic.github.io/p/redis%E4%B8%AD%E7%9A%84list/list%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png&#34;
	width=&#34;1642&#34;
	height=&#34;374&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;img&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;439&#34;
		data-flex-basis=&#34;1053px&#34;
	
&gt;
&lt;ul&gt;
&lt;li&gt;生产者使用 &lt;code&gt;LPUSH key value[value...]&lt;/code&gt; 将消息插入到队列的头部，如果 key 不存在则会创建一个空的队列再插入消息。&lt;/li&gt;
&lt;li&gt;消费者使用 &lt;code&gt;RPOP key&lt;/code&gt; 依次读取队列的消息，先进先出。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消息重复性：&lt;strong&gt;自行为每个消息生成一个全局唯一ID&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;消息可靠性：&lt;strong&gt;让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Redis中的String</title>
        <link>https://Tyritic.github.io/p/redis%E4%B8%AD%E7%9A%84string/</link>
        <pubDate>Wed, 26 Feb 2025 15:51:21 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/redis%E4%B8%AD%E7%9A%84string/</guid>
        <description>&lt;h2 id=&#34;string的定义&#34;&gt;String的定义
&lt;/h2&gt;&lt;p&gt;字符串是最基础的数据类型，value 可以是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符串（简单的字符串、复杂的字符串（例如 JSON、XML））&lt;/li&gt;
&lt;li&gt;数字 （整数、浮点数）&lt;/li&gt;
&lt;li&gt;是二进制（图片、音频、视频），但最大不能超过 512MB。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;string的常见命令&#34;&gt;String的常见命令
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;设置键值对&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;SET KEY_NAME VALUE&lt;/code&gt;&lt;/strong&gt; ：设置给定 key 的值。如果 key 已经存储其他值， SET 就覆写旧值，且无视类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;GETSET KEY_NAME VALUE&lt;/code&gt;&lt;/strong&gt; ：设置指定 key 的值，并返回 key 的旧值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;SETEX KEY_NAME TIMEOUT VALUE&lt;/code&gt;&lt;/strong&gt; ：为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;MSET key1 value1 key2 value2 .. keyN valueN&lt;/code&gt;&lt;/strong&gt;  :同时设置一个或多个 key-value 对&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据键查找值： &lt;strong&gt;&lt;code&gt;GET KEY_NAME&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回 key 的值，如果 key 不存在时，返回 nil。 如果 key 不是字符串类型，那么返回一个错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获取指定 key 所储存的字符串值的长度：&lt;strong&gt;&lt;code&gt;STRLEN KEY_NAME&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;string的底层实现&#34;&gt;String的底层实现
&lt;/h2&gt;&lt;p&gt;Redis 中的 String 类型底层实现主要基于 SDS（Simple Dynamic String 简单动态字符串）结构，并结合 int、embstr、raw 等不同的编码方式进行优化存储。&lt;/p&gt;
&lt;h3 id=&#34;sds的结构&#34;&gt;SDS的结构
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/redis%E4%B8%AD%E7%9A%84string/image-20240725232549832.png&#34;
	width=&#34;1470&#34;
	height=&#34;728&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;SDS数据结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;201&#34;
		data-flex-basis=&#34;484px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;en，记录了字符串长度&lt;/strong&gt;。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;alloc，分配给字符数组的空间长度&lt;/strong&gt;。这样在修改字符串的时候，可以通过 &lt;code&gt;alloc - len&lt;/code&gt; 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;flags，用来表示不同类型的 SDS&lt;/strong&gt;。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;buf[]，字符数组，用来保存实际数据&lt;/strong&gt;。不仅可以保存字符串，也可以保存二进制数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;编码方式&#34;&gt;编码方式
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;如果一个字符串对象保存的是整数值，并且这个整数值可以用&lt;code&gt;long&lt;/code&gt;类型来表示，那么字符串对象会将整数值保存在字符串对象结构的&lt;code&gt;ptr&lt;/code&gt;属性里面（将&lt;code&gt;void*&lt;/code&gt;转换成 long），并将字符串对象的编码设置为&lt;code&gt;int&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果字符串对象保存的是一个短字符串，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为&lt;code&gt;embstr&lt;/code&gt;， &lt;code&gt;embstr&lt;/code&gt;编码是专门用于保存短字符串的一种优化编码方式&lt;/li&gt;
&lt;li&gt;如果字符串对象保存的是一个长字符串，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为&lt;code&gt;raw&lt;/code&gt;：&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Redis的读写效率</title>
        <link>https://Tyritic.github.io/p/redis%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%88%E7%8E%87/</link>
        <pubDate>Mon, 24 Feb 2025 17:30:12 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/redis%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%88%E7%8E%87/</guid>
        <description>&lt;h2 id=&#34;redis性能强大的原因&#34;&gt;Redis性能强大的原因
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基于内存的数据存储&lt;/strong&gt; ：Redis 将数据存储在内存中，提供快速的读写速度，使得数据的读写操作避开了磁盘 I/O。而内存的访问速度远超硬盘。相比于传统的磁盘数据库，内存访问速度快得多。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单线程模型&lt;/strong&gt; ：Redis 使用单线程事件驱动模型，避免了多线程上下文切换和竞争条件，提高了并发处理效率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高效的数据结构&lt;/strong&gt; ：Redis 提供多种高效的数据结构（如字符串、哈希、列表、集合等），这些结构经过优化，能够快速完成各种操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IO多路复用&lt;/strong&gt; ：基于 Linux 的 select/epoll 机制。该机制允许内核中同时存在多个监听套接字和已连接套接字，内核会一直监听这些套接字上的连接请求或者数据请求，一旦有请求到达，就会交给 Redis 处理，就实现了所谓的 Redis 单个线程处理多个 IO 读写的请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;单线程模型&#34;&gt;单线程模型
&lt;/h2&gt;&lt;h3 id=&#34;使用原因&#34;&gt;使用原因
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Redis 的大部分操作&lt;strong&gt;都在内存中完成&lt;/strong&gt;，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了。&lt;/li&gt;
&lt;li&gt;Redis 采用单线程模型可以&lt;strong&gt;避免了多线程之间的竞争&lt;/strong&gt;，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;io多路复用机制&#34;&gt;IO多路复用机制
&lt;/h3&gt;&lt;p&gt;IO 多路复用机制是指一个线程处理多个 IO 流，就是 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。&lt;/p&gt;
&lt;p&gt;这里“多路”指的是多个网络连接客户端，“复用”指的是复用同一个线程(单进程)。&lt;img src=&#34;https://Tyritic.github.io/p/redis%E7%9A%84%E8%AF%BB%E5%86%99%E6%95%88%E7%8E%87/1720433058791-94f03cb5-e89c-45ed-ba34-88a0dac99d98.png&#34;
	width=&#34;1137&#34;
	height=&#34;500&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;IO多路复用&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;227&#34;
		data-flex-basis=&#34;545px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个 socket 客户端与服务端连接时，会生成对应一个套接字描述符(套接字描述符是文件描述符的一种)，每一个 socket 网络连接其实都对应一个文件描述符。&lt;/li&gt;
&lt;li&gt;多个客户端与服务端连接时，Redis 使用 I/O 多路复用程序 将客户端 socket 对应的 FD 注册到监听列表(一个队列)中。当客户端执行 read、write 等操作命令时，I/O 多路复用程序会将命令封装成一个事件，并绑定到对应的 FD 上。&lt;/li&gt;
&lt;li&gt;文件事件处理器使用 I/O 多路复用模块同时监控多个文件描述符（fd）的读写情况，当 accept、read、write 和 close 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器进行处理相关命令操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;style type=&#34;text/css&#34;&gt;
   
  .notice {
    --title-color: #fff;
    --title-background-color: #6be;
    --content-color: #444;
    --content-background-color: #e7f2fa;
  }

  .notice.info {
    --title-background-color: #fb7;
    --content-background-color: #fec;
  }

  .notice.tip {
    --title-background-color: #5a5;
    --content-background-color: #efe;
  }

  .notice.warning {
    --title-background-color: #c33;
    --content-background-color: #fee;
  }

   
  @media (prefers-color-scheme: dark) {
    .notice {
      --title-color: #fff;
      --title-background-color: #069;
      --content-color: #ddd;
      --content-background-color: #023;
    }

    .notice.info {
      --title-background-color: #a50;
      --content-background-color: #420;
    }

    .notice.tip {
      --title-background-color: #363;
      --content-background-color: #121;
    }

    .notice.warning {
      --title-background-color: #800;
      --content-background-color: #400;
    }
  }

  body.dark .notice {
    --title-color: #fff;
    --title-background-color: #069;
    --content-color: #ddd;
    --content-background-color: #023;
  }

  body.dark .notice.info {
    --title-background-color: #a50;
    --content-background-color: #420;
  }

  body.dark .notice.tip {
    --title-background-color: #363;
    --content-background-color: #121;
  }

  body.dark .notice.warning {
    --title-background-color: #800;
    --content-background-color: #400;
  }

   
  .notice {
    width: 100%;  
    max-width: 600px;  
    padding: 18px;
    line-height: 24px;
    margin-bottom: 24px;
    border-radius: 4px;
    color: var(--content-color);
    background: var(--content-background-color);
  }

  .notice p:last-child {
    margin-bottom: 0;
  }

   
  .notice-title {
    margin: -18px -18px 12px;
    padding: 4px 18px;
    border-radius: 4px 4px 0 0;
    font-weight: 700;
    color: var(--title-color);
    background: var(--title-background-color);
  }

   
  .icon-notice {
    display: inline-flex;
    align-self: center;
    margin-right: 8px;
  }

  .icon-notice img,
  .icon-notice svg {
    height: 1em;
    width: 1em;
    fill: currentColor;
  }

  .icon-notice img,
  .icon-notice.baseline svg {
    top: 0.125em;
    position: relative;
  }
&lt;/style&gt;&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;select，epoll和epoll的实现原理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;select 使用位图管理 fd，每次调用都需要将 fd 集合从用户态复制到内核态。最大支持 1024 个文件描述符。&lt;/li&gt;
&lt;li&gt;poll 使用动态数组管理 fd，突破了 select 的数量限制。&lt;/li&gt;
&lt;li&gt;epoll 使用红黑树和链表管理 fd，每次调用只需要将 fd 集合从用户态复制到内核态一次，不需要重复复制。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h3 id=&#34;多线程的引入&#34;&gt;多线程的引入
&lt;/h3&gt;&lt;p&gt;随着数据规模的增长、请求量的增多，Redis 的执行瓶颈主要在于⽹络 I/O。引入多线程处理可以提高网络 I/O处理速度。在 Redis 6.0 中，多线程主要用来处理网络 IO 操作，命令解析和执行仍然是单线程完成，这样既可以发挥多核 CPU 的优势，又能避免锁和上下文切换带来的性能损耗。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Redis基础</title>
        <link>https://Tyritic.github.io/p/redis%E5%9F%BA%E7%A1%80/</link>
        <pubDate>Mon, 24 Feb 2025 15:10:42 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/redis%E5%9F%BA%E7%A1%80/</guid>
        <description>&lt;h2 id=&#34;nosql型数据库&#34;&gt;NoSQL型数据库
&lt;/h2&gt;&lt;p&gt;NoSQL（Not Only SQL）是指一类不使用传统关系型数据库结构的数据库。NoSQL数据库通常用于大规模数据存储、处理和快速访问的场景。与关系型数据库不同，NoSQL数据库不要求数据必须存储为表格形式，也不需要固定的模式（schema）。它们通常具有更高的扩展性、灵活性和适应性。&lt;/p&gt;
&lt;h3 id=&#34;四大分类&#34;&gt;四大分类
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;键值存储（Key-Value Stores）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;数据以键值对的形式存储。&lt;/li&gt;
&lt;li&gt;适合快速访问单个值。&lt;/li&gt;
&lt;li&gt;例如：Redis、Amazon DynamoDB。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;列族存储（Column Family Stores）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;数据按列而非行来存储。&lt;/li&gt;
&lt;li&gt;高效地存储和查询大规模的、非结构化的数据。&lt;/li&gt;
&lt;li&gt;例如：Apache Cassandra、HBase。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文档存储（Document Stores）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;存储类似JSON、BSON或XML的文档数据，文档中可以包含嵌套的数据。&lt;/li&gt;
&lt;li&gt;适合存储和查询灵活的、层次化的数据。&lt;/li&gt;
&lt;li&gt;例如：MongoDB、CouchDB。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图数据库（Graph Databases）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;以图形结构（节点、边和属性）存储数据，用于表示实体之间的关系。&lt;/li&gt;
&lt;li&gt;适合复杂的关系型数据查询。&lt;/li&gt;
&lt;li&gt;例如：Neo4j、ArangoDB。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;与sql数据库的对比&#34;&gt;与SQL数据库的对比
&lt;/h3&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;SQL&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;NoSQL&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;数据结构&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;结构化&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;非结构化&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;数据关联&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;不同数据之间具有关联性&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;无关联性&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;查询方式&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;SQL标准&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;无标准&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;事务特性&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;ACID&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;BASE&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;存储方式&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;磁盘&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;内盘&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;拓展性&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;垂直&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;水平&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;使用场景&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;数据结构固定&lt;br&gt;相关业务对数据安全性，一致性要求较高&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;数据结构不固定&lt;br/&gt;对一致性、安全性要求不高&lt;br/&gt;对性能要求&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;redis缓存中间件&#34;&gt;Redis缓存中间件
&lt;/h2&gt;&lt;p&gt;Redis（Remote Dictionary Server）是一个开源的内存数据库，遵守 BSD 协议，它提供了一个高性能的键值（key-value）存储系统，常用于缓存、消息队列、会话存储等应用场景。&lt;/p&gt;
&lt;h3 id=&#34;基本特点&#34;&gt;基本特点
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;性能极高：&lt;/strong&gt; Redis 以其极高的性能而著称，能够支持每秒数十万次的读写操作24。这使得Redis成为处理高并发请求的理想选择，尤其是在需要快速响应的场景中，如缓存、会话管理、排行榜等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;丰富的数据类型：&lt;/strong&gt; Redis 不仅支持基本的键值存储，还提供了丰富的数据类型，包括字符串、列表、集合、哈希表、有序集合等。这些数据类型为开发者提供了灵活的数据操作能力，使得Redis可以适应各种不同的应用场景。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原子性操作：&lt;/strong&gt; Redis 的所有操作都是原子性的，这意味着操作要么完全执行，要么完全不执行。这种特性对于确保数据的一致性和完整性至关重要，尤其是在高并发环境下处理事务时。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持久化：&lt;/strong&gt; Redis 支持数据的持久化，可以将内存中的数据保存到磁盘中，以便在系统重启后恢复数据。这为 Redis 提供了数据安全性，确保数据不会因为系统故障而丢失。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持发布/订阅模式：&lt;/strong&gt; Redis 内置了发布/订阅模式（Pub/Sub），允许客户端之间通过消息传递进行通信。这使得 Redis 可以作为消息队列和实时数据传输的平台。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单线程模型：&lt;/strong&gt; 尽管 Redis 是单线程的，但它通过高效的事件驱动模型来处理并发请求，确保了高性能和低延迟。单线程模型也简化了并发控制的复杂性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主从复制：&lt;/strong&gt; Redis 支持主从复制，可以通过从节点来备份数据或分担读请求，提高数据的可用性和系统的伸缩性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用场景&#34;&gt;使用场景
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;缓存&lt;/strong&gt; ：Redis 最常用的场景是作为缓存层，以减少数据库的负载，提高数据读取速度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为 Redis 是基于内存的，其读写速度比 MySQL 基于磁盘的方式要快很多，所以其作为热点数据的缓存是非常合适的。使用 Redis 缓存可以极大地提高应用的响应速度和吞吐量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;实时系统&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis 支持快速的数据写入和读取，非常适合用于实时分析，如网站点击统计、实时排行榜等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;消息队列&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用 Redis 的 List 和 Pub/Sub 功能，可以实现轻量级的消息队列，适用于任务处理和异步消息传递。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分布式锁&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis 可以用作分布式锁的实现，确保在分布式系统中资源的安全访问，避免竞态条件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;计数器&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis 的原子性操作非常适合用作计数器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis的服务端命令&#34;&gt;Redis的服务端命令
&lt;/h2&gt;&lt;p&gt;进入redis的安装根目录的命令行可以启动redis服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启动临时redis服务（不会在window Service列表出现Redis服务名称和状态，此窗口关闭，服务会自动关闭。）：&lt;strong&gt;&lt;code&gt;redis-server.exe redis.windows.conf&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;注册redis服务：&lt;strong&gt;&lt;code&gt;redis-server.exe --service-install redis.windows.conf --service-name redisserver1 --loglevel verbose&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;启动服务：&lt;strong&gt;&lt;code&gt;redis-server.exe  --service-start --service-name redisserver1&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;停止服务：&lt;strong&gt;&lt;code&gt;redis-server.exe  --service-stop --service-name redisserver1&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;卸载服务：&lt;strong&gt;&lt;code&gt;redis-server.exe  --service-uninstall--service-name redisserver1&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以在主机中配置多个端口的redis服务，参见&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/yqwang75457/article/details/83412614&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;博客&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;redis的客户端命令&#34;&gt;Redis的客户端命令
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;redis&lt;/code&gt;&lt;/strong&gt; 在安装后就自带命令行客户端 &lt;strong&gt;&lt;code&gt;redis-cli&lt;/code&gt;&lt;/strong&gt; ，客户端的通用命令格式为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;redis&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cli&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;option&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;commands&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;常见的option如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;-h ip_address&lt;/code&gt;&lt;/strong&gt; ：指定要连接的redis节点的IP地址，默认是127.0.0.1（回环地址，表示访问本机）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;-p port&lt;/code&gt;&lt;/strong&gt;：指定要连接的redis节点的端口，默认是6379&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;-a password&lt;/code&gt;&lt;/strong&gt; ：指定redis的访问密码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;commands是redis的操作命令&lt;/p&gt;
&lt;h2 id=&#34;redis的基本数据结构&#34;&gt;Redis的基本数据结构
&lt;/h2&gt;&lt;p&gt;Redis 提供了丰富的数据类型。&lt;/p&gt;
&lt;p&gt;基本的有五种数据类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;String（字符串）&lt;/strong&gt; ：Redis中最基本的数据类型，可以存储任何类型的数据，包括文本、数字和二进制数据。它的最大长度为512MB。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;缓存&lt;/strong&gt;：存储临时数据，如用户会话、页面缓存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;计数器&lt;/strong&gt;：用于统计访问量、点赞数等，通过原子操作增加或减少。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hash（哈希）&lt;/strong&gt; ：哈希是一个键值对集合，适合存储对象的属性。Redis内部使用哈希表实现，适合小规模数据。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;商品详情&lt;/strong&gt;：存储商品的各个属性，方便快速检索。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;List（列表）&lt;/strong&gt; ：列表是有序的字符串集合，支持从两端推入和弹出元素，底层实现为双向链表。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;消息队列&lt;/strong&gt;：用于简单任务调度、消息传递等场景，通过&lt;code&gt;LPUSH&lt;/code&gt;和&lt;code&gt;RPOP&lt;/code&gt;操作实现生产者消费者模式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;历史记录&lt;/strong&gt;：存储用户操作的历史记录，便于快速访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Set（集合）&lt;/strong&gt; ：集合是无序且不重复的字符串集合，使用哈希表实现，支持快速查找和去重操作。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;标签系统&lt;/strong&gt;：存储用户的兴趣标签，避免重复。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;唯一用户集合&lt;/strong&gt;：记录访问过某个页面的唯一用户，方便进行分析。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Zset（有序集合）&lt;/strong&gt; ：有序集合类似于集合，但每个元素都有一个分数（score），用于排序。底层使用跳表实现，支持快速的范围查询。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;排行榜&lt;/strong&gt;：存储用户分数，实现实时排行榜。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;任务调度&lt;/strong&gt;：根据任务的优先级进行排序，方便调度执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后面又支持了四种数据类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;BitMap&lt;/strong&gt; ：BitMap 是一种以位为单位存储数据的高效方式，适合用来表示布尔值（如存在性、状态等）。每个 bit 可以表示一个状态（0 或 1），使用空间少且操作快速。
&lt;ul&gt;
&lt;li&gt;统计每天用户的在线状态，可以用 Bitmap 记录每个用户是否在线：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HyperLogLog&lt;/strong&gt; ：HyperLogLog 是一种概率性数据结构，主要用于估算基数（不同元素的数量），内存占用固定，适合处理大规模数据的去重和计数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GEO&lt;/strong&gt; ：GEO 是 Redis 提供的一种用于存储地理位置信息的数据结构，可以存储经纬度信息并支持空间查询，例如计算距离和获取范围内的坐标。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Stream&lt;/strong&gt; ：Stream 是 Redis 提供的一种日志数据结构，适合于存储时间序列数据或消息流。支持高效的消息生产和消费模式，具有持久性和序列化特性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis的通用命令&#34;&gt;Redis的通用命令
&lt;/h2&gt;&lt;h3 id=&#34;keys命令&#34;&gt;Keys命令
&lt;/h3&gt;&lt;p&gt;Redis 键命令用于管理 redis 的键。&lt;/p&gt;
&lt;h4 id=&#34;基本格式&#34;&gt;基本格式
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;redis 127.0.0.1:6379&amp;gt; COMMAND KEY_NAME
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;常见操作&#34;&gt;常见操作
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;删除键
&lt;ul&gt;
&lt;li&gt;删除已存在的键：&lt;strong&gt;&lt;code&gt;DEL KEY_NAME&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;返回值：被删除 key 的数量。&lt;/li&gt;
&lt;li&gt;不存在的 key 会被忽略&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;查找键
&lt;ul&gt;
&lt;li&gt;检查键是否存在：&lt;strong&gt;&lt;code&gt;EXISTS KEY_NAME&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;返回值：若 key 存在返回 1 ，否则返回 0 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;查找符合格式的键：&lt;strong&gt;&lt;code&gt;KEYS PATTERN&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;返回值：符合给定模式的 key 列表 (Array)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;查看键的过期时间：&lt;strong&gt;&lt;code&gt;TTL KEY_NAME&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;返回值：当 key 不存在时，返回 -2 。 当 key 存在但没有设置剩余生存时间时，返回 -1 。 否则，以秒为单位，返回 key 的剩余生存时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设置键
&lt;ul&gt;
&lt;li&gt;设置键的过期时间：&lt;strong&gt;&lt;code&gt;Expire KEY_NAME TIME_IN_SECONDS&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;返回值：设置成功返回 1 。 当 key 不存在返回 0 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;移除键的过期时间：&lt;strong&gt;&lt;code&gt;PERSIST KEY_NAME&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;返回值：当过期时间移除成功时，返回 1 。 如果 key 不存在或 key 没有设置过期时间，返回 0 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将当前数据库的 key 移动到给定的数据库 db 当中：&lt;strong&gt;&lt;code&gt;MOVE KEY_NAME DESTINATION_DATABASE&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;返回值：移动成功返回 1 ，失败则返回 0 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将键重新命名：&lt;strong&gt;&lt;code&gt;RENAME OLD_KEY_NAME NEW_KEY_NAME&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;返回值
&lt;ul&gt;
&lt;li&gt;改名成功时提示 OK&lt;/li&gt;
&lt;li&gt;失败时候返回一个错误。当 OLD_KEY_NAME 和 NEW_KEY_NAME 相同，或者 OLD_KEY_NAME 不存在时，返回一个错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;style type=&#34;text/css&#34;&gt;
   
  .notice {
    --title-color: #fff;
    --title-background-color: #6be;
    --content-color: #444;
    --content-background-color: #e7f2fa;
  }

  .notice.info {
    --title-background-color: #fb7;
    --content-background-color: #fec;
  }

  .notice.tip {
    --title-background-color: #5a5;
    --content-background-color: #efe;
  }

  .notice.warning {
    --title-background-color: #c33;
    --content-background-color: #fee;
  }

   
  @media (prefers-color-scheme: dark) {
    .notice {
      --title-color: #fff;
      --title-background-color: #069;
      --content-color: #ddd;
      --content-background-color: #023;
    }

    .notice.info {
      --title-background-color: #a50;
      --content-background-color: #420;
    }

    .notice.tip {
      --title-background-color: #363;
      --content-background-color: #121;
    }

    .notice.warning {
      --title-background-color: #800;
      --content-background-color: #400;
    }
  }

  body.dark .notice {
    --title-color: #fff;
    --title-background-color: #069;
    --content-color: #ddd;
    --content-background-color: #023;
  }

  body.dark .notice.info {
    --title-background-color: #a50;
    --content-background-color: #420;
  }

  body.dark .notice.tip {
    --title-background-color: #363;
    --content-background-color: #121;
  }

  body.dark .notice.warning {
    --title-background-color: #800;
    --content-background-color: #400;
  }

   
  .notice {
    width: 100%;  
    max-width: 600px;  
    padding: 18px;
    line-height: 24px;
    margin-bottom: 24px;
    border-radius: 4px;
    color: var(--content-color);
    background: var(--content-background-color);
  }

  .notice p:last-child {
    margin-bottom: 0;
  }

   
  .notice-title {
    margin: -18px -18px 12px;
    padding: 4px 18px;
    border-radius: 4px 4px 0 0;
    font-weight: 700;
    color: var(--title-color);
    background: var(--title-background-color);
  }

   
  .icon-notice {
    display: inline-flex;
    align-self: center;
    margin-right: 8px;
  }

  .icon-notice img,
  .icon-notice svg {
    height: 1em;
    width: 1em;
    fill: currentColor;
  }

  .icon-notice img,
  .icon-notice.baseline svg {
    top: 0.125em;
    position: relative;
  }
&lt;/style&gt;&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;Key的层级结构&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;Redis&lt;/strong&gt; 中，&lt;strong&gt;Key 的层级格式&lt;/strong&gt; 其实是&lt;strong&gt;一种命名约定&lt;/strong&gt;，并没有真正的“层级”结构（不像关系型数据库中的表或目录结构）。&lt;/p&gt;
&lt;p&gt;通常使用 &lt;code&gt;:&lt;/code&gt; 分隔层级&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;namespace:object_type:id:field
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&#34;数据库命令&#34;&gt;数据库命令
&lt;/h3&gt;&lt;p&gt;Redis默认有16个数据库，默认使用编号为0的数据库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;切换数据库：&lt;strong&gt;&lt;code&gt;select db_num&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;查看当前数据库key的数量：&lt;strong&gt;&lt;code&gt;DBSIZE&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;清除当前数据库：&lt;strong&gt;&lt;code&gt;flushdb&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;清除所有数据库：&lt;strong&gt;&lt;code&gt;flushall&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
