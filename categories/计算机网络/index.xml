<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>计算机网络 on Tyritic</title>
        <link>https://Tyritic.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
        <description>Recent content in 计算机网络 on Tyritic</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Tyritic</copyright><atom:link href="https://Tyritic.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>网络层协议</title>
        <link>https://Tyritic.github.io/p/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/</link>
        <pubDate>Tue, 25 Feb 2025 19:32:28 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/</guid>
        <description>&lt;h2 id=&#34;网际协议-ip地址&#34;&gt;网际协议-IP地址
&lt;/h2&gt;&lt;h3 id=&#34;作用&#34;&gt;作用
&lt;/h3&gt;&lt;h4 id=&#34;在tcpip参考模型的作用&#34;&gt;在TCP/IP参考模型的作用
&lt;/h4&gt;&lt;p&gt;IP协议 在 TCP/IP 参考模型中处于第三层，也就是&lt;strong&gt;网络层&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;网络层的主要作用是：&lt;strong&gt;实现主机与主机之间的通信，也叫点对点（end to end）通信。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;寻址&lt;/strong&gt; ：每个连接到网络的设备都有一个唯一的 IP 地址。IP 协议使用这些地址来标识数据包的源地址和目的地址，确保数据包能够准确地传输到目标设备。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路由&lt;/strong&gt; ：IP 协议负责决定数据包在网络传输中的路径。比如说路由器使用路由表和 IP 地址信息来确定数据包的最佳传输路径。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分片和重组&lt;/strong&gt; ：当数据包过大无法在某个网络上传输时，IP 协议会将数据包分成更小的片段进行传输。接收端会根据头部信息将这些片段重新组装成完整的数据包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;与数据链路层的关系&#34;&gt;与数据链路层的关系
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;MAC 的作用则是实现&lt;strong&gt;直连&lt;/strong&gt;的两个设备之间通信&lt;/li&gt;
&lt;li&gt;IP 则负责在&lt;strong&gt;没有直连&lt;/strong&gt;的两个网络之间进行通信传输。&lt;/li&gt;
&lt;/ul&gt;
&lt;style type=&#34;text/css&#34;&gt;
   
  .notice {
    --title-color: #fff;
    --title-background-color: #6be;
    --content-color: #444;
    --content-background-color: #e7f2fa;
  }

  .notice.info {
    --title-background-color: #fb7;
    --content-background-color: #fec;
  }

  .notice.tip {
    --title-background-color: #5a5;
    --content-background-color: #efe;
  }

  .notice.warning {
    --title-background-color: #c33;
    --content-background-color: #fee;
  }

   
  @media (prefers-color-scheme: dark) {
    .notice {
      --title-color: #fff;
      --title-background-color: #069;
      --content-color: #ddd;
      --content-background-color: #023;
    }

    .notice.info {
      --title-background-color: #a50;
      --content-background-color: #420;
    }

    .notice.tip {
      --title-background-color: #363;
      --content-background-color: #121;
    }

    .notice.warning {
      --title-background-color: #800;
      --content-background-color: #400;
    }
  }

  body.dark .notice {
    --title-color: #fff;
    --title-background-color: #069;
    --content-color: #ddd;
    --content-background-color: #023;
  }

  body.dark .notice.info {
    --title-background-color: #a50;
    --content-background-color: #420;
  }

  body.dark .notice.tip {
    --title-background-color: #363;
    --content-background-color: #121;
  }

  body.dark .notice.warning {
    --title-background-color: #800;
    --content-background-color: #400;
  }

   
  .notice {
    width: 100%;  
    max-width: 600px;  
    padding: 18px;
    line-height: 24px;
    margin-bottom: 24px;
    border-radius: 4px;
    color: var(--content-color);
    background: var(--content-background-color);
  }

  .notice p:last-child {
    margin-bottom: 0;
  }

   
  .notice-title {
    margin: -18px -18px 12px;
    padding: 4px 18px;
    border-radius: 4px 4px 0 0;
    font-weight: 700;
    color: var(--title-color);
    background: var(--title-background-color);
  }

   
  .icon-notice {
    display: inline-flex;
    align-self: center;
    margin-right: 8px;
  }

  .icon-notice img,
  .icon-notice svg {
    height: 1em;
    width: 1em;
    fill: currentColor;
  }

  .icon-notice img,
  .icon-notice.baseline svg {
    top: 0.125em;
    position: relative;
  }
&lt;/style&gt;&lt;div
  class=&#34;notice ip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      
    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;MAC地址&lt;/p&gt;
&lt;p&gt;MAC称为物理地址，也叫硬件地址，用来定义网络设备的位置，MAC地址是网卡出厂时设定的，是固定的（但可以通过在设备管理器中或注册表等方式修改，同一网段内的MAC地址必须唯一）。&lt;/p&gt;
&lt;p&gt;MAC地址采用十六进制数表示，长度是6个字节（48位），分为前24位和后24位。&lt;/p&gt;&lt;/div&gt;

&lt;h3 id=&#34;ip数据报&#34;&gt;IP数据报
&lt;/h3&gt;&lt;h4 id=&#34;ipv4报文格式&#34;&gt;IPV4报文格式
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/7f3a337b8d87d12aed267798c2552c7f.png&#34;
	width=&#34;814&#34;
	height=&#34;440&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;IP数据报格式&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;185&#34;
		data-flex-basis=&#34;444px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首部
&lt;ul&gt;
&lt;li&gt;版本号：指定IP协议版本&lt;/li&gt;
&lt;li&gt;首部长度：确定IP数据报中的载荷的实际开始位置&lt;/li&gt;
&lt;li&gt;服务类型：指定不同类型的IP数据报&lt;/li&gt;
&lt;li&gt;数据报长度&lt;/li&gt;
&lt;li&gt;标识：用于分片后重新组装数据报&lt;/li&gt;
&lt;li&gt;标志：决定是否进行分片&lt;/li&gt;
&lt;li&gt;片偏移：较长的IP报文在分片后，某片在原分组中的相对位置&lt;/li&gt;
&lt;li&gt;生存时间（TTL）：数据报在网络中的寿命。&lt;/li&gt;
&lt;li&gt;协议：占8位，协议字段指出此数据报携带的数据是使用何种协议&lt;/li&gt;
&lt;li&gt;首部检验和：帮助路由器检测收到的IP数据报中的比特错误&lt;/li&gt;
&lt;li&gt;源IP地址&lt;/li&gt;
&lt;li&gt;目的IP地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;载荷&lt;/li&gt;
&lt;/ul&gt;
&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;IPV6的改进&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;取消了首部校验和字段。&lt;/strong&gt; 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;取消了分片/重新组装相关字段。&lt;/strong&gt; 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;取消选项字段。&lt;/strong&gt; 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 &lt;code&gt;40&lt;/code&gt; 字节。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h4 id=&#34;数据报分片&#34;&gt;数据报分片
&lt;/h4&gt;&lt;p&gt;通常将链路层帧可以承载的最大数据量称为MTU。当IP数据报长度大于MTU会进行数据报分片，并使用单独的链路层帧进行封装。然后端系统接收后会进行重新组装&lt;/p&gt;
&lt;h3 id=&#34;ip地址&#34;&gt;IP地址
&lt;/h3&gt;&lt;p&gt;在 TCP/IP 网络通信时，为了保证能正常通信，每个设备都需要配置正确的 IP 地址，否则无法实现正常的通信。&lt;/p&gt;
&lt;p&gt;IP 地址（IPv4 地址）由 &lt;code&gt;32&lt;/code&gt; 位正整数来表示，IP 地址在计算机是以二进制的方式处理的。&lt;/p&gt;
&lt;h4 id=&#34;ip地址的分类&#34;&gt;IP地址的分类
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/7.jpg&#34;
	width=&#34;813&#34;
	height=&#34;759&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;IP 地址分类&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;107&#34;
		data-flex-basis=&#34;257px&#34;
	
&gt;
&lt;/p&gt;
$$
最大主机数=2^{主机号}-2
$$&lt;p&gt;
其中要去除两个特殊的IP地址，主机号全为 1 和 全为 0 地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/10.jpg&#34;
	width=&#34;963&#34;
	height=&#34;485&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;特殊IP地址&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;198&#34;
		data-flex-basis=&#34;476px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主机号全为 1 指定某个网络下的所有主机，用于广播
&lt;ul&gt;
&lt;li&gt;广播地址用于在 &lt;strong&gt;同一个链路中相互连接的主机之间发送数据包&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主机号全为 0 指定某个网络&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;无分类ip地址cidr&#34;&gt;无分类IP地址CIDR
&lt;/h4&gt;&lt;p&gt;IP地址由 &lt;strong&gt;网络号和主机号&lt;/strong&gt; 构成&lt;/p&gt;
&lt;p&gt;表示形式 &lt;code&gt;a.b.c.d/x&lt;/code&gt;，其中 &lt;code&gt;/x&lt;/code&gt; 表示前 x 位属于&lt;strong&gt;网络号&lt;/strong&gt;， x 的范围是 &lt;code&gt;0 ~ 32&lt;/code&gt;，&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/15.jpg&#34;
	width=&#34;648&#34;
	height=&#34;837&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;CIDR地址&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;77&#34;
		data-flex-basis=&#34;185px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;子网掩码用于指示IP地址的网络部分。&lt;strong&gt;将子网掩码和 IP 地址按位计算 AND，就可得到网络号。&lt;/strong&gt; 两台主机要通信，首先要判断是否处于同一网段，即网络地址是否相同。&lt;/p&gt;
&lt;p&gt;如果相同，那么可以把数据包直接发送到目标主机，否则就需要路由网关将数据包转发送到目的地。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/16.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;子网掩码&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;子网划分&#34;&gt;子网划分
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;子网划分实际上是将主机号分为两个部分：子网号和子网主机号&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/19.jpg&#34;
	width=&#34;804&#34;
	height=&#34;393&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;子网划分&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;204&#34;
		data-flex-basis=&#34;490px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;ip协议的相关应用&#34;&gt;IP协议的相关应用
&lt;/h2&gt;&lt;h3 id=&#34;arp协议&#34;&gt;ARP协议
&lt;/h3&gt;&lt;h4 id=&#34;作用-1&#34;&gt;作用
&lt;/h4&gt;&lt;p&gt;将 IP 地址转换为 MAC 地址，它工作在 &lt;strong&gt;网络层&lt;/strong&gt; 和 &lt;strong&gt;数据链路层&lt;/strong&gt; 之间，主要用于在局域网中确定一个特定 IP 地址对应的物理地址（MAC 地址）。因为最终需要找到 MAC 地址才能跟具体的设备通信。&lt;/p&gt;
&lt;h4 id=&#34;工作流程&#34;&gt;工作流程
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ARP 请求&lt;/strong&gt;：主机 A 需要发送数据包给主机 B，但只有主机 B 的 IP 地址，没有它的 MAC 地址。主机 A 发送一个 ARP 请求广播到网络。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ARP 响应&lt;/strong&gt;：当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，回复一个 ARP 响应，告知主机 A 自己的 MAC 地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更新 ARP 表&lt;/strong&gt;：主机 A 将主机 B 的 IP 和 MAC 地址的映射关系保存到 ARP 表中，以便以后使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dhcp协议&#34;&gt;DHCP协议
&lt;/h3&gt;&lt;p&gt;DHCP全称为动态主机配置协议，通过配置DHCP协议保证给定主机每次连接得到相同的IP地址或者分配到临时的IP地址&lt;/p&gt;
&lt;h4 id=&#34;工作流程-1&#34;&gt;工作流程
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DHCP服务器发现&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;客户端首先发起 &lt;strong&gt;DHCP 发现报文（DHCP DISCOVER）&lt;/strong&gt; 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP &lt;strong&gt;广播&lt;/strong&gt; 通信，其使用的广播目的地址是 255.255.255.255（端口 67） 并且使用 0.0.0.0（端口 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DHCP服务器提供&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;DHCP 服务器收到 DHCP 发现报文时，用 &lt;strong&gt;DHCP 提供报文（DHCP OFFER）&lt;/strong&gt; 向客户端做出响应。该报文仍然使用 IP 广播地址 255.255.255.255，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 &lt;strong&gt;IP 地址租用期&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DHCP请求&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 &lt;strong&gt;DHCP 请求报文（DHCP REQUEST&lt;/strong&gt; 进行响应，回显配置的参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DHCP ACK&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;服务端用 &lt;em&gt;DHCP ACK 报文&lt;/em&gt;对 DHCP 请求报文进行响应，应答所要求的参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;再次租用&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP 请求报文：
&lt;ul&gt;
&lt;li&gt;服务器如果同意继续租用，则用 DHCP ACK 报文进行应答，客户端就会延长租期。&lt;/li&gt;
&lt;li&gt;服务器如果不同意继续租用，则用 DHCP NACK 报文，客户端就要停止使用租约的 IP 地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;nat协议&#34;&gt;NAT协议
&lt;/h3&gt;&lt;p&gt;网络地址转换协议，将私有IP地址转换为公有IP地址&lt;/p&gt;
&lt;p&gt;NAT将IP地址和端口号一起转换，保证所有离开专有网络的设备具有相同的源IP地址，所有进入专有网络的报文具有相同的目的IP地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/39.jpg&#34;
	width=&#34;1541&#34;
	height=&#34;834&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;NAPT&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;184&#34;
		data-flex-basis=&#34;443px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两个私有 IP 地址都被路由器转换 IP 地址为公有地址 120.229.175.121，但是以不同的端口号作为区分。&lt;/strong&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>传输层协议</title>
        <link>https://Tyritic.github.io/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/</link>
        <pubDate>Wed, 12 Jun 2024 20:58:45 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/</guid>
        <description>&lt;h2 id=&#34;传输层的作用&#34;&gt;传输层的作用
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;主要职责&lt;/strong&gt; ：负责不同主机的进程间通信&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;拥塞控制&lt;/strong&gt; ：防止&lt;strong&gt;整个网络&lt;/strong&gt;因负载过大而崩溃&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流量控制&lt;/strong&gt; ：协调发送速率和接受速率&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提供端到端服务&lt;/strong&gt; ：不同主机之间的进程通信&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常见协议&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;TCP&lt;/strong&gt; ：面向连接的可靠传输服务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UDP&lt;/strong&gt; ：非面向连接的不可靠传输服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多路复用和多路分解&#34;&gt;多路复用和多路分解
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多路分解&lt;/strong&gt; ：在接收端，传输层检测报文的字段，识别出接受端的socket，进而将报文段定向并正确交付到对应的socket中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多路复用&lt;/strong&gt; ：源主机从不同的socket收集数据块，并将数据报封装首部信息，从而生成报文段。然后将报文段交付到网络层&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;无连接的多路复用和多路分解&#34;&gt;无连接的多路复用和多路分解
&lt;/h3&gt;&lt;p&gt;通过UDP套接字分配特定端口&lt;/p&gt;
&lt;p&gt;UDP套接字的格式（目的IP，目的端口号）&lt;/p&gt;
&lt;h3 id=&#34;有连接的多路复用和多路分解&#34;&gt;有连接的多路复用和多路分解
&lt;/h3&gt;&lt;p&gt;通过TCP套接字分配端口&lt;/p&gt;
&lt;p&gt;TCP套接字的格式（源IP，源端口号，目的IP，目的端口号）&lt;/p&gt;
&lt;h2 id=&#34;面向连接的可靠传输tcp协议&#34;&gt;面向连接的可靠传输—TCP协议
&lt;/h2&gt;&lt;p&gt;TCP是一个传输层协议，提供可靠传输，支持全双工，是一个连接导向的协议。数据任何时候都可以双向传输。&lt;/p&gt;
&lt;h3 id=&#34;tcp的主要特点&#34;&gt;TCP的主要特点
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;面向连接&lt;/strong&gt; ：双方传输数据之前，必须先建立一条通道&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可靠传输&lt;/strong&gt; ：TCP提供可靠的传输服务。传送的数据无差错、不丢失、不重复、按序到达，通过确认（ACK）、重传机制以及序列号，TCP 能够保证数据在不可靠的 IP 网络上可靠传输。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;面向字节流&lt;/strong&gt; ：虽然应用程序与TCP交互是一次一个大小不等的数据块，但TCP把这些数据看成一连串无结构的字节流，它不保证接收方收到的数据块和发送方发送的数据块具有对应大小关系，&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;差错检测&lt;/strong&gt; ：发现差错会重发报文段&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拥塞控制&lt;/strong&gt; ：TCP 通过拥塞避免算法（如慢启动、拥塞避免、快速重传和快速恢复）来防止网络过载，协调整个网络的流量，使得每条TCP连接共享带宽&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流量控制&lt;/strong&gt; ：TCP 通过滑动窗口机制调节发送方的数据发送速率，防止接收方因为处理能力有限而被数据流淹没。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp报文格式&#34;&gt;TCP报文格式
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/format,png-20230309230534096.png&#34;
	width=&#34;1053&#34;
	height=&#34;828&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;TCP 头格式&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;127&#34;
		data-flex-basis=&#34;305px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;报文段 = 首部 + 数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;首部&lt;/strong&gt; ：最小长度 &lt;strong&gt;20&lt;/strong&gt; 字节&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;源端口号和目的端口号&lt;/strong&gt; ：对应用层数据进行多路复用和多路分解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;序列号 &lt;code&gt;seq&lt;/code&gt;&lt;/strong&gt; ：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就累加一次该「数据字节数」的大小。&lt;strong&gt;用来解决网络包乱序问题。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;确认号 &lt;code&gt;ack&lt;/code&gt;&lt;/strong&gt; ：指下一次期望收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。&lt;strong&gt;用来解决丢包的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;控制位&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;ACK&lt;/em&gt;：该位为 1 时，确认应答的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;RST&lt;/em&gt;：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;端口未监听&lt;/strong&gt;：当主机接收到一个发往没有在监听的端口的 TCP 数据包时，会回复一个 &lt;code&gt;RST&lt;/code&gt; 报文来告知发送方该端口不可用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连接异常关闭后&lt;/strong&gt;：如果一方出现崩溃、强制退出或被其他因素干扰导致连接中断，TCP 会使用 &lt;code&gt;RST&lt;/code&gt; 报文来通知对方连接已无法继续。（例如服务端断电重启后，客户端再次通过之前的连接请求，就会被返回一个 &lt;code&gt;RST&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据包冲突&lt;/strong&gt;：当某一方接收到的序列号不在预期范围内时，可能会发送 &lt;code&gt;RST&lt;/code&gt; 报文以重置连接。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重置无效的连接请求&lt;/strong&gt;：当主机收到与当前连接状态不符的请求时，例如在未建立连接时收到 &lt;code&gt;FIN&lt;/code&gt; 报文，会发送 &lt;code&gt;RST&lt;/code&gt; 报文表示无效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;SYN&lt;/em&gt;：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;FIN&lt;/em&gt;：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;窗口&lt;/strong&gt;：滑动窗口大小，用来告知发送端接收端缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;校验和&lt;/strong&gt;：奇偶校验，此校验和是对整个的TCP报文段（包括TCP头部和TCP数据），以16位进行计算所得，由发送端计算和存储，接收端进行验证。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp粘包拆包&#34;&gt;TCP粘包，拆包
&lt;/h3&gt;&lt;h4 id=&#34;现象描述&#34;&gt;现象描述
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;粘包&lt;/strong&gt; ：在 TCP 传输中，发送方的多个数据包在接收方被合并成一个包接收，导致多条消息数据粘在一起，接收方无法正确区分这些消息的边界。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拆包&lt;/strong&gt; ：发送方的一个数据包在接收方被分成了多个包接收，导致一条完整的消息被拆成多个部分，接收方无法一次性接收到完整的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;出现原因&#34;&gt;出现原因
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;粘包&lt;/strong&gt; ：TCP是面向字节流的协议，把上层应用层的数据看成字节流，所以它发送的不是固定大小的数据包，TCP协议也没有字段说明发送数据包的大小。数据在发送方可能被一次性发送，接收方在读取时可能会将多个消息拼接在一起。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拆包&lt;/strong&gt; ：由于网络传输中的 MTU（最大传输单元）限制或发送缓冲区大小限制，一个大包被分成了多个小包传输。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;解决方案&#34;&gt;解决方案
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;消息定长&lt;/strong&gt; ：每个发送的数据包大小固定，不足的部分用空格补充，接受方取数据的时候根据这个长度来读取数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息末尾增加换行符来表示一条完整的消息&lt;/strong&gt; ：接收方读取的时候根据换行符来判断是否是一条完整的消息，如果消息的内容也包含换行符，那么这种方式就不合适了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用消息头&lt;/strong&gt; ：在消息的头部添加一个长度字段，指示消息的长度，接收方根据这个长度来读取相应长度的数据。（UDP的设计方法）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp连接的基本认识&#34;&gt;TCP连接的基本认识
&lt;/h3&gt;&lt;p&gt;TCP 为每个数据流初始化并维护的某些状态信息（这些信息包括 socket、序列号和窗口大小），称为连接。&lt;/p&gt;
&lt;p&gt;建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Socket&lt;/strong&gt;：由 IP 地址和端口号组成，是通信的端点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;序列号&lt;/strong&gt;：用来解决乱序问题，帮助于接收方按顺序重组数据包，并检测丢包情况&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;窗口大小&lt;/strong&gt;：用来做流量控制&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;tcp连接的唯一确定&#34;&gt;TCP连接的唯一确定
&lt;/h4&gt;&lt;p&gt;TCP 四元组可以唯一标识一个连接&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源地址&lt;/li&gt;
&lt;li&gt;源端口&lt;/li&gt;
&lt;li&gt;目的地址&lt;/li&gt;
&lt;li&gt;目的端口&lt;/li&gt;
&lt;/ul&gt;
&lt;style type=&#34;text/css&#34;&gt;
   
  .notice {
    --title-color: #fff;
    --title-background-color: #6be;
    --content-color: #444;
    --content-background-color: #e7f2fa;
  }

  .notice.info {
    --title-background-color: #fb7;
    --content-background-color: #fec;
  }

  .notice.tip {
    --title-background-color: #5a5;
    --content-background-color: #efe;
  }

  .notice.warning {
    --title-background-color: #c33;
    --content-background-color: #fee;
  }

   
  @media (prefers-color-scheme: dark) {
    .notice {
      --title-color: #fff;
      --title-background-color: #069;
      --content-color: #ddd;
      --content-background-color: #023;
    }

    .notice.info {
      --title-background-color: #a50;
      --content-background-color: #420;
    }

    .notice.tip {
      --title-background-color: #363;
      --content-background-color: #121;
    }

    .notice.warning {
      --title-background-color: #800;
      --content-background-color: #400;
    }
  }

  body.dark .notice {
    --title-color: #fff;
    --title-background-color: #069;
    --content-color: #ddd;
    --content-background-color: #023;
  }

  body.dark .notice.info {
    --title-background-color: #a50;
    --content-background-color: #420;
  }

  body.dark .notice.tip {
    --title-background-color: #363;
    --content-background-color: #121;
  }

  body.dark .notice.warning {
    --title-background-color: #800;
    --content-background-color: #400;
  }

   
  .notice {
    width: 100%;  
    max-width: 600px;  
    padding: 18px;
    line-height: 24px;
    margin-bottom: 24px;
    border-radius: 4px;
    color: var(--content-color);
    background: var(--content-background-color);
  }

  .notice p:last-child {
    margin-bottom: 0;
  }

   
  .notice-title {
    margin: -18px -18px 12px;
    padding: 4px 18px;
    border-radius: 4px 4px 0 0;
    font-weight: 700;
    color: var(--title-color);
    background: var(--title-background-color);
  }

   
  .icon-notice {
    display: inline-flex;
    align-self: center;
    margin-right: 8px;
  }

  .icon-notice img,
  .icon-notice svg {
    height: 1em;
    width: 1em;
    fill: currentColor;
  }

  .icon-notice img,
  .icon-notice.baseline svg {
    top: 0.125em;
    position: relative;
  }
&lt;/style&gt;&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;TCP 三元组&lt;/p&gt;
&lt;p&gt;三元组指的是 IP 地址和端口号的组合，即 &lt;code&gt;IP 地址 + 端口号 + 协议类型&lt;/code&gt;。例如，&lt;code&gt;192.168.1.1:8080 (TCP)&lt;/code&gt; 就是一个三元组。在一个机器上，这样的组合唯一标识了一个网络服务或应用程序。&lt;/p&gt;&lt;/div&gt;

&lt;h3 id=&#34;tcp连接的建立三次握手&#34;&gt;TCP连接的建立—三次握手
&lt;/h3&gt;&lt;h4 id=&#34;握手过程&#34;&gt;握手过程
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/1719902940519-03556a12-819b-42b4-b6f7-41b4448d9d99.png&#34;
	width=&#34;1221&#34;
	height=&#34;1019&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;三次握手&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;119&#34;
		data-flex-basis=&#34;287px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;握手前&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端和服务端都处于 &lt;code&gt;CLOSE&lt;/code&gt; 状态。先是服务端主动监听某个端口，处于 &lt;code&gt;LISTEN&lt;/code&gt; 状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第一次握手&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;客户端向服务端发送特殊的TCP报文段（SYN报文段），该报文段被封装到IP数据报中，客户端处于 &lt;code&gt;SYN-SENT&lt;/code&gt; 状态，表示向服务端发起连接，并告知服务器自己的初始序列号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SYN 报文段结构&lt;img src=&#34;https://Tyritic.github.io/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/format,png-20230309230500953.png&#34;
	width=&#34;1173&#34;
	height=&#34;708&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;SYN 报文&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;165&#34;
		data-flex-basis=&#34;397px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;客户端随机初始化序号（&lt;strong&gt;&lt;code&gt;client_isn&lt;/code&gt;&lt;/strong&gt;），设为x，填入序列号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;SYN&lt;/code&gt;&lt;/strong&gt; 字段置为1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;报文段不包含数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二次握手&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务端接收到 &lt;strong&gt;&lt;code&gt;SYN&lt;/code&gt;&lt;/strong&gt; 报文段，为TCP连接分配TCP缓存和变量，并向客户端发送允许连接的报文段 &lt;strong&gt;&lt;code&gt;(SYN + ACK)&lt;/code&gt;&lt;/strong&gt; ，服务端处于 &lt;strong&gt;&lt;code&gt;SYN-RCVD&lt;/code&gt;&lt;/strong&gt; 状态，表示的连接请求被接受了，并通知客户端自己的初始序列号。&lt;/li&gt;
&lt;li&gt;SYN+ACK 报文段结构&lt;img src=&#34;https://Tyritic.github.io/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/format,png-20230309230504118.png&#34;
	width=&#34;1188&#34;
	height=&#34;708&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;SYN &amp;#43; ACK 报文&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;167&#34;
		data-flex-basis=&#34;402px&#34;
	
&gt;
&lt;ul&gt;
&lt;li&gt;服务端随机初始化自己的序号（ &lt;strong&gt;&lt;code&gt;server_isn&lt;/code&gt;&lt;/strong&gt; ）设为y，填入序列号&lt;/li&gt;
&lt;li&gt;将确认应答号 &lt;strong&gt;&lt;code&gt;ack&lt;/code&gt;&lt;/strong&gt; 置为 &lt;strong&gt;&lt;code&gt;client_isn + 1&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;SYN和ACK字段置为1&lt;/li&gt;
&lt;li&gt;不携带数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​	&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;第二次握手为什么要传回ACK和SYN&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ACK：是第一次握手的确认报文，告知客户端从客户端到服务端的通信是正常的，服务端正确接收到客户端的信息&lt;/li&gt;
&lt;li&gt;SYN：建立并确认从服务端到客户端的通信&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​&lt;/p&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第三次握手
&lt;ul&gt;
&lt;li&gt;客户端收到服务端报文后，为TCP连接分配缓存和变量，客户端向服务端发送确认连接的报文（ACK报文），客户端处于 ESTABLISHED 状态。服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态&lt;/li&gt;
&lt;li&gt;ACK报文结构&lt;img src=&#34;https://Tyritic.github.io/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/1719902940762-a8cb1769-ed0d-4f73-aedf-116d918f23e3.png&#34;
	width=&#34;1188&#34;
	height=&#34;708&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;ACK报文&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;167&#34;
		data-flex-basis=&#34;402px&#34;
	
&gt;
&lt;ul&gt;
&lt;li&gt;将确认应答号 &lt;strong&gt;&lt;code&gt;ack&lt;/code&gt;&lt;/strong&gt; 置为 &lt;strong&gt;&lt;code&gt;server_isn + 1&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将 &lt;strong&gt;&lt;code&gt;ACK&lt;/code&gt;&lt;/strong&gt; 字段置为1&lt;/li&gt;
&lt;li&gt;报文可以携带数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;三次握手的必要性&#34;&gt;三次握手的必要性
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;三次握手才可以阻止重复历史连接的初始化（主要原因）
&lt;ul&gt;
&lt;li&gt;一个「旧 SYN 报文」比「最新的 SYN」 报文早到达了服务端，那么此时服务端就会回一个 SYN + ACK 报文给客户端，此报文中的确认号是 &lt;strong&gt;旧的SYN报文中的ISN+1&lt;/strong&gt;  。（第二次挥手）&lt;/li&gt;
&lt;li&gt;客户端收到后，发现自己期望收到的确认号应该是 &lt;strong&gt;新的SYN报文中的ISN+1&lt;/strong&gt; ，于是就会回 RST 报文。（第三次握手）&lt;/li&gt;
&lt;li&gt;服务端收到 RST 报文后，就会释放连接。&lt;/li&gt;
&lt;li&gt;后续最新的 SYN 抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;三次握手才可以同步双方的初始序列号&lt;img src=&#34;https://Tyritic.github.io/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/1713944607932-bc673dc4-6c94-45f5-a731-d583a44feba8.webp&#34;
	width=&#34;1080&#34;
	height=&#34;709&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;三次握手和四次握手&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;152&#34;
		data-flex-basis=&#34;365px&#34;
	
&gt;
&lt;ul&gt;
&lt;li&gt;当客户端发送携带初始序列号的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收。&lt;/li&gt;
&lt;li&gt;当服务端发送初始序列号给客户端的时候，依然也要得到客户端的应答回应&lt;/li&gt;
&lt;li&gt;三次握手只是将服务端的ACK报文和SYN报文合为一步&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;三次握手可以避免资源浪费
&lt;ul&gt;
&lt;li&gt;如果没有第三次握手，&lt;strong&gt;服务端不清楚客户端是否收到了自己回复的&lt;/strong&gt; &lt;strong&gt;ACK&lt;/strong&gt; &lt;strong&gt;报文&lt;/strong&gt; 。如果客户端发送的 SYN 报文在网络中阻塞了，重复发送多次 SYN 报文，那么服务端在收到请求后就会 &lt;strong&gt;建立多个冗余的无效链接，造成不必要的资源浪费。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;TCP连接为什么不设计成两次握手&lt;/p&gt;
&lt;p&gt;两次握手的形式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端 → SYN → 服务器。&lt;/li&gt;
&lt;li&gt;服务器 → ACK → 客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不设计为两次握手的原因&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;两次握手无法阻止重复历史连接的初始化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费&lt;/strong&gt;。
&lt;ul&gt;
&lt;li&gt;服务端在收到 SYN 报文后，就进入 &lt;strong&gt;ESTABLISHED&lt;/strong&gt; 状态，意味着这时可以给对方发送数据，但是客户端此时还没有进入 &lt;strong&gt;ESTABLISHED&lt;/strong&gt; 状态。&lt;/li&gt;
&lt;li&gt;假设这次是历史连接，客户端判断到此次连接为历史连接，那么就会回 RST 报文来断开连接，而服务端在第一次握手的时候就进入 &lt;strong&gt;ESTABLISHED&lt;/strong&gt; 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接。&lt;/li&gt;
&lt;li&gt;服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，浪费了服务端的资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两次握手无法保持序列化的同步，只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务端确认了客户端的初始序列号但是客户端无法确认服务端的序列化。后续数据传输可能因序列号不同步而混乱。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两次握手无法无法确认双向通信&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器发送 ACK 后，认为连接已建立，但客户端可能未收到 ACK（例如网络丢包）。&lt;/li&gt;
&lt;li&gt;客户端无法确认服务器的接收能力，服务器也无法确认客户端是否收到 ACK。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两次握手无法识别历史连接&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果握手只有两次，那么接收方应对发送方的请求只能拒绝或者接受，但是&lt;strong&gt;它无法识别当前的请求是旧的请求还是新的请求&lt;/strong&gt;。由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 ACK 报文，所以服务端每收到一个 SYN 就只能先主动建立一个连接。&lt;/li&gt;
&lt;li&gt;如果客户端发送的 SYN 报文在网络中阻塞了，重复发送多次 SYN 报文，那么服务端在收到请求后就会&lt;strong&gt;建立多个冗余的无效链接，造成不必要的资源浪费。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h4 id=&#34;初始序列号isn&#34;&gt;初始序列号ISN
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了防止历史报文被下一个相同四元组的连接接收
&lt;ul&gt;
&lt;li&gt;当客户端和服务端中出现连接中断，若客户端又与服务端建立了与上一个连接相同四元组的连接，上一个连接中被网络阻塞的数据包正好抵达了服务端，刚好该数据包的序列号正好是在服务端的接收窗口内，所以该数据包会被服务端正常接收，就会造成数据错乱。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;生成过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;初始序列号 ISN 是以时间戳为基础生成的。&lt;/p&gt;
&lt;h4 id=&#34;握手丢失&#34;&gt;握手丢失
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;第一次握手丢失（客户端发送SYN报文丢失）：客户端触发超时重传机制
&lt;ul&gt;
&lt;li&gt;服务端：不会进行任何的动作&lt;/li&gt;
&lt;li&gt;客户端：发完SYN报文后处于 &lt;strong&gt;SYN_SENT&lt;/strong&gt; 状态。由于一段时间内没有收到服务端发来的确认报文，等待一段时间后会重新发送 SYN 报文（ &lt;strong&gt;重传的 SYN 报文的序列号都是一样的&lt;/strong&gt; ），如果仍然没有回应，会重复这个过程，直到发送次数超过最大重传次数限制，就会返回连接建立失败。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第二次握手丢失（服务端发送SYN+ACK报文丢失）：客户端和服务端均触发超时重传机制
&lt;ul&gt;
&lt;li&gt;客户端：第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是 &lt;strong&gt;客户端就会触发超时重传机制，重传 SYN 报文（第一次握手）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;服务端：第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是 &lt;strong&gt;服务端这边会触发超时重传机制，重传 SYN-ACK 报文（第二次握手）&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第三次握手丢失（客户端发送的ACK报文丢失）：服务端触发超时重传机制
&lt;ul&gt;
&lt;li&gt;客户端：发完SYN报文后处于 &lt;strong&gt;ESTABLISHED&lt;/strong&gt; 状态&lt;/li&gt;
&lt;li&gt;服务端：第三次握手的 ACK 报文是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;tcp半连接&#34;&gt;TCP半连接
&lt;/h4&gt;&lt;p&gt;TCP 半连接指的是在 TCP 三次握手过程中，服务器接收到了客户端的 SYN 包，但还没有完成第三次握手，此时的连接处于一种未完全建立的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;半连接队列和全连接队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCP 进入三次握手前，服务端会从 &lt;strong&gt;CLOSED&lt;/strong&gt; 状态变为 &lt;strong&gt;LISTEN&lt;/strong&gt; 状态, 同时在内部创建了两个队列：半连接队列（SYN 队列）和全连接队列（ACCEPT 队列）。&lt;/p&gt;
&lt;p&gt;半连接队列存放的是三次握手未完成的连接，全连接队列存放的是完成三次握手的连接&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发送 SYN 到服务端，服务端收到之后，便回复 &lt;strong&gt;ACK 和 SYN&lt;/strong&gt;，状态由 &lt;strong&gt;LISTEN 变为 SYN_RCVD&lt;/strong&gt;，此时这个连接就被推入了 &lt;strong&gt;SYN 队列&lt;/strong&gt;，即半连接队列。&lt;/li&gt;
&lt;li&gt;当客户端回复 ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入 ACCEPT 队列，即全连接队列。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;syn洪泛攻击&#34;&gt;SYN洪泛攻击
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SYN 洪泛 是一种拒绝服务攻击（DoS）。攻击者伪造&lt;strong&gt;不存在的 IP 地址&lt;/strong&gt;, 向服务器发送大量 SYN 报文。当服务器回复 SYN+ACK 报文后，不会收到 ACK 回应报文，那么 SYN 队列里的连接旧不会出对队，久⽽久之就会占满服务端的 &lt;strong&gt;SYN&lt;/strong&gt; 接收队列（半连接队列），使得服务器不能为正常⽤户服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应对策略&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;syn cookie&lt;/strong&gt;：在收到 SYN 包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个 cookie 值作为自己的 SYNACK 包的序列号，回复 SYN+ACK 后，服务器并不立即分配资源进行处理，等收到发送方的 ACK 包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SYN Proxy 防火墙&lt;/strong&gt;：服务器防火墙会对收到的每一个 SYN 报文进行代理和回应，并保持半连接。等发送方将 ACK 包返回后，再重新构造 SYN 包发到服务器，建立真正的 TCP 连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp连接的断开四次挥手&#34;&gt;TCP连接的断开—四次挥手
&lt;/h3&gt;&lt;h4 id=&#34;挥手过程&#34;&gt;挥手过程
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/format,png-20230309230614791.png&#34;
	width=&#34;753&#34;
	height=&#34;794&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;客户端主动关闭连接 —— TCP 四次挥手&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;94&#34;
		data-flex-basis=&#34;227px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一次挥手
&lt;ul&gt;
&lt;li&gt;客户端主动关闭连接，发送 FIN 包。服务器收到 FIN 后，表示不再接收数据，但仍可能继续发送数据。
&lt;ul&gt;
&lt;li&gt;客户端进入 &lt;strong&gt;&lt;code&gt;FIN_WAIT_1&lt;/code&gt;&lt;/strong&gt; 状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第二次挥手
&lt;ul&gt;
&lt;li&gt;服务器发送 ACK 包，确认已收到 FIN。在收到 FIN 报文的时候，TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，服务端应用程序可以通过 read 调用来感知这个 FIN 包，这个 EOF 会被&lt;strong&gt;放在已排队等候的其他已接收的数据之后&lt;/strong&gt;，所以必须要得继续 read 接收缓冲区已接收的数据；&lt;/li&gt;
&lt;li&gt;双方状态
&lt;ul&gt;
&lt;li&gt;服务器进入 &lt;strong&gt;&lt;code&gt;CLOSE_WAIT&lt;/code&gt;&lt;/strong&gt; 状态&lt;/li&gt;
&lt;li&gt;客户端进入 &lt;strong&gt;&lt;code&gt;FIN_WAIT_2&lt;/code&gt;&lt;/strong&gt; 状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第三次挥手
&lt;ul&gt;
&lt;li&gt;服务器完成所有数据传输后，发送 FIN 包。客户端收到 FIN 后，准备关闭连接。
&lt;ul&gt;
&lt;li&gt;服务端进入 &lt;strong&gt;&lt;code&gt;LAST_ACK&lt;/code&gt;&lt;/strong&gt; 状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第四次挥手
&lt;ul&gt;
&lt;li&gt;客户端发送最后一个 ACK 包，并等待可能迟到的 FIN 包。服务器收到 ACK 后，关闭连接。客户端在 TIME_WAIT 计时结束后（2MSL），正式关闭连接。&lt;/li&gt;
&lt;li&gt;双方状态
&lt;ul&gt;
&lt;li&gt;服务端进入 &lt;strong&gt;&lt;code&gt;CLOSED&lt;/code&gt;&lt;/strong&gt; 状态&lt;/li&gt;
&lt;li&gt;客户端进入 &lt;strong&gt;&lt;code&gt;TIME_WAIT&lt;/code&gt;&lt;/strong&gt; 状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;四次挥手的必要性&#34;&gt;四次挥手的必要性
&lt;/h4&gt;&lt;p&gt;主要是为了&lt;strong&gt;确保数据完整性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;TCP 是一个全双工协议，也就是说双方都要关闭，每一方都向对方发送 FIN 和回应 ACK。&lt;/p&gt;
&lt;p&gt;客户端发起连接断开，代表客户端没数据要发送的，但是服务端可能还有数据没有返回给客户端。&lt;/p&gt;
&lt;p&gt;所以一个 FIN + ACK 代表一方结束数据的传输，因此需要两对 FIN + ACK，加起来就是四次通信。&lt;/p&gt;
&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;四次挥手变成三次挥手的情况&lt;/p&gt;
&lt;p&gt;如果客户端发送 FIN 给服务端的时候服务端已经没数据发送给客户端了并且开启了 TCP 延迟确认机制，那么服务端就可以&lt;strong&gt;将 ACK （第二次挥手）和它的 FIN（第三次挥手） 合并传输&lt;/strong&gt; 一起发给客户端，这样一来就变成三次挥手&lt;/p&gt;
&lt;p&gt;TCP延迟确认机制&lt;/p&gt;
&lt;p&gt;当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。 为了解决 ACK 传输效率低问题，所以就衍生出了 &lt;strong&gt;TCP 延迟确认&lt;/strong&gt;。 TCP 延迟确认的策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方&lt;/li&gt;
&lt;li&gt;当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送&lt;/li&gt;
&lt;li&gt;如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h4 id=&#34;挥手丢失&#34;&gt;挥手丢失
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;第一次挥手丢失
&lt;ul&gt;
&lt;li&gt;客户端：迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制
&lt;ul&gt;
&lt;li&gt;重传 FIN 报文（第一次握手），重发次数由 &lt;code&gt;tcp_orphan_retries&lt;/code&gt; 参数控制。&lt;/li&gt;
&lt;li&gt;当客户端重传 FIN 报文的次数超过 &lt;code&gt;tcp_orphan_retries&lt;/code&gt; 后，就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务端：不会有任何动作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第二次挥手丢失
&lt;ul&gt;
&lt;li&gt;客户端：就会触发超时重传机制
&lt;ul&gt;
&lt;li&gt;重传 FIN 报文（第一次报文），直到收到服务端的第二次挥手，或者达到最大的重传次数。&lt;/li&gt;
&lt;li&gt;已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK 报文），那么客户端就会断开连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务端：不会有任何动作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第三次挥手丢失
&lt;ul&gt;
&lt;li&gt;服务端：触发重传机制
&lt;ul&gt;
&lt;li&gt;重发 FIN 报文，重发次数仍然由 &lt;strong&gt;&lt;code&gt;tcp_orphan_retries&lt;/code&gt;&lt;/strong&gt; 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。&lt;/li&gt;
&lt;li&gt;当服务端重传第三次挥手报文的次数达到了 3 次后，由于 &lt;strong&gt;&lt;code&gt;tcp_orphan_retries&lt;/code&gt;&lt;/strong&gt; 为 3，达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK报文），那么服务端就会断开连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;客户端：处于 FIN_WAIT_2 状态是有时长限制的，如果 tcp_fin_timeout 时间内还是没能收到服务端的第三次挥手（FIN 报文），那么客户端就会断开连接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第四次挥手丢失
&lt;ul&gt;
&lt;li&gt;服务端：触发重传机制
&lt;ul&gt;
&lt;li&gt;当服务端重传第三次挥手报文达到 2 时，由于 tcp_orphan_retries 为 2， 达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;客户端：进入 &lt;strong&gt;&lt;code&gt;TIME_WAIT&lt;/code&gt;&lt;/strong&gt; 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;time_wait状态&#34;&gt;TIME_WAIT状态
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证被动关闭连接的一方，能被正确的关闭： &lt;strong&gt;&lt;code&gt;TIME_WAIT&lt;/code&gt;&lt;/strong&gt; 状态中，客户端可以重新发送 ACK 确保对方正常关闭连接。
&lt;ul&gt;
&lt;li&gt;在 TCP 四次挥手过程中，主动关闭连接的一方在发送最后一个 ACK 确认包后进入 &lt;strong&gt;TIME_WAIT&lt;/strong&gt; 状态。&lt;/li&gt;
&lt;li&gt;如果这个 ACK 丢失了，另一方（被动关闭连接的一方）没有收到确认包，会重发 FIN 报文。主动关闭的一方需要在 &lt;strong&gt;TIME_WAIT&lt;/strong&gt; 状态下保持一段时间，以便能够重发 ACK，确保连接能被正确地关闭。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;防止历史连接中的数据，被后面相同四元组的连接错误的接收：在 &lt;strong&gt;&lt;code&gt;TIME_WAIT&lt;/code&gt;&lt;/strong&gt; 持续的 2MSL 时间后，确保旧数据包完全消失，避免它们干扰未来建立的新连接。
&lt;ul&gt;
&lt;li&gt;TCP 连接在关闭后，可能会有一些延迟的或者已经失效的报文还在网络中传输。如果立即重新使用相同的 IP 地址和端口建立新的连接，可能会受到这些旧报文的干扰。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TIME_WAIT&lt;/strong&gt; 状态可以确保在旧连接的所有报文都超时失效后，才允许新的连接使用相同的 IP 地址和端口，从而避免数据混乱。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;为什么 &lt;strong&gt;&lt;code&gt;TIME_WAIT&lt;/code&gt;&lt;/strong&gt; 等待时间为2MSL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;MSL&lt;/code&gt;&lt;/strong&gt; 是 Maximum Segment Lifetime，&lt;strong&gt;报文最大生存时间&lt;/strong&gt;，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。&lt;/p&gt;
&lt;p&gt;网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以 &lt;strong&gt;一来一回需要等待 2 倍的时间&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;TIME_WAIT状态过多的危害&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;占用系统资源：比如文件描述符、内存资源、CPU 资源、线程资源等；&lt;/li&gt;
&lt;li&gt;占用端口资源：端口资源也是有限的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;原因&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 没有使用长连接&lt;/li&gt;
&lt;li&gt;大量HTTP 长连接超时&lt;/li&gt;
&lt;li&gt;单条HTTP 长连接的请求数量达到上限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项：&lt;strong&gt;复用处于 TIME_WAIT 的 socket 为新的连接所用&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;net.ipv4.tcp_max_tw_buckets：&lt;strong&gt;当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;程序中使用 SO_LINGER ，应用强制使用 RST 关闭。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;close_wait状态&#34;&gt;CLOSE_WAIT状态
&lt;/h4&gt;&lt;p&gt;CLOSE_WAIT状态的作用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持半关闭状态：TCP 是全双工协议，发送和接收通道独立。
&lt;ul&gt;
&lt;li&gt;允许服务器在收到 FIN 后继续发送剩余数据。&lt;/li&gt;
&lt;li&gt;半关闭状态确保服务器能优雅地完成任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;确保被动方控制关闭时机
&lt;ul&gt;
&lt;li&gt;给服务器缓冲时间，应用程序决定何时发送 FIN。&lt;/li&gt;
&lt;li&gt;避免数据丢失，保证关闭的可靠性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;防止数据丢失
&lt;ul&gt;
&lt;li&gt;服务器在 CLOSE_WAIT 期间处理剩余数据并发送。&lt;/li&gt;
&lt;li&gt;确保数据传输完整性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;连接的强制断开&#34;&gt;连接的强制断开
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RST（Reset）标志&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;使用 TCP RST 标志可以强制立即终止连接。发送方可以直接发送带有 RST 标志的 TCP 报文，通知对方立即断开连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;超时（Timeout）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;如果连接一段时间内没有任何数据包传输，连接双方可以依据设定的超时时间自动断开连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp的可靠传输原理&#34;&gt;TCP的可靠传输原理
&lt;/h3&gt;&lt;h4 id=&#34;检验和&#34;&gt;检验和
&lt;/h4&gt;&lt;p&gt;TCP 报文段包括一个校验和字段，用于检测报文段在传输过程中的变化。如果接收方检测到校验和错误，就会丢弃这个报文段&lt;img src=&#34;https://Tyritic.github.io/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/weixin-mianznxjsjwllsewswztwxxssc-d875c766-0c96-4733-8ca6-181d31c0f83d.jpg&#34;
	width=&#34;996&#34;
	height=&#34;298&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;三分恶面渣逆袭：TCP 校验和&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;334&#34;
		data-flex-basis=&#34;802px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;重传机制和序列号确认机制&#34;&gt;重传机制和序列号确认机制
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;序列号/确认机制&lt;/strong&gt;：TCP 将数据分成多个小段，每段数据都有唯一的序列号，以确保数据包的顺序传输和完整性。同时，发送方如果没有收到接收方的确认应答，会重传数据。&lt;img src=&#34;https://Tyritic.github.io/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/weixin-mianznxjsjwllsewswztwxxssc-cbf040f5-ccc5-437d-98c4-711701e47113.jpg&#34;
	width=&#34;818&#34;
	height=&#34;594&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;序列号/确认应答&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;137&#34;
		data-flex-basis=&#34;330px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重传机制&lt;/strong&gt; ：用于防止数据包的丢失。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;超时重传：发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 &lt;code&gt;ACK&lt;/code&gt; 确认应答报文，就会重发该数据
&lt;ul&gt;
&lt;li&gt;发生条件
&lt;ul&gt;
&lt;li&gt;数据包丢失：发送方重新发送数据包&lt;/li&gt;
&lt;li&gt;确认应答丢失：发送方重新发送数据包&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;快速重传：发送方连续收到三次相同 ACK，会在定时器过期之前，重传丢失的报文段。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;SACK方法&lt;/strong&gt; ：带选择确认的重传&lt;/p&gt;
&lt;p&gt;传统的 TCP 使用累计确认（Cumulative ACK）机制，只能确认到达的连续数据段，无法有效告知发送方中间某些数据段的丢失或乱序情况。结果是发送方只能依赖超时或重复 ACK 来重传数据，这可能导致不必要的重传，浪费带宽，降低效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SACK可以将已收到的数据的信息发送给「发送方」&lt;/strong&gt;，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以&lt;strong&gt;只重传丢失的数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/sM13suJb_173347d1-465e-4eb7-b686-e0ee6efff1cc_mianshiya.png&#34;
	width=&#34;1024&#34;
	height=&#34;768&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;SACK方法示例&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;320px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;通过 ACK 告知我接下来要 5500 开始的数据，并一直更新 SACK，6000-6500 收到了，6000-7000的数据收到了，6000-7500的数据我收到了，发送方很明确的知道，5500-5999 的那一波数据应该是丢了，于是重传。&lt;/p&gt;
&lt;h4 id=&#34;滑动窗口机制&#34;&gt;滑动窗口机制
&lt;/h4&gt;&lt;p&gt;TCP 滑动窗口机制的主要作用是实现流量控制（Flow Control），即协调发送方和接收方的数据传输速率，确保发送方不会发送超出接收方处理能力的数据量，防止接收端缓冲区溢出。&lt;/p&gt;
&lt;p&gt;滑动窗口允许发送方在未收到前一个数据包的确认（ACK）前继续发送多个数据包，从而提高网络吞吐量，减少等待时间，实现高效的数据流传输。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/15.jpg&#34;
	width=&#34;857&#34;
	height=&#34;602&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;用滑动窗口方式并行处理&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;142&#34;
		data-flex-basis=&#34;341px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;累计确认机制：图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。&lt;/p&gt;
&lt;h4 id=&#34;拥塞控制&#34;&gt;拥塞控制
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;慢启动&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;发送方在连接建立初期，缓慢地增加数据发送速率。初始的拥塞窗口（cwnd）通常为一个 MSS（最大报文段大小），然后在每次收到 ACK 后成倍增加 cwnd，直到达到慢启动阈值（ssthresh）或检测到网络拥塞。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拥塞避免&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;当 cwnd 达到 ssthresh 后，TCP 进入拥塞避免阶段，拥塞窗口的增长速度从指数变为线性增长，即每个 RTT（往返时间）增加一个 MSS。这一阶段旨在避免激烈的拥塞反应，保持网络稳定性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拥塞发生&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;当网络出现拥塞，也就是会发生数据包重传
&lt;ul&gt;
&lt;li&gt;超时重传
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ssthresh&lt;/code&gt; 设为 &lt;code&gt;cwnd/2&lt;/code&gt;，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cwnd&lt;/code&gt; 重置为 &lt;code&gt;1&lt;/code&gt; （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;快速重传
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cwnd = cwnd/2&lt;/code&gt; ，也就是设置为原来的一半;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ssthresh = cwnd&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;快速恢复（Fast Recovery）&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;在快速重传后，TCP 不进入慢启动，而是减小 cwnd 到当前的一半，并设置 ssthresh 为当前新的 cwnd 的值，然后开始线性增加 cwnd，以快速恢复到丢包前的传输速率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保活机制&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。&lt;/li&gt;
&lt;li&gt;如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 &lt;strong&gt;TCP 保活时间会被重置&lt;/strong&gt;，等待下一个 TCP 保活时间的到来。&lt;/li&gt;
&lt;li&gt;如果对端主机宕机（&lt;em&gt;注意不是进程崩溃，进程崩溃后操作系统在回收进程资源的时候，会发送 FIN 报文，而主机宕机则是无法感知的，所以需要 TCP 保活机制来探测对方是不是发生了主机宕机&lt;/em&gt;），或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，&lt;strong&gt;TCP 会报告该 TCP 连接已经死亡&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;HTTP Keep-Alive 和 TCP Keep-Alive&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由 &lt;strong&gt;应用程序&lt;/strong&gt; 实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。&lt;/li&gt;
&lt;li&gt;TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由 &lt;strong&gt;内核&lt;/strong&gt; 实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h2 id=&#34;非面向连接的不可靠传输-udp协议&#34;&gt;非面向连接的不可靠传输-UDP协议
&lt;/h2&gt;&lt;h3 id=&#34;udp的主要特点&#34;&gt;UDP的主要特点
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非面向连接&lt;/strong&gt; ：进程之间通信之前没有握手过程，而是将带有目的地址的报文放入线路&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可靠服务&lt;/strong&gt; ：不确保报文段按序交付，不保证报文的完整性&lt;/li&gt;
&lt;li&gt;不提供拥塞控制和流量控制&lt;/li&gt;
&lt;li&gt;使用场景：实时通讯、语音、视频、游戏等高性能要求应用&lt;/li&gt;
&lt;li&gt;面向报文段&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;udp报文结构&#34;&gt;UDP报文结构
&lt;/h3&gt;&lt;p&gt;报文段结构：数据字段 + 首部字段&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/wangluo-a5d0d209-01db-4ee7-b63b-bf2659545702.png&#34;
	width=&#34;1486&#34;
	height=&#34;638&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;UDP报文结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;232&#34;
		data-flex-basis=&#34;558px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首部
&lt;ul&gt;
&lt;li&gt;源端口：这个字段占据 UDP 报文头的前 16 位，通常包含发送数据报的应用程序所使用的 UDP 端口，接收端的应用程序利用这个字段的值作为发送响应的目的地址，这个字段是可选的，所以发送端的应用程序不一定会把自己的端口号写入该字段中，如果不写入端口号，则把这个字段设置为 0，这样，接收端的应用程序就不能发送响应了。&lt;/li&gt;
&lt;li&gt;目的端口：接收端计算机上 UDP 软件使用的端口，占据 16 位。&lt;/li&gt;
&lt;li&gt;长度：该字段占据 16 位，表示 UDP 数据报长度，包含 UDP 报文头和 UDP 数据长度，因为 UDP 报文头长度是 8 个字节，所以这个值最小为 8。&lt;/li&gt;
&lt;li&gt;校验值：该字段占据 16 位，可以检验数据在传输过程中是否被损坏。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据部分&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>应用层协议</title>
        <link>https://Tyritic.github.io/p/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/</link>
        <pubDate>Sun, 09 Jun 2024 10:51:40 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/</guid>
        <description>&lt;h2 id=&#34;网络应用程序的常见架构&#34;&gt;网络应用程序的常见架构
&lt;/h2&gt;&lt;h3 id=&#34;客户端服务器结构cs结构&#34;&gt;客户端—服务器结构（CS结构）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;设置一台或多台高性能计算机（服务器集群）作为服务端，接受其他主机（客户端）的请求
&lt;ul&gt;
&lt;li&gt;服务端总是打开，并具有固定的地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;客户端之间 &lt;strong&gt;不能直接通信&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;需要安装特定的客户端软件，该客户端需要承担部分业务逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;浏览器服务器结构bs结构&#34;&gt;浏览器—服务器结构（BS结构）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;客户端仅使用浏览器（Browser）作为访问入口&lt;/strong&gt;，完成不需要安装额外的软件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;所有的业务逻辑和数据处理都在服务器端（Server）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;点对点结构p2p结构&#34;&gt;点对点结构（P2P结构）
&lt;/h3&gt;&lt;p&gt;P2P（Peer-to-Peer）架构是一种&lt;strong&gt;去中心化的网络架构&lt;/strong&gt;，每个节点（Peer）既可以作为&lt;strong&gt;客户端（请求资源）&lt;/strong&gt;，也可以作为&lt;strong&gt;服务器（提供资源）&lt;/strong&gt;，节点之间可以直接通信、共享资源，而无需依赖中央服务器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对服务器具有最小依赖&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;具有自拓展性&lt;/strong&gt; ：网络能够随着节点（Peer）数量的增加，自主扩展计算能力、存储容量和带宽，而不依赖中央服务器。每个对等节点都由于接受请求产生工作负荷，但是每个对等节点向其他对等节点分发文件也为系统增加服务能力&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进程与网络之间的接口socket&#34;&gt;进程与网络之间的接口（Socket）
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Socket（套接字）&lt;/strong&gt; 是计算机网络中用于 &lt;strong&gt;进程间通信（IPC, Inter-Process Communication）&lt;/strong&gt; 的一种机制，它可以让不同计算机上的进程通过网络进行通信。Socket 提供了一种标准化的接口，使应用程序能够发送和接收数据，而不需要关心底层网络协议的实现细节。&lt;/p&gt;
&lt;h2 id=&#34;超文本传输协议http&#34;&gt;超文本传输协议（HTTP）
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;HTTP（超文本传输协议，HyperText Transfer Protocol）&lt;/strong&gt; 是一种 &lt;strong&gt;无状态、基于请求-响应模式&lt;/strong&gt; 的 &lt;strong&gt;应用层协议&lt;/strong&gt; ，用于在 &lt;strong&gt;Web 浏览器和服务器之间&lt;/strong&gt; 传输数据，如 HTML 页面、图片、视频等。&lt;/p&gt;
&lt;p&gt;HTTP 是 &lt;strong&gt;互联网的基础协议&lt;/strong&gt;，它构建在 &lt;strong&gt;TCP/IP 协议&lt;/strong&gt; 之上，使得客户端（如浏览器）和服务器可以相互通信。默认端口为 80&lt;/p&gt;
&lt;h3 id=&#34;uri和url&#34;&gt;URI和URL
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;URI(Uniform Resource Identifier)&lt;/strong&gt; 全称是统一资源标志符，可以唯一标识一个资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;URL(Uniform Resource Locator)&lt;/strong&gt; 全称是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;基本工作模型&#34;&gt;基本工作模型
&lt;/h3&gt;&lt;p&gt;基于 &lt;strong&gt;请求—响应&lt;/strong&gt; 模型进行工作，客户端向服务器发送 HTTP Request（请求），服务器响应请求并返回 HTTP Response（响应）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/450px-HTTP-Header.png&#34;
	width=&#34;450&#34;
	height=&#34;340&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;基本工作模型&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;132&#34;
		data-flex-basis=&#34;317px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HTTP客户端先建立与服务端的TCP连接&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器发起到服务器的 TCP 连接（创建套接字 &lt;strong&gt;&lt;code&gt;Socket&lt;/code&gt;&lt;/strong&gt;）。&lt;/li&gt;
&lt;li&gt;服务器接收来自浏览器的 TCP 连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端进程和服务器进程通过 &lt;strong&gt;&lt;code&gt;Socket&lt;/code&gt;&lt;/strong&gt; 访问网络连接&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端从 &lt;strong&gt;&lt;code&gt;Socket&lt;/code&gt;&lt;/strong&gt; 发出请求并接受响应&lt;/li&gt;
&lt;li&gt;服务端从 &lt;strong&gt;&lt;code&gt;Socket&lt;/code&gt;&lt;/strong&gt; 接受请求并发送响应&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;协议特点&#34;&gt;协议特点
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;无状态协议&lt;/strong&gt; ：HTTP 协议是 &lt;strong&gt;无状态&lt;/strong&gt; 的协议，它无法记录客户端用户的状态，一般我们都是通过 &lt;strong&gt;&lt;code&gt;Session&lt;/code&gt;&lt;/strong&gt; 来记录客户端用户的状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;明文传输&lt;/strong&gt; ：默认情况下数据不加密，容易被监听（可用 HTTPS 加密）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于请求—响应机制&lt;/strong&gt; ：客户端发送请求，服务器返回响应。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可靠传输&lt;/strong&gt; ：HTTP 通过 &lt;strong&gt;TCP协议（三次握手）&lt;/strong&gt; 确保可靠传输。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http状态码&#34;&gt;HTTP状态码
&lt;/h3&gt;&lt;p&gt;状态码由 &lt;strong&gt;3&lt;/strong&gt; 位数字组成，第一位定义 &lt;strong&gt;响应的类别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;1xx: 信息响应&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;100 Continue&lt;/strong&gt;：服务器已接收请求的初步部分，客户端应继续请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;：服务器同意切换协议，如从 HTTP 切换到 WebSocket。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;2xx: 成功&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;200 OK&lt;/strong&gt;：请求成功，服务器返回所请求的资源或数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;201 Created&lt;/strong&gt;：请求成功并创建了新的资源，常用于 POST 请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;204 No Content&lt;/strong&gt;：请求成功但服务器不返回任何内容，常用于删除操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;206 Partial Content&lt;/strong&gt; ：应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;3xx: 重定向&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;301 Moved Permanently&lt;/strong&gt;：资源已永久移动到新的 URL，客户端应使用新 URL 访问。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;302 Found&lt;/strong&gt;：资源临时移动到新的 URL，客户端应继续使用原来的 URL。搜索引擎会抓取新的内容而保存旧的网址并认为新的网址只是暂时的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;304 Not Modified&lt;/strong&gt;：资源未修改，客户端可以使用缓存版本。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;4xx: 客户端错误&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;：请求无效或语法错误，服务器无法处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;401 Unauthorized&lt;/strong&gt;：请求需要身份验证，客户端未提供有效的凭证。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;403 Forbidden&lt;/strong&gt;：服务器理解请求但拒绝执行，通常是权限问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;：请求的资源在服务器上未找到。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;5xx: 服务器错误&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;500 Internal Server Error&lt;/strong&gt;：服务器内部错误，无法完成请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt; ：客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;502 Bad Gateway&lt;/strong&gt;：服务器作为网关或代理，从上游服务器接收到无效响应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;503 Service Unavailable&lt;/strong&gt;：服务器暂时无法处理请求，通常是因为过载或维护。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;style type=&#34;text/css&#34;&gt;
   
  .notice {
    --title-color: #fff;
    --title-background-color: #6be;
    --content-color: #444;
    --content-background-color: #e7f2fa;
  }

  .notice.info {
    --title-background-color: #fb7;
    --content-background-color: #fec;
  }

  .notice.tip {
    --title-background-color: #5a5;
    --content-background-color: #efe;
  }

  .notice.warning {
    --title-background-color: #c33;
    --content-background-color: #fee;
  }

   
  @media (prefers-color-scheme: dark) {
    .notice {
      --title-color: #fff;
      --title-background-color: #069;
      --content-color: #ddd;
      --content-background-color: #023;
    }

    .notice.info {
      --title-background-color: #a50;
      --content-background-color: #420;
    }

    .notice.tip {
      --title-background-color: #363;
      --content-background-color: #121;
    }

    .notice.warning {
      --title-background-color: #800;
      --content-background-color: #400;
    }
  }

  body.dark .notice {
    --title-color: #fff;
    --title-background-color: #069;
    --content-color: #ddd;
    --content-background-color: #023;
  }

  body.dark .notice.info {
    --title-background-color: #a50;
    --content-background-color: #420;
  }

  body.dark .notice.tip {
    --title-background-color: #363;
    --content-background-color: #121;
  }

  body.dark .notice.warning {
    --title-background-color: #800;
    --content-background-color: #400;
  }

   
  .notice {
    width: 100%;  
    max-width: 600px;  
    padding: 18px;
    line-height: 24px;
    margin-bottom: 24px;
    border-radius: 4px;
    color: var(--content-color);
    background: var(--content-background-color);
  }

  .notice p:last-child {
    margin-bottom: 0;
  }

   
  .notice-title {
    margin: -18px -18px 12px;
    padding: 4px 18px;
    border-radius: 4px 4px 0 0;
    font-weight: 700;
    color: var(--title-color);
    background: var(--title-background-color);
  }

   
  .icon-notice {
    display: inline-flex;
    align-self: center;
    margin-right: 8px;
  }

  .icon-notice img,
  .icon-notice svg {
    height: 1em;
    width: 1em;
    fill: currentColor;
  }

  .icon-notice img,
  .icon-notice.baseline svg {
    top: 0.125em;
    position: relative;
  }
&lt;/style&gt;&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;重定向机制的区别
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;301 Moved Permanently&lt;/strong&gt; ：用于临时重定向，不会更新书签。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;302 Found&lt;/strong&gt; ：用于永久重定向，通常会更新客户端的书签&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h3 id=&#34;http请求方法&#34;&gt;HTTP请求方法
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GET&lt;/strong&gt; ：用于请求获取指定资源，通常用于获取数据。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GET&lt;/strong&gt; 请求的参数位置一般是写在 &lt;strong&gt;URL&lt;/strong&gt; 中，但是浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;POST&lt;/strong&gt; ：用于向服务器提交数据，通常用于提交表单数据或进行资源的创建。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;POST&lt;/strong&gt; 请求携带数据的位置一般是写在报文请求体 &lt;strong&gt;body&lt;/strong&gt; 中，请求体中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对请求体大小做限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PUT&lt;/strong&gt; ：用于向服务器更新指定资源，通常用于更新已存在的资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DELETE&lt;/strong&gt; ：用于请求服务器删除指定资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HEAD&lt;/strong&gt; ：类似于GET请求，但只返回资源的头部信息，用于获取资源的元数据而不获取实际内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;&lt;strong&gt;GET&lt;/strong&gt; 和 &lt;strong&gt;POST&lt;/strong&gt; 的区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GET&lt;/strong&gt;：用于获取资源，通常用于请求数据而不改变服务器状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;POST&lt;/strong&gt;：用于提交数据到服务器，通常会改变服务器的状态或产生副作用（如创建或更新资源）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;参数传递方式
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GET&lt;/strong&gt;：参数通过 URL 拼接传递，暴露在请求 URL 中，具有可见性，长度有限（取决于浏览器和服务器）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;POST&lt;/strong&gt;：参数放在请求体中，通常不可见且长度理论上没有限制，更适合传递大量数据或敏感信息（但是注意，POST 也可以在 URL 上放参数！）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安全性
&lt;ul&gt;
&lt;li&gt;数据安全性
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GET&lt;/strong&gt;：参数可见，数据容易暴露在浏览器历史记录、日志和缓存中，不适合传递敏感信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;POST&lt;/strong&gt;：数据放在请求体中，相对安全，但需要 &lt;strong&gt;HTTPS&lt;/strong&gt; 才能保证数据加密传输。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HTTP定义：在 HTTP 协议里，所谓的 &lt;strong&gt;安全&lt;/strong&gt; 是指请求方法不会 &lt;strong&gt;破坏&lt;/strong&gt; 服务器上的资源。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GET&lt;/strong&gt; ：是 &lt;strong&gt;只读&lt;/strong&gt; 操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;POST&lt;/strong&gt; ：是 &lt;strong&gt;新增或提交数据&lt;/strong&gt; 的操作，会修改服务器上的资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;幂等性：多次执行相同的操作，结果都是相同的
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GET&lt;/strong&gt; ：&lt;strong&gt;GET&lt;/strong&gt; 具有幂等性，&lt;strong&gt;GET&lt;/strong&gt; 是 &lt;strong&gt;只读&lt;/strong&gt; 操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。（重复请求不会改变服务器状态）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;POST&lt;/strong&gt; ：&lt;strong&gt;POST&lt;/strong&gt; 具有非幂等，&lt;strong&gt;POST&lt;/strong&gt; 是 &lt;strong&gt;新增或提交数据&lt;/strong&gt; 的操作，会修改服务器上的资源（多次请求可能导致重复创建资源或执行多次相同操作）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缓存机制
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GET&lt;/strong&gt; ：可以对 &lt;strong&gt;GET&lt;/strong&gt; 请求的数据做缓存，当请求同一个 URL 时可以直接返回缓存内容，减少服务器负载。适用于不频繁变动的资源，比如图片、静态页面。
&lt;ul&gt;
&lt;li&gt;缓存可以做到浏览器本身上（彻底避免浏览器发请求）&lt;/li&gt;
&lt;li&gt;缓存可以做到代理上，而且在浏览器中 &lt;strong&gt;GET&lt;/strong&gt; 请求可以保存为书签。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;POST&lt;/strong&gt; ：&lt;strong&gt;POST&lt;/strong&gt; 请求默认不缓存，大部分浏览器和缓存服务器不缓存 POST 请求，主要因为 POST 请求通常会对服务器数据产生影响（如创建、修改数据），需要确保请求每次都传递到服务器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h3 id=&#34;http报文格式&#34;&gt;HTTP报文格式
&lt;/h3&gt;&lt;h4 id=&#34;请求报文&#34;&gt;请求报文
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/HTTP%E8%AF%B7%E6%B1%82%E5%8D%8F%E8%AE%AE.png&#34;
	width=&#34;1062&#34;
	height=&#34;585&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;HTTP请求报文&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;181&#34;
		data-flex-basis=&#34;435px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;HTTP 请求报文由三个部分组成(请求行+请求头+请求体)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;请求行 （红色部分）&lt;/strong&gt; ：请求报文的第一行
&lt;ul&gt;
&lt;li&gt;请求方法（如&lt;strong&gt;GET&lt;/strong&gt;、&lt;strong&gt;POST&lt;/strong&gt; ）&lt;/li&gt;
&lt;li&gt;请求的资源路径 &lt;strong&gt;URI&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;HTTP协议版本（如HTTP/1.1）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求头（深黄色部分）&lt;/strong&gt;：以键值对的形式表现，用于传递客户端环境、请求内容、认证信息等。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;实体头部&lt;/strong&gt; ：描述请求体的头部
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/strong&gt; ：表明本次请求的数据长度。用于服务端进行拆包
&lt;ul&gt;
&lt;li&gt;当客户端发送一个HTTP请求时，会在请求头中添加 &lt;strong&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/strong&gt; 字段，该字段的值表示请求正文的字节数。服务器在接收到请求后，会根据 &lt;strong&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/strong&gt; 字段的值来确定请求的长度，并从请求中读取相应数量的字节，直到读取完整个请求内容。这种基于 &lt;strong&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/strong&gt; 字段的拆包机制可以确保服务器正确接收到完整的请求，避免了请求的丢失或截断问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/strong&gt; ：请求体的多媒体类型（用于 POST 和 PUT 请求中）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通用头部&lt;/strong&gt;：适用于请求和响应
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/strong&gt; ：用来指定在这次的请求/响应链中的所有缓存机制都必须 遵守的指令&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/strong&gt; ：该浏览器想要优先使用的连接类型（持久连接还是非持久连接）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求头部&lt;/strong&gt;：特定于请求的头部
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/strong&gt; ：客户端发送请求时，用来指定服务器的域名。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/strong&gt; ：浏览器的浏览器身份标识字符串&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/strong&gt; ：能够接受的回应内容类型（Content-Types）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/strong&gt; ：能够接受的编码方式列表&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/strong&gt; ：能够接受的回应内容的自然语言列表。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/strong&gt; ：服务器通过 Set-Cookie发送的一个超文本传输协议 Cookie&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/strong&gt; ：用于超文本传输协议的认证的认证信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空行&lt;/strong&gt;：用于分隔请求头和请求体。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求体&lt;/strong&gt;：仅在POST、PUT等方法中存在，包含需要发送到服务器的数据。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;表单数据（Form Data）&lt;/strong&gt;：&lt;strong&gt;&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;&lt;/strong&gt;，用于提交表单数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多部分数据（Multipart Data）&lt;/strong&gt;：&lt;code&gt;multipart/form-data&lt;/code&gt;，用于上传文件或复杂表单数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JSON数据&lt;/strong&gt;：&lt;strong&gt;&lt;code&gt;application/json&lt;/code&gt;&lt;/strong&gt; ，用于提交JSON格式的数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;XML数据&lt;/strong&gt;：&lt;strong&gt;&lt;code&gt;application/xml&lt;/code&gt;&lt;/strong&gt; ，用于提交XML格式的数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文本数据&lt;/strong&gt;：&lt;strong&gt;&lt;code&gt;text/plain&lt;/code&gt;&lt;/strong&gt; ，用于提交纯文本数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;请求解析过程&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;请求行解析&lt;/strong&gt;：根据 HTTP 请求的第一行（请求行），服务器首先解析出请求方法、请求 URI 和协议版本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求头解析&lt;/strong&gt;：请求头的格式为 &lt;strong&gt;&lt;code&gt;key: value&lt;/code&gt;&lt;/strong&gt;，可以通过换行符来分隔每一行的头部信息。头部信息指示了客户端的行为、首选内容类型、缓存控制等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求体解析&lt;/strong&gt;：对于包含请求体的请求（如 POST 或 PUT），服务器需要解析请求体的内容。通常，内容类型会告知服务器如何解析请求体。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求路由与处理&lt;/strong&gt;：HTTP 请求中的 URI 部分会被用来进行路由匹配，决定请求应该被哪个资源或处理程序处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生成 HTTP 响应&lt;/strong&gt;：服务器处理请求后，会生成一个 HTTP 响应&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;发送 HTTP 响应&lt;/strong&gt;：服务器将构造好的 HTTP 响应通过 TCP 连接返回给客户端。客户端接收到响应后，会根据状态码和响应头判断如何处理响应体&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;响应报文&#34;&gt;响应报文
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/image-20250209191221600.png&#34;
	width=&#34;486&#34;
	height=&#34;140&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;HTTP响应报文&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;347&#34;
		data-flex-basis=&#34;833px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;HTTP响应报文由三个部分组成(响应行,响应头,响应体)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;响应行（红色部分）&lt;/strong&gt;：响应报文的第一行
&lt;ul&gt;
&lt;li&gt;HTTP协议版本&lt;/li&gt;
&lt;li&gt;状态码：用于描述响应结果&lt;/li&gt;
&lt;li&gt;描述&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;响应头（黄色部分）&lt;/strong&gt;：以键值对形式表现
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/strong&gt; ：服务端可以设置客户端的cookie&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/strong&gt; ：该浏览器想要优先使用的连接类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;响应体（绿色部分）&lt;/strong&gt;：存放响应数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http缓存技术&#34;&gt;HTTP缓存技术
&lt;/h3&gt;&lt;p&gt;对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对请求-响应的数据都&lt;strong&gt;缓存在本地&lt;/strong&gt;，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，由此HTTP/1.1 的性能会提升不少。&lt;/p&gt;
&lt;h4 id=&#34;强制缓存&#34;&gt;强制缓存
&lt;/h4&gt;&lt;p&gt;强制缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存。由浏览器决定是否使用缓存的主动性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;强制缓存是利用HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/strong&gt; ：是一个相对时间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/strong&gt; ：是一个绝对时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;工作流程&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在请求头部加上 &lt;strong&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/strong&gt; ，&lt;strong&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/strong&gt; 中设置了过期时间大小；&lt;/li&gt;
&lt;li&gt;浏览器再次请求访问服务器中的该资源时，会先 &lt;strong&gt;通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期&lt;/strong&gt; ，如果没有，则使用该缓存，否则重新请求服务器；&lt;/li&gt;
&lt;li&gt;服务器再次收到请求后，会再次更新请求头的 &lt;strong&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;协商缓存&#34;&gt;协商缓存
&lt;/h4&gt;&lt;p&gt;通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;响应头部中 &lt;strong&gt;&lt;code&gt;Etag&lt;/code&gt;&lt;/strong&gt; ：唯一标识响应资源&lt;/li&gt;
&lt;li&gt;请求头部中的 &lt;strong&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/strong&gt; ：当资源过期时，浏览器发现响应头里有 &lt;strong&gt;&lt;code&gt;Etag&lt;/code&gt;&lt;/strong&gt;，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 &lt;strong&gt;Etag&lt;/strong&gt; 的值。服务器收到请求后进行比对，如果资源没有变化返回 &lt;strong&gt;304（允许使用本地缓存）&lt;/strong&gt;，如果资源变化了返回 &lt;strong&gt;200&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;工作流程&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在请求头部加上 &lt;strong&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/strong&gt; 唯一标识，这个唯一标识的值是根据当前请求的资源生成的&lt;/li&gt;
&lt;li&gt;当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：
&lt;ul&gt;
&lt;li&gt;如果没有过期，则直接使用本地缓存；&lt;/li&gt;
&lt;li&gt;如果缓存过期了，会在请求头部加上 &lt;strong&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/strong&gt; 字段，该字段的值就是 &lt;strong&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/strong&gt; 唯一标识；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务器再次收到请求后，会根据请求中的 &lt;strong&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/strong&gt; 值与当前请求的资源生成的唯一标识进行比较
&lt;ul&gt;
&lt;li&gt;如果值相等代表服务器中的资源未被修改，则返回 &lt;strong&gt;304 Not Modified&lt;/strong&gt;，不会返回资源&lt;/li&gt;
&lt;li&gt;如果不相等代表服务器中的资源被修改，则返回 &lt;strong&gt;200&lt;/strong&gt; 状态码和返回资源，并在请求头部加上新的 ETag 唯一标识；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果浏览器收到 &lt;strong&gt;304&lt;/strong&gt; 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http版本&#34;&gt;HTTP版本
&lt;/h3&gt;&lt;h4 id=&#34;http10版本&#34;&gt;HTTP1.0版本
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;无状态协议&lt;/strong&gt;：HTTP 1.0 是无状态的，每个请求之间相互独立，服务器不保存任何请求的状态信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非持久连接&lt;/strong&gt;：默认情况下，每个 HTTP 请求/响应对之后，连接会被关闭，属于短连接。这意味着对于同一个网站的每个资源请求，如 HTML 页面上的图片和脚本，都需要建立一个新的 TCP 连接。可以设置 &lt;code&gt;Connection: keep-alive&lt;/code&gt; 强制开启长连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;http11版本&#34;&gt;HTTP1.1版本
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;新增特性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;默认使用长连接即  &lt;strong&gt;&lt;code&gt;keep—alive&lt;/code&gt;&lt;/strong&gt; ，允许持久连接。只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。&lt;img src=&#34;https://Tyritic.github.io/p/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/16-%E7%9F%AD%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%95%BF%E8%BF%9E%E6%8E%A5.png&#34;
	width=&#34;616&#34;
	height=&#34;472&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;短连接与长连接&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;130&#34;
		data-flex-basis=&#34;313px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持 &lt;strong&gt;&lt;code&gt;pipeline&lt;/code&gt;&lt;/strong&gt;，在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以 &lt;strong&gt;减少整体的响应时间。&lt;/strong&gt; 但是&lt;strong&gt;服务器必须按照接收请求的顺序发送对这些管道化请求的响应（队尾堵塞）&lt;/strong&gt;。 所以，&lt;strong&gt;HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/17-%E7%AE%A1%E9%81%93%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93.png&#34;
	width=&#34;351&#34;
	height=&#34;381&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;管道网络传输&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;92&#34;
		data-flex-basis=&#34;221px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;允许响应数据分块（chunked)，即响应的时候不标明 &lt;strong&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/strong&gt; ，客户端就无法断开连接，直到收到服务端的 EOF ，利于传输大文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新增缓存的控制和管理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求头中加入了 &lt;strong&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/strong&gt; 字段：解决了域名系统（DNS）允许多个主机名绑定到同一个 IP 地址上，而请求报文无法指出所请求的主机名的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;范围请求：HTTP/1.1 引入了范围请求（range request）机制，以避免带宽的浪费。当客户端想请求一个文件的一部分，或者需要继续下载一个已经下载了部分但被终止的文件，HTTP/1.1 可以在请求中加入 &lt;strong&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/strong&gt; 头部，以请求（并只能请求字节型数据）数据的一部分。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;性能瓶颈&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;头部冗余：请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 &lt;code&gt;Body&lt;/code&gt; 的部分，发送冗长的首部。每次互相发送相同的首部造成的浪费较多&lt;/li&gt;
&lt;li&gt;请求队头阻塞：服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据&lt;/li&gt;
&lt;li&gt;没有请求优先级控制&lt;/li&gt;
&lt;li&gt;请求只能从客户端开始，服务器只能被动响应。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;优化思路&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免发送HTTP请求
&lt;ul&gt;
&lt;li&gt;实现方案：采用缓存技术，对于一些具有重复性的 HTTP 请求，可以把这对请求-响应的数据都&lt;strong&gt;缓存在本地&lt;/strong&gt;，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;减少HTTP响应数据大小
&lt;ul&gt;
&lt;li&gt;实现方案
&lt;ul&gt;
&lt;li&gt;无损压缩（适合用在文本文件、程序可执行文件、程序源代码）、&lt;/li&gt;
&lt;li&gt;有损压缩（压缩多媒体数据）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;减少 HTTP 请求的次数
&lt;ul&gt;
&lt;li&gt;实现方案
&lt;ul&gt;
&lt;li&gt;减少重定向请求：将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数&lt;/li&gt;
&lt;li&gt;合并请求：将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输，再来减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;http20版本&#34;&gt;HTTP2.0版本
&lt;/h4&gt;&lt;p&gt;新增特性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;二进制帧&lt;/strong&gt;：相较于HTTP/1.1 则使用文本格式的报文，HTTP 2.0 使用二进制而不是文本格式来传输数据，解析更加高效。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多路复用&lt;/strong&gt;：一个 TCP 连接上可以同时进行多个 HTTP 请求/响应，解决了 HTTP 1.x 的请求队头阻塞问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;头部压缩&lt;/strong&gt;：HTTP 协议不带状态，所以每次请求都必须附上所有信息。HTTP 2.0 引入了头部压缩机制，可以使用 gzip 或 compress 压缩后再发送，减少了冗余头部信息的带宽消耗。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务端推送&lt;/strong&gt;：服务器可以主动向客户端推送资源，而不需要客户端明确请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优先级设置&lt;/strong&gt; ：HTTP2.0支持优先级设置，允许按 &lt;strong&gt;权重和依赖关系&lt;/strong&gt; 优先传输关键资源，优化用户体验。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;底层实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/image-20240105143224839.png&#34;
	width=&#34;464&#34;
	height=&#34;535&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;底层图&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;86&#34;
		data-flex-basis=&#34;208px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Stream&lt;/strong&gt; ：一个TCP连接中包含多条 &lt;strong&gt;Stream&lt;/strong&gt; ，一个 &lt;strong&gt;Stream&lt;/strong&gt;中包含一对请求响应报文&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Message&lt;/strong&gt; ：请求或响应报文&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Frame&lt;/strong&gt; ：Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 HTTP/2 连接上，&lt;strong&gt;不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ）&lt;/strong&gt;，因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，而&lt;strong&gt;同一 Stream 内部的帧必须是严格有序的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;客户端和服务器&lt;strong&gt;双方都可以建立 Stream&lt;/strong&gt; ，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/image-20240105143421889.png&#34;
	width=&#34;1492&#34;
	height=&#34;568&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;示例图&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;262&#34;
		data-flex-basis=&#34;630px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;HTTP/2 还可以对每个 Stream 设置不同 &lt;strong&gt;优先级&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;http30版本&#34;&gt;HTTP3.0版本
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;HTTP2.0的问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;队头阻塞：HTTP/2 多个请求是跑在一个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。&lt;/li&gt;
&lt;li&gt;网络连接迁移：一个 TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，这意味着如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手，这不利于移动设备切换网络的场景&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;HTTP3.0的改进&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将传输层协议改为UDP，并且基于UDP实现了应用层的QUIC协议&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QUIC协议的特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;传输协议&lt;/strong&gt; ：HTTP/2.0 是基于 TCP 协议实现的，HTTP/3.0 新增了 QUIC（Quick UDP Internet Connections） 协议来实现可靠的传输，提供与 TLS/SSL 相当的安全性，具有较低的连接和传输延迟。可以将 QUIC 看作是 UDP 的升级版本，在其基础上新增了很多功能比如加密、重传等等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连接建立快&lt;/strong&gt;：对于 HTTP/1 和 HTTP/2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、OpenSSL 库实现的表示层。 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS 1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无队头阻塞&lt;/strong&gt;：HTTP/2.0 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。由于 QUIC 协议的特性，HTTP/3.0 在一定程度上解决了队头阻塞问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连接迁移&lt;/strong&gt;：HTTP/3.0 支持连接迁移，因为 QUIC 使用 64 位 ID 标识连接，只要 ID 不变就不会中断，网络环境改变时（如从 Wi-Fi 切换到移动数据）也能保持连接。而 TCP 连接是由（源 IP，源端口，目的 IP，目的端口）组成，这个四元组中一旦有一项值发生改变，这个连接也就不能用了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安全性&lt;/strong&gt;：在 HTTP/2.0 中，TLS 用于加密和认证整个 HTTP 会话，包括所有的 HTTP 头部和数据负载。TLS 的工作是在 TCP 层之上，它加密的是在 TCP 连接中传输的应用层的数据，并不会对 TCP 头部以及 TLS 记录层头部进行加密，所以在传输的过程中 TCP 头部可能会被攻击者篡改来干扰通信。而 HTTP/3.0 的 QUIC 对整个数据包（包括报文头和报文体）进行了加密与认证处理，保障安全性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;https协议&#34;&gt;HTTPS协议
&lt;/h2&gt;&lt;p&gt;HTTP 是明文传输的，存在数据窃听、数据篡改和身份伪造等问题。而 HTTPS 通过引入 SSL/TLS 解决安全性问题，HTTPS 默认端口号是  &lt;strong&gt;443&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;信息加密&lt;/strong&gt;：交互信息无法被窃取。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;校验机制&lt;/strong&gt;：无法篡改通信内容，篡改了就不能正常显示。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;身份证书&lt;/strong&gt;：证明身份。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;加密机制&#34;&gt;加密机制
&lt;/h3&gt;&lt;h4 id=&#34;混合加密&#34;&gt;混合加密
&lt;/h4&gt;&lt;p&gt;HTTPS 采用的是&lt;strong&gt;对称加密&lt;/strong&gt;和&lt;strong&gt;非对称加密&lt;/strong&gt;结合的混合加密方式实现消息的机密性，保证消息不被窃听&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在通信建立前（TLS四次握手）采用&lt;strong&gt;非对称加密&lt;/strong&gt;的方式交换会话秘钥，后续就不再使用非对称加密。&lt;/li&gt;
&lt;li&gt;在通信过程（后续加密通信）中全部使用&lt;strong&gt;对称加密&lt;/strong&gt;的会话秘钥的方式加密明文数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;&lt;strong&gt;非对称加密和对称加密&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对称加密：双方用会话密钥加密通信内容。&lt;/li&gt;
&lt;li&gt;非对称加密：服务器向客户端发送公钥，然后客户端用公钥加密自己的随机密钥，也就是会话密钥，发送给服务器，服务器用私钥解密，得到会话密钥。
&lt;ul&gt;
&lt;li&gt;密钥类型
&lt;ul&gt;
&lt;li&gt;公钥：负责加密&lt;/li&gt;
&lt;li&gt;私钥：负责解密&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用公钥加密过的密文只有私钥才能解密，用私钥加密过的密文只有公钥才能解密
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;公钥加密，私钥解密&lt;/strong&gt; ：这个目的是为了&lt;strong&gt;保证内容传输的安全&lt;/strong&gt;，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;私钥加密，公钥解密&lt;/strong&gt; ：这个目的是为了&lt;strong&gt;保证消息不会被冒充&lt;/strong&gt;，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;相较于对称加密，非对称加密的速度慢&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h4 id=&#34;数字签名和摘要算法&#34;&gt;数字签名和摘要算法
&lt;/h4&gt;&lt;p&gt;HTTPS 采用的是 &lt;strong&gt;数字签名&lt;/strong&gt; 和 &lt;strong&gt;摘要算法&lt;/strong&gt; 实现消息的完整性，保证消息不被篡改&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;摘要算法&lt;/strong&gt; 用于保证消息的 &lt;strong&gt;完整性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算机里会 &lt;strong&gt;用摘要算法（哈希函数）来计算出内容的哈希值&lt;/strong&gt; ，也就是内容的摘要，这个&lt;strong&gt;哈希值是唯一的，且无法通过哈希值推导出内容&lt;/strong&gt;，然后将内容和哈希值一同发送。对方收到后，先是对内容也计算出一个摘要，然后跟发送方发送的摘要做一个比较，如果摘要相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95.png&#34;
	width=&#34;1276&#34;
	height=&#34;636&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;摘要算法&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;200&#34;
		data-flex-basis=&#34;481px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数字签名&lt;/strong&gt; 用于保证消息保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）&lt;/p&gt;
&lt;p&gt;数字签名算法利用非对称加密的机制，服务器用私钥对内容的哈希值进行加密，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png&#34;
	width=&#34;1282&#34;
	height=&#34;652&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;数字签名过程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;196&#34;
		data-flex-basis=&#34;471px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;数字证书&#34;&gt;数字证书
&lt;/h4&gt;&lt;p&gt;由于客户端的公钥可以被替换或者伪造，导致在通信时攻击者可以使用与自己私钥配对的公钥替换客户端的公钥然后与客户端进行通信&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数字证书&lt;/strong&gt; 用于保证公钥无法被伪造或者替换&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;数子证书工作流程&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;服务器将自己的公钥注册到数字证书认证机构（CA）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CA 使用自己的私钥将服务器的公钥进行加密，生成数字证书&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CA 会把持有者的公钥、⽤途、颁发者、有效时间等信息打成⼀个包，然后对这些信息进⾏ Hash 计算，得到⼀个 Hash 值；&lt;/li&gt;
&lt;li&gt;CA 会使⽤⾃⼰的私钥将该 Hash 值加密，⽣成 Certificate Signature；&lt;/li&gt;
&lt;li&gt;最后将 Certificate Signature 添加在⽂件证书上，形成数字证书。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端拿到服务器的数字证书后，使用CA的公钥确认服务器的数字证书的真实性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端从数字证书获取服务器公钥后，使用已被验证的公钥进行加密后发送&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器用私钥对报文解密&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;生活例子解释&#34;&gt;生活例子解释
&lt;/h4&gt;&lt;p&gt;你想向老师请假，一般来说是要求由家长写一份请假理由并签名，老师才能允许你请假&lt;/p&gt;
&lt;p&gt;这里的老师对应于客户端，家长对应服务端，你对应一名攻击者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么需要数字签名？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设你有模仿家长字迹的能力，你用家长的字迹写了一份请假条然后签上你爸爸的名字，老师一看到这个请假条，查看字迹和签名，就误以为是家长写的，就会允许你请假。&lt;/p&gt;
&lt;p&gt;引入了数字签名算法后，你就无法模仿家长的字迹来请假了，家长手上持有着私钥，老师持有着公钥。&lt;/p&gt;
&lt;p&gt;其中请假条中的签名对于数字签名，字迹对应内容&lt;/p&gt;
&lt;p&gt;这样只有用家长手上的私钥才对请假条进行签名，老师通过公钥看能不能解出这个签名，如果能解出并且确认内容的完整性，就能证明是由家长发起的请假条，这样老师才允许你请假，否则老师就不认。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么需要数字证书？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然家长持有私钥，老师通过是否能用公钥解密来确认这个请假条是不是来源你父亲的。但是我们还可以自己伪造出一对公私钥啊！&lt;/p&gt;
&lt;p&gt;你找了个夜晚，偷偷把老师桌面上和你爸爸配对的公钥，换成了你的公钥，那么下次你在请假的时候，你继续模仿你爸爸的字迹写了个请假条，然后用你的私钥做个了数字签名。&lt;/p&gt;
&lt;p&gt;但是老师并不知道自己的公钥被你替换过了，所以他还是按照往常一样用公钥解密，由于这个公钥和你的私钥是配对的，老师当然能用这个被替换的公钥解密出来，并且确认了内容的完整性，于是老师就会以为是家长写的请假条，又允许你请假了。&lt;/p&gt;
&lt;h4 id=&#34;通信过程&#34;&gt;通信过程
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;第一阶段&lt;/strong&gt;是TLS四次握手，这一阶段主要是利用&lt;strong&gt;非对称加密&lt;/strong&gt;的特性各种交换信息，最后得到一个&amp;quot;会话秘钥&amp;quot;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二阶段&lt;/strong&gt;是则是在第一阶段的&amp;quot;&lt;strong&gt;会话秘钥&lt;/strong&gt;&amp;ldquo;基础上，进行&lt;strong&gt;对称加密&lt;/strong&gt;通信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/640.png&#34;
	width=&#34;1080&#34;
	height=&#34;1283&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;四次握手过程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;84&#34;
		data-flex-basis=&#34;202px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一次握手：由客户端向服务器发起加密通信请求，也就是 &lt;strong&gt;ClientHello&lt;/strong&gt; 请求。
&lt;ul&gt;
&lt;li&gt;客户端支持的 TLS 协议版本，如 TLS 1.2 版本。&lt;/li&gt;
&lt;li&gt;客户端生产的随机数 &lt;strong&gt;&lt;code&gt;（Client Random）&lt;/code&gt;&lt;/strong&gt; ，后面用于生成「会话秘钥」条件之一。&lt;/li&gt;
&lt;li&gt;客户端支持的密码套件列表，如 RSA 加密算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第二次握手：服务器收到客户端请求后，向客户端发出响应，也就是 &lt;strong&gt;SeverHello&lt;/strong&gt; 响应
&lt;ul&gt;
&lt;li&gt;确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。&lt;/li&gt;
&lt;li&gt;服务器生产的随机数 &lt;strong&gt;&lt;code&gt;（Server Random）&lt;/code&gt;&lt;/strong&gt; ，也是后面用于生产会话秘钥条件之一。&lt;/li&gt;
&lt;li&gt;确认的密码套件列表，如 RSA 加密算法。&lt;/li&gt;
&lt;li&gt;服务器的数字证书，包含被CA私钥加密过的服务器公钥。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第三次握手：通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。同时生成会话密钥： 客户端使用客户端随机数，服务器随机数和 &lt;strong&gt;&lt;code&gt;pre_master_key&lt;/code&gt;&lt;/strong&gt; 这三个随机数进行计算得到一个 &lt;strong&gt;会话秘钥&lt;/strong&gt; 。客户端会 &lt;strong&gt;从数字证书中取出服务器的公钥&lt;/strong&gt; ，然后使用它加密报文的 &lt;strong&gt;&lt;code&gt;pre-master key&lt;/code&gt;&lt;/strong&gt; ，向服务器发送如下信息：
&lt;ul&gt;
&lt;li&gt;一个随机数 &lt;strong&gt;&lt;code&gt;（pre-master key）&lt;/code&gt;&lt;/strong&gt; ：该随机数由客户端生成，并被服务器公钥加密。&lt;/li&gt;
&lt;li&gt;加密通信算法改变通知：表示随后的信息都将用会话秘钥加密通信。&lt;/li&gt;
&lt;li&gt;内容摘要：客户端会把迄今为止的通信数据内容生成一个摘要，用 &lt;strong&gt;会话秘钥&lt;/strong&gt; 加密，发给服务器做校验，此时客户端这边的握手流程就结束了，因此也叫 &lt;strong&gt;Finished报文&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第四次握手：服务器收到客户端的第三个随机数 &lt;strong&gt;&lt;code&gt;（pre-master key）&lt;/code&gt;&lt;/strong&gt; 之后通过服务器私钥进行解密获得原文，通过与客户端协商的加密算法，计算出本次通信的 &lt;strong&gt;会话秘钥&lt;/strong&gt; 。
&lt;ul&gt;
&lt;li&gt;加密通信算法改变通知，表示随后的信息都将用会话秘钥加密通信。&lt;/li&gt;
&lt;li&gt;服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dns域名解析协议&#34;&gt;DNS（域名解析协议）
&lt;/h2&gt;&lt;p&gt;DNS的全称是Domain Name System（域名系统），它是互联网中用于将域名转换为对应IP地址的分布式数据库系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DNS 是应用层协议，基于 UDP 协议之上，端口为 53&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=&#34;dns服务器&#34;&gt;DNS服务器
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;根 DNS 服务器：根 DNS 服务器提供 TLD 服务器的 IP 地址。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。&lt;/li&gt;
&lt;li&gt;顶级域 DNS 服务器（TLD 服务器）：顶级域是指域名的后缀，如&lt;code&gt;com&lt;/code&gt;、&lt;code&gt;org&lt;/code&gt;、&lt;code&gt;net&lt;/code&gt;和&lt;code&gt;edu&lt;/code&gt;等。国家也有自己的顶级域，如&lt;code&gt;uk&lt;/code&gt;、&lt;code&gt;fr&lt;/code&gt;和&lt;code&gt;ca&lt;/code&gt;。TLD 服务器提供了权威 DNS 服务器的 IP 地址。&lt;/li&gt;
&lt;li&gt;权威 DNS 服务器：在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。&lt;/li&gt;
&lt;li&gt;本地 DNS 服务器：每个 ISP（互联网服务提供商）都有一个自己的本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 层次结构中。严格说来，不属于 DNS 层级结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/5.jpg&#34;
	width=&#34;621&#34;
	height=&#34;420&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;DNS 树状结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;147&#34;
		data-flex-basis=&#34;354px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;域名解析过程&#34;&gt;域名解析过程
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/DNS-process.png&#34;
	width=&#34;496&#34;
	height=&#34;539&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;迭代式域名解析过程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;92&#34;
		data-flex-basis=&#34;220px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;域名解析请求&lt;/strong&gt;：用户在浏览器中输入一个域名，浏览器首先检查本地缓存（如果有的话）是否存有该域名的 IP 地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;本地DNS解析&lt;/strong&gt;：如果本地缓存中没有所需的 IP 地址，浏览器会向配置的 &lt;strong&gt;本地 DNS 服务器&lt;/strong&gt; 发送请求。若存在则直接返回&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根DNS解析&lt;/strong&gt; ：如果 &lt;strong&gt;本地DNS服务器&lt;/strong&gt; 中没有所需的 IP 地址，&lt;strong&gt;本地 DNS 服务器&lt;/strong&gt; 向 &lt;strong&gt;根DNS服务器&lt;/strong&gt; 发出请求，查询 &lt;strong&gt;根DNS&lt;/strong&gt; 以获取 &lt;strong&gt;顶级域（TLD）的 DNS&lt;/strong&gt; 地址。 &lt;strong&gt;根DNS&lt;/strong&gt; 负责将 &lt;strong&gt;顶级域DNS&lt;/strong&gt; 的IP地址发回到 &lt;strong&gt;本地DNS&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;顶级域DNS解析&lt;/strong&gt; ：&lt;strong&gt;本地DNS&lt;/strong&gt; 向 &lt;strong&gt;顶级域DNS&lt;/strong&gt; 发出请求，查询 &lt;strong&gt;顶级域DNS&lt;/strong&gt; 以获取 &lt;strong&gt;权威DNS&lt;/strong&gt; 地址。 &lt;strong&gt;顶级域DNS&lt;/strong&gt; 负责将 &lt;strong&gt;权威DNS&lt;/strong&gt; 的IP地址发回到 &lt;strong&gt;本地DNS&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;权威DNS解析&lt;/strong&gt; ：&lt;strong&gt;本地DNS&lt;/strong&gt; 向 &lt;strong&gt;权威DNS&lt;/strong&gt; 发出请求，查询 &lt;strong&gt;权威DNS&lt;/strong&gt; 以获取 &lt;strong&gt;域名对应的IP地址&lt;/strong&gt; 。 &lt;strong&gt;权威DNS&lt;/strong&gt; 负责将 &lt;strong&gt;域名对应的IP地址&lt;/strong&gt; 发回到 &lt;strong&gt;本地DNS&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;浏览器缓存该 IP 地址以供后续请求使用，并通过 IP 地址连接到目标服务器以访问网站内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rpc远程过程调用&#34;&gt;RPC（&lt;strong&gt;远程过程调用&lt;/strong&gt;）
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;RPC&lt;/strong&gt;（&lt;strong&gt;R&lt;/strong&gt;emote &lt;strong&gt;P&lt;/strong&gt;rocedure &lt;strong&gt;C&lt;/strong&gt;all），又叫做&lt;strong&gt;远程过程调用&lt;/strong&gt;。它本身并不是一个具体的协议，而是一种&lt;strong&gt;调用方式&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;服务发现&#34;&gt;服务发现
&lt;/h3&gt;&lt;p&gt;在 &lt;strong&gt;HTTP&lt;/strong&gt; 中，你知道服务的域名，就可以通过 &lt;strong&gt;DNS 服务&lt;/strong&gt;去解析得到它背后的 IP 地址，默认 80 端口。&lt;/p&gt;
&lt;p&gt;而 &lt;strong&gt;RPC&lt;/strong&gt; 的话，就有些区别，一般会有专门的&lt;strong&gt;中间服务&lt;/strong&gt;去保存服务名和IP信息，比如 &lt;strong&gt;Consul 或者 Etcd，甚至是 Redis&lt;/strong&gt;。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 DNS 也是服务发现的一种，所以也有基于 DNS 去做服务发现的组件，比如&lt;strong&gt;CoreDNS&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;底层连接形式&#34;&gt;底层连接形式
&lt;/h3&gt;&lt;p&gt;主流的 &lt;strong&gt;HTTP/1.1&lt;/strong&gt; 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（&lt;strong&gt;Keep Alive&lt;/strong&gt;），之后的请求和响应都会复用这条连接。&lt;/p&gt;
&lt;p&gt;而 &lt;strong&gt;RPC&lt;/strong&gt; 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个&lt;strong&gt;连接池&lt;/strong&gt;，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，&lt;strong&gt;用完放回去，下次再复用&lt;/strong&gt;，可以说非常环保。&lt;/p&gt;
&lt;h2 id=&#34;websocket&#34;&gt;WebSocket
&lt;/h2&gt;&lt;p&gt;WebSocket 适用于需要实时通信和双向数据流的场景，而 HTTP 更适合于传统的客户端与服务器之间的短时请求响应场景。&lt;/p&gt;
&lt;p&gt;WebSocket 是一种基于 TCP 连接的全双工通信协议，即客户端和服务器可以同时发送和接收数据。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。&lt;/p&gt;
&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;全双工和半双工的概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全双工&lt;/strong&gt; ：&lt;strong&gt;同一时间里&lt;/strong&gt;，&lt;strong&gt;双方&lt;/strong&gt;都可以&lt;strong&gt;主动&lt;/strong&gt;向对方发送数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;半双工&lt;/strong&gt; ：&lt;strong&gt;同一时间里&lt;/strong&gt;，客户端和服务器&lt;strong&gt;只能有一方主动&lt;/strong&gt;发数据&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h3 id=&#34;与http的区别&#34;&gt;与HTTP的区别
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;WebSocket 是一种双向实时通信协议，客户端和服务器建立持久连接后，双方可以随时发送消息，直到主动关闭连接&lt;/li&gt;
&lt;li&gt;HTTP 是一种单向通信协议。HTTP 协议基于请求/响应模型，下的通信只能由客户端发起，服务器无法主动通知客户端&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http轮询和长轮询&#34;&gt;HTTP轮询和长轮询
&lt;/h3&gt;&lt;p&gt;为了实现类似服务器主动发送消息给客户端的场景，有HTTP轮询和长轮询两种实现方案&lt;/p&gt;
&lt;h4 id=&#34;http轮询&#34;&gt;HTTP轮询
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;网页的前端代码里不断定时发 HTTP 请求到服务器，服务器收到请求后给客户端响应消息。&lt;/strong&gt;。这是一种伪实现。本质上并不是服务器主动发消息到客户端，而是客户端自己不断偷偷请求服务器，只是用户无感知而已。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消耗带宽，同时也会增加下游服务器的负担。&lt;/li&gt;
&lt;li&gt;使用体验上会出现 &lt;strong&gt;明显的卡顿&lt;/strong&gt; ，用户需要等个 1~2 秒，正好才触发下一次 HTTP 请求&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;长轮询&#34;&gt;长轮询
&lt;/h4&gt;&lt;p&gt;将HTTP 请求的 &lt;strong&gt;超时时间设置的很大&lt;/strong&gt; ，比如 30 秒，&lt;strong&gt;在这 30 秒内只要服务器收到了请求，就立马返回给客户端。如果超时，那就立马发起下一次请求。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这样就减少了 HTTP 请求的个数，并且由于大部分情况下，响应也是及时的。&lt;/p&gt;
&lt;h3 id=&#34;websocket握手过程&#34;&gt;WebSocket握手过程
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;客户端向服务器发送一个 HTTP 请求，请求头中包含 &lt;strong&gt;&lt;code&gt;Upgrade: websocket&lt;/code&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;code&gt;Sec-WebSocket-Key&lt;/code&gt;&lt;/strong&gt; 等字段，表示要求升级协议为 &lt;strong&gt;WebSocket&lt;/strong&gt; ；
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Upgrade: websocket&lt;/code&gt;&lt;/strong&gt; ：请求升级协议到 &lt;strong&gt;WebSocket&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Sec-WebSocket-Key&lt;/code&gt;&lt;/strong&gt;  ：&lt;strong&gt;随机生成的 base64 码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务器收到这个请求后，会进行升级协议的操作，如果支持 WebSocket，它将回复一个 HTTP 101 状态码，响应头中包含 ，&lt;strong&gt;&lt;code&gt;Connection: Upgrade&lt;/code&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;code&gt;Sec-WebSocket-Accept: xxx&lt;/code&gt;&lt;/strong&gt; 等字段、表示成功升级到 WebSocket 协议。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Connection: Upgrade&lt;/code&gt;&lt;/strong&gt; ：支持协议切换&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt;&lt;/strong&gt; ：根据客户端生成的 &lt;strong&gt;&lt;code&gt;Sec-WebSocket-Key&lt;/code&gt;&lt;/strong&gt; ，用 &lt;strong&gt;公开的&lt;/strong&gt; 算法变成另一段字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;客户端也用同样的&lt;strong&gt;公开算法&lt;/strong&gt;将 &lt;strong&gt;&lt;code&gt;Sec-WebSocket-Key&lt;/code&gt;&lt;/strong&gt; 转成另一段字符串，如果这段字符串跟服务器传回来的 &lt;strong&gt;&lt;code&gt;Sec-WebSocket-Accept&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;一致&lt;/strong&gt;，那验证通过。客户端和服务器之间建立了一个 WebSocket 连接，可以进行双向的数据传输。&lt;/li&gt;
&lt;li&gt;数据以帧（frames）的形式进行传送，WebSocket 的每条消息可能会被切分成多个数据帧（最小单位）。发送端会将消息切割成多个帧发送给接收端，接收端接收消息帧，并将关联的帧重新组装成完整的消息。&lt;/li&gt;
&lt;li&gt;客户端或服务器可以主动发送一个关闭帧，表示要断开连接。另一方收到后，也会回复一个关闭帧，然后双方关闭 TCP 连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tomcat服务器&#34;&gt;Tomcat服务器
&lt;/h2&gt;&lt;h3 id=&#34;基本使用&#34;&gt;基本使用
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;启动Tomcat服务器&lt;/strong&gt;：双击Tomcat服务器目录下的bin\startup.bat&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关闭Tomcat服务器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CTRL+C&lt;/strong&gt;：正常关闭&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;直接关闭运行窗口&lt;/strong&gt;：强制关闭&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;双击Tomcat服务器目录下的bin\shutdown.bat&lt;/strong&gt;：正常关闭&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;部署项目&lt;/strong&gt;：将应用放入webapps目录下&lt;/p&gt;
&lt;h3 id=&#34;tomcat服务器的目录结构&#34;&gt;Tomcat服务器的目录结构
&lt;/h3&gt;


&lt;div class=&#34;goat svg-container &#34;&gt;
  
    &lt;svg
      xmlns=&#34;http://www.w3.org/2000/svg&#34;
      font-family=&#34;Menlo,Lucida Console,monospace&#34;
      
        viewBox=&#34;0 0 176 137&#34;
      &gt;
      &lt;g transform=&#39;translate(8,16)&#39;&gt;
&lt;path d=&#39;M 8,16 L 16,16&#39; fill=&#39;none&#39; stroke=&#39;currentColor&#39;&gt;&lt;/path&gt;
&lt;path d=&#39;M 8,32 L 16,32&#39; fill=&#39;none&#39; stroke=&#39;currentColor&#39;&gt;&lt;/path&gt;
&lt;path d=&#39;M 8,48 L 16,48&#39; fill=&#39;none&#39; stroke=&#39;currentColor&#39;&gt;&lt;/path&gt;
&lt;path d=&#39;M 8,64 L 16,64&#39; fill=&#39;none&#39; stroke=&#39;currentColor&#39;&gt;&lt;/path&gt;
&lt;path d=&#39;M 8,80 L 16,80&#39; fill=&#39;none&#39; stroke=&#39;currentColor&#39;&gt;&lt;/path&gt;
&lt;path d=&#39;M 8,96 L 16,96&#39; fill=&#39;none&#39; stroke=&#39;currentColor&#39;&gt;&lt;/path&gt;
&lt;path d=&#39;M 8,112 L 16,112&#39; fill=&#39;none&#39; stroke=&#39;currentColor&#39;&gt;&lt;/path&gt;
&lt;path d=&#39;M 0,16 L 0,112&#39; fill=&#39;none&#39; stroke=&#39;currentColor&#39;&gt;&lt;/path&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;0&#39; y=&#39;4&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;T&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;8&#39; y=&#39;4&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;o&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;16&#39; y=&#39;4&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;m&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;16&#39; y=&#39;20&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;-&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;16&#39; y=&#39;36&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;-&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;16&#39; y=&#39;52&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;-&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;16&#39; y=&#39;68&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;-&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;16&#39; y=&#39;84&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;-&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;16&#39; y=&#39;100&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;-&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;16&#39; y=&#39;116&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;-&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;24&#39; y=&#39;4&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;c&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;24&#39; y=&#39;20&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;b&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;24&#39; y=&#39;36&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;c&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;24&#39; y=&#39;52&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;l&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;24&#39; y=&#39;68&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;l&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;24&#39; y=&#39;84&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;t&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;24&#39; y=&#39;100&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;w&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;24&#39; y=&#39;116&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;r&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;32&#39; y=&#39;4&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;a&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;32&#39; y=&#39;20&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;i&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;32&#39; y=&#39;36&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;o&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;32&#39; y=&#39;52&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;i&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;32&#39; y=&#39;68&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;o&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;32&#39; y=&#39;84&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;e&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;32&#39; y=&#39;100&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;e&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;32&#39; y=&#39;116&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;e&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;40&#39; y=&#39;4&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;t&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;40&#39; y=&#39;20&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;n&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;40&#39; y=&#39;36&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;n&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;40&#39; y=&#39;52&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;b&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;40&#39; y=&#39;68&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;g&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;40&#39; y=&#39;84&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;m&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;40&#39; y=&#39;100&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;b&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;40&#39; y=&#39;116&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;s&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;48&#39; y=&#39;4&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;/&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;48&#39; y=&#39;20&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;（&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;48&#39; y=&#39;36&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;f&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;48&#39; y=&#39;52&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;（&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;48&#39; y=&#39;68&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;s&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;48&#39; y=&#39;84&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;p&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;48&#39; y=&#39;100&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;a&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;48&#39; y=&#39;116&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;o&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;56&#39; y=&#39;20&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;可&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;56&#39; y=&#39;36&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;（&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;56&#39; y=&#39;52&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;T&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;56&#39; y=&#39;68&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;（&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;56&#39; y=&#39;84&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;（&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;56&#39; y=&#39;100&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;p&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;56&#39; y=&#39;116&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;u&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;64&#39; y=&#39;20&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;执&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;64&#39; y=&#39;36&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;配&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;64&#39; y=&#39;52&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;o&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;64&#39; y=&#39;68&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;日&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;64&#39; y=&#39;84&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;测&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;64&#39; y=&#39;100&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;p&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;64&#39; y=&#39;116&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;r&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;72&#39; y=&#39;20&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;行&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;72&#39; y=&#39;36&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;置&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;72&#39; y=&#39;52&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;m&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;72&#39; y=&#39;68&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;志&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;72&#39; y=&#39;84&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;试&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;72&#39; y=&#39;100&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;s&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;72&#39; y=&#39;116&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;c&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;80&#39; y=&#39;20&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;文&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;80&#39; y=&#39;36&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;文&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;80&#39; y=&#39;52&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;c&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;80&#39; y=&#39;68&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;文&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;80&#39; y=&#39;84&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;代&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;80&#39; y=&#39;100&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;（&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;80&#39; y=&#39;116&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;e&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;88&#39; y=&#39;20&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;件&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;88&#39; y=&#39;36&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;件&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;88&#39; y=&#39;52&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;a&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;88&#39; y=&#39;68&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;件&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;88&#39; y=&#39;84&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;码&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;88&#39; y=&#39;100&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;应&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;88&#39; y=&#39;116&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;（&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;96&#39; y=&#39;20&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;）&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;96&#39; y=&#39;36&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;）&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;96&#39; y=&#39;52&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;t&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;96&#39; y=&#39;68&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;）&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;96&#39; y=&#39;84&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;资&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;96&#39; y=&#39;100&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;用&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;96&#39; y=&#39;116&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;工&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;104&#39; y=&#39;52&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;依&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;104&#39; y=&#39;84&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;源&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;104&#39; y=&#39;100&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;发&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;104&#39; y=&#39;116&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;作&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;112&#39; y=&#39;52&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;赖&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;112&#39; y=&#39;84&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;）&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;112&#39; y=&#39;100&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;布&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;112&#39; y=&#39;116&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;目&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;120&#39; y=&#39;52&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;的&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;120&#39; y=&#39;100&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;目&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;120&#39; y=&#39;116&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;录&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;128&#39; y=&#39;52&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;j&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;128&#39; y=&#39;100&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;录&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;128&#39; y=&#39;116&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;）&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;136&#39; y=&#39;52&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;a&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;136&#39; y=&#39;100&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;）&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;144&#39; y=&#39;52&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;r&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;152&#39; y=&#39;52&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;包&lt;/text&gt;
&lt;text text-anchor=&#39;middle&#39; x=&#39;160&#39; y=&#39;52&#39; fill=&#39;currentColor&#39; style=&#39;font-size:1em&#39;&gt;）&lt;/text&gt;
&lt;/g&gt;

    &lt;/svg&gt;
  
&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/Tomcat%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png&#34;
	width=&#34;240&#34;
	height=&#34;162&#34;
	
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;148&#34;
		data-flex-basis=&#34;355px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>网络分层模型</title>
        <link>https://Tyritic.github.io/p/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/</link>
        <pubDate>Thu, 06 Jun 2024 21:09:15 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/</guid>
        <description>&lt;h2 id=&#34;网络中的常见设备&#34;&gt;网络中的常见设备
&lt;/h2&gt;&lt;h3 id=&#34;主机host&#34;&gt;&lt;strong&gt;主机（host）&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;主机（Host）&lt;/strong&gt; 是指连接到网络并能够发送或接收数据的设备。&lt;/p&gt;
&lt;h4 id=&#34;常见的主机类型&#34;&gt;常见的主机类型
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;个人计算机（PC）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;普通用户使用的台式机或笔记本电脑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过有线（以太网）或无线（Wi-Fi）方式连接到网络。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;服务器（Server）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;提供网络服务的计算机，如Web服务器、数据库服务器、云服务器等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行稳定性和计算能力较强，可同时为多个客户端提供服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常见操作系统：Windows Server、Linux（Ubuntu、CentOS等）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;物联网设备（IoT Devices）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;连接到互联网的智能设备，如智能家居、传感器、工业控制系统等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;资源有限，通常使用轻量级协议（如MQTT、CoAP）进行通信。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;移动设备（Mobile Devices）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;智能手机、平板电脑等设备，也可以作为主机接入网络。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主要通过Wi-Fi或蜂窝网络（4G/5G）访问互联网。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;交换机switch&#34;&gt;交换机（Switch）
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;交换机（Switch）&lt;/strong&gt; 是一种&lt;strong&gt;二层（数据链路层）或三层（网络层）网络设备&lt;/strong&gt;，用于在局域网（LAN）中连接多个设备，并根据&lt;strong&gt;MAC地址或IP地址&lt;/strong&gt;高效地转发数据。&lt;strong&gt;交换机没有MAC地址&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;主要功能&#34;&gt;主要功能
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据转发&lt;/strong&gt;：接收数据帧，并根据目标MAC地址决定将其发送到哪个端口，而不是像集线器（Hub）那样广播给所有设备。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流量管理&lt;/strong&gt;：通过 &lt;strong&gt;全双工通信&lt;/strong&gt; ，同时支持数据的发送和接收，减少网络冲突，提高带宽利用率。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;地址学习（MAC表）&lt;/strong&gt;：存储设备的MAC地址和端口映射关系，智能决定数据流向。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;常见交换机类型&#34;&gt;常见交换机类型
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;二层交换机（L2 Switch）&lt;/strong&gt;：依据MAC地址转发数据，不具备IP路由功能，适用于小型局域网&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;三层交换机（L3 Switch）&lt;/strong&gt;：结合路由功能，能根据IP地址转发数据包，适用于大型网络。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;路由器router&#34;&gt;路由器（Router）
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;路由器（Router）&lt;/strong&gt; 是一种 &lt;strong&gt;网络层（第三层）设备&lt;/strong&gt; ，用于连接不同的网络，并根据 &lt;strong&gt;IP地址&lt;/strong&gt; 确定数据包的最佳传输路径。它是互联网通信的核心设备，负责数据的转发和寻址。&lt;/p&gt;
&lt;h4 id=&#34;主要功能-1&#34;&gt;主要功能
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;IP地址转发&lt;/strong&gt;：根据数据包的&lt;strong&gt;目标IP地址&lt;/strong&gt;，选择最佳路径进行转发。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络隔离&lt;/strong&gt;：不同的网络（如家庭网络和外部互联网）通过路由器进行连接和隔离。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NAT（网络地址转换）&lt;/strong&gt;：允许多个设备共享一个公网IP上网。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DHCP（动态主机配置协议）&lt;/strong&gt;：自动分配IP地址，简化网络配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;集线器hub&#34;&gt;集线器（Hub）
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;集线器（Hub）&lt;/strong&gt; 是一种 &lt;strong&gt;物理层（第一层）&lt;/strong&gt; 的网络设备，用于在局域网（LAN）内连接多个设备。它的主要作用是广播（Broadcast）数据，即收到数据后，会将其发送到所有端口，而不进行智能转发或流量管理。作为接收方的主机发现Mac地址不是自己会忽略该数据包&lt;/p&gt;
&lt;h4 id=&#34;主要功能-2&#34;&gt;主要功能
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;信号复制&lt;/strong&gt;：收到数据后，将其广播到所有端口。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;物理连接&lt;/strong&gt;：提供多个端口，用于连接计算机、打印机等设备。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;放大信号&lt;/strong&gt;（部分型号）：用于延长网络传输距离（称为&lt;strong&gt;中继器集线器&lt;/strong&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分组交换技术&#34;&gt;分组交换技术
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;分组交换（Packet Switching）&lt;/strong&gt; 是一种将数据&lt;strong&gt;拆分成多个小数据包&lt;/strong&gt;，并&lt;strong&gt;独立&lt;/strong&gt;传输到目标地址的通信方式。它不需要建立固定的通信路径，而是&lt;strong&gt;根据网络的实时状态&lt;/strong&gt;选择最优路径，从而提高资源利用率和网络可靠性。&lt;/p&gt;
&lt;h3 id=&#34;存储转发机制&#34;&gt;存储转发机制
&lt;/h3&gt;&lt;p&gt;交换机或路由器开始向链路传输该分组的第一个比特之前必须接受整个分组&lt;/p&gt;
&lt;h3 id=&#34;工作流程&#34;&gt;工作流程
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据拆分&lt;/strong&gt;：将大数据拆分为多个小的数据包（Packet）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据打包&lt;/strong&gt;：每个数据包包含&lt;strong&gt;源地址、目标地址和序列号&lt;/strong&gt;，确保数据按顺序重组。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态路由&lt;/strong&gt;：每个数据包&lt;strong&gt;独立选择路径&lt;/strong&gt;，可能走不同的路。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据包重组&lt;/strong&gt;：接收端根据序列号&lt;strong&gt;重新组装数据&lt;/strong&gt;，恢复原始信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;优缺点&#34;&gt;优缺点
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;无建立时延&lt;/strong&gt; ：通信前无须建立间接，用户可以随时发送分组&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线路利用率高&lt;/strong&gt; ：分组在哪段链路上传送时才占用这段链路的通信资源。相比采用电路交换传送突发式的计算机数据，分组交换的通信线路利用率大大提高。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简化了存储管理（相对于报文交换）&lt;/strong&gt;：因为分组的长度固定，相应缓冲区的大小也固定，在交换结点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加速传输&lt;/strong&gt; ：分组是逐个传输的，可以使后一个分组的存储操作与前一个分组的转发操作并行，这种流水线方式减少了报文的传输时间。此外，传输一个分组比传输一次报文所需的缓冲区小得多，这样，因缓冲区不足而等待发送的概率及时间必然也少得多。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;减小了出错概率和重发数据量&lt;/strong&gt; ：因为分组较短，其出错概率必然减小，所以每次重发的数据量也就大大减少，这样不仅提高了可靠性，而且减小了传输时延。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;存在存储转发时延&lt;/strong&gt; ：尽管分组交换比报文交换的传输时延小，但相对于电路交换仍存在存储转发时延，且其结点交换机必须具有更强的处理能力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;需要传输额外的信息量&lt;/strong&gt; ：每个小数据段都要加上控制信息以构成分组，这使得传送的信息量增大，进而使得控制复杂，降低了通信效率，增大了处理的时延。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当分组交换网采用数据报服务时，可能出现失序、丢失或重复分组的情况&lt;/strong&gt; ：分组到达目的结点时，要对分组按编号进行排序等工作，&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;应用场景&#34;&gt;应用场景
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;互联网通信&lt;/strong&gt;（如网页浏览、电子邮件、社交网络）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;VoIP（网络电话）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;视频流&lt;/strong&gt;（如YouTube、Netflix）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无线通信（4G/5G）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;电路交换技术&#34;&gt;电路交换技术
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;电路交换（Circuit Switching）&lt;/strong&gt; 是指在通信开始前，&lt;strong&gt;必须建立一个固定的端到端通信路径（电路）&lt;/strong&gt;，预留好了通信所需资源，并在整个通信过程中保持该路径。&lt;/p&gt;
&lt;h3 id=&#34;复用技术&#34;&gt;复用技术
&lt;/h3&gt;&lt;p&gt;在电路交换中，复用指的是将多个用户或通信流的信号&lt;strong&gt;合并&lt;/strong&gt;到一个物理路径上，并根据需要将其分开进行通信。在通信过程中，虽然多个通信流共享同一条物理线路，但每个用户都能获得一个独占的&lt;strong&gt;虚拟通道&lt;/strong&gt;，在会话期间保持通道的占用。&lt;/p&gt;
&lt;p&gt;常见的复用技术&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;时分复用（TDM, Time Division Multiplexing）&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;时分复用技术将一个物理信道&lt;strong&gt;按时间划分为多个时隙&lt;/strong&gt;，每个通信会话在不同的时隙内传输数据。这样，多个用户或信号可以&lt;strong&gt;交替使用同一通道&lt;/strong&gt;，但每个用户在其专有的时间段内使用该通道。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;频分复用（FDM, Frequency Division Multiplexing）&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;频分复用技术将可用的传输带宽&lt;strong&gt;划分为多个频带&lt;/strong&gt;，每个通信会话被分配到一个独立的频带上进行传输。每个频带相当于一个&lt;strong&gt;独立的虚拟信道&lt;/strong&gt;，每个用户在自己分配的频带内进行通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;工作流程-1&#34;&gt;工作流程
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;建立连接&lt;/strong&gt;（拨号和呼叫建立阶段）：系统为通信双方&lt;strong&gt;预留一条专用电路&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据传输&lt;/strong&gt;（通信阶段）：数据沿固定路径传输，保证稳定性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;释放连接&lt;/strong&gt;（挂断阶段）：通话结束后，释放电路资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;优缺点-1&#34;&gt;优缺点
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;通信质量稳定&lt;/strong&gt;：由于通话期间通道被&lt;strong&gt;独占&lt;/strong&gt;，不会有其他用户占用带宽。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;延迟低&lt;/strong&gt;：不需要数据包排序或重组，数据按固定路径流动，时延较小。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适用于实时通信&lt;/strong&gt;：如传统电话、专线通信等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;资源利用率低&lt;/strong&gt;，即使通话双方没有发送数据，通信通道仍然被占用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;通信时延&#34;&gt;通信时延
&lt;/h2&gt;&lt;p&gt;节点总时延=节点处理时延+排队时延+传输时延+传播时延&lt;/p&gt;
&lt;h3 id=&#34;节点处理时延&#34;&gt;节点处理时延
&lt;/h3&gt;&lt;p&gt;检查分组首部以及决定分组导向何处所需时间&lt;/p&gt;
&lt;h3 id=&#34;排队时延&#34;&gt;排队时延
&lt;/h3&gt;&lt;p&gt;分组在链路上等待传输所需的时间&lt;/p&gt;
&lt;h3 id=&#34;传输时延&#34;&gt;传输时延
&lt;/h3&gt;&lt;p&gt;将所有分组推向链路的时延&lt;/p&gt;
&lt;h3 id=&#34;传播时延&#34;&gt;传播时延
&lt;/h3&gt;&lt;p&gt;从链路的起点到交换机所需的时间&lt;/p&gt;
&lt;h2 id=&#34;osi七层协议模型&#34;&gt;OSI七层协议模型
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;协议&lt;/strong&gt;：定义了在两个或多个通信实体之间交换的报文格式和顺序，以及报文发送或接受报文或其他事件所采取的动作&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B2.png&#34;
	width=&#34;1852&#34;
	height=&#34;1384&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;osi七层模型&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;321px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;计算机网络的协议采用分层架构。每一层都依赖于&lt;strong&gt;上层提供的服务&lt;/strong&gt;并向&lt;strong&gt;下层提供服务&lt;/strong&gt;。（通常以物理层为第一层，作为最下层）&lt;/p&gt;
&lt;p&gt;当数据从设备发出时，数据从应用层逐层向下传递，每一层会对数据进行&lt;strong&gt;封装&lt;/strong&gt;，增加自己的头部信息，以便下一层能够正确地识别、处理和传输数据。&lt;/p&gt;
&lt;p&gt;当数据到达目标设备时，数据从物理层逐层向上传递，每一层会进行 &lt;strong&gt;解封装&lt;/strong&gt;，提取出属于该层的数据部分，并将其传递给上一层，直到最终到达应用层。&lt;/p&gt;
&lt;p&gt;每一层分工明确&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;应用层&lt;/strong&gt; ：为计算机用户提供服务，给应用程序提供统一的接口&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;表示层&lt;/strong&gt; ：数据处理(编解码、加密解密、压缩解压缩)，使得通信的应用程序能够解释交换数据的含义&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;会话层&lt;/strong&gt; ：管理（建立、维护、重连）表示层实体之间的会话&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传输层&lt;/strong&gt; ：负责端到端的数据传输，为两台主机进程之间的通信提供通用的数据传输服务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络层&lt;/strong&gt; ：负责数据的路由、转发、分片，决定数据在网络的游走路径&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据链路层&lt;/strong&gt; ：负责数据的封帧和差错检测，以及 MAC 寻址&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;物理层&lt;/strong&gt; ：负责在物理网络中传输数据帧，透明地传送比特流传输&lt;/li&gt;
&lt;/ul&gt;
&lt;style type=&#34;text/css&#34;&gt;
   
  .notice {
    --title-color: #fff;
    --title-background-color: #6be;
    --content-color: #444;
    --content-background-color: #e7f2fa;
  }

  .notice.info {
    --title-background-color: #fb7;
    --content-background-color: #fec;
  }

  .notice.tip {
    --title-background-color: #5a5;
    --content-background-color: #efe;
  }

  .notice.warning {
    --title-background-color: #c33;
    --content-background-color: #fee;
  }

   
  @media (prefers-color-scheme: dark) {
    .notice {
      --title-color: #fff;
      --title-background-color: #069;
      --content-color: #ddd;
      --content-background-color: #023;
    }

    .notice.info {
      --title-background-color: #a50;
      --content-background-color: #420;
    }

    .notice.tip {
      --title-background-color: #363;
      --content-background-color: #121;
    }

    .notice.warning {
      --title-background-color: #800;
      --content-background-color: #400;
    }
  }

  body.dark .notice {
    --title-color: #fff;
    --title-background-color: #069;
    --content-color: #ddd;
    --content-background-color: #023;
  }

  body.dark .notice.info {
    --title-background-color: #a50;
    --content-background-color: #420;
  }

  body.dark .notice.tip {
    --title-background-color: #363;
    --content-background-color: #121;
  }

  body.dark .notice.warning {
    --title-background-color: #800;
    --content-background-color: #400;
  }

   
  .notice {
    width: 100%;  
    max-width: 600px;  
    padding: 18px;
    line-height: 24px;
    margin-bottom: 24px;
    border-radius: 4px;
    color: var(--content-color);
    background: var(--content-background-color);
  }

  .notice p:last-child {
    margin-bottom: 0;
  }

   
  .notice-title {
    margin: -18px -18px 12px;
    padding: 4px 18px;
    border-radius: 4px 4px 0 0;
    font-weight: 700;
    color: var(--title-color);
    background: var(--title-background-color);
  }

   
  .icon-notice {
    display: inline-flex;
    align-self: center;
    margin-right: 8px;
  }

  .icon-notice img,
  .icon-notice svg {
    height: 1em;
    width: 1em;
    fill: currentColor;
  }

  .icon-notice img,
  .icon-notice.baseline svg {
    top: 0.125em;
    position: relative;
  }
&lt;/style&gt;&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;网络模型为什么要采用分层模型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;各层之间相互独立&lt;/strong&gt;：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）&lt;strong&gt;。这个和我们对开发时系统进行分层是一个道理。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高了灵活性和可替换性&lt;/strong&gt;：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。并且，每一层都可以根据需要进行修改或替换，而不会影响到整个网络的结构。&lt;strong&gt;这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;问题分解&lt;/strong&gt;：分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 &lt;strong&gt;这个和平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h3 id=&#34;应用层&#34;&gt;应用层
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt; 是OSI模型的最高层，它为用户提供直接的&lt;strong&gt;网络服务&lt;/strong&gt;。它是应用程序与网络之间的接口，&lt;strong&gt;它定义了信息交换的格式，消息会交给下一层传输层来传输&lt;/strong&gt;，是应用程序以及应用层协议存在的地方，负责用户与计算机的交互。&lt;/p&gt;
&lt;p&gt;应用层是不用去关心数据是如何传输的，而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。&lt;/p&gt;
&lt;p&gt;应用层的信息分组称为 &lt;strong&gt;报文&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;常用协议&#34;&gt;常用协议
&lt;/h4&gt;&lt;p&gt;常见的应用层协议&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTTP（Hypertext Transfer Protocol，超文本传输协议）&lt;/strong&gt;：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）&lt;/strong&gt;：基于 TCP 协议，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FTP（File Transfer Protocol，文件传输协议）&lt;/strong&gt;：基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSH（Secure Shell Protocol，安全的网络传输协议）&lt;/strong&gt;：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DNS（Domain Name System，域名管理系统）&lt;/strong&gt;: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;表示层&#34;&gt;表示层
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;表示层&lt;/strong&gt; 负责&lt;strong&gt;数据格式的转换&lt;/strong&gt;，确保不同系统之间的数据能够互相理解。它通常包括数据的&lt;strong&gt;编码、加密、解密&lt;/strong&gt;和&lt;strong&gt;压缩&lt;/strong&gt;功能。&lt;/p&gt;
&lt;p&gt;例如：&lt;strong&gt;Linux&lt;/strong&gt; 给 &lt;strong&gt;WIndows&lt;/strong&gt; 发包，不同系统语法不一致，如 &lt;strong&gt;exe&lt;/strong&gt; 不能在 &lt;strong&gt;Linux&lt;/strong&gt; 下执行，&lt;strong&gt;shell&lt;/strong&gt; 不能在 &lt;strong&gt;Windows&lt;/strong&gt; 不能直接运行。因此需要表示层。解决&lt;strong&gt;不同系统之间通信语法问题&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;会话层&#34;&gt;会话层
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;会话层&lt;/strong&gt; 负责&lt;strong&gt;建立、管理和终止会话&lt;/strong&gt;，它提供了在应用程序之间的&lt;strong&gt;会话管理功能&lt;/strong&gt;，保证数据的同步、恢复以及多次通信的管理。它确保数据传输的&lt;strong&gt;秩序性&lt;/strong&gt;，如恢复中断的连接。&lt;/p&gt;
&lt;p&gt;常见的协议有 &lt;code&gt;ADSP、RPC&lt;/code&gt; 等&lt;/p&gt;
&lt;h3 id=&#34;传输层&#34;&gt;传输层
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;传输层&lt;/strong&gt; 负责在通信的两端提供 &lt;strong&gt;端到端的可靠性（不同主机上不同进程的通信）&lt;/strong&gt; ，它确保数据的&lt;strong&gt;可靠传输&lt;/strong&gt;和&lt;strong&gt;流量控制&lt;/strong&gt;。它将数据从应用层交给网络层，然后将接收到的数据传递给应用层。传输层还负责错误检测与修正。&lt;/p&gt;
&lt;h4 id=&#34;报文段&#34;&gt;报文段
&lt;/h4&gt;&lt;p&gt;传输层的数据分组称为 &lt;strong&gt;报文段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/TCP%E6%AE%B5.png&#34;
	width=&#34;581&#34;
	height=&#34;392&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;报文切分&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;148&#34;
		data-flex-basis=&#34;355px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;常用协议-1&#34;&gt;常用协议
&lt;/h4&gt;&lt;p&gt;在传输层会有两个传输协议，分别是 &lt;strong&gt;TCP&lt;/strong&gt; 和 &lt;strong&gt;UDP&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;TCP 的全称叫传输控制协议（&lt;em&gt;Transmission Control Protocol&lt;/em&gt;），具有以下功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流量控制&lt;/li&gt;
&lt;li&gt;超时重传&lt;/li&gt;
&lt;li&gt;拥塞控制等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过提供面向连接的服务保证报文段可靠地传输给对方&lt;/p&gt;
&lt;p&gt;UDP 相对来说就很简单，提供无连接服务，只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。&lt;/p&gt;
&lt;p&gt;当设备作为接收方时，传输层则要负责把报文段传给应用进程，但是一台设备上可能会有很多应用进程在接收或者传输数据，因此需要用一个 &lt;strong&gt;端口号&lt;/strong&gt; 将应用进程区分开来。&lt;/p&gt;
&lt;h3 id=&#34;网络层&#34;&gt;网络层
&lt;/h3&gt;&lt;p&gt;随着网络节点的不断增加，点对点通讯需要通过多个节点，如何找到目标节点，如何选择最佳路径成为首要需求。&lt;/p&gt;
&lt;p&gt;网络层主要功能是将 &lt;strong&gt;网络地址转化为对应的物理地址（寻址）&lt;/strong&gt; ，并 &lt;strong&gt;决定如何将数据从发送方路由到接收方（路由选择）&lt;/strong&gt; 。&lt;/p&gt;
&lt;h4 id=&#34;数据报&#34;&gt;数据报
&lt;/h4&gt;&lt;p&gt;位于网络层的数据分组称为 &lt;strong&gt;数据报&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络层最常使用的是 IP 协议（&lt;em&gt;Internet Protocol&lt;/em&gt;），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会&lt;strong&gt;再次进行分片&lt;/strong&gt;，得到一个即将发送到网络的 IP 报文。&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/12.jpg&#34;
	width=&#34;1142&#34;
	height=&#34;702&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;报文段切片&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;162&#34;
		data-flex-basis=&#34;390px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;ip地址&#34;&gt;IP地址
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;IP地址&lt;/strong&gt; 用于区分不同的物理设备&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;网络号&lt;/strong&gt;：负责标识该 IP 地址是属于哪个「子网」的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主机号&lt;/strong&gt;：负责标识同一「子网」下的不同主机；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;子网掩码&lt;/strong&gt; ：用于计算网络号和主机号&lt;/p&gt;
&lt;p&gt;将 &lt;strong&gt;子网掩码&lt;/strong&gt; 和 &lt;strong&gt;IP地址&lt;/strong&gt; 进行按位与操作即可计算出网络号&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/16.jpg&#34;
	width=&#34;521&#34;
	height=&#34;481&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;网络号的计算过程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;108&#34;
		data-flex-basis=&#34;259px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;将 &lt;strong&gt;子网掩码&lt;/strong&gt; 取反后与 &lt;strong&gt;IP地址&lt;/strong&gt; 进行进行&lt;strong&gt;按位与运算&lt;/strong&gt;，就可以得到主机号&lt;/p&gt;
&lt;h4 id=&#34;常见协议&#34;&gt;常见协议
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;IP（Internet Protocol，网际协议）&lt;/strong&gt;：TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ARP（Address Resolution Protocol，地址解析协议）&lt;/strong&gt;：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ICMP（Internet Control Message Protocol，互联网控制报文协议）&lt;/strong&gt;：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NAT（Network Address Translation，网络地址转换协议）&lt;/strong&gt;：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RIP(Routing Information Protocol，路由信息协议）&lt;/strong&gt;：一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;数据链路层&lt;/strong&gt; 在物理连接中提供可靠的传输（ &lt;strong&gt;点到点的传输&lt;/strong&gt; ），负责建立和维护两个相邻节点间的链路。包括&lt;strong&gt;数据帧的封装与解封装&lt;/strong&gt;，以及&lt;strong&gt;错误检测与校正&lt;/strong&gt;。它还负责处理&lt;strong&gt;物理地址&lt;/strong&gt;（MAC地址），管理局域网的访问控制。&lt;/p&gt;
&lt;p&gt;链路层中的数据分组为 &lt;strong&gt;帧&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;物理层&#34;&gt;物理层
&lt;/h3&gt;&lt;p&gt;物理层是OSI模型的最底层，负责将数据以&lt;strong&gt;电气信号、光信号或无线信号&lt;/strong&gt;的形式传输到物理媒介上。它定义了硬件设备的接口、传输媒介的电气特性、连接器的标准等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网卡工作在这层&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;tcpip模型&#34;&gt;TCP/IP模型
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;TCP/IP 四层模型&lt;/strong&gt; 是目前被广泛采用的一种模型,可以将 &lt;strong&gt;TCP / IP&lt;/strong&gt; 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;应用层&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传输层&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络层&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络接口层&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/tcp-ip-4-model.png&#34;
	width=&#34;818&#34;
	height=&#34;469&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;TCP/IP 四层模型与OSI七层模型的简单对应&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;174&#34;
		data-flex-basis=&#34;418px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;网络接口层&#34;&gt;网络接口层
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;网络接口层（Network Access Layer）&lt;/strong&gt;：可以把网络接口层看作是数据链路层和物理层的合体。负责将数字信号在物理通道（网线）中准确传输，定义了如何在单一网络链路上传输数据，如何处理数据帧的发送和接收，包括物理地址（MAC 地址）的解析。&lt;/p&gt;
&lt;h3 id=&#34;mac地址&#34;&gt;MAC地址
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Mac地址&lt;/strong&gt; 是一个全球唯一的物理地址，由设备制造商在生产时烧录到网卡的固件中。MAC 地址用于局域网（LAN）中的设备识别和通信。&lt;/p&gt;
&lt;p&gt;IP 网络使用 &lt;strong&gt;IP 地址&lt;/strong&gt; 进行通信，但在局域网内，设备最终依靠 &lt;strong&gt;MAC 地址&lt;/strong&gt; 进行数据传输。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ARP（Address Resolution Protocol）&lt;/strong&gt; 负责将 IP 地址转换为 MAC 地址。&lt;/p&gt;
&lt;h3 id=&#34;数据封装过程&#34;&gt;数据封装过程
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/%E5%B0%81%E8%A3%85.png&#34;
	width=&#34;905&#34;
	height=&#34;501&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;数据封装过程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;180&#34;
		data-flex-basis=&#34;433px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;网页显示过程&#34;&gt;网页显示过程
&lt;/h2&gt;&lt;h3 id=&#34;工作流程-2&#34;&gt;工作流程
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;浏览器解析 &lt;strong&gt;URL&lt;/strong&gt;：浏览器会解析 &lt;strong&gt;URL&lt;/strong&gt; 并根据解析结果和缓存分析获得传输协议和资源路径，并试图从缓存获得IP地址
&lt;ul&gt;
&lt;li&gt;浏览器分析 URL 所需要使用的传输协议和请求的资源路径。
&lt;ul&gt;
&lt;li&gt;如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。&lt;/li&gt;
&lt;li&gt;如果没有问题，浏览器会检查 URL 中是否出现了非法字符，则对非法字符进行转义后在进行下一过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里且没有失效，那么就直接使用，否则向服务器发起新的请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;浏览器通过  &lt;strong&gt;DNS&lt;/strong&gt;   做域名解析从而获取域名对应的IP地址：请求需要知晓服务器域名对应的 IP 地址才能通信，浏览器会检查本地缓存、操作系统缓存，甚至路由器缓存。如果未命中缓存，浏览器向配置的 &lt;strong&gt;DNS&lt;/strong&gt; 服务器发送查询请求，&lt;strong&gt;DNS 服务器递归查询&lt;/strong&gt; 最终返回 &lt;strong&gt;IP&lt;/strong&gt; 地址。&lt;/li&gt;
&lt;li&gt;通过 &lt;strong&gt;DNS&lt;/strong&gt; 获取到 &lt;strong&gt;IP&lt;/strong&gt; 后，就可以把 HTTP 的传输工作交给操作系统中的&lt;strong&gt;协议栈&lt;/strong&gt;。&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/7.jpg&#34;
	width=&#34;903&#34;
	height=&#34;917&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;协议栈&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;98&#34;
		data-flex-basis=&#34;236px&#34;
	
&gt;
&lt;ul&gt;
&lt;li&gt;浏览器会调用 Socket 库委托协议栈工作，并得到了封装了 &lt;strong&gt;HTTP&lt;/strong&gt; 数据的 &lt;strong&gt;TCP&lt;/strong&gt; 数据包, &lt;strong&gt;TCP&lt;/strong&gt;协议指定了指定源端口号和目的端口号，然后下发给网络层&lt;/li&gt;
&lt;li&gt;在 TCP 数据包的基础上，再封装源地址 &lt;strong&gt;IP&lt;/strong&gt; 和前面 &lt;strong&gt;DNS&lt;/strong&gt; 解析出来目标地址 &lt;strong&gt;IP&lt;/strong&gt; 等信息，得到网络包。并多个网络节点中确定数据包的传输路径，最终能找到目标服务器。然后将下发给数据链路层&lt;/li&gt;
&lt;li&gt;数据链路层的发送需要封装通信双方的 MAC 地址。
&lt;ul&gt;
&lt;li&gt;本机的 MAC 地址作为源 MAC 地址。&lt;/li&gt;
&lt;li&gt;接收方目标 MAC 地址的获取方式是通过将 IP 地址与本机的子网掩码相结合，可以判断是否与请求主机在同一个子网里
&lt;ul&gt;
&lt;li&gt;如果在同一个子网里，可以使用 ARP 协议获取到目的主机的 MAC 地址&lt;/li&gt;
&lt;li&gt;如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网卡驱动获取网络包之后，会将其&lt;strong&gt;复制&lt;/strong&gt;到网卡内的缓存区中。网卡会将包转为电信号，通过网线发送出去&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;建立TCP连接：主机将使用目标 IP地址和目标MAC地址发送一个TCP SYN包，请求建立一个TCP连接，然后交给路由器或者交换机
&lt;ul&gt;
&lt;li&gt;交换机：它会根据数据包中的 MAC 头来查找MAC表来找到另一个设备连接在交换机的哪个端口，然后传输。&lt;/li&gt;
&lt;li&gt;路由器：路由器进行跨子网的转发，通过查找路由表中IP地址和端口的映射关系来决定从路由器的哪个端口发出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;发送HTTP请求：连接建立后，浏览器会向服务器发送HTTP请求。请求中包含了用户需要获取的资源的信息，例如网页的URL、请求方法（GET、POST等）等。&lt;/li&gt;
&lt;li&gt;服务器处理请求并返回响应：服务器收到请求后，会根据请求的内容进行相应的处理。例如，如果是请求网页，服务器会读取相应的网页文件，并生成HTTP响应。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据封装过程-1&#34;&gt;数据封装过程
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/1720420602148-199136a3-681d-4f87-9bcf-42ef227e6b95.webp&#34;
	width=&#34;936&#34;
	height=&#34;953&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;数据包封装过程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;98&#34;
		data-flex-basis=&#34;235px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;数据包传递过程&#34;&gt;数据包传递过程
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/640.webp&#34;
	width=&#34;861&#34;
	height=&#34;747&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;示例网络拓扑&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;115&#34;
		data-flex-basis=&#34;276px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;路由器1的路由表&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;目的地址&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;下一跳&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;端口&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;192.168.0.0/24&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;192.168.0.254/32&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;192.168.1.0/24&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;192.168.1.254/32&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;192.168.2.0/24&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;192.168.100.5&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;192.168.100.0/24&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;192.168.100.4/32&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;2&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以主机A发送给主机F数据包为例&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;（192.168.0.1）&lt;/strong&gt; 通过子网掩码 &lt;strong&gt;（255.255.255.0）&lt;/strong&gt; 计算出自己与 F &lt;strong&gt;（192.168.2.2）&lt;/strong&gt; 并不在同一个子网内，于是决定发送给默认网关 &lt;strong&gt;（192.168.0.254）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;A 通过 ARP 找到 默认网关 &lt;strong&gt;192.168.0.254&lt;/strong&gt; 的 MAC 地址 &lt;strong&gt;（ABAB）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;A 封装数据包
&lt;ul&gt;
&lt;li&gt;数据链路层头部
&lt;ul&gt;
&lt;li&gt;源 MAC 地址设置为A的MAC地址 &lt;strong&gt;（AAAA）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;目标MAC地址为网关 MAC 地址 &lt;strong&gt;（ABAB）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网络层头部
&lt;ul&gt;
&lt;li&gt;源 IP 地址设置为A的IP地址 &lt;strong&gt;（192.168.0.1）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;目的 IP 地址设置为F的IP地址 &lt;strong&gt;（192.168.2.2）&lt;/strong&gt;（从始至终这个数据包的两个 IP 地址都是不变的，只有 MAC 地址在不断变化）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交换机 1 收到数据包后，查询MAC地址表，目标 MAC 地址是 &lt;strong&gt;ABAB&lt;/strong&gt; ，从MAC地址表的指定端口转发给路由器1&lt;/li&gt;
&lt;li&gt;数据包来到了路由器 1，发现其目标 IP 地址是 &lt;strong&gt;192.168.2.2&lt;/strong&gt; ，查看其路由表，发现了下一跳的地址是 &lt;strong&gt;192.168.100.5&lt;/strong&gt; ，从映射端口发出数据包到路由器2
&lt;ul&gt;
&lt;li&gt;源MAC设置为路由器1的映射端口的MAC地址 &lt;strong&gt;（D1D1）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;目标MAC设置为下一跳的MAC地址 &lt;strong&gt;（D2D2）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;此时路由器 2 收到了数据包，看到其目标IP地址是 &lt;strong&gt;192.168.2.2&lt;/strong&gt; ，查询其路由表，准备从映射端口把数据包送出去。&lt;/li&gt;
&lt;li&gt;但此时路由器 2 需要知道 &lt;strong&gt;192.168.2.2&lt;/strong&gt; 的 MAC 地址了，于是查看其 arp 缓存，找到其 MAC 地址为 &lt;strong&gt;FFFF&lt;/strong&gt; ，将其封装在数据链路层头部，并从映射端口把包发出去。
&lt;ul&gt;
&lt;li&gt;源MAC设置为路由器2的映射端口的MAC地址 &lt;strong&gt;（EFEF）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;目标MAC设置为F的MAC地址 &lt;strong&gt;（FFFF）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交换机 3 收到了数据包，发现目的 MAC 地址为 &lt;strong&gt;FFFF&lt;/strong&gt; ，查询其 MAC 地址表，从映射端口把数据包发出去。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;F 最终收到了数据包&lt;/strong&gt;并且发现目的 MAC 地址就是自己，于是收下了这个包&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
