<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>操作系统 on Tyritic</title>
        <link>https://Tyritic.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
        <description>Recent content in 操作系统 on Tyritic</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Tyritic</copyright><atom:link href="https://Tyritic.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>操作系统的IO模型</title>
        <link>https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84io%E6%A8%A1%E5%9E%8B/</link>
        <pubDate>Sun, 16 Mar 2025 14:47:26 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84io%E6%A8%A1%E5%9E%8B/</guid>
        <description>&lt;h2 id=&#34;常见的io模型&#34;&gt;常见的IO模型
&lt;/h2&gt;&lt;h3 id=&#34;同步io型&#34;&gt;同步IO型
&lt;/h3&gt;&lt;h4 id=&#34;阻塞型io模型&#34;&gt;阻塞型IO模型
&lt;/h4&gt;&lt;p&gt;应用程序发起I/O操作后会被阻塞，直到操作完成才返回结果。期间调用方会被挂起，不能继续执行其他任务，直到请求的操作完成&lt;/p&gt;
&lt;p&gt;此时 阻塞等待的是&lt;strong&gt;内核数据准备好&lt;/strong&gt;和&lt;strong&gt;数据从内核态拷贝到用户态&lt;/strong&gt;这两个过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：实现简单，逻辑直观；调用后直接等待数据就绪。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：每个连接都需要一个线程，即使没有数据到达，线程也会被占用，导致资源浪费，不适合高并发场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84io%E6%A8%A1%E5%9E%8B/os-f06db5ff-661c-4ddf-9115-4ed9c9a21d01.png&#34;
	width=&#34;816&#34;
	height=&#34;485&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;阻塞I/O&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;168&#34;
		data-flex-basis=&#34;403px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;非阻塞型io模型&#34;&gt;非阻塞型IO模型
&lt;/h4&gt;&lt;p&gt;I/O操作不会阻塞进程，在非阻塞操作中，调用方在发出请求后立即返回。在没数据的时候，用户程序可以不再阻塞等着，而是直接返回错误，告知暂无准备就绪的数据，用户程序会通过轮询操作，不断发起 read 调用，直到内核中的数据拷贝就绪，才会停止发起 read 调用，这时调用方可以继续执行其他任务。&lt;/p&gt;
&lt;p&gt;但是 &lt;strong&gt;从内核拷贝到用户空间这一步，用户线程还是会被阻塞的&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：线程不会长时间阻塞，可以在无数据时执行其他任务；适用于部分实时性要求较高的场景。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：轮询方式会频繁进行系统调用，上下文切换开销较大，CPU 占用率较高，不适合大规模连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84io%E6%A8%A1%E5%9E%8B/os-771e014e-7ed9-4101-8bb5-4413b8069fd6.png&#34;
	width=&#34;813&#34;
	height=&#34;676&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;非阻塞I/O&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;120&#34;
		data-flex-basis=&#34;288px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;io复用模型&#34;&gt;IO复用模型
&lt;/h4&gt;&lt;p&gt;使用 &lt;strong&gt;&lt;code&gt;select&lt;/code&gt;&lt;/strong&gt; 、&lt;strong&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;code&gt;epoll&lt;/code&gt;&lt;/strong&gt; 等系统调用，允许程序同时等待多个I/O操作，当其中任意一个就绪时进行处理。当其中任何一个I/O操作准备就绪时，应用程序会被通知。通常使用select线程 ，可以往 select 线程注册需要被监听的连接，由 select 线程来监控它所管理的连接是否有数据已就绪，如果有则可以通知别的线程来 read 读取数据。&lt;/p&gt;
&lt;p&gt;但是 &lt;strong&gt;从内核拷贝到用户空间这一步，用户线程还是会被阻塞的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84io%E6%A8%A1%E5%9E%8B/os-86e54fa3-ad36-43c7-9d2d-5a68139c310f.png&#34;
	width=&#34;843&#34;
	height=&#34;667&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;基于非阻塞的I/O多路复用&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;126&#34;
		data-flex-basis=&#34;303px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;异步io型&#34;&gt;异步IO型
&lt;/h3&gt;&lt;p&gt;应用程序发起I/O操作后可以立即做其他事情，当I/O操作完成时，应用程序会得到通知。异步I/O模型由操作系统内核完成I/O操作，应用程序只需等待通知即可。&lt;/p&gt;
&lt;p&gt;异步 I/O 是 &lt;strong&gt;内核数据准备好&lt;/strong&gt; 和 &lt;strong&gt;数据从内核态拷贝到用户态&lt;/strong&gt; 这两个过程都不⽤等待。&lt;/p&gt;
&lt;p&gt;与多路复用模型的区别就是让内核直接把数据拷贝到用户空间之后再告知用户线程&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84io%E6%A8%A1%E5%9E%8B/os-869021ed-5e4e-4490-9174-7291d8ddf55c.png&#34;
	width=&#34;781&#34;
	height=&#34;614&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;异步/IO&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;127&#34;
		data-flex-basis=&#34;305px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;同步和异步的区别&#34;&gt;同步和异步的区别
&lt;/h3&gt;&lt;p&gt;同步和异步（Asynchronous） 是两种不同的任务执行方式，主要区别在于任务的执行是否需要等待其他任务完成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;同步&lt;/strong&gt; ：在同步操作中，任务需要等待前一个任务完成后才能继续。调用者发起请求后，会被阻塞，直到任务完成并返回结果。调用者必须等待结果才能进行后续操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步&lt;/strong&gt; ：在异步操作中，任务在发出请求后可以立即继续执行，不需要等待请求的完成。请求的结果会通过回调机制在任务完成后通知调用者。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;零拷贝技术&#34;&gt;零拷贝技术
&lt;/h2&gt;&lt;h3 id=&#34;解放cpu的技术-dma技术&#34;&gt;解放CPU的技术-DMA技术
&lt;/h3&gt;&lt;p&gt;传统的IO流程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态&lt;/li&gt;
&lt;li&gt;CPU 发出对应的指令给磁盘控制器，然后返回&lt;/li&gt;
&lt;li&gt;磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个&lt;strong&gt;中断&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84io%E6%A8%A1%E5%9E%8B/%E4%BC%A0%E7%BB%9FIO%E4%B8%AD%E6%96%AD.png&#34;
	width=&#34;1337&#34;
	height=&#34;785&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;传统中断流程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;170&#34;
		data-flex-basis=&#34;408px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。&lt;/p&gt;
&lt;p&gt;DMA（直接内存访问技术）：&lt;strong&gt;在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，CPU 就可以去处理别的事务&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DMA的工作流程&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态&lt;/li&gt;
&lt;li&gt;CPU收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务&lt;/li&gt;
&lt;li&gt;DMA 进一步将 I/O 请求发送给磁盘；&lt;/li&gt;
&lt;li&gt;磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中&lt;/li&gt;
&lt;li&gt;DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务&lt;/li&gt;
&lt;li&gt;当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；&lt;/li&gt;
&lt;li&gt;CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84io%E6%A8%A1%E5%9E%8B/DMA%E8%BF%87%E7%A8%8B.png&#34;
	width=&#34;1832&#34;
	height=&#34;860&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;DMA过程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;213&#34;
		data-flex-basis=&#34;511px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;CPU 不再参与将数据从 &lt;strong&gt;磁盘控制器缓冲区搬运到内核空间&lt;/strong&gt; 的工作，这部分工作全程由 DMA 完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DMA的模式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;突发传输模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一旦DMA控制器由处理器授权可以使用总线，就将系统总线的控制权交还給处理器之前传输数据块中的所有数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用场合：将程序或数据文件加载到内存中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：使处理器在相对较长的时间内处于活动状态&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;循环窃取模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一旦DMA控制器获得对系统总线的使用权就传输一个字节的数据然后将系统总线的控制权返还给处理器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多次发出请求直到填满整个数据块&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;透明模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DMA控制器只在CPU执行不使用系统总线的操作时传输数据，DMA控制器不需要请求系统总线的控制权&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优点：处理器不用停止执行程序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：确定处理器何时需要使用系统总线所需硬件相对复杂&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;传统文件传输技术&#34;&gt;传统文件传输技术
&lt;/h3&gt;&lt;p&gt;传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84io%E6%A8%A1%E5%9E%8B/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png&#34;
	width=&#34;1100&#34;
	height=&#34;678&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;传统文件传输&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;162&#34;
		data-flex-basis=&#34;389px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;期间共&lt;strong&gt;发生了 4 次用户态与内核态的上下文切换&lt;/strong&gt; ，因为发生了两次系统调用，一次是 &lt;strong&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/strong&gt; ，一次是 &lt;strong&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/strong&gt; ，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一次上下文切换：把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。&lt;/li&gt;
&lt;li&gt;第二次上下文切换：把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。&lt;/li&gt;
&lt;li&gt;第三次拷贝：把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。&lt;/li&gt;
&lt;li&gt;第四次拷贝：把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;零拷贝技术-1&#34;&gt;零拷贝技术
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;零拷贝（Zero-Copy）&lt;/strong&gt; 是一种高效的数据传输技术，它可以将数据从内核空间直接传输到应用程序的内存空间中，避免了不必要的数据拷贝，从而提高了数据传输的效率和性能。数据可以&lt;strong&gt;直接从外部设备复制到应用程序的内存空间中&lt;/strong&gt;，避免了&lt;strong&gt;中间的内核空间缓冲区&lt;/strong&gt;，减少了&lt;strong&gt;不必要的数据拷贝&lt;/strong&gt;，提高了&lt;strong&gt;数据传输的效率和性能&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;mmap--write&#34;&gt;mmap + write
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;mmap()&lt;/code&gt;&lt;/strong&gt; 系统调用函数会直接把内核缓冲区里的数据&lt;strong&gt;映射&lt;/strong&gt;到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用进程调用了 &lt;strong&gt;&lt;code&gt;mmap()&lt;/code&gt;&lt;/strong&gt; 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核共享这个缓冲区；&lt;/li&gt;
&lt;li&gt;应用进程再调用 &lt;strong&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/strong&gt;，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；&lt;/li&gt;
&lt;li&gt;最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84io%E6%A8%A1%E5%9E%8B/mmap%E5%92%8Cwrite%E9%9B%B6%E6%8B%B7%E8%B4%9D.png&#34;
	width=&#34;1100&#34;
	height=&#34;677&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;mmap实现&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;162&#34;
		data-flex-basis=&#34;389px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;sendfile&#34;&gt;sendfile
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;sendfile()&lt;/code&gt;&lt;/strong&gt; 可以替代前面的 &lt;strong&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/strong&gt; 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。这个系统调用可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84io%E6%A8%A1%E5%9E%8B/senfile-3%E6%AC%A1%E6%8B%B7%E8%B4%9D.png&#34;
	width=&#34;1100&#34;
	height=&#34;686&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;sendfile&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;160&#34;
		data-flex-basis=&#34;384px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;对于支持网卡支持 SG-DMA 技术的情况下， &lt;strong&gt;&lt;code&gt;sendfile()&lt;/code&gt;&lt;/strong&gt; 系统调用的过程得到优化，具体过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；&lt;/li&gt;
&lt;li&gt;缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84io%E6%A8%A1%E5%9E%8B/senfile-%E9%9B%B6%E6%8B%B7%E8%B4%9D.png&#34;
	width=&#34;1160&#34;
	height=&#34;686&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;SG-DMA&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;169&#34;
		data-flex-basis=&#34;405px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;网络模型&#34;&gt;网络模型
&lt;/h2&gt;&lt;h3 id=&#34;基本的socket模型&#34;&gt;基本的Socket模型
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84io%E6%A8%A1%E5%9E%8B/tcp_socket.png&#34;
	width=&#34;407&#34;
	height=&#34;722&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;socket模型&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;56&#34;
		data-flex-basis=&#34;135px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;服务端&#34;&gt;服务端
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;服务端首先调用 &lt;code&gt;socket()&lt;/code&gt; 函数，创建网络协议为 IPv4，以及传输协议为 TCP 的 Socket&lt;/li&gt;
&lt;li&gt;接着调用 &lt;code&gt;bind()&lt;/code&gt; 函数，给这个 Socket 绑定一个 &lt;strong&gt;IP 地址&lt;/strong&gt; 和 &lt;strong&gt;端口&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;绑定端口的目的：当内核收到 TCP 报文，通过 TCP 头里面的端口号，来找到应用程序，然后把数据传递给我们。&lt;/li&gt;
&lt;li&gt;绑定 IP 地址的目的：一台机器是可以有多个网卡的，每个网卡都有对应的 IP 地址，当绑定一个网卡时，内核在收到该网卡上的包，才会发给我们&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;listen()&lt;/code&gt; 函数进行监听&lt;/li&gt;
&lt;li&gt;服务端进入了监听状态后，通过调用 &lt;code&gt;accept()&lt;/code&gt; 函数，来从内核获取客户端的连接，如果没有客户端连接，则会阻塞等待客户端连接的到来。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 TCP 连接的过程中，服务器的内核实际上为每个 Socket 维护了两个队列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个是「还没完全建立」连接的队列，称为 &lt;strong&gt;TCP 半连接队列&lt;/strong&gt; ，这个队列都是没有完成三次握手的连接，此时服务端处于 &lt;code&gt;syn_rcvd&lt;/code&gt; 的状态；&lt;/li&gt;
&lt;li&gt;一个是「已经建立」连接的队列，称为 &lt;strong&gt;TCP 全连接队列&lt;/strong&gt; ，这个队列都是完成了三次握手的连接，此时服务端处于 &lt;code&gt;established&lt;/code&gt; 状态；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 TCP 全连接队列不为空后，服务端的 &lt;code&gt;accept()&lt;/code&gt; 函数，就会从内核中的 TCP 全连接队列里拿出一个已经完成连接的 Socket 返回应用程序，后续数据传输都用这个 Socket。&lt;/p&gt;
&lt;h4 id=&#34;客户端&#34;&gt;客户端
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;客户端创建好 Socket 后&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;connect()&lt;/code&gt; 函数发起连接，指明服务端的 IP 地址和端口号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;连接建立后，客户端和服务端就开始相互传输数据了，双方都可以通过 &lt;code&gt;read()&lt;/code&gt; 和 &lt;code&gt;write()&lt;/code&gt; 函数来读写数据。&lt;/p&gt;
&lt;h4 id=&#34;模型的限制&#34;&gt;模型的限制
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;文件描述符&lt;/strong&gt; ：Socket 实际上是一个文件，也就会对应一个文件描述符。在 Linux 下，单个进程打开的文件描述符数是有限制的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统内存&lt;/strong&gt; ：每个 TCP 连接在内核中都有对应的数据结构，意味着每个连接都是会占用一定内存的；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;多进程模型&#34;&gt;多进程模型
&lt;/h3&gt;&lt;p&gt;服务器的主进程负责监听客户的连接，一旦与客户端连接完成，accept() 函数就会返回一个「已连接 Socket」，这时就通过 &lt;code&gt;fork()&lt;/code&gt; 函数创建一个子进程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子进程会 &lt;strong&gt;复制父进程的文件描述符&lt;/strong&gt; ，于是就可以直接使用已连接 Socket 和客户端通信了&lt;/li&gt;
&lt;li&gt;父进程将客户端服务交给子进程来处理，因此父进程不需要关心已连接 Socket，只需要关心监听 Socket&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84io%E6%A8%A1%E5%9E%8B/%E5%A4%9A%E8%BF%9B%E7%A8%8B.png&#34;
	width=&#34;977&#34;
	height=&#34;407&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;多进程模型&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;240&#34;
		data-flex-basis=&#34;576px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;多线程模型&#34;&gt;多线程模型
&lt;/h3&gt;&lt;p&gt;当服务器与客户端 TCP 完成连接后，通过 &lt;code&gt;pthread_create()&lt;/code&gt; 函数创建线程，然后将已连接 Socket的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84io%E6%A8%A1%E5%9E%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png&#34;
	width=&#34;1382&#34;
	height=&#34;452&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;线程池&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;305&#34;
		data-flex-basis=&#34;733px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程池&lt;/strong&gt; 可以避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出「已连接 Socket 」进行处理。&lt;/p&gt;
&lt;h3 id=&#34;io多路复用模型&#34;&gt;IO多路复用模型
&lt;/h3&gt;&lt;h4 id=&#34;selectpoll模型&#34;&gt;select/poll模型
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;IO 多路复用是&lt;/strong&gt;指将已连接的 Socket 都放到一个文件描述符集合 ，然后调用函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生。&lt;/p&gt;
&lt;p&gt;检查的方式，就是通过&lt;strong&gt;遍历&lt;/strong&gt;文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合&lt;strong&gt;拷贝&lt;/strong&gt;回用户态里，然后用户态还需要再通过&lt;strong&gt;遍历&lt;/strong&gt;的方法找到可读或可写的 Socket，然后再对其处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;select&lt;/code&gt;&lt;/strong&gt; 模型和 &lt;strong&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/strong&gt; 模型没有本质区别，都是使用线性结构存储socket&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;select&lt;/code&gt;&lt;/strong&gt; 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/strong&gt; 使用动态数组，以链表形式来组织，突破了 &lt;strong&gt;&lt;code&gt;select&lt;/code&gt;&lt;/strong&gt; 的文件描述符个数限制&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;epoll模型&#34;&gt;epoll模型
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;epoll&lt;/code&gt;&lt;/strong&gt; 是Linux系统对 &lt;strong&gt;&lt;code&gt;select&lt;/code&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/strong&gt; 的优化。优化在以下方面。&lt;/p&gt;
&lt;p&gt;红黑树的使用：epoll 在内核里使用 &lt;strong&gt;红黑树&lt;/strong&gt; 代替线性结构跟踪进程所有待检测的文件描述符。红黑树的增删改一般时间复杂度是 $O(logn)$。相较于select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket，当事件发生时只需要传递活跃的文件描述符而不需要传递所有的文件描述符，减少了内核和用户空间大量的数据拷贝和内存分配。&lt;/p&gt;
&lt;p&gt;事件驱动的机制： epoll 使用 &lt;strong&gt;事件驱动&lt;/strong&gt; 的机制，内核里&lt;strong&gt;维护了一个链表来记录就绪事件&lt;/strong&gt; ，当某个 socket 有事件发生时，通过 &lt;strong&gt;回调函数&lt;/strong&gt; 内核会将其加入到这个就绪事件列表中，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。&lt;/p&gt;
&lt;p&gt;epoll提供了两种事件触发机制 &lt;strong&gt;边缘触发&lt;/strong&gt; 和 &lt;strong&gt;水平触发&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;边缘触发：当被监控的 Socket 描述符上有事件发生时， &lt;strong&gt;服务器端只会从 &lt;code&gt;epoll_wait&lt;/code&gt; 中苏醒一次，只会当事件发生时传递一次事件&lt;/strong&gt; ，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完&lt;/li&gt;
&lt;li&gt;水平触发：当被监控的 Socket 上有可读事件发生时，&lt;strong&gt;服务器端不断地从 &lt;code&gt;epoll_wait&lt;/code&gt; 中苏醒，一直不断地把这个事件传递给用户&lt;/strong&gt;，直到内核缓冲区数据被 read 函数读完才结束 ，目的是告诉我们有数据需要读取&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;高性能网络模式&#34;&gt;高性能网络模式
&lt;/h2&gt;&lt;h3 id=&#34;reactor模式&#34;&gt;Reactor模式
&lt;/h3&gt;&lt;p&gt;Reactor模式是对 I/O 多路复用作了一层封装，让使用者不用考虑底层网络 API 的细节，只需要关注应用代码的编写。&lt;/p&gt;
&lt;p&gt;Reactor模式的核心思想是 &lt;strong&gt;将I/O事件与相应的处理程序解耦&lt;/strong&gt; ，并通过 &lt;strong&gt;事件分发器&lt;/strong&gt; 来管理事件和响应操作。&lt;/p&gt;
&lt;h4 id=&#34;组成部分&#34;&gt;组成部分
&lt;/h4&gt;&lt;p&gt;Reactor 模式主要由 Reactor 和处理资源池这两个核心部分组成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Reactor： 负责监听和分发事件，它通常封装了一个多路复用器（如 &lt;strong&gt;&lt;code&gt;select&lt;/code&gt;&lt;/strong&gt; 、&lt;strong&gt;&lt;code&gt;epoll&lt;/code&gt;&lt;/strong&gt; ），在事件到达时将其分发给相应的事件处理器。&lt;/li&gt;
&lt;li&gt;Handler：负责处理事件，每个事件处理器与一个具体的I/O事件绑定，定义了在事件发生时应该执行的逻辑。&lt;/li&gt;
&lt;li&gt;Acceptor：在服务器端，&lt;strong&gt;&lt;code&gt;Acceptor&lt;/code&gt;&lt;/strong&gt; 用于接受新的客户端连接，并为每个新连接分配一个Handler进行后续的数据处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;工作流程&#34;&gt;工作流程
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Reactor&lt;/strong&gt; 通过多路复用器监听多个通道，等待事件（如连接到达、数据可读等）的发生。&lt;/li&gt;
&lt;li&gt;当某个通道有事件发生时，Reactor将事件分发给相应的 &lt;strong&gt;Handler&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Handler&lt;/strong&gt; 根据事件类型执行相应的操作，如读取数据、写入数据或处理业务逻辑。&lt;/li&gt;
&lt;li&gt;事件处理完成后，&lt;strong&gt;Reactor&lt;/strong&gt; 继续监听其他事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;proactor模式&#34;&gt;Proactor模式
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Proactor 是异步网络模式， 感知的是已完成的读写事件&lt;/strong&gt; 。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read/write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。&lt;/p&gt;
&lt;h4 id=&#34;工作流程-1&#34;&gt;工作流程
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Proactor Initiator 负责创建 Proactor 和 Handler 对象，并将 Proactor 和 Handler 都通过 Asynchronous Operation Processor 注册到内核；&lt;/li&gt;
&lt;li&gt;Asynchronous Operation Processor 负责处理注册请求，并处理 I/O 操作&lt;/li&gt;
&lt;li&gt;Asynchronous Operation Processor 完成 I/O 操作后通知 Proactor&lt;/li&gt;
&lt;li&gt;Proactor 根据不同的事件类型回调不同的 Handler 进行业务处理&lt;/li&gt;
&lt;li&gt;Handler 完成业务处理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84io%E6%A8%A1%E5%9E%8B/Proactor.png&#34;
	width=&#34;1427&#34;
	height=&#34;654&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Proactor模式&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;218&#34;
		data-flex-basis=&#34;523px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;reactor模式和proactor模式的区别&#34;&gt;Reactor模式和Proactor模式的区别
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件&lt;/strong&gt; ：在每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Proactor 是异步网络模式， 感知的是已完成的读写事件&lt;/strong&gt; ：在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read/write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>操作系统的文件系统</title>
        <link>https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link>
        <pubDate>Fri, 14 Mar 2025 17:35:09 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid>
        <description>&lt;h2 id=&#34;文件系统的概念&#34;&gt;文件系统的概念
&lt;/h2&gt;&lt;p&gt;文件系统是操作系统中负责管理持久数据的子系统&lt;/p&gt;
&lt;p&gt;文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。&lt;/p&gt;
&lt;p&gt;对于Linux系统 &lt;strong&gt;一切皆文件&lt;/strong&gt;，除了普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。&lt;/p&gt;
&lt;h2 id=&#34;文件的结构&#34;&gt;文件的结构
&lt;/h2&gt;&lt;p&gt;Linux 文件系统会为每个文件分配两个数据结构：索引节点（index node）和目录项（directory entry），它们主要用来记录文件的元信息和目录层次结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引节点：用来记录文件的元信息，比如文件大小、访问权限、创建时间、修改时间、 &lt;strong&gt;数据在磁盘的位置&lt;/strong&gt; 等等。索引节点是文件的 &lt;strong&gt;唯一&lt;/strong&gt; 标识，它们之间一一对应，也同样都会被存储在硬盘中，所以 &lt;strong&gt;索引节点同样占用磁盘空间&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;目录项：用来记录文件的名字、&lt;strong&gt;索引节点指针&lt;/strong&gt; 以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是， &lt;strong&gt;目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目录项和索引节点的关系是多对一，一个文件可以有多个别名&lt;/p&gt;
&lt;style type=&#34;text/css&#34;&gt;
   
  .notice {
    --title-color: #fff;
    --title-background-color: #6be;
    --content-color: #444;
    --content-background-color: #e7f2fa;
  }

  .notice.info {
    --title-background-color: #fb7;
    --content-background-color: #fec;
  }

  .notice.tip {
    --title-background-color: #5a5;
    --content-background-color: #efe;
  }

  .notice.warning {
    --title-background-color: #c33;
    --content-background-color: #fee;
  }

   
  @media (prefers-color-scheme: dark) {
    .notice {
      --title-color: #fff;
      --title-background-color: #069;
      --content-color: #ddd;
      --content-background-color: #023;
    }

    .notice.info {
      --title-background-color: #a50;
      --content-background-color: #420;
    }

    .notice.tip {
      --title-background-color: #363;
      --content-background-color: #121;
    }

    .notice.warning {
      --title-background-color: #800;
      --content-background-color: #400;
    }
  }

  body.dark .notice {
    --title-color: #fff;
    --title-background-color: #069;
    --content-color: #ddd;
    --content-background-color: #023;
  }

  body.dark .notice.info {
    --title-background-color: #a50;
    --content-background-color: #420;
  }

  body.dark .notice.tip {
    --title-background-color: #363;
    --content-background-color: #121;
  }

  body.dark .notice.warning {
    --title-background-color: #800;
    --content-background-color: #400;
  }

   
  .notice {
    width: 100%;  
    max-width: 600px;  
    padding: 18px;
    line-height: 24px;
    margin-bottom: 24px;
    border-radius: 4px;
    color: var(--content-color);
    background: var(--content-background-color);
  }

  .notice p:last-child {
    margin-bottom: 0;
  }

   
  .notice-title {
    margin: -18px -18px 12px;
    padding: 4px 18px;
    border-radius: 4px 4px 0 0;
    font-weight: 700;
    color: var(--title-color);
    background: var(--title-background-color);
  }

   
  .icon-notice {
    display: inline-flex;
    align-self: center;
    margin-right: 8px;
  }

  .icon-notice img,
  .icon-notice svg {
    height: 1em;
    width: 1em;
    fill: currentColor;
  }

  .icon-notice img,
  .icon-notice.baseline svg {
    top: 0.125em;
    position: relative;
  }
&lt;/style&gt;&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;目录项和目录的关系和区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;目录是个文件，持久化存储在磁盘&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目录项是内核维护数据结构，缓存在内存。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E7%9B%AE%E5%BD%95%E9%A1%B9%E5%92%8C%E7%B4%A2%E5%BC%95%E5%85%B3%E7%B3%BB%E5%9B%BE.png&#34;
	width=&#34;1172&#34;
	height=&#34;842&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;目录项和索引节点&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;139&#34;
		data-flex-basis=&#34;334px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;虚拟文件系统&#34;&gt;虚拟文件系统
&lt;/h2&gt;&lt;p&gt;操作系统 &lt;strong&gt;对用户提供一个统一的接口&lt;/strong&gt; ，于是在用户层与文件系统层引入了虚拟文件系统作为中间层&lt;/p&gt;
&lt;p&gt;虚拟文件系统定义了一组所有文件系统都支持的数据结构和标准接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%5c%e8%99%9a%e6%8b%9f%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;虚拟文件系统&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁盘的文件系统：直接把数据存储在磁盘中&lt;/li&gt;
&lt;li&gt;内存的文件系统：数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 &lt;code&gt;/proc&lt;/code&gt; 和 &lt;code&gt;/sys&lt;/code&gt; 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据。&lt;/li&gt;
&lt;li&gt;网络的文件系统：用来访问其他计算机主机数据的文件系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文件系统首先要先挂载到某个目录才可以正常使用&lt;/p&gt;
&lt;h2 id=&#34;linux系统的目录树&#34;&gt;Linux系统的目录树
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%E7%9B%AE%E5%BD%95%E6%A0%91-DzjzZEII.png&#34;
	width=&#34;823&#34;
	height=&#34;315&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Linux的目录结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;261&#34;
		data-flex-basis=&#34;627px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;目录树由根目录（/）作为起始点，向下延伸，形成一系列的目录和子目录。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;/bin：&lt;/strong&gt; 存放二进制可执行文件(ls、cat、mkdir 等)，常用命令一般都在这里；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/etc：&lt;/strong&gt; 存放系统管理和配置文件；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/home：&lt;/strong&gt; 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是/home/user，可以用~user 表示；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/usr：&lt;/strong&gt; 用于存放系统应用程序；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/opt：&lt;/strong&gt; 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/proc：&lt;/strong&gt; 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/root：&lt;/strong&gt; 超级用户（系统管理员）的主目录（特权阶级^o^）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/sbin:&lt;/strong&gt; 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/dev：&lt;/strong&gt; 用于存放设备文件；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/mnt：&lt;/strong&gt; 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/boot：&lt;/strong&gt; 存放用于系统引导时使用的各种文件；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/lib 和/lib64：&lt;/strong&gt; 存放着和系统运行相关的库文件 ；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/tmp：&lt;/strong&gt; 用于存放各种临时文件，是公用的临时文件存储点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/var：&lt;/strong&gt; 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/lost+found：&lt;/strong&gt; 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;软链接和硬链接&#34;&gt;软链接和硬链接
&lt;/h2&gt;&lt;p&gt;在 Linux系统上，文件链接是一种特殊的文件类型，可以在文件系统中指向另一个文件。&lt;/p&gt;
&lt;h3 id=&#34;硬链接&#34;&gt;硬链接
&lt;/h3&gt;&lt;p&gt;硬链接是为 &lt;strong&gt;同一个文件创建多个目录项&lt;/strong&gt; ，也就是指向同一个索引节点。由于多个目录项都是指向一个索引节点，那么 &lt;strong&gt;只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。&lt;/strong&gt; 硬链接具有一些限制，不能对目录以及不存在的文件创建硬链接，并且，硬链接也不能跨越文件系统。&lt;/p&gt;
&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;为什么硬链接不能跨域文件系统&lt;/p&gt;
&lt;p&gt;硬链接是 &lt;strong&gt;多个目录项中的索引节点指向一个文件&lt;/strong&gt; ，也就是指向同一个索引节点。索引节点是不可能跨越文件系统的，每个文件系统都有各自的索引节点数据结构和列表，所以&lt;strong&gt;硬链接是不可用于跨文件系统的&lt;/strong&gt;。&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E9%93%BE%E6%8E%A5-2.png&#34;
	width=&#34;1154&#34;
	height=&#34;624&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;硬链接&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;184&#34;
		data-flex-basis=&#34;443px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;软链接&#34;&gt;软链接
&lt;/h3&gt;&lt;p&gt;软链接本质上是一个特殊类型的文件，这个文件有 &lt;strong&gt;独立的索引节点&lt;/strong&gt; ，但是这个 &lt;strong&gt;文件的内容是另外一个文件的路径&lt;/strong&gt; ，类似于Windows系统的快捷方式，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以 &lt;strong&gt;软链接是可以跨文件系统的&lt;/strong&gt; ，即使&lt;strong&gt;目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E8%BD%AF%E9%93%BE%E6%8E%A5.png&#34;
	width=&#34;1232&#34;
	height=&#34;642&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;软链接&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;191&#34;
		data-flex-basis=&#34;460px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>操作系统的内存管理</title>
        <link>https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
        <pubDate>Fri, 14 Mar 2025 14:46:12 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
        <description>&lt;h2 id=&#34;虚拟内存&#34;&gt;虚拟内存
&lt;/h2&gt;&lt;h3 id=&#34;虚拟内存的定义&#34;&gt;虚拟内存的定义
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;虚拟内存&lt;/strong&gt; 是计算机系统内存管理非常重要的一个技术，本质上来说它只是逻辑存在的，是一个假想出来的内存空间，主要作用是作为进程访问主存（物理内存）的桥梁并简化内存管理。每个程序在运行时认为自己拥有的内存空间就是虚拟内存，其大小可以远远大于物理内存的大小。&lt;/p&gt;
&lt;h3 id=&#34;虚拟内存的存在意义&#34;&gt;虚拟内存的存在意义
&lt;/h3&gt;&lt;p&gt;如果直接操作物理地址的话，存在以下的问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易破坏操作系统，造成操作系统崩溃。&lt;/li&gt;
&lt;li&gt;同时运行多个程序会特别困难，当两个用户程序引用同一个物理地址时会导致程序崩溃&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而在进程和物理内存之间添加一个中间层虚拟地址，就可以解决这个问题。因为进程不会直接操作物理地址，导致多个进程不会同时引用同一个物理地址&lt;/p&gt;
&lt;h3 id=&#34;虚拟地址的原理&#34;&gt;虚拟地址的原理
&lt;/h3&gt;&lt;p&gt;虚拟地址作为中间层把进程所使用的地址隔离开来（让操作系统为每个进程分配独立的一套 &lt;strong&gt;虚拟地址&lt;/strong&gt; ，进程之间的地址是隔离的，互不干涉。前提每个进程都不能访问物理地址。至于虚拟地址最终怎么映射到物理内存里，对进程来说是透明的，操作系统将决定虚拟地址和物理地址的映射关系&lt;/p&gt;
&lt;p&gt;程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。&lt;/p&gt;
&lt;style type=&#34;text/css&#34;&gt;
   
  .notice {
    --title-color: #fff;
    --title-background-color: #6be;
    --content-color: #444;
    --content-background-color: #e7f2fa;
  }

  .notice.info {
    --title-background-color: #fb7;
    --content-background-color: #fec;
  }

  .notice.tip {
    --title-background-color: #5a5;
    --content-background-color: #efe;
  }

  .notice.warning {
    --title-background-color: #c33;
    --content-background-color: #fee;
  }

   
  @media (prefers-color-scheme: dark) {
    .notice {
      --title-color: #fff;
      --title-background-color: #069;
      --content-color: #ddd;
      --content-background-color: #023;
    }

    .notice.info {
      --title-background-color: #a50;
      --content-background-color: #420;
    }

    .notice.tip {
      --title-background-color: #363;
      --content-background-color: #121;
    }

    .notice.warning {
      --title-background-color: #800;
      --content-background-color: #400;
    }
  }

  body.dark .notice {
    --title-color: #fff;
    --title-background-color: #069;
    --content-color: #ddd;
    --content-background-color: #023;
  }

  body.dark .notice.info {
    --title-background-color: #a50;
    --content-background-color: #420;
  }

  body.dark .notice.tip {
    --title-background-color: #363;
    --content-background-color: #121;
  }

  body.dark .notice.warning {
    --title-background-color: #800;
    --content-background-color: #400;
  }

   
  .notice {
    width: 100%;  
    max-width: 600px;  
    padding: 18px;
    line-height: 24px;
    margin-bottom: 24px;
    border-radius: 4px;
    color: var(--content-color);
    background: var(--content-background-color);
  }

  .notice p:last-child {
    margin-bottom: 0;
  }

   
  .notice-title {
    margin: -18px -18px 12px;
    padding: 4px 18px;
    border-radius: 4px 4px 0 0;
    font-weight: 700;
    color: var(--title-color);
    background: var(--title-background-color);
  }

   
  .icon-notice {
    display: inline-flex;
    align-self: center;
    margin-right: 8px;
  }

  .icon-notice img,
  .icon-notice svg {
    height: 1em;
    width: 1em;
    fill: currentColor;
  }

  .icon-notice img,
  .icon-notice.baseline svg {
    top: 0.125em;
    position: relative;
  }
&lt;/style&gt;&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;虚拟内存地址&lt;/strong&gt; ：程序所使用的内存地址，由CPU生成，用于内存的访问和操作。逻辑地址在程序编写和编译时使用，并由操作系统通过地址转换机制（如页表）映射到物理地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;物理内存地址&lt;/strong&gt; ：实际存在硬件里面的空间地址，由内存管理单元（MMU）直接访问。它表示数据在物理内存中的实际存储位置，是由硬件层面决定的。物理地址直接对应到内存芯片上的某个位置，它是CPU在访问内存时经过地址转换后的实际地址&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/72ab76ba697e470b8ceb14d5fc5688d9.png&#34;
	width=&#34;831&#34;
	height=&#34;539&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;虚拟内存的使用&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;154&#34;
		data-flex-basis=&#34;370px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;虚拟内存的优点&#34;&gt;虚拟内存的优点
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;内存扩展能力：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟内存允许程序运行在比实际物理内存大的地址空间上。即使物理内存不足，系统也可以通过交换（swapping）将不常用的内存页移到磁盘中，使得多个程序能够同时运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;进程隔离：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个进程拥有独立的虚拟地址空间，防止进程间的内存访问冲突，提高系统稳定性和安全性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用虚拟内存，操作系统可以通过页面表设置访问权限，防止非法访问。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;简化内存管理：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;操作系统可以更灵活地分配和回收内存，无需手动考虑物理内存布局问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚拟内存可以将程序逻辑地址与物理地址解耦。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;物理地址和虚拟地址的映射管理方式&#34;&gt;物理地址和虚拟地址的映射管理方式
&lt;/h2&gt;&lt;h3 id=&#34;分段管理&#34;&gt;分段管理
&lt;/h3&gt;&lt;p&gt;将程序视为若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，同时具有实际意义和逻辑信息。将程序以段的形式进行划分，&lt;strong&gt;连续&lt;/strong&gt; 的物理内存的形式管理/分配物理内存&lt;/p&gt;
&lt;h4 id=&#34;分段管理下的虚拟地址&#34;&gt;分段管理下的虚拟地址
&lt;/h4&gt;&lt;p&gt;分段机制下的虚拟地址由两部分组成：&lt;strong&gt;段选择因子&lt;/strong&gt; 和 &lt;strong&gt;段内偏移量&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;段选择因子&lt;/strong&gt; ：保存在段寄存器里面
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;段号&lt;/strong&gt; ：用作段表的索引，标识这个段在虚拟地址的哪一段&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;段标志位&lt;/strong&gt; ：某些特权位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;段内偏移量&lt;/strong&gt; ：相对于该段的起始地址的偏移量，位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/a9ed979e2ed8414f9828767592aadc21.png&#34;
	width=&#34;1382&#34;
	height=&#34;1004&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;虚拟地址的结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;137&#34;
		data-flex-basis=&#34;330px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;分段管理下的地址映射&#34;&gt;分段管理下的地址映射
&lt;/h4&gt;&lt;p&gt;虚拟地址是通过 &lt;strong&gt;段表&lt;/strong&gt; 与物理地址进行映射的。&lt;strong&gt;段表&lt;/strong&gt; 里面保存的是这个 &lt;strong&gt;段的基地址、段的界限和特权等级&lt;/strong&gt; 等。&lt;/p&gt;
&lt;p&gt;分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，由MMU进行地址翻译&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MMU 首先解析得到虚拟地址中的段号&lt;/li&gt;
&lt;li&gt;通过段号去该应用程序的段表中取出对应的段信息（找到对应的段表项）&lt;/li&gt;
&lt;li&gt;从段信息中取出该段的起始地址（物理地址）加上虚拟地址中的段内偏移量得到最终的物理地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/c5e2ab63e6ee4c8db575f3c7c9c85962.png&#34;
	width=&#34;1055&#34;
	height=&#34;651&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;地址映射过程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;162&#34;
		data-flex-basis=&#34;388px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;分段管理的缺点&#34;&gt;分段管理的缺点
&lt;/h4&gt;&lt;p&gt;分段管理会产生 &lt;strong&gt;外部碎片&lt;/strong&gt;  。每个段的长度不固定，所以多个段未必能恰好使用所有的内存空间，会产生了多个不连续的小物理内存，导致新的程序无法被装载&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/6142bc3c917e4a6298bdb62936e0d332.png&#34;
	width=&#34;1518&#34;
	height=&#34;806&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;外部碎片&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;188&#34;
		data-flex-basis=&#34;452px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;解决方法：&lt;strong&gt;内存交换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以通过将整块的内存先写入硬盘然后在读入内存，但是读入内存时不会占据原来的内存位置而是尽量和其他的整块内存相连，使得原来碎片化的内存合并起来。&lt;/p&gt;
&lt;h3 id=&#34;分页管理&#34;&gt;分页管理
&lt;/h3&gt;&lt;p&gt;分页管理是把整个虚拟和物理内存空间切成⼀段段连续且尺寸固定的内存空间。其中在虚拟内存称为 &lt;strong&gt;页&lt;/strong&gt; ，在物理内存的称为 &lt;strong&gt;页框&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;页和页框的大小相同，在Linux系统中大小为4KB。页表保存了页和页框之间的映射关系&lt;/p&gt;
&lt;h4 id=&#34;分页管理下的虚拟地址&#34;&gt;分页管理下的虚拟地址
&lt;/h4&gt;&lt;p&gt;在分页机制下，虚拟地址分为两部分，&lt;strong&gt;页号&lt;/strong&gt; 和 &lt;strong&gt;页内偏移&lt;/strong&gt; 。页号作为页表的索引，&lt;strong&gt;页表&lt;/strong&gt; 包含物理页每页所在 &lt;strong&gt;物理内存的基地址&lt;/strong&gt; ，这个基地址与页内偏移的组合就形成了物理内存地址。地址翻译依然由MMU完成&lt;/p&gt;
&lt;h4 id=&#34;分页管理下的地址映射&#34;&gt;分页管理下的地址映射
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;MMU 首先解析得到虚拟地址中的虚拟页号&lt;/li&gt;
&lt;li&gt;通过虚拟页号去该应用程序的页表中取出对应的物理页号（找到对应的页表项）&lt;/li&gt;
&lt;li&gt;用该物理页号对应的物理页起始地址（物理地址）加上虚拟地址中的页内偏移量得到最终的物理地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/7884f4d8db4949f7a5bb4bbd0f452609.png&#34;
	width=&#34;1067&#34;
	height=&#34;797&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;地址翻译过程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;321px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;当页表中的页表项未被命中时，代表物理内存中没有对应的物理页或者物理内存中有对应的物理页但虚拟页还未和物理页建立映射（对应的页表项不存在）就会抛出缺页异常。此时系统进入内核态，针对不同类型的缺页中断进行操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;硬性页缺失&lt;/strong&gt; ：物理内存中没有对应的物理页。于是，Page Fault Handler 会指示 CPU 从已经打开的磁盘文件中读取相应的内容到物理内存，而后交由 MMU 建立相应的虚拟页和物理页的映射关系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;软性页缺失&lt;/strong&gt; ：物理内存中有对应的物理页，但虚拟页还未和物理页建立映射。于是，Page Fault Handler 会指示 MMU 建立相应的虚拟页和物理页的映射关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果没有空闲的物理内存，那么内核就会开始进行 &lt;strong&gt;回收内存&lt;/strong&gt; 的工作，回收的方式主要是两种：直接内存回收和后台内存回收。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;后台内存回收&lt;/strong&gt; ：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程&lt;strong&gt;异步&lt;/strong&gt;的，不会阻塞进程的执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;直接内存回收&lt;/strong&gt; ：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是&lt;strong&gt;同步&lt;/strong&gt;的，会阻塞进程的执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;分页管理下的内存交换&#34;&gt;分页管理下的内存交换
&lt;/h4&gt;&lt;p&gt;当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间会被临时保存到磁盘，等到那些程序要运行时，再从磁盘中恢复保存的数据到内存中。&lt;/p&gt;
&lt;p&gt;内存交换 就是把一块磁盘空间或者本地文件，当成内存来使用，它包含换出和换入两个过程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;换出&lt;/strong&gt; ：把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;换入&lt;/strong&gt; ：在进程再次访问这些内存的时候，把它们从磁盘读到内存中来&lt;/li&gt;
&lt;/ul&gt;
&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;
  &lt;p&gt;当内存资源不足时，Linux 把某些页的内容转移至磁盘上的一块空间上，以释放内存空间。磁盘上的那块空间叫做交换空间（swap space），而这一过程被称为交换。物理内存和交换空间的总容量就是虚拟内存的可用容量。&lt;/p&gt;
  &lt;/div&gt;

&lt;h4 id=&#34;分页管理的优缺点&#34;&gt;分页管理的优缺点
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;优点
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;解决了外部碎片的问题&lt;/strong&gt; ：由于页和页框大小固定，可以有效避免分段方式中段间未使用内存造成的外部碎片问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存管理灵活&lt;/strong&gt;：页表支持页的按需加载和交换（如虚拟内存机制），可以将不常用的页交换到磁盘上，从而扩大进程的可用内存空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内部碎片&lt;/strong&gt; ：如果程序使用的内存量不足一个页的大小，会造成页内未使用部分的浪费，即内部碎片问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;页表管理开销大&lt;/strong&gt; ：每个进程都需要维护自己的页表，页表的大小与逻辑地址空间成正比。多级页表虽然节省了内存，但增加了地址转换的复杂性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;页面置换算法&#34;&gt;页面置换算法
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;先进先出置换算法&lt;/strong&gt; ：基本思路是，优先淘汰最早进入内存的页面。FIFO 算法维护一个队列，新来的页面加入队尾，当发生页面置换时，队头的页面（即最早进入内存的页面）被移出。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最少使用页面置换算法（LFU）&lt;/strong&gt; : 置换算法选择的是之前一段时间内使用最少的页面作为淘汰页。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时钟页面置换算法&lt;/strong&gt; ：LRU 的一种近似和实现简单的形式。它通过一个循环列表（类似时钟的指针）遍历页面，每个页面有一个使用位，当页面被访问时，使用位设置为 1。当需要页面置换时，时钟指针会顺时针移动，直到找到使用位为 0 的页面进行置换。这个过程类似于给每个页面一个二次机会。算法执行时，会先将使用位从 1 清零，如果该页面再次被访问，它的使用位再次被设置为 1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最近最久未使用页面置换算法（LRU）&lt;/strong&gt; ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>操作系统的进程管理和线程管理</title>
        <link>https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/</link>
        <pubDate>Thu, 13 Feb 2025 15:10:49 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/</guid>
        <description>&lt;h2 id=&#34;进程&#34;&gt;进程
&lt;/h2&gt;&lt;p&gt;在系统中正在运行的一个应用程序；程序一旦运行会被载入内存。进程是资源分配的最小单位。在操作系统中能同时运行多个进程；&lt;/p&gt;
&lt;p&gt;进程可以分成以下两类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用户态进程&lt;/strong&gt; ：通常是应用程序的副本&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内核态进程&lt;/strong&gt; ：内核本身的进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果用户态进程需要申请资源，比如内存，可以通过系统调用向内核申请。&lt;/p&gt;
&lt;p&gt;每个进程都有独立的内存空间，存放代码和数据段等，程序之间的切换会有较大的开销&lt;/p&gt;
&lt;h3 id=&#34;并发和并行&#34;&gt;并发和并行
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;并发：在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行。
&lt;ul&gt;
&lt;li&gt;单核处理器做到的并发，其实是利用时间片的轮转，例如有两个进程 A 和 B，A 运行一个时间片之后，切换到 B，B 运行一个时间片之后又切换到 A。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;并行：在同一时刻，有多个任务在执行。这个需要多核处理器才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/5-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C.jpg&#34;
	width=&#34;672&#34;
	height=&#34;548&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;并发与并行&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;122&#34;
		data-flex-basis=&#34;294px&#34;
	
&gt;行&lt;/p&gt;
&lt;p&gt;进程之间是独立和隔离的，一个进程崩溃不会导致所有进程崩溃&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程隔离性&lt;/strong&gt;：每个进程都有自己独立的内存空间，当一个进程崩溃时，其内存空间会被操作系统回收，不会影响其他进程的内存空间。这种进程间的隔离性保证了一个进程崩溃不会直接影响其他进程的执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程独立性&lt;/strong&gt;：每个进程都是独立运行的，它们之间不会共享资源，如文件、网络连接等。因此，一个进程的崩溃通常不会对其他进程的资源产生影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程的状态&#34;&gt;进程的状态
&lt;/h3&gt;&lt;h4 id=&#34;进程状态&#34;&gt;进程状态
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建状态（new）：进程正在被创建时的状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;就绪状态（Ready）：进程处于可运行，进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。由于其他进程处于运行状态而暂时停止运行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行状态（Running）：进程正在处理器上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阻塞状态（Blocked）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结束状态（Exit）：进程正在从系统中消失时的状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/8-%E8%BF%9B%E7%A8%8B%E4%BA%94%E4%B8%AA%E7%8A%B6%E6%80%81.jpg&#34;
	width=&#34;1007&#34;
	height=&#34;332&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;进程状态的变迁&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;303&#34;
		data-flex-basis=&#34;727px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;进程挂起&#34;&gt;进程挂起
&lt;/h4&gt;&lt;p&gt;如果有大量处于阻塞状态的进程，进程可能会占用着物理内存空间，出现浪费物理内存的行为。所以，在虚拟内存管理的操作系统中，通常会把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存。&lt;/p&gt;
&lt;p&gt;挂起状态用来描述 &lt;strong&gt;进程没有占用实际的物理内存空间的情况&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现&lt;/li&gt;
&lt;li&gt;就绪挂起状态：进程在外存（硬盘），但只要进入内存，即刻立刻运行&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;僵尸进程&#34;&gt;僵尸进程
&lt;/h4&gt;&lt;p&gt;僵尸进程是已完成且处于终止状态，但在进程表中却仍然存在的进程。（进程已经终止，但其父进程未对其进行回收）&lt;/p&gt;
&lt;p&gt;僵尸进程占用系统的进程表项，但不再消耗其他资源。操作系统会等待其父进程来获取它的终止状态信息，清除僵尸进程。&lt;/p&gt;
&lt;p&gt;僵尸进程一般发生有父子关系的进程中，一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 &lt;strong&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/strong&gt; 或 &lt;strong&gt;&lt;code&gt;waitpid()&lt;/code&gt;&lt;/strong&gt; 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 &lt;strong&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/strong&gt; 或 &lt;strong&gt;&lt;code&gt;waitpid()&lt;/code&gt;&lt;/strong&gt; ，那么子进程的进程描述符仍然保存在系统中。&lt;/p&gt;
&lt;h4 id=&#34;孤儿进程&#34;&gt;孤儿进程
&lt;/h4&gt;&lt;p&gt;父进程提前终止，子进程继续运行，这些子进程就成为孤儿进程。操作系统会将孤儿进程托管给 &lt;strong&gt;&lt;code&gt;init&lt;/code&gt;&lt;/strong&gt; 进程（Linux系统中的PID为1的进程），由 &lt;strong&gt;&lt;code&gt;init&lt;/code&gt;&lt;/strong&gt; 进程来收养并清理这些孤儿进程。&lt;/p&gt;
&lt;h3 id=&#34;进程控制块pcb&#34;&gt;进程控制块PCB
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;PCB 是进程存在的唯一标识&lt;/strong&gt; 。一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。&lt;/p&gt;
&lt;h4 id=&#34;pcb的结构&#34;&gt;PCB的结构
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;进程描述信息&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;进程控制和管理信息&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;进程当前状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程优先级：进程抢占 CPU 时的优先级；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;资源分配清单&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有关内存地址空间或虚拟地址空间的信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所打开文件的列表和所使用的 I/O 设备信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CPU 相关信息&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;pcb之间的组织&#34;&gt;PCB之间的组织
&lt;/h4&gt;&lt;p&gt;通常是通过 &lt;strong&gt;链表&lt;/strong&gt; 的方式进行组织。&lt;strong&gt;相同状态的进程会被链接在一起，组成各种队列&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;进程的控制&#34;&gt;进程的控制
&lt;/h3&gt;&lt;h4 id=&#34;创建进程&#34;&gt;创建进程
&lt;/h4&gt;&lt;p&gt;操作系统提供了 &lt;strong&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/strong&gt; 指令，允许一个进程创建另一个进程，而且允许子进程继承父进程所拥有的资源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20250313154646.jpg&#34;
	width=&#34;847&#34;
	height=&#34;824&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;fork进程&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;102&#34;
		data-flex-basis=&#34;246px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/strong&gt; 函数用于创建一个与当前进程一样的子进程，所创建的子进程将复制父进程的代码段、数据段、堆、栈等所有用户空间信息，在内核中操作系统会重新为其申请一个子进程执行的位置。但是会有自己的进程空间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/strong&gt; 函数被调用一次但返回两次，两次返回的唯一区别是子进程中返回0而父进程中返回子进程ID。&lt;/p&gt;
&lt;style type=&#34;text/css&#34;&gt;
   
  .notice {
    --title-color: #fff;
    --title-background-color: #6be;
    --content-color: #444;
    --content-background-color: #e7f2fa;
  }

  .notice.info {
    --title-background-color: #fb7;
    --content-background-color: #fec;
  }

  .notice.tip {
    --title-background-color: #5a5;
    --content-background-color: #efe;
  }

  .notice.warning {
    --title-background-color: #c33;
    --content-background-color: #fee;
  }

   
  @media (prefers-color-scheme: dark) {
    .notice {
      --title-color: #fff;
      --title-background-color: #069;
      --content-color: #ddd;
      --content-background-color: #023;
    }

    .notice.info {
      --title-background-color: #a50;
      --content-background-color: #420;
    }

    .notice.tip {
      --title-background-color: #363;
      --content-background-color: #121;
    }

    .notice.warning {
      --title-background-color: #800;
      --content-background-color: #400;
    }
  }

  body.dark .notice {
    --title-color: #fff;
    --title-background-color: #069;
    --content-color: #ddd;
    --content-background-color: #023;
  }

  body.dark .notice.info {
    --title-background-color: #a50;
    --content-background-color: #420;
  }

  body.dark .notice.tip {
    --title-background-color: #363;
    --content-background-color: #121;
  }

  body.dark .notice.warning {
    --title-background-color: #800;
    --content-background-color: #400;
  }

   
  .notice {
    width: 100%;  
    max-width: 600px;  
    padding: 18px;
    line-height: 24px;
    margin-bottom: 24px;
    border-radius: 4px;
    color: var(--content-color);
    background: var(--content-background-color);
  }

  .notice p:last-child {
    margin-bottom: 0;
  }

   
  .notice-title {
    margin: -18px -18px 12px;
    padding: 4px 18px;
    border-radius: 4px 4px 0 0;
    font-weight: 700;
    color: var(--title-color);
    background: var(--title-background-color);
  }

   
  .icon-notice {
    display: inline-flex;
    align-self: center;
    margin-right: 8px;
  }

  .icon-notice img,
  .icon-notice svg {
    height: 1em;
    width: 1em;
    fill: currentColor;
  }

  .icon-notice img,
  .icon-notice.baseline svg {
    top: 0.125em;
    position: relative;
  }
&lt;/style&gt;&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;fork函数为什么被调用一次但是返回两次&lt;/p&gt;
&lt;p&gt;因为复制时会复制父进程的堆栈段，所以两个进程都停留在 &lt;strong&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/strong&gt; 函数中等待返回，因此会返回两次，一个是在父进程中返回，一次是在子进程中返回，两次返回值是不一样的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在父进程中将返回新建子进程的进程ID&lt;/li&gt;
&lt;li&gt;在子进程中将返回0&lt;/li&gt;
&lt;li&gt;若出现错误则返回一个负数&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/strong&gt; 的具体流程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;申请一个空白的 PCB，并向 PCB 中填写一些控制和管理进程的信息，比如进程的唯一标识等；&lt;/li&gt;
&lt;li&gt;为该进程分配运行时所必需的资源，比如内存资源；&lt;/li&gt;
&lt;li&gt;将 PCB 插入到就绪队列，等待被调度运行；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;终止进程&#34;&gt;终止进程
&lt;/h4&gt;&lt;p&gt;进程有以下三种结束方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正常结束&lt;/li&gt;
&lt;li&gt;异常结束&lt;/li&gt;
&lt;li&gt;外界干预（信号 &lt;strong&gt;&lt;code&gt;kill&lt;/code&gt;&lt;/strong&gt; 掉）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当子进程被终止时，其在父进程处继承的资源应当还给父进程。而当父进程被终止时，该父进程的子进程就变为孤儿进程，会被 1 号进程收养，并由 1 号进程对它们完成状态收集工作。&lt;/p&gt;
&lt;p&gt;终止线程的过程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查找需要终止的进程的 PCB；&lt;/li&gt;
&lt;li&gt;如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程；&lt;/li&gt;
&lt;li&gt;如果其还有子进程，则应将该进程的子进程交给 1 号进程接管；&lt;/li&gt;
&lt;li&gt;将该进程所拥有的全部资源都归还给操作系统；&lt;/li&gt;
&lt;li&gt;将其从 PCB 所在队列中删除；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;阻塞线程&#34;&gt;阻塞线程
&lt;/h4&gt;&lt;p&gt;当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待。而一旦被阻塞等待，它只能由另一个进程唤醒。&lt;/p&gt;
&lt;p&gt;阻塞进程的过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到将要被阻塞进程标识号对应的 PCB；&lt;/li&gt;
&lt;li&gt;如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行；&lt;/li&gt;
&lt;li&gt;将该 PCB 插入到阻塞队列中去；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;唤醒进程&#34;&gt;唤醒进程
&lt;/h4&gt;&lt;p&gt;进程只能被另一个进程唤醒，唤醒进程的过程如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在该事件的阻塞队列中找到相应进程的 PCB；&lt;/li&gt;
&lt;li&gt;将其从阻塞队列中移出，并置其状态为就绪状态；&lt;/li&gt;
&lt;li&gt;把该 PCB 插入到就绪队列中，等待调度程序调度；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程的上下文切换&#34;&gt;进程的上下文切换
&lt;/h3&gt;&lt;h4 id=&#34;上下文切换的概念&#34;&gt;上下文切换的概念
&lt;/h4&gt;&lt;p&gt;上下文切换是一种将CPU资源从一个进程分配给另一个进程的机制。&lt;/p&gt;
&lt;p&gt;操作系统需要事先帮 CPU 设置好 &lt;strong&gt;CPU 寄存器和程序计数器&lt;/strong&gt;。CPU 寄存器和程序计数是 CPU 在运行任何任务前所必须依赖的环境，这就是CPU上下文&lt;/p&gt;
&lt;p&gt;CPU 上下文切换就是先把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。&lt;/p&gt;
&lt;p&gt;系统内核会存储保持下来的上下文信息，当此任务再次被分配给 CPU 运行时，CPU 会重新加载这些上下文，这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。&lt;/p&gt;
&lt;h4 id=&#34;进程上下文切换过程&#34;&gt;进程上下文切换过程
&lt;/h4&gt;&lt;p&gt;进程是由内核管理和调度的，所以进程的切换只能发生在内核态。&lt;strong&gt;进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/13-%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2.jpg&#34;
	width=&#34;870&#34;
	height=&#34;191&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;进程上下文切换&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;455&#34;
		data-flex-basis=&#34;1093px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;进程上下文切换的场景&#34;&gt;进程上下文切换的场景
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPU调度&lt;/strong&gt; ：CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统资源不足&lt;/strong&gt; ：进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程主动挂起&lt;/strong&gt; ：当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高优先级进程运行&lt;/strong&gt; ：当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;发生硬件中断&lt;/strong&gt; ：CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程间通信&#34;&gt;进程间通信
&lt;/h3&gt;&lt;p&gt;每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走。&lt;/p&gt;
&lt;h4 id=&#34;命名管道匿名管道&#34;&gt;命名管道/匿名管道
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;匿名管道&lt;/strong&gt; ：匿名管道是一种单向通信方式，用于在父进程和子进程之间或者同一主机上的不同进程之间传递数据，数据从一端写入，从另一端读取&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;命名管道&lt;/strong&gt; ：是匿名管道的改进版，支持无亲缘关系的进程之间的通信。命名管道是一种存在于文件系统中的特殊文件，通过管道名称可以进行读写操作。适用于需要跨进程通信但不具备亲缘关系的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本质上管道是&lt;strong&gt;内核里面的一串缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于匿名管道来说，匿名管道没有实体，不存在管道文件，只能通过父进程和子进程的文件描述符来进行通信&lt;/p&gt;
&lt;p&gt;对于命名管道来说，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/8-%E7%AE%A1%E9%81%93-pipe-shell.jpg&#34;
	width=&#34;1307&#34;
	height=&#34;1037&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;命名管道&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;126&#34;
		data-flex-basis=&#34;302px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;共享内存&#34;&gt;共享内存
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中&lt;/strong&gt; 。这样这个进程写入的东西对于另外一个进程是可见的，不需要经过数据的拷贝和传输，大大提高了进程间通信的速度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/9-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.jpg&#34;
	width=&#34;714&#34;
	height=&#34;609&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;共享内存&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;117&#34;
		data-flex-basis=&#34;281px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;消息队列&#34;&gt;消息队列
&lt;/h4&gt;&lt;p&gt;消息队列的通信模式适用于频繁地进行信息传输。消息队列允许一个进程向另一个进程发送消息，消息在队列中按顺序存储，并且接收方可以按需接收。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息队列是保存在内核中的消息链表&lt;/strong&gt; ，消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在&lt;/p&gt;
&lt;p&gt;消息队列具有以下缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;消息队列不适合比较大数据的传输&lt;/strong&gt; ：因为在内核中每个消息体都有一个最大长度的限制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销&lt;/strong&gt; ：因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;信号&#34;&gt;信号
&lt;/h4&gt;&lt;p&gt;信号是一种 &lt;strong&gt;异步&lt;/strong&gt; 的通信方式，用于通知目标进程发生了某个事件。信号常用于进程之间发送中断或终止命令。信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件&lt;/p&gt;
&lt;h4 id=&#34;套接字&#34;&gt;套接字
&lt;/h4&gt;&lt;p&gt;套接字提供网络通信的端点，可以让不同机器上运行的进程之间进行双向通信。但是套接字实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信。&lt;/p&gt;
&lt;h4 id=&#34;信号量&#34;&gt;信号量
&lt;/h4&gt;&lt;p&gt;进程间通信处理同步互斥的机制。是在多线程环境下使用的一种设施，它负责协调各个线程，以保证它们能够正确，合理的使用公共资源。&lt;/p&gt;
&lt;p&gt;对于信号量有两种操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;P 操作&lt;/strong&gt;，这个操作会把信号量减去 1，相减后如果信号量 &amp;lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &amp;gt;= 0，则表明还有资源可使用，进程可正常继续执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;V 操作&lt;/strong&gt;，这个操作会把信号量加上 1，相加后如果信号量 &amp;lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &amp;gt; 0，则表明当前没有阻塞中的进程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;信号量有两种类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;互斥信号量&lt;/strong&gt; ：信号初始化为 &lt;strong&gt;&lt;code&gt;1&lt;/code&gt;&lt;/strong&gt; ，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步信号量&lt;/strong&gt; ：保证进程之间的顺序执行&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程调度&#34;&gt;进程调度
&lt;/h3&gt;&lt;h4 id=&#34;调度时机&#34;&gt;调度时机
&lt;/h4&gt;&lt;p&gt;以下状态的变化都会触发操作系统的调度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从就绪态 -&amp;gt; 运行态：当进程被创建时，会进入到就绪队列，操作系统会从就绪队列选择一个进程运行；&lt;/li&gt;
&lt;li&gt;从运行态 -&amp;gt; 阻塞态：当进程发生 I/O 事件而阻塞时，操作系统必须选择另外一个进程运行；&lt;/li&gt;
&lt;li&gt;从运行态 -&amp;gt; 结束态：当进程退出结束后，操作系统得从就绪队列选择另外一个进程运行；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;调度算法&#34;&gt;调度算法
&lt;/h4&gt;&lt;p&gt;调度算法分为以下两类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非抢占式调度算法&lt;/strong&gt; ：挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抢占式调度算法&lt;/strong&gt; ：挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生 &lt;strong&gt;时钟中断&lt;/strong&gt; ，以便把 CPU 控制返回给调度程序进行调度，也就是常说的 &lt;strong&gt;时间片机制&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于单核CPU有以下常见的调度算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;先来先服务（FCFS, First-Come, First-Served）&lt;/strong&gt; ：按照进程到达的顺序进行调度，每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。
&lt;ul&gt;
&lt;li&gt;适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统&lt;/li&gt;
&lt;li&gt;可能造成“长任务”拖延其他任务的执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;短作业优先(SJF，Shortest Job First)&lt;/strong&gt;  : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
&lt;ul&gt;
&lt;li&gt;很难准确预知进程的执行时间，并且可能因为短作业一直在执行，导致长作业持续被推迟执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最高响应比优先（HRRN, Highest Response Ratio Next）&lt;/strong&gt; ：通过计算响应比来决定下一个被调度的进程 ，把响应比优先级最高的进程投入运行，平衡长短任务的等待时间，防止短任务过多导致长任务饥饿。响应比的公式为： &lt;strong&gt;(等待时间 + 服务时间) / 服务时间&lt;/strong&gt; 其中，&lt;strong&gt;等待时间&lt;/strong&gt;是进程在就绪队列中等待的时间，&lt;strong&gt;服务时间&lt;/strong&gt;是进程预计需要的执行时间
&lt;ul&gt;
&lt;li&gt;对于短任务，其服务时间小，初始响应比就较高，容易被优先调度。&lt;/li&gt;
&lt;li&gt;对于长任务，随着等待时间的增加，响应比逐渐提升，最终也会被调度，避免了长任务的饥饿。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时间片轮转（RR, Round Robin）&lt;/strong&gt; ：为每个进程分配固定的时间片，时间片结束后调度下一个进程，如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程；如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多级反馈队列调度（MLFQ, Multilevel Feedback Queue）&lt;/strong&gt;：通过将进程放入不同优先级的队列，实现灵活的调度机制。优先级较高的进程先被调度，随着执行时间增加，进程可能被降至低优先级队列。适合多任务、多类型的操作系统。
&lt;ul&gt;
&lt;li&gt;设置了多个队列，赋予每个队列不同的优先级，每个 &lt;strong&gt;队列优先级从高到低&lt;/strong&gt; ，同时 &lt;strong&gt;优先级越高时间片越短&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成&lt;/li&gt;
&lt;li&gt;当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程&#34;&gt;线程
&lt;/h2&gt;&lt;h3 id=&#34;线程的定义&#34;&gt;线程的定义
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;线程（Thread）&lt;/strong&gt; 可以被视为轻量级进程，是进程当中的一条执行流程，任务调度和执行的基本单位。线程的生命周期由进程控制，进程终止时，其所有线程也会终止。多个线程可以在同一个进程中同时执行，并且共享进程的资源比如内存空间、文件句柄、网络连接等。但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。&lt;/p&gt;
&lt;h3 id=&#34;线程的优缺点和存在意义&#34;&gt;线程的优缺点和存在意义
&lt;/h3&gt;&lt;p&gt;线程具有以下优缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个进程中可以同时存在多个线程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各个线程之间可以并发执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各个线程之间可以共享地址空间和文件等资源&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当进程中的一个线程崩溃时，可能影响其所属进程的所有线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程的存在意义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程切换是一个开销很大的操作，线程切换的成本较低。&lt;/li&gt;
&lt;li&gt;线程更轻量，一个进程可以创建多个线程。&lt;/li&gt;
&lt;li&gt;多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题比如 IO 阻塞就会挂起直到结果返回。&lt;/li&gt;
&lt;li&gt;同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程和线程的区别&#34;&gt;进程和线程的区别
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;本质区别&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;进程是操作系统资源分配的基本单位&lt;/li&gt;
&lt;li&gt;线程是任务调度和执行的基本单位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;切换开销&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;每个进程都有独立的代码和数据空间（程序上下文），对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的&lt;/li&gt;
&lt;li&gt;线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;稳定性&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;进程中某个线程如果崩溃了可能会影响所属进程的其他进程&lt;/li&gt;
&lt;li&gt;进程中的子进程崩溃，并不会影响其他进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通信方式&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;因为各自独立的内存空间，进程间通信（IPC）较为复杂，需要使用管道、消息队列、共享内存、套接字等方式&lt;/li&gt;
&lt;li&gt;同一进程内的线程共享内存空间，因此线程直接读写内存即可，但注意需要使用同步机制避免数据错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程的上下文切换&#34;&gt;线程的上下文切换
&lt;/h3&gt;&lt;p&gt;线程切换是指将 CPU 的控制权从一个线程转移到另一个线程的过程。与进程切换相比，线程切换的开销较小，因为同一进程内的线程共享相同的地址空间和资源。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保存当前线程的上下文（如 CPU 寄存器、栈指针等）到线程控制块（TCB）中&lt;/li&gt;
&lt;li&gt;更新当前线程的状态（如就绪、阻塞等）。&lt;/li&gt;
&lt;li&gt;选择下一个要执行的线程，更新调度信息。&lt;/li&gt;
&lt;li&gt;恢复下一个线程的上下文，恢复 CPU 寄存器、栈指针、程序计数器等信息，确保线程能够从上次中断的地方继续执行，开始执行其任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;线程控制块 TCB&lt;/p&gt;
&lt;p&gt;类似于进程控制块PCB，TCB是操作系统用来管理线程的一个数据结构，它包含了与线程执行相关的所有必要信息，确保线程能够在系统中被正确调度和执行。每个线程都有一个对应的 TCB，操作系统通过 TCB 来管理和调度线程的执行。&lt;/p&gt;
&lt;p&gt;TCB的主要内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线程状态&lt;/strong&gt;：操作系统通过线程状态来判断线程是否可以被执行或者需要被挂起。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;程序计数器&lt;/strong&gt; ：程序计数器保存线程当前执行指令的地址，标识线程的执行位置。线程切换时，程序计数器的值需要被保存和恢复。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;寄存器内容&lt;/strong&gt; ：线程的寄存器值（如通用寄存器、栈指针等）需要在上下文切换时保存和恢复。它们包含了线程执行期间的局部变量、函数调用的返回地址等信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程栈指针（Stack Pointer, SP）&lt;/strong&gt; ：每个线程都有一个栈，用于存储函数调用信息（如局部变量、返回地址等）。栈指针指向当前栈顶，线程切换时，栈指针需要被保存和恢复。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程优先级（Thread Priority）&lt;/strong&gt; ：操作系统通常根据线程的优先级来决定哪个线程应该被调度执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程标识符（Thread ID）&lt;/strong&gt; ：每个线程都有一个唯一的标识符（线程ID），操作系统通过它来区分不同的线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程的调度信息&lt;/strong&gt; ：包括线程的调度策略、时间片（如果采用时间片轮转调度）、期望的调度器等。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h3 id=&#34;线程的实现&#34;&gt;线程的实现
&lt;/h3&gt;&lt;h4 id=&#34;用户线程&#34;&gt;用户线程
&lt;/h4&gt;&lt;p&gt;用户线程是在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理。操作系统内核并不知道它的存在，它完全是在用户空间中创建。所以 &lt;strong&gt;用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户线程的优缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;管理开销小：创建、销毁不需要系统调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切换成本低：用户空间程序可以自己维护，不需要走操作系统调度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与内核协作成本高：比如这种线程完全是用户空间程序在管理，当它进行 I/O 的时候，无法利用到内核的优势，需要频繁进行用户态到内核态的切换。&lt;/li&gt;
&lt;li&gt;由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了。&lt;/li&gt;
&lt;li&gt;当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行，因为用户态的线程没法打断当前运行中的线程，它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;内核线程&#34;&gt;内核线程
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;内核线程是由操作系统管理的，线程对应的 TCB 是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行&lt;/li&gt;
&lt;li&gt;分配给线程，多线程的进程获得更多的 CPU 运行时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程的同步机制&#34;&gt;线程的同步机制
&lt;/h2&gt;&lt;p&gt;竞态条件：指当多个线程同时访问和操作同一块数据时，最终结果依赖于线程的执行顺序，这可能导致数据的不一致性。&lt;/p&gt;
&lt;p&gt;临界区：对共享资源访问的程序片段，我们希望这段代码是互斥的，可以保证在某个时刻只能被一个线程执行，也就是说一个线程在临界区执行时，其它线程应该被阻止进入临界区。&lt;/p&gt;
&lt;h3 id=&#34;锁机制&#34;&gt;锁机制
&lt;/h3&gt;&lt;h4 id=&#34;互斥锁&#34;&gt;互斥锁
&lt;/h4&gt;&lt;p&gt;使⽤加锁操作和解锁操作可以解决并发线程/进程的互斥问题。&lt;/p&gt;
&lt;p&gt;任何想进⼊临界区的线程，必须先执⾏加锁操作。若加锁操作顺利通过，则线程可进⼊临界区；在完成对临界资源的访问后再执⾏解锁操作，以释放该临界资源。&lt;/p&gt;
&lt;p&gt;锁有以下两类实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自旋锁：当一个线程试图获取锁时，如果该锁已经被其他线程持有，当前线程不会立即进入休眠或阻塞，而是不断地检查锁的状态，直到该锁可用为止。这个过程被称为忙等待（busy waiting），因为线程在等待锁时仍然占用 CPU 资源，处于活跃状态。优点是避免了线程的上下文切换。&lt;/li&gt;
&lt;li&gt;非自旋锁：指当一个线程尝试获取锁时，如果锁已经被其他线程持有，当前线程不会忙等待，而是主动让出 CPU，进入阻塞状态或休眠状态，等待锁释放。当锁被释放时，线程被唤醒并重新尝试获取锁。这类锁的主要目的是避免忙等待带来的 CPU 资源浪费。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;死锁&#34;&gt;死锁
&lt;/h3&gt;&lt;h4 id=&#34;死锁的发生条件&#34;&gt;死锁的发生条件
&lt;/h4&gt;&lt;p&gt;当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成 &lt;strong&gt;两个线程都在等待对方释放锁&lt;/strong&gt; ，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了&lt;strong&gt;死锁&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;死锁的发生条件如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;互斥条件&lt;/strong&gt; ：多个线程不能同时使用同一个资源，如果另一进程申请该资源，那么必须等待直到该资源被释放为止。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;等待占有条件&lt;/strong&gt; ：一个进程已经持有了至少一个资源，同时还在等待获取其他被占用的资源。在此期间，该进程不会释放已经持有的资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可剥夺条件&lt;/strong&gt; ：当线程已经持有了资源 ，在自己使用完之前不能被其他线程获取&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;环路等待条件&lt;/strong&gt; ：在死锁发生的时候，两个线程获取资源的顺序构成了环形链&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;避免死锁的方法&#34;&gt;避免死锁的方法
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;忽略死锁&lt;/strong&gt; ：使用鸵鸟算法，假装死锁不会发生&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;保证系统不进入死锁状态&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;银行家算法：资源分配时使用银行家算法检测死锁，在&lt;strong&gt;分配给进程资源前，首先判断这个进程的安全性&lt;/strong&gt; ，也就是预执行，判断分配后是否产生死锁现象。如果系统当前资源能满足其执行，则尝试分配，如果不满足则让该进程等待。通过不断检查剩余可用资源是否满足某个进程的最大需求，如果可以则加入安全序列，并把该进程当前持有的资源回收；不断重复这个过程，看最后能否实现让所有进程都加入安全序列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;破坏死锁条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;破坏占用等待条件&lt;/strong&gt; ：所有进程在开始执行前请求所需的全部资源，若全部资源可用才分配&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;破坏环路等待条件&lt;/strong&gt; ：可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后就不存在环路了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;破坏不可剥夺条件&lt;/strong&gt;：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;允许系统进入死锁后再处理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;利用抢占恢复&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;某些情况下可能临时将某个资源从当前所有者这里转移到另一个进程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可行性：取决于资源的特性&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用回滚恢复&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;周期性进行检查点检查：将进程的状态写入一个文件以备以后重启&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一旦检查到死锁回滚到上一个检查点&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;杀死进程恢复&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;杀死环中一个进程，直到打破死循环&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;杀死环外的一个进程以释放该进程所占用的资源&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>操作系统的结构和主要功能</title>
        <link>https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD/</link>
        <pubDate>Wed, 12 Feb 2025 20:36:54 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD/</guid>
        <description>&lt;h2 id=&#34;操作系统的主要功能&#34;&gt;操作系统的主要功能
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;负责创建和终止进程。进程是正在运行的程序实例，每个进程都有自己的地址空间和资源。&lt;/li&gt;
&lt;li&gt;负责为进程分配资源，比如说内存，并在进程终止时回收内存。&lt;/li&gt;
&lt;li&gt;提供创建、删除、读写文件的功能，并组织文件的存储结构，比如说目录。&lt;/li&gt;
&lt;li&gt;通过设备驱动程序控制和管理计算机的硬件设备，如键盘、鼠标、打印机等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;操作系统内核&#34;&gt;操作系统内核
&lt;/h2&gt;&lt;p&gt;计算机是由各种外部硬件设备组成的，比如内存、cpu、硬盘等，&lt;strong&gt;内核作为应用连接硬件设备的桥梁&lt;/strong&gt; ，应用程序只需关心与内核交互，不用关心硬件的细节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD/Kernel_Layout.png&#34;
	width=&#34;1280&#34;
	height=&#34;1011&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;内核&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;126&#34;
		data-flex-basis=&#34;303px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;操作系统内核具有很高的权限&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程调度&lt;/strong&gt; ：管理进程、线程，决定哪个进程、线程使用 CPU&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存管理&lt;/strong&gt; ：管理内存，决定内存的分配和回收&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬件通信&lt;/strong&gt; ：管理硬件设备，为进程与硬件设备之间提供通信能力&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统调用&lt;/strong&gt; ：提供系统调用，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;style type=&#34;text/css&#34;&gt;
   
  .notice {
    --title-color: #fff;
    --title-background-color: #6be;
    --content-color: #444;
    --content-background-color: #e7f2fa;
  }

  .notice.info {
    --title-background-color: #fb7;
    --content-background-color: #fec;
  }

  .notice.tip {
    --title-background-color: #5a5;
    --content-background-color: #efe;
  }

  .notice.warning {
    --title-background-color: #c33;
    --content-background-color: #fee;
  }

   
  @media (prefers-color-scheme: dark) {
    .notice {
      --title-color: #fff;
      --title-background-color: #069;
      --content-color: #ddd;
      --content-background-color: #023;
    }

    .notice.info {
      --title-background-color: #a50;
      --content-background-color: #420;
    }

    .notice.tip {
      --title-background-color: #363;
      --content-background-color: #121;
    }

    .notice.warning {
      --title-background-color: #800;
      --content-background-color: #400;
    }
  }

  body.dark .notice {
    --title-color: #fff;
    --title-background-color: #069;
    --content-color: #ddd;
    --content-background-color: #023;
  }

  body.dark .notice.info {
    --title-background-color: #a50;
    --content-background-color: #420;
  }

  body.dark .notice.tip {
    --title-background-color: #363;
    --content-background-color: #121;
  }

  body.dark .notice.warning {
    --title-background-color: #800;
    --content-background-color: #400;
  }

   
  .notice {
    width: 100%;  
    max-width: 600px;  
    padding: 18px;
    line-height: 24px;
    margin-bottom: 24px;
    border-radius: 4px;
    color: var(--content-color);
    background: var(--content-background-color);
  }

  .notice p:last-child {
    margin-bottom: 0;
  }

   
  .notice-title {
    margin: -18px -18px 12px;
    padding: 4px 18px;
    border-radius: 4px 4px 0 0;
    font-weight: 700;
    color: var(--title-color);
    background: var(--title-background-color);
  }

   
  .icon-notice {
    display: inline-flex;
    align-self: center;
    margin-right: 8px;
  }

  .icon-notice img,
  .icon-notice svg {
    height: 1em;
    width: 1em;
    fill: currentColor;
  }

  .icon-notice img,
  .icon-notice.baseline svg {
    top: 0.125em;
    position: relative;
  }
&lt;/style&gt;&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;微内核和宏内核&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;微内核&lt;/strong&gt; ：尽量将大部分操作系统功能移至用户态，仅保留最基础的功能（如进程间通信、内存管理）在内核态中。优点是系统更稳定、模块化，但切换频繁，性能不如宏内核。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;宏内核&lt;/strong&gt; ：大部分操作系统服务在内核态中运行，包括文件系统、驱动程序等。优点是性能高，因为减少了用户态与内核态之间的切换，但可能增加系统的复杂性和维护难度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;混合内核&lt;/strong&gt; ：是宏内核和微内核的结合体，内核中抽象出了微内核的概念，也就是内核中会有一个小型的内核，其他模块就在这个基础上搭建，整个内核是个完整的程序；&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h2 id=&#34;内核态和用户态&#34;&gt;内核态和用户态
&lt;/h2&gt;&lt;p&gt;内核具有很高的权限，可以控制CPU、内存、硬盘等硬件，而应用程序具有的权限很小，因此大多数操作系统，把内存分成了两个区域&lt;/p&gt;
&lt;h3 id=&#34;定义&#34;&gt;定义
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;内核态：在内核态下，CPU可以执行所有的指令和访问所有的硬件资源。这种模式下的操作具有更高的权限，主要用于操作系统内核的运行。&lt;/li&gt;
&lt;li&gt;用户态：在用户态下，CPU只能执行部分指令集，无法直接访问硬件资源。这种模式下的操作权限较低。应用程序需要通过系统调用与内核进行通信，由内核代为执行敏感操作。即使程序出现问题也不会影响操作系统的稳定性，主要用于运行用户程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;切换机制&#34;&gt;切换机制
&lt;/h3&gt;&lt;p&gt;大部分的状态切换出现在用户程序调用系统调用的时候，当应用程序执行系统调用时，CPU 将从用户态切换到内核态，进入内核空间执行相应的内核代码，然后再切换回用户态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD/systemcall.png&#34;
	width=&#34;1053&#34;
	height=&#34;332&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;内核态和用户态的切换&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;317&#34;
		data-flex-basis=&#34;761px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;内核程序执行在内核态，用户程序执行在用户态。当应用程序使用系统调用时，会产生一个中断。发生中断后， CPU 会中断当前在执行的用户程序，转而跳转到中断处理程序，也就是开始执行内核程序。内核处理完后，主动触发中断，把 CPU 执行权限交回给用户程序，回到用户态继续工作。&lt;/p&gt;
&lt;p&gt;什么时候会出现上下文切换&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;系统调用&lt;/strong&gt;：用户态进程&lt;strong&gt;主动&lt;/strong&gt;要求切换到内核态的一种方式，主要是为了使用内核态才能做的事情比如读取磁盘资源。系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中断&lt;/strong&gt;：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异常&lt;/strong&gt;：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在用户态和内核态之间切换时，操作系统会执行&lt;strong&gt;上下文切换&lt;/strong&gt; ，包括保存当前进程的寄存器、状态和堆栈等信息，并加载内核态的状态以处理系统调用。上下文切换的成本较高，所以优化系统性能时，需要减少不必要的系统调用和态切换。&lt;/p&gt;
&lt;p&gt;内核态和用户态的切换过程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;保存用户态的上下文信息&lt;/strong&gt; ：CPU 会将当前用户态进程使用的通用寄存器、程序计数器（PC）、栈指针（SP）、标志寄存器等内容保存起来。这些寄存器中存储着用户态程序当前的执行状态和相关数据，以便内核态处理完任务后能恢复到正确的用户态执行位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进行模式与权限的切换&lt;/strong&gt; ：通过修改 CPU 的特定标志位或寄存器，将处理器的运行模式从用户态切换到内核态，使 CPU 能够执行特权指令，访问所有的内存空间和硬件资源。内核会检查此次切换的合法性和权限，比如检查系统调用的参数是否正确、进程是否具有相应的权限来执行此操作等，以确保系统的安全性和稳定性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加载内核态上下文并执行内核态代码&lt;/strong&gt; ：根据进程的描述符或任务控制块（TCB）中保存的内核栈信息，将栈指针设置为指向内核栈的地址，开始使用内核栈来进行内核代码的执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;内核态和用户态的存在原因&#34;&gt;内核态和用户态的存在原因
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;安全性&lt;/strong&gt;：用户态和内核态的划分确保了普通应用程序无法直接访问硬件资源或执行敏感操作，避免了程序或用户恶意操作对系统核心的破坏。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;稳定性&lt;/strong&gt;：通过在内核态中运行关键系统服务（如内存管理、文件系统、设备驱动等），操作系统可以对资源进行集中管理和保护。某个应用程序崩溃，只会影响用户态中的进程，不会影响到整个系统。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隔离性&lt;/strong&gt;：通过设置不同的权限级别，操作系统能够更好地控制对资源的访问。只有在内核态下，操作系统才有权对硬件资源进行操作，而用户态程序必须通过系统调用请求内核服务，这种设计确保了对系统资源的统一管理。内核态和用户态的划分使得操作系统内核与用户程序之间有了明确的边界，有利于系统的模块化和维护。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;系统调用&#34;&gt;系统调用
&lt;/h2&gt;&lt;p&gt;系统调用提供了调用操作系统提供的内核态级别的子功能。凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。&lt;/p&gt;
&lt;p&gt;系统调用过程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户态的程序发起系统调用，因为系统调用中涉及一些特权指令（只能由操作系统内核态执行的指令），用户态程序权限不足，因此会中断执行，也就是 Trap（Trap 是一种中断）。&lt;/li&gt;
&lt;li&gt;发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序。内核程序开始执行，也就是开始处理系统调用。&lt;/li&gt;
&lt;li&gt;内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>操作系统的硬件结构</title>
        <link>https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/</link>
        <pubDate>Wed, 12 Feb 2025 18:42:06 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/</guid>
        <description>&lt;h2 id=&#34;冯诺依曼体系&#34;&gt;冯诺依曼体系
&lt;/h2&gt;&lt;p&gt;现代计算机模型是基于&lt;strong&gt;冯诺依曼计算机模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算机在运行时，先从内存中取出第一条指令，通过控制器的译码，按指令的要求，从存储器中取出数据进行指定的运算和逻辑操作等加工，然后再按地址把结果送到内存中去，接下来，再取出第二条指令，在控制器的指挥下完成规定操作，依此进行下去。直至遇到停止指令&lt;/p&gt;
&lt;p&gt;程序与数据一样存贮，按程序编排的顺序，一步一步地取出指令，自动地完成指令规定的操作是计算机最基本的工作模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/Von_Neumann_architecture.svg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;操作系统的结构&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;计算机基本结构为 5 个部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;运算器&lt;/strong&gt; ：对数据进行各种算术运算和逻辑运算，即对数据进行加工处理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制器&lt;/strong&gt; ：是整个计算机的中枢神经，其功能是对程序规定的控制信息进行解释，根据其要求进行控制，调度程序、数据、地址，协调计算机各部分工作及内存与外设的访问等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存储器&lt;/strong&gt; ：存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输入设备&lt;/strong&gt; ：将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输出设备&lt;/strong&gt; ：它把计算机的中间结果或最后结果、机内的各种数据符号及文字或各种控制信号等信息输出出来&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B.png&#34;
	width=&#34;613&#34;
	height=&#34;271&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;总线通信&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;226&#34;
		data-flex-basis=&#34;542px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;内存&#34;&gt;内存
&lt;/h3&gt;&lt;p&gt;在冯诺依曼模型中，程序和数据被存储在一个被称作内存的线性排列存储区域。&lt;/p&gt;
&lt;p&gt;存储的数据单位是一个二进制位，最小的存储单位叫作字节，也就是 8 位，英文是 byte，每一个字节都对应一个内存地址。&lt;/p&gt;
&lt;p&gt;内存地址由 0 开始编号，比如第 1 个地址是 0，第 2 个地址是 1， 然后自增排列，最后一个地址是内存中的字节数减 1。&lt;/p&gt;
&lt;p&gt;我们通常说的内存都是随机存取器（RAM），也就是读取任何一个地址数据的速度是一样的，写入任何一个地址数据的速度也是一样的。&lt;/p&gt;
&lt;h3 id=&#34;中央处理器cpu&#34;&gt;中央处理器CPU
&lt;/h3&gt;&lt;p&gt;冯诺依曼模型中 CPU 负责控制和计算，为了方便计算较大的数值，CPU 每次可以计算多个字节的数据。&lt;/p&gt;
&lt;style type=&#34;text/css&#34;&gt;
   
  .notice {
    --title-color: #fff;
    --title-background-color: #6be;
    --content-color: #444;
    --content-background-color: #e7f2fa;
  }

  .notice.info {
    --title-background-color: #fb7;
    --content-background-color: #fec;
  }

  .notice.tip {
    --title-background-color: #5a5;
    --content-background-color: #efe;
  }

  .notice.warning {
    --title-background-color: #c33;
    --content-background-color: #fee;
  }

   
  @media (prefers-color-scheme: dark) {
    .notice {
      --title-color: #fff;
      --title-background-color: #069;
      --content-color: #ddd;
      --content-background-color: #023;
    }

    .notice.info {
      --title-background-color: #a50;
      --content-background-color: #420;
    }

    .notice.tip {
      --title-background-color: #363;
      --content-background-color: #121;
    }

    .notice.warning {
      --title-background-color: #800;
      --content-background-color: #400;
    }
  }

  body.dark .notice {
    --title-color: #fff;
    --title-background-color: #069;
    --content-color: #ddd;
    --content-background-color: #023;
  }

  body.dark .notice.info {
    --title-background-color: #a50;
    --content-background-color: #420;
  }

  body.dark .notice.tip {
    --title-background-color: #363;
    --content-background-color: #121;
  }

  body.dark .notice.warning {
    --title-background-color: #800;
    --content-background-color: #400;
  }

   
  .notice {
    width: 100%;  
    max-width: 600px;  
    padding: 18px;
    line-height: 24px;
    margin-bottom: 24px;
    border-radius: 4px;
    color: var(--content-color);
    background: var(--content-background-color);
  }

  .notice p:last-child {
    margin-bottom: 0;
  }

   
  .notice-title {
    margin: -18px -18px 12px;
    padding: 4px 18px;
    border-radius: 4px 4px 0 0;
    font-weight: 700;
    color: var(--title-color);
    background: var(--title-background-color);
  }

   
  .icon-notice {
    display: inline-flex;
    align-self: center;
    margin-right: 8px;
  }

  .icon-notice img,
  .icon-notice svg {
    height: 1em;
    width: 1em;
    fill: currentColor;
  }

  .icon-notice img,
  .icon-notice.baseline svg {
    top: 0.125em;
    position: relative;
  }
&lt;/style&gt;&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;CPU位宽：代表的是 CPU 一次可以计算（运算）的数据量&lt;/p&gt;
&lt;p&gt;32 位和 64 位 CPU 最主要区别在于一次能计算多少字节数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;32 位 CPU 一次可以计算 4 个字节&lt;/li&gt;
&lt;li&gt;64 位 CPU 一次可以计算 8 个字节&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPU 的位宽最好不要小于线路位宽&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;CPU 内部还有一些组件，常见的有 &lt;strong&gt;寄存器、控制单元和逻辑运算单元&lt;/strong&gt; 等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制单元：负责控制 CPU 工作&lt;/li&gt;
&lt;li&gt;逻辑运算单元：负责逻辑运算&lt;/li&gt;
&lt;li&gt;寄存器：存放计算的中间结果，离控制单元和逻辑运算单元非常近，因此速度很快
&lt;ul&gt;
&lt;li&gt;通用寄存器：用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。&lt;/li&gt;
&lt;li&gt;程序计数器：用来存储 CPU 要执行下一条指令「所在的内存地址」，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令「的地址」。&lt;/li&gt;
&lt;li&gt;指令寄存器：用来存放当前正在执行的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;局部性原理&#34;&gt;局部性原理
&lt;/h4&gt;&lt;p&gt;在CPU访问存储设备时，无论是存取数据抑或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;时间局部性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;空间局部性（Spatial Locality）：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;总线&#34;&gt;总线
&lt;/h3&gt;&lt;p&gt;总线是用于 CPU 和内存以及其他设备之间的通信，总线可分为 3 种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;地址总线：用于指定 CPU 将要操作的内存地址&lt;/li&gt;
&lt;li&gt;数据总线：用于读写内存的数据&lt;/li&gt;
&lt;li&gt;控制总线：用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 CPU 要读写内存数据的时候，一般需要通过以下三条总线&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先要通过地址总线来指定内存的地址&lt;/li&gt;
&lt;li&gt;然后通过控制总线控制是读或写命令&lt;/li&gt;
&lt;li&gt;最后通过数据总线来传输数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;程序执行的基本过程&#34;&gt;程序执行的基本过程
&lt;/h2&gt;&lt;p&gt;程序实际上是一条一条指令，所以程序的运行过程就是把每一条指令一步一步的执行起来，负责执行指令的就是 CPU 了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;取得指令&lt;/strong&gt; ：CPU 读取程序计数器的值，这个值是指令的内存地址，然后 CPU 的控制单元操作地址总线指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过数据总线将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到指令寄存器。程序计数器的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指令译码&lt;/strong&gt; ：CPU 的控制器分析指令寄存器中的指令，确定指令的类型和参数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行指令&lt;/strong&gt; ：把指令交给逻辑运算单元运算；如果是存储类型的指令，则交由控制单元执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据回写&lt;/strong&gt; ：CPU 将计算结果存回寄存器或者将寄存器的值存入内存&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;存储器的层次结构&#34;&gt;存储器的层次结构
&lt;/h2&gt;&lt;h3 id=&#34;寄存器&#34;&gt;寄存器
&lt;/h3&gt;&lt;p&gt;寄存器是最靠近 CPU 的控制单元和逻辑计算单元的存储器。寄存器的访问速度非常快，一般要求在半个 CPU 时钟周期内完成读写&lt;/p&gt;
&lt;h3 id=&#34;cpu多级缓存&#34;&gt;CPU多级缓存
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/CPU-Cache.png&#34;
	width=&#34;1325&#34;
	height=&#34;881&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;CPU-Cache&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;150&#34;
		data-flex-basis=&#34;360px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU缓存&lt;/strong&gt; 是高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器&lt;/p&gt;
&lt;p&gt;由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用，减少CPU的等待时间，提高了系统的效率，具体包括以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;L1-Cache&lt;/strong&gt; ：L1- 缓存在 CPU 中，相比寄存器，虽然它的位置距离 CPU 核心更远，但造价更低，读写速度在 2~4 个 CPU 时钟周期。
&lt;ul&gt;
&lt;li&gt;每个 CPU 核心都有一块属于自己的 L1 高速缓存，指令和数据在 L1 是分开存放的，所以 L1 高速缓存通常分成 &lt;strong&gt;指令缓存&lt;/strong&gt; 和 &lt;strong&gt;数据缓存&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L2-Cache&lt;/strong&gt; ：L2- 缓存也在 CPU 中，位置比 L1- 缓存距离 CPU 核心更远，它的大小比 L1-Cache 更大，速度在 10~20 个 CPU 周期。
&lt;ul&gt;
&lt;li&gt;L2 高速缓存同样每个 CPU 核心都有&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L3-Cache&lt;/strong&gt; ：L3- 缓存同样在 CPU 中，位置比 L2- 缓存距离 CPU 核心更远，大小通常比 L2-Cache 更大，读写速度在 20~60 个 CPU 周期。
&lt;ul&gt;
&lt;li&gt;L3 高速缓存通常是多个 CPU 核心共用的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 CPU 需要内存中某个数据的时候，如果寄存器中有这个数据，我们可以直接使用；如果寄存器中没有这个数据，我们就要先查询 L1 缓存；L1 中没有，再查询 L2 缓存；L2 中没有再查询 L3 缓存；L3 中没有，再去内存中拿。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储器存储空间大小：内存&amp;gt;L3&amp;gt;L2&amp;gt;L1&amp;gt;寄存器&lt;/li&gt;
&lt;li&gt;存储器速度快慢排序：寄存器&amp;gt;L1&amp;gt;L2&amp;gt;L3&amp;gt;内存&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;cpu缓存一致性&#34;&gt;CPU缓存一致性
&lt;/h4&gt;&lt;p&gt;CPU 缓存 是由很多个 Cache Line 组成的，CPU Line 是 CPU 从内存读取数据的基本单位，而 CPU Line 是由各种标志（Tag）+ 数据块（Data Block）组成&lt;/p&gt;
&lt;p&gt;CPU写入数据通常有以下两种策略&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写穿： &lt;strong&gt;把数据同时写入内存和 Cache 中&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;写入前会先判断数据是否已经在 CPU 缓存里面了：
&lt;ul&gt;
&lt;li&gt;如果数据已经在 Cache 里面，先将数据更新到 Cache 里面，再写入到内存里面&lt;/li&gt;
&lt;li&gt;如果数据没有在 Cache 里面，就直接把数据更新到内存里面。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;写回：&lt;strong&gt;当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block 被替换时才需要写到内存中&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;如果当发生写操作时，数据命中缓存，则把数据更新到 CPU 缓存 里，同时标记 CPU 缓存里的这个 Cache Block 为脏（Dirty）的，这个脏的标记代表这个时候，CPU Cache 里面的这个 Cache Block 的数据和内存是不一致的&lt;/li&gt;
&lt;li&gt;如果当发生写操作时，数据未命中缓存，就要检查这个 Cache Block 里的数据有没有被标记为脏的
&lt;ul&gt;
&lt;li&gt;如果是脏的话，就要把这个 Cache Block 里的数据写回到内存，然后再把当前要写入的数据，先从内存读入到 Cache Block 里，然后再把当前要写入的数据写入到 Cache Block，最后也把它标记为脏的&lt;/li&gt;
&lt;li&gt;如果不是脏的话，把当前要写入的数据先从内存读入到 Cache Block 里，接着将数据写入到这个 Cache Block 里，然后再把这个 Cache Block 标记为脏的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缓存一致性问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不同核心的缓存，在同一行时候是不一致，从而会导致执行结果的错误。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决思路&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;写传播&lt;/strong&gt; ：某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事务的串行化&lt;/strong&gt; ：某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;内存-1&#34;&gt;内存
&lt;/h3&gt;&lt;p&gt;内存通常使用 &lt;strong&gt;DRAM （Dynamic Random Access Memory，动态随机存取存储器）&lt;/strong&gt; 。DRAM的数据会被存储在电容里，电容会不断漏电，所以需要「定时刷新」电容，才能保证数据不会被丢失，这就是 DRAM 之所以被称为「动态」存储器的原因，只有不断刷新，数据才能被存储起来。因此断电后内存中的数据全部丢失&lt;/p&gt;
&lt;h3 id=&#34;磁盘&#34;&gt;磁盘
&lt;/h3&gt;&lt;p&gt;SSD 就是固体硬盘，结构和内存类似，但是它相比内存的优点是断电后数据还是存在的，而内存、寄存器、高速缓存断电后数据都会丢失。&lt;/p&gt;
&lt;h3 id=&#34;存储器的层次关系&#34;&gt;存储器的层次关系
&lt;/h3&gt;&lt;p&gt;存储空间越大的存储器设备，其访问速度越慢，所需成本也相对越少。&lt;/p&gt;
&lt;p&gt;CPU 并不会直接和每一种存储器设备直接打交道，而是每一种存储器设备只和它相邻的存储器设备打交道。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB%E5%9B%BE.png&#34;
	width=&#34;1007&#34;
	height=&#34;485&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;存储器的层次关系&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;207&#34;
		data-flex-basis=&#34;498px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;当 CPU 需要访问内存中某个数据的时候，如果寄存器有这个数据，CPU 就直接从寄存器取数据即可，如果寄存器没有这个数据，CPU 就会查询 L1 高速缓存，如果 L1 没有，则查询 L2 高速缓存，L2 还是没有的话就查询 L3 高速缓存，L3 依然没有的话，才去内存中取数据&lt;/p&gt;
&lt;h2 id=&#34;中断&#34;&gt;中断
&lt;/h2&gt;&lt;p&gt;在计算机中，中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求&lt;/p&gt;
&lt;p&gt;操作系统收到了中断请求，会打断其他进程的运行，所以 &lt;strong&gt;中断请求的响应程序，也就是中断处理程序，要尽可能快的执行完，这样可以减少对正常进程运行调度地影响。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;硬中断和软中断&#34;&gt;硬中断和软中断
&lt;/h3&gt;&lt;p&gt;Linux 系统为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;上半部用来快速处理中断（硬中断）&lt;/strong&gt; ：由 &lt;strong&gt;硬件设备&lt;/strong&gt;（如键盘、网络卡、定时器等）触发的中断信号，当硬件设备需要与 CPU 交互（如数据传输完成、定时中断等），会通过硬中断通知 CPU。硬中断具有较高的优先级，一般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。
&lt;ul&gt;
&lt;li&gt;当硬中断发生时，CPU会保存当前执行的上下文，并跳转到中断处理程序。&lt;/li&gt;
&lt;li&gt;中断处理程序处理完成后，会恢复被中断的程序的上下文，并继续执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;下半部用来延迟处理上半部未完成的工作（软中断）&lt;/strong&gt;：由内核触发，一般以内核线程的方式运行。通常是通过执行特定指令（如&lt;code&gt;int&lt;/code&gt;指令）或系统调用产生的。在程序运行中请求操作系统的服务，软中断的优先级一般低于硬中断。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
