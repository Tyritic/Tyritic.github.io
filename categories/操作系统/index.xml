<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>操作系统 on Tyritic</title>
        <link>https://Tyritic.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
        <description>Recent content in 操作系统 on Tyritic</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Tyritic</copyright><atom:link href="https://Tyritic.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>操作系统的结构和主要功能</title>
        <link>https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD/</link>
        <pubDate>Wed, 12 Feb 2025 20:36:54 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD/</guid>
        <description>&lt;h2 id=&#34;操作系统的主要功能&#34;&gt;操作系统的主要功能
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;负责创建和终止进程。进程是正在运行的程序实例，每个进程都有自己的地址空间和资源。&lt;/li&gt;
&lt;li&gt;负责为进程分配资源，比如说内存，并在进程终止时回收内存。&lt;/li&gt;
&lt;li&gt;提供创建、删除、读写文件的功能，并组织文件的存储结构，比如说目录。&lt;/li&gt;
&lt;li&gt;通过设备驱动程序控制和管理计算机的硬件设备，如键盘、鼠标、打印机等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;操作系统内核&#34;&gt;操作系统内核
&lt;/h2&gt;&lt;p&gt;计算机是由各种外部硬件设备组成的，比如内存、cpu、硬盘等，&lt;strong&gt;内核作为应用连接硬件设备的桥梁&lt;/strong&gt; ，应用程序只需关心与内核交互，不用关心硬件的细节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD/Kernel_Layout.png&#34;
	width=&#34;1280&#34;
	height=&#34;1011&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;内核&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;126&#34;
		data-flex-basis=&#34;303px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;操作系统内核具有很高的权限&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程调度&lt;/strong&gt; ：管理进程、线程，决定哪个进程、线程使用 CPU&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存管理&lt;/strong&gt; ：管理内存，决定内存的分配和回收&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬件通信&lt;/strong&gt; ：管理硬件设备，为进程与硬件设备之间提供通信能力&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统调用&lt;/strong&gt; ：提供系统调用，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;style type=&#34;text/css&#34;&gt;
   
  .notice {
    --title-color: #fff;
    --title-background-color: #6be;
    --content-color: #444;
    --content-background-color: #e7f2fa;
  }

  .notice.info {
    --title-background-color: #fb7;
    --content-background-color: #fec;
  }

  .notice.tip {
    --title-background-color: #5a5;
    --content-background-color: #efe;
  }

  .notice.warning {
    --title-background-color: #c33;
    --content-background-color: #fee;
  }

   
  @media (prefers-color-scheme: dark) {
    .notice {
      --title-color: #fff;
      --title-background-color: #069;
      --content-color: #ddd;
      --content-background-color: #023;
    }

    .notice.info {
      --title-background-color: #a50;
      --content-background-color: #420;
    }

    .notice.tip {
      --title-background-color: #363;
      --content-background-color: #121;
    }

    .notice.warning {
      --title-background-color: #800;
      --content-background-color: #400;
    }
  }

  body.dark .notice {
    --title-color: #fff;
    --title-background-color: #069;
    --content-color: #ddd;
    --content-background-color: #023;
  }

  body.dark .notice.info {
    --title-background-color: #a50;
    --content-background-color: #420;
  }

  body.dark .notice.tip {
    --title-background-color: #363;
    --content-background-color: #121;
  }

  body.dark .notice.warning {
    --title-background-color: #800;
    --content-background-color: #400;
  }

   
  .notice {
    width: 100%;  
    max-width: 600px;  
    padding: 18px;
    line-height: 24px;
    margin-bottom: 24px;
    border-radius: 4px;
    color: var(--content-color);
    background: var(--content-background-color);
  }

  .notice p:last-child {
    margin-bottom: 0;
  }

   
  .notice-title {
    margin: -18px -18px 12px;
    padding: 4px 18px;
    border-radius: 4px 4px 0 0;
    font-weight: 700;
    color: var(--title-color);
    background: var(--title-background-color);
  }

   
  .icon-notice {
    display: inline-flex;
    align-self: center;
    margin-right: 8px;
  }

  .icon-notice img,
  .icon-notice svg {
    height: 1em;
    width: 1em;
    fill: currentColor;
  }

  .icon-notice img,
  .icon-notice.baseline svg {
    top: 0.125em;
    position: relative;
  }
&lt;/style&gt;&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;微内核和宏内核&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;微内核&lt;/strong&gt; ：尽量将大部分操作系统功能移至用户态，仅保留最基础的功能（如进程间通信、内存管理）在内核态中。优点是系统更稳定、模块化，但切换频繁，性能不如宏内核。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;宏内核&lt;/strong&gt; ：大部分操作系统服务在内核态中运行，包括文件系统、驱动程序等。优点是性能高，因为减少了用户态与内核态之间的切换，但可能增加系统的复杂性和维护难度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;混合内核&lt;/strong&gt; ：是宏内核和微内核的结合体，内核中抽象出了微内核的概念，也就是内核中会有一个小型的内核，其他模块就在这个基础上搭建，整个内核是个完整的程序；&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h2 id=&#34;内核态和用户态&#34;&gt;内核态和用户态
&lt;/h2&gt;&lt;p&gt;内核具有很高的权限，可以控制 cpu、内存、硬盘等硬件，而应用程序具有的权限很小，因此大多数操作系统，把内存分成了两个区域&lt;/p&gt;
&lt;h3 id=&#34;定义&#34;&gt;定义
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;内核空间：这个内存空间只有内核程序可以访问，内核态是操作系统内核运行的模式，具有最高的权限，可以直接访问硬件资源和执行各种特权操作（如内存管理、进程调度）。&lt;/li&gt;
&lt;li&gt;用户空间：这个内存空间专门给应用程序使用，应用程序在用户态下运行，权限较低，不能直接访问硬件或进行特权操作。应用程序需要通过系统调用与内核进行通信，由内核代为执行敏感操作。即使程序出现问题也不会影响操作系统的稳定性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;切换机制&#34;&gt;切换机制
&lt;/h3&gt;&lt;p&gt;大部分的状态切换出现在用户程序调用系统调用的时候，当应用程序执行系统调用时，CPU 将从用户态切换到内核态，进入内核空间执行相应的内核代码，然后再切换回用户态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD/systemcall.png&#34;
	width=&#34;1053&#34;
	height=&#34;332&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;内核态和用户态的切换&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;317&#34;
		data-flex-basis=&#34;761px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;内核程序执行在内核态，用户程序执行在用户态。当应用程序使用系统调用时，会产生一个中断。发生中断后， CPU 会中断当前在执行的用户程序，转而跳转到中断处理程序，也就是开始执行内核程序。内核处理完后，主动触发中断，把 CPU 执行权限交回给用户程序，回到用户态继续工作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;系统调用&lt;/strong&gt;：用户态进程 &lt;strong&gt;主动&lt;/strong&gt; 要求切换到内核态的一种方式，主要是为了使用内核态才能做的事情比如读取磁盘资源。系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中断&lt;/strong&gt;：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异常&lt;/strong&gt;：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在用户态和内核态之间切换时，操作系统会执行 &lt;strong&gt;上下文切换&lt;/strong&gt; ，包括保存当前进程的寄存器、状态和堆栈等信息，并加载内核态的状态以处理系统调用。上下文切换的成本较高，所以优化系统性能时，需要减少不必要的系统调用和态切换。&lt;/p&gt;
&lt;h3 id=&#34;内核态和用户态的存在原因&#34;&gt;内核态和用户态的存在原因
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;安全性&lt;/strong&gt;：用户态和内核态的划分确保了普通应用程序无法直接访问硬件资源或执行敏感操作，避免了程序或用户恶意操作对系统核心的破坏。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;稳定性&lt;/strong&gt;：通过在内核态中运行关键系统服务（如内存管理、文件系统、设备驱动等），操作系统可以对资源进行集中管理和保护。某个应用程序崩溃，只会影响用户态中的进程，不会影响到整个系统。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;访问控制&lt;/strong&gt;：通过设置不同的权限级别，操作系统能够更好地控制对资源的访问。只有在内核态下，操作系统才有权对硬件资源进行操作，而用户态程序必须通过系统调用请求内核服务，这种设计确保了对系统资源的统一管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;系统调用&#34;&gt;系统调用
&lt;/h2&gt;&lt;p&gt;系统调用提供了调用操作系统提供的内核态级别的子功能。凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。&lt;/p&gt;
&lt;p&gt;系统调用过程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户态的程序发起系统调用，因为系统调用中涉及一些特权指令（只能由操作系统内核态执行的指令），用户态程序权限不足，因此会中断执行，也就是 Trap（Trap 是一种中断）。&lt;/li&gt;
&lt;li&gt;发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序。内核程序开始执行，也就是开始处理系统调用。&lt;/li&gt;
&lt;li&gt;内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>操作系统的硬件结构</title>
        <link>https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/</link>
        <pubDate>Wed, 12 Feb 2025 18:42:06 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/</guid>
        <description>&lt;h2 id=&#34;冯诺依曼体系&#34;&gt;冯诺依曼体系
&lt;/h2&gt;&lt;p&gt;现代计算机模型是基于-&lt;strong&gt;冯诺依曼计算机模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算机在运行时，先从内存中取出第一条指令，通过控制器的译码，按指令的要求，从存储器中取出数据进行指定的运算和逻辑操作等加工，然后再按地址把结果送到内存中去，接下来，再取出第二条指令，在控制器的指挥下完成规定操作，依此进行下去。直至遇到停止指令&lt;/p&gt;
&lt;p&gt;程序与数据一样存贮，按程序编排的顺序，一步一步地取出指令，自动地完成指令规定的操作是计算机最基本的工作模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/Von_Neumann_architecture.svg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;操作系统的结构&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;计算机基本结构为 5 个部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;运算器&lt;/strong&gt; ：对数据进行各种算术运算和逻辑运算，即对数据进行加工处理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制器&lt;/strong&gt; ：是整个计算机的中枢神经，其功能是对程序规定的控制信息进行解释，根据其要求进行控制，调度程序、数据、地址，协调计算机各部分工作及内存与外设的访问等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存储器&lt;/strong&gt; ：存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输入设备&lt;/strong&gt; ：将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输出设备&lt;/strong&gt; ：它把计算机的中间结果或最后结果、机内的各种数据符号及文字或各种控制信号等信息输出出来&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B.png&#34;
	width=&#34;613&#34;
	height=&#34;271&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;总线通信&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;226&#34;
		data-flex-basis=&#34;542px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;内存&#34;&gt;内存
&lt;/h3&gt;&lt;p&gt;在冯诺依曼模型中，程序和数据被存储在一个被称作内存的线性排列存储区域。&lt;/p&gt;
&lt;p&gt;存储的数据单位是一个二进制位，最小的存储单位叫作字节，也就是 8 位，英文是 byte，每一个字节都对应一个内存地址。&lt;/p&gt;
&lt;p&gt;内存地址由 0 开始编号，比如第 1 个地址是 0，第 2 个地址是 1， 然后自增排列，最后一个地址是内存中的字节数减 1。&lt;/p&gt;
&lt;p&gt;我们通常说的内存都是随机存取器（RAM），也就是读取任何一个地址数据的速度是一样的，写入任何一个地址数据的速度也是一样的。&lt;/p&gt;
&lt;h3 id=&#34;中央处理器cpu&#34;&gt;中央处理器CPU
&lt;/h3&gt;&lt;p&gt;冯诺依曼模型中 CPU 负责控制和计算，为了方便计算较大的数值，CPU 每次可以计算多个字节的数据。&lt;/p&gt;
&lt;style type=&#34;text/css&#34;&gt;
   
  .notice {
    --title-color: #fff;
    --title-background-color: #6be;
    --content-color: #444;
    --content-background-color: #e7f2fa;
  }

  .notice.info {
    --title-background-color: #fb7;
    --content-background-color: #fec;
  }

  .notice.tip {
    --title-background-color: #5a5;
    --content-background-color: #efe;
  }

  .notice.warning {
    --title-background-color: #c33;
    --content-background-color: #fee;
  }

   
  @media (prefers-color-scheme: dark) {
    .notice {
      --title-color: #fff;
      --title-background-color: #069;
      --content-color: #ddd;
      --content-background-color: #023;
    }

    .notice.info {
      --title-background-color: #a50;
      --content-background-color: #420;
    }

    .notice.tip {
      --title-background-color: #363;
      --content-background-color: #121;
    }

    .notice.warning {
      --title-background-color: #800;
      --content-background-color: #400;
    }
  }

  body.dark .notice {
    --title-color: #fff;
    --title-background-color: #069;
    --content-color: #ddd;
    --content-background-color: #023;
  }

  body.dark .notice.info {
    --title-background-color: #a50;
    --content-background-color: #420;
  }

  body.dark .notice.tip {
    --title-background-color: #363;
    --content-background-color: #121;
  }

  body.dark .notice.warning {
    --title-background-color: #800;
    --content-background-color: #400;
  }

   
  .notice {
    width: 100%;  
    max-width: 600px;  
    padding: 18px;
    line-height: 24px;
    margin-bottom: 24px;
    border-radius: 4px;
    color: var(--content-color);
    background: var(--content-background-color);
  }

  .notice p:last-child {
    margin-bottom: 0;
  }

   
  .notice-title {
    margin: -18px -18px 12px;
    padding: 4px 18px;
    border-radius: 4px 4px 0 0;
    font-weight: 700;
    color: var(--title-color);
    background: var(--title-background-color);
  }

   
  .icon-notice {
    display: inline-flex;
    align-self: center;
    margin-right: 8px;
  }

  .icon-notice img,
  .icon-notice svg {
    height: 1em;
    width: 1em;
    fill: currentColor;
  }

  .icon-notice img,
  .icon-notice.baseline svg {
    top: 0.125em;
    position: relative;
  }
&lt;/style&gt;&lt;div
  class=&#34;notice tip&#34;
  
&gt;
  &lt;p class=&#34;notice-title&#34;&gt;
    &lt;span class=&#34;icon-notice baseline&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;300.5 134 300 300&#34;&gt;
  &lt;path d=&#34;M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32 0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32 0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984 0 3.32 1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32 0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789ZM600.5 284c0 82.813-67.188 150-150 150-82.813 0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813 0 150 67.188 150 150Z&#34;/&gt;
&lt;/svg&gt;

    &lt;/span&gt;提示&lt;/p&gt;&lt;p&gt;CPU位宽：代表的是 CPU 一次可以计算（运算）的数据量&lt;/p&gt;
&lt;p&gt;32 位和 64 位 CPU 最主要区别在于一次能计算多少字节数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;32 位 CPU 一次可以计算 4 个字节&lt;/li&gt;
&lt;li&gt;64 位 CPU 一次可以计算 8 个字节&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPU 的位宽最好不要小于线路位宽&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;CPU 内部还有一些组件，常见的有 &lt;strong&gt;寄存器、控制单元和逻辑运算单元&lt;/strong&gt; 等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制单元：负责控制 CPU 工作&lt;/li&gt;
&lt;li&gt;逻辑运算单元：计算&lt;/li&gt;
&lt;li&gt;寄存器：存放计算的中间结果，离控制单元和逻辑运算单元非常近，因此速度很快
&lt;ul&gt;
&lt;li&gt;通用寄存器：用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。&lt;/li&gt;
&lt;li&gt;程序计数器：用来存储 CPU 要执行下一条指令「所在的内存地址」，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令「的地址」。&lt;/li&gt;
&lt;li&gt;指令寄存器：用来存放当前正在执行的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;局部性原理&#34;&gt;局部性原理
&lt;/h4&gt;&lt;p&gt;在CPU访问存储设备时，无论是存取数据抑或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;时间局部性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;空间局部性（Spatial Locality）：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;总线&#34;&gt;总线
&lt;/h3&gt;&lt;p&gt;总线是用于 CPU 和内存以及其他设备之间的通信，总线可分为 3 种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;地址总线：用于指定 CPU 将要操作的内存地址；&lt;/li&gt;
&lt;li&gt;数据总线：用于读写内存的数据；&lt;/li&gt;
&lt;li&gt;控制总线：用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 CPU 要读写内存数据的时候，一般需要通过以下三条总线&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先要通过地址总线来指定内存的地址；&lt;/li&gt;
&lt;li&gt;然后通过控制总线控制是读或写命令；&lt;/li&gt;
&lt;li&gt;最后通过数据总线来传输数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;程序执行的基本过程&#34;&gt;程序执行的基本过程
&lt;/h2&gt;&lt;p&gt;程序实际上是一条一条指令，所以程序的运行过程就是把每一条指令一步一步的执行起来，负责执行指令的就是 CPU 了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;取得指令&lt;/strong&gt; ：CPU 读取程序计数器的值，这个值是指令的内存地址，然后 CPU 的控制单元操作地址总线指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过数据总线将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到指令寄存器。程序计数器的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指令译码&lt;/strong&gt; ：CPU 的控制器分析指令寄存器中的指令，确定指令的类型和参数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行指令&lt;/strong&gt; ：把指令交给逻辑运算单元运算；如果是存储类型的指令，则交由控制单元执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据回写&lt;/strong&gt; ：CPU 将计算结果存回寄存器或者将寄存器的值存入内存&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;存储器的层次结构&#34;&gt;存储器的层次结构
&lt;/h2&gt;&lt;h3 id=&#34;寄存器&#34;&gt;寄存器
&lt;/h3&gt;&lt;p&gt;寄存器是最靠近 CPU 的控制单元和逻辑计算单元的存储器。寄存器的访问速度非常快，一般要求在半个 CPU 时钟周期内完成读写&lt;/p&gt;
&lt;h3 id=&#34;cpu多级缓存&#34;&gt;CPU多级缓存
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;CPU缓存&lt;/strong&gt; 是高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器&lt;/p&gt;
&lt;p&gt;由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用，减少CPU的等待时间，提高了系统的效率，具体包括以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;L1-Cache&lt;/strong&gt; ：L1- 缓存在 CPU 中，相比寄存器，虽然它的位置距离 CPU 核心更远，但造价更低，读写速度在 2~4 个 CPU 时钟周期。
&lt;ul&gt;
&lt;li&gt;每个 CPU 核心都有一块属于自己的 L1 高速缓存，指令和数据在 L1 是分开存放的，所以 L1 高速缓存通常分成 &lt;strong&gt;指令缓存&lt;/strong&gt; 和 &lt;strong&gt;数据缓存&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L2-Cache&lt;/strong&gt; ：L2- 缓存也在 CPU 中，位置比 L1- 缓存距离 CPU 核心更远，它的大小比 L1-Cache 更大，速度在 10~20 个 CPU 周期。
&lt;ul&gt;
&lt;li&gt;L2 高速缓存同样每个 CPU 核心都有&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L3-Cache&lt;/strong&gt; ：L3- 缓存同样在 CPU 中，位置比 L2- 缓存距离 CPU 核心更远，大小通常比 L2-Cache 更大，读写速度在 20~60 个 CPU 周期。
&lt;ul&gt;
&lt;li&gt;L3 高速缓存通常是多个 CPU 核心共用的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 CPU 需要内存中某个数据的时候，如果寄存器中有这个数据，我们可以直接使用；如果寄存器中没有这个数据，我们就要先查询 L1 缓存；L1 中没有，再查询 L2 缓存；L2 中没有再查询 L3 缓存；L3 中没有，再去内存中拿。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储器存储空间大小：内存&amp;gt;L3&amp;gt;L2&amp;gt;L1&amp;gt;寄存器&lt;/li&gt;
&lt;li&gt;存储器速度快慢排序：寄存器&amp;gt;L1&amp;gt;L2&amp;gt;L3&amp;gt;内存&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;cpu缓存一致性&#34;&gt;CPU缓存一致性
&lt;/h4&gt;&lt;p&gt;CPU 缓存 是由很多个 Cache Line 组成的，CPU Line 是 CPU 从内存读取数据的基本单位，而 CPU Line 是由各种标志（Tag）+ 数据块（Data Block）组成&lt;/p&gt;
&lt;p&gt;CPU写入数据通常有以下两种策略&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写穿： &lt;strong&gt;把数据同时写入内存和 Cache 中&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;写入前会先判断数据是否已经在 CPU 缓存 里面了：
&lt;ul&gt;
&lt;li&gt;如果数据已经在 Cache 里面，先将数据更新到 Cache 里面，再写入到内存里面；&lt;/li&gt;
&lt;li&gt;如果数据没有在 Cache 里面，就直接把数据更新到内存里面。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;写回：&lt;strong&gt;当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block 被替换时才需要写到内存中&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;如果当发生写操作时，数据命中缓存，则把数据更新到 CPU 缓存 里，同时标记 CPU 缓存 里的这个 Cache Block 为脏（Dirty）的，这个脏的标记代表这个时候，我们 CPU Cache 里面的这个 Cache Block 的数据和内存是不一致的&lt;/li&gt;
&lt;li&gt;如果当发生写操作时，数据未命中缓存，就要检查这个 Cache Block 里的数据有没有被标记为脏的
&lt;ul&gt;
&lt;li&gt;如果是脏的话，我们就要把这个 Cache Block 里的数据写回到内存，然后再把当前要写入的数据，先从内存读入到 Cache Block 里，然后再把当前要写入的数据写入到 Cache Block，最后也把它标记为脏的&lt;/li&gt;
&lt;li&gt;如果不是脏的话，把当前要写入的数据先从内存读入到 Cache Block 里，接着将数据写入到这个 Cache Block 里，然后再把这个 Cache Block 标记为脏的就好了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缓存一致性问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不同核心的缓存，在同一行时候是不一致，从而会导致执行结果的错误。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决思路&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;写传播&lt;/strong&gt; ：某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事务的串行化&lt;/strong&gt; ：某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;内存-1&#34;&gt;内存
&lt;/h3&gt;&lt;p&gt;内存通常使用 &lt;strong&gt;DRAM （Dynamic Random Access Memory，动态随机存取存储器）&lt;/strong&gt; 。DRAM的数据会被存储在电容里，电容会不断漏电，所以需要「定时刷新」电容，才能保证数据不会被丢失，这就是 DRAM 之所以被称为「动态」存储器的原因，只有不断刷新，数据才能被存储起来。因此断电后内存中的数据全部丢失&lt;/p&gt;
&lt;h3 id=&#34;磁盘&#34;&gt;磁盘
&lt;/h3&gt;&lt;p&gt;SSD 就是固体硬盘，结构和内存类似，但是它相比内存的优点是断电后数据还是存在的，而内存、寄存器、高速缓存断电后数据都会丢失。&lt;/p&gt;
&lt;h3 id=&#34;存储器的层次关系&#34;&gt;存储器的层次关系
&lt;/h3&gt;&lt;p&gt;存储空间越大的存储器设备，其访问速度越慢，所需成本也相对越少。&lt;/p&gt;
&lt;p&gt;CPU 并不会直接和每一种存储器设备直接打交道，而是每一种存储器设备只和它相邻的存储器设备打交道。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB%E5%9B%BE.png&#34;
	width=&#34;1007&#34;
	height=&#34;485&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;存储器的层次关系&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;207&#34;
		data-flex-basis=&#34;498px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;当 CPU 需要访问内存中某个数据的时候，如果寄存器有这个数据，CPU 就直接从寄存器取数据即可，如果寄存器没有这个数据，CPU 就会查询 L1 高速缓存，如果 L1 没有，则查询 L2 高速缓存，L2 还是没有的话就查询 L3 高速缓存，L3 依然没有的话，才去内存中取数据&lt;/p&gt;
&lt;h2 id=&#34;中断&#34;&gt;中断
&lt;/h2&gt;&lt;p&gt;在计算机中，中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求&lt;/p&gt;
&lt;p&gt;操作系统收到了中断请求，会打断其他进程的运行，所以 &lt;strong&gt;中断请求的响应程序，也就是中断处理程序，要尽可能快的执行完，这样可以减少对正常进程运行调度地影响。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;硬中断和软中断&#34;&gt;硬中断和软中断
&lt;/h3&gt;&lt;p&gt;Linux 系统为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;上半部用来快速处理中断（硬中断）&lt;/strong&gt; ：由 &lt;strong&gt;硬件设备&lt;/strong&gt;（如键盘、网络卡、定时器等）触发的中断信号，具有较高的优先级，一般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。
&lt;ul&gt;
&lt;li&gt;当硬中断发生时，CPU会保存当前执行的上下文，并跳转到中断处理程序。&lt;/li&gt;
&lt;li&gt;中断处理程序处理完成后，会恢复被中断的程序的上下文，并继续执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;下半部用来延迟处理上半部未完成的工作（软中断）&lt;/strong&gt;：由内核触发，一般以内核线程的方式运行。通常是通过执行特定指令（如&lt;code&gt;int&lt;/code&gt;指令）或系统调用产生的。在程序运行中请求操作系统的服务&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
