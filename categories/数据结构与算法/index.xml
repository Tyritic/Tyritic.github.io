<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>数据结构与算法 on Tyritic</title>
        <link>https://Tyritic.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</link>
        <description>Recent content in 数据结构与算法 on Tyritic</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Tyritic</copyright><atom:link href="https://Tyritic.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>线性表</title>
        <link>https://Tyritic.github.io/p/%E7%BA%BF%E6%80%A7%E8%A1%A8/</link>
        <pubDate>Sat, 19 Oct 2024 15:57:38 +0800</pubDate>
        
        <guid>https://Tyritic.github.io/p/%E7%BA%BF%E6%80%A7%E8%A1%A8/</guid>
        <description>&lt;h2 id=&#34;顺序表&#34;&gt;顺序表
&lt;/h2&gt;&lt;h3 id=&#34;数组&#34;&gt;数组
&lt;/h3&gt;&lt;h4 id=&#34;定义&#34;&gt;定义
&lt;/h4&gt;&lt;p&gt;数组由相同类型的元素（element）组成，并且是使用一块连续的内存来存储。直接可以利用元素的索引（index）可以计算出该元素对应的存储地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;提供随机访问&lt;/strong&gt; ：可以利用元素的索引访问元素&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容量固定&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;插入和删除元素较慢&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;基本操作&#34;&gt;基本操作
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;访问特定元素：$O(1)$&lt;/li&gt;
&lt;li&gt;插入元素：$O(n)$
&lt;ul&gt;
&lt;li&gt;最好情况：在表尾插入元素，时间复杂度为 $O(1)$&lt;/li&gt;
&lt;li&gt;最坏情况：发生在插入发生在数组的首部，此时需要移动所有元素，时间复杂度为$O(n)$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除元素：$O(n)$
&lt;ul&gt;
&lt;li&gt;最好情况：在表尾删除元素，时间复杂度为 $O(1)$&lt;/li&gt;
&lt;li&gt;最坏情况：发生在删除发生在数组的首部，此时需要移动所有元素，时间复杂度为$O(n)$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;单链表&#34;&gt;单链表
&lt;/h3&gt;&lt;h4 id=&#34;定义-1&#34;&gt;定义
&lt;/h4&gt;&lt;p&gt;**单链表 ** 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。单链表只有一个方向，结点只有一个后继指针 next 指向后面的节点，通过连续的节点组成，但是节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上。链表通常有一个不保存任何值的 head 节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BA%BF%E6%80%A7%E8%A1%A8/single-linkedlist.png&#34;
	width=&#34;651&#34;
	height=&#34;181&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;单链表&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;359&#34;
		data-flex-basis=&#34;863px&#34;
	
&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ListNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ListNode&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ListNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不提供随机访问&lt;/strong&gt; ：每次访问元素需要遍历链表&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容量不固定&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;插入和删除元素速度快&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;基本操作-1&#34;&gt;基本操作
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;访问特定元素：$O(n)$&lt;/li&gt;
&lt;li&gt;插入元素：$O(1)$&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BA%BF%E6%80%A7%E8%A1%A8/20200806195134331-20230310121503147.png&#34;
	width=&#34;1122&#34;
	height=&#34;420&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;链表-添加节点&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;267&#34;
		data-flex-basis=&#34;641px&#34;
	
&gt;
&lt;ul&gt;
&lt;li&gt;找到要插入位置的前驱节点 &lt;strong&gt;&lt;code&gt;pre&lt;/code&gt;&lt;/strong&gt; 和后驱节点 &lt;strong&gt;&lt;code&gt;temp=pre.next&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;前驱节点 &lt;strong&gt;&lt;code&gt;pre&lt;/code&gt;&lt;/strong&gt; 指向目标节点 &lt;strong&gt;&lt;code&gt;target&lt;/code&gt;&lt;/strong&gt; ：&lt;strong&gt;&lt;code&gt;pre.next=target&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;目标节点指向后驱节点 &lt;strong&gt;&lt;code&gt;temp&lt;/code&gt;&lt;/strong&gt; ：&lt;strong&gt;&lt;code&gt;target.next=temp&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除元素：$O(1)$&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BA%BF%E6%80%A7%E8%A1%A8/20200806195114541-20230310121459257.png&#34;
	width=&#34;1132&#34;
	height=&#34;308&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;链表-删除节点&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;367&#34;
		data-flex-basis=&#34;882px&#34;
	
&gt;
&lt;ul&gt;
&lt;li&gt;找到要删除位置的前驱节点 &lt;strong&gt;&lt;code&gt;pre&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将前驱节点 &lt;strong&gt;&lt;code&gt;pre&lt;/code&gt;&lt;/strong&gt; 指向目标节点的后驱节点：&lt;strong&gt;&lt;code&gt;pre.next=pre.next.next&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;双向链表&#34;&gt;双向链表
&lt;/h3&gt;&lt;h4 id=&#34;定义-2&#34;&gt;定义
&lt;/h4&gt;&lt;p&gt;基本定义与单链表一致，但是 &lt;strong&gt;双向链表&lt;/strong&gt; 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。因此双向链表支持反向遍历&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BA%BF%E6%80%A7%E8%A1%A8/bidirectional-linkedlist.png&#34;
	width=&#34;511&#34;
	height=&#34;201&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;双向链表&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;254&#34;
		data-flex-basis=&#34;610px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;基本操作-2&#34;&gt;基本操作
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;访问元素&lt;/li&gt;
&lt;li&gt;插入元素：$O(1)$&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BA%BF%E6%80%A7%E8%A1%A8/R-C.8689c31dff2149b3d9742e26b9a06ed3.png&#34;
	width=&#34;948&#34;
	height=&#34;575&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;双向链表的插入&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;164&#34;
		data-flex-basis=&#34;395px&#34;
	
&gt;
&lt;ul&gt;
&lt;li&gt;找到要插入位置的前驱节点 &lt;strong&gt;&lt;code&gt;pre&lt;/code&gt;&lt;/strong&gt; 和后驱节点 &lt;strong&gt;&lt;code&gt;temp=pre.next&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;前驱节点 &lt;strong&gt;&lt;code&gt;pre&lt;/code&gt;&lt;/strong&gt; 和目标节点 &lt;strong&gt;&lt;code&gt;target&lt;/code&gt;&lt;/strong&gt; 建立双向链接
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;pre.next=target&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;target.prev=pre&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;目标节点 &lt;strong&gt;&lt;code&gt;target&lt;/code&gt;&lt;/strong&gt; 和后驱节点 &lt;strong&gt;&lt;code&gt;temp&lt;/code&gt;&lt;/strong&gt; 建立双向链接
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;target.next=temp&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;temp.prev=target&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除元素：$O(1)$&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BA%BF%E6%80%A7%E8%A1%A8/00537f0ad4d843679655ded36e8e8503.png&#34;
	width=&#34;1894&#34;
	height=&#34;532&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;双向链表的删除&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;356&#34;
		data-flex-basis=&#34;854px&#34;
	
&gt;
&lt;ul&gt;
&lt;li&gt;找到要删除位置的前驱节点 &lt;strong&gt;&lt;code&gt;pre&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将前驱节点 &lt;strong&gt;&lt;code&gt;pre&lt;/code&gt;&lt;/strong&gt; 指向目标节点的后驱节点 &lt;strong&gt;&lt;code&gt;temp&lt;/code&gt;&lt;/strong&gt; 建立双向联系
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;pre.next=temp&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;temp.prev=pre&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数组和链表的区别&#34;&gt;数组和链表的区别
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;访问效率&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;数组可以通过索引直接访问任何位置的元素，访问效率高，时间复杂度为$O(1)$，&lt;/li&gt;
&lt;li&gt;链表需要从头节点开始遍历到目标位置，访问效率较低，时间复杂度为$O(n)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;插入和删除效率&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;数组插入和删除操作需要移动其他元素，时间复杂度为$O(n)$&lt;/li&gt;
&lt;li&gt;链表只需要修改指针指向，时间复杂度为$O(1)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存命中率&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;数组元素在内存中连续存储，可以提高CPU缓存的命中率&lt;/li&gt;
&lt;li&gt;链表节点不连续存储，可能导致CPU缓存的命中率较低，频繁的缓存失效会影响性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;数组适合静态大小、频繁访问元素的场景&lt;/li&gt;
&lt;li&gt;链表适合动态大小、频繁插入、删除操作的场景&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;栈&#34;&gt;栈
&lt;/h2&gt;&lt;h3 id=&#34;定义-3&#34;&gt;定义
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;栈 (Stack)&lt;/strong&gt; 只允许在有序的线性数据集合的一端（栈顶）进行加入数据（入栈）和移除数据（出栈）。因而按照 &lt;strong&gt;后进先出（LIFO, Last In First Out）&lt;/strong&gt; 的原理运作。&lt;strong&gt;在栈中，push 和 pop 的操作都发生在栈顶。&lt;/strong&gt; 在Java中栈一般由Stack类实现，而且栈顶一般为数组末端&lt;/p&gt;
&lt;h3 id=&#34;基本操作-3&#34;&gt;基本操作
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;访问元素&lt;/strong&gt; ：需要遍历元素，时间复杂度为$O(n)$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;入栈和出栈&lt;/strong&gt; ：只对栈顶的元素进行操作，时间复杂度为$O(1)$&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20240725233451930.png&#34;
	width=&#34;1674&#34;
	height=&#34;504&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;入栈和出栈&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;332&#34;
		data-flex-basis=&#34;797px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;常见应用场景&#34;&gt;常见应用场景
&lt;/h3&gt;&lt;h4 id=&#34;浏览器的回退和前进&#34;&gt;浏览器的回退和前进
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BA%BF%E6%80%A7%E8%A1%A8/%E6%A0%88%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%80%92%E9%80%80%E5%92%8C%E5%89%8D%E8%BF%9B.png&#34;
	width=&#34;875&#34;
	height=&#34;616&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;栈实现浏览器倒退和前进-来自JavaGuide&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;142&#34;
		data-flex-basis=&#34;340px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;可以使用两个栈来实现浏览器的回退和前进。一个栈Stack1用于保存当前浏览的界面，另一个栈Stack2用于回退的页面。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前进页面：将页面从 Stack2 弹出，然后压入到 Stack1 中&lt;/li&gt;
&lt;li&gt;回退页面：把页面从 Stack1 弹出，然后压入 Stack2 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;队列&#34;&gt;队列
&lt;/h2&gt;&lt;h3 id=&#34;定义-4&#34;&gt;定义
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;队列（Queue）&lt;/strong&gt; 是 &lt;strong&gt;先进先出 (FIFO，First In, First Out)&lt;/strong&gt; 的线性表。队列只允许在后端（队尾）进行插入操作（入队），在前端（队头）进行删除操作（出队）。在Java中队列由Queue的实现类来实现，队尾为数组后端，队头为数组前端&lt;/p&gt;
&lt;h3 id=&#34;基本操作-4&#34;&gt;基本操作
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;访问元素&lt;/strong&gt; ：需要遍历元素，时间复杂度为$O(n)$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;入队和出队&lt;/strong&gt; ：只对队头和队尾的元素进行操作，时间复杂度为$O(1)$&lt;img src=&#34;https://Tyritic.github.io/p/%E7%BA%BF%E6%80%A7%E8%A1%A8/OIP-C.G5n6ACcW_VofRsdMgqID4wHaCM.png&#34;
	width=&#34;430&#34;
	height=&#34;135&#34;
	
	loading=&#34;lazy&#34;
	
		alt=&#34;队列的基本操作&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;318&#34;
		data-flex-basis=&#34;764px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;栈和队列的相互转换&#34;&gt;栈和队列的相互转换
&lt;/h2&gt;&lt;h3 id=&#34;栈实现队列&#34;&gt;栈实现队列
&lt;/h3&gt;&lt;p&gt;使用两个栈，一个栈为输入栈，另一个栈为输出栈。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入队：将元素压入输入栈。&lt;/li&gt;
&lt;li&gt;出队：先判断输出栈是否为空，如果不为空，则直接弹出栈顶元素；如果为空，则将输入栈中的所有元素依次弹出并压入输出栈中，然后再从输出栈中弹出栈顶元素作为出队元素。&lt;/li&gt;
&lt;li&gt;查询队首元素时，同样需要先将输入栈中的元素转移到输出栈中，然后取出的输出栈顶元素但不弹出。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;队列实现栈&#34;&gt;队列实现栈
&lt;/h3&gt;&lt;p&gt;使用一个栈可以实现队列。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入栈：先入队然后将队列中的元素（除了最后一个）依次出队再入队（相当于反转一次）&lt;/li&gt;
&lt;li&gt;出栈：直接出队&lt;/li&gt;
&lt;li&gt;查询栈顶元素：直接返回队首元素&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
